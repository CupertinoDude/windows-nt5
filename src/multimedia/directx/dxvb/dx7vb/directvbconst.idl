//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       directxconst.idl
//
//--------------------------------------------------------------------------




typedef enum CONST_D3DVERTEXBLENDFLAGS
{
    D3DVBLEND_DISABLE  = 0, // Disable vertex blending
    D3DVBLEND_1WEIGHT  = 1, // blend between 2 matrices
    D3DVBLEND_2WEIGHTS = 2, // blend between 3 matrices
    D3DVBLEND_3WEIGHTS = 3, // blend between 4 matrices
} CONST_D3DVERTEXBLENDFLAGS;


typedef enum CONST_D3DTEXTURETRANSFORMFLAGS {
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256   // texcoords to be divided by COUNTth element    
} CONST_D3DTEXTURETRANSFORMFLAGS;


typedef enum CONST_D3DVTXPCAPSFLAGS {
	D3DVTXPCAPS_TEXGEN            = 0x00000001,
	D3DVTXPCAPS_MATERIALSOURCE7   = 0x00000002, 
	D3DVTXPCAPS_VERTEXFOG         = 0x00000004, 
	D3DVTXPCAPS_DIRECTIONALLIGHTS = 0x00000008,
	D3DVTXPCAPS_POSITIONALLIGHTS  = 0x00000010,
	D3DVTXPCAPS_NONLOCALVIEWER    = 0x00000020,
} D3DVTXPCAPSFLAGS; 

typedef enum CONST_D3DFDSFLAGS {
         D3DFDS_COLORMODE         =0x00000001, /* Match color mode, */
	 D3DFDS_GUID              =0x00000002, /* Match guid */
	 D3DFDS_HARDWARE          =0x00000004, /* Match hardware/software */
	 D3DFDS_TRIANGLES         =0x00000008, /* Match in triCaps */
	 D3DFDS_LINES             =0x00000010, /* Match in lineCaps  */
	 D3DFDS_MISCCAPS          =0x00000020, /* Match primCaps.dwMiscCaps */
	 D3DFDS_RASTERCAPS        =0x00000040, /* Match primCaps.dwRasterCaps */
	 D3DFDS_ZCMPCAPS          =0x00000080, /* Match primCaps.dwZCmpCaps */
	 D3DFDS_ALPHACMPCAPS      =0x00000100, /* Match primCaps.dwAlphaCmpCaps */
	 D3DFDS_SRCBLENDCAPS      =0x00000200, /* Match primCaps.dwSourceBlendCaps */
	 D3DFDS_DSTBLENDCAPS      =0x00000400, /* Match primCaps.dwDestBlendCaps */
	 D3DFDS_SHADECAPS         =0x00000800, /* Match primCaps.dwShadeCaps */
	 D3DFDS_TEXTURECAPS       =0x00001000, /* Match primCaps.dwTextureCaps */
	 D3DFDS_TEXTUREFILTERCAPS =0x00002000, /* Match primCaps.dwTextureFilterCaps */
	 D3DFDS_TEXTUREBLENDCAPS  =0x00004000, /* Match primCaps.dwTextureBlendCaps */
	 D3DFDS_TEXTUREADDRESSCAPS  =0x00008000, /* Match primCaps.dwTextureBlendCaps */
} D3DFDSFLAGS;

typedef enum CONST_D3DTEXOPCAPSFLAGS {
	 D3DTEXOPCAPS_DISABLE                    =0x00000001,
	 D3DTEXOPCAPS_SELECTARG1                 =0x00000002,
	 D3DTEXOPCAPS_SELECTARG2                 =0x00000004,
	 D3DTEXOPCAPS_MODULATE                   =0x00000008,
	 D3DTEXOPCAPS_MODULATE2X                 =0x00000010,
	 D3DTEXOPCAPS_MODULATE4X                 =0x00000020,
	 D3DTEXOPCAPS_ADD                        =0x00000040,
	 D3DTEXOPCAPS_ADDSIGNED                  =0x00000080,
	 D3DTEXOPCAPS_ADDSIGNED2X                =0x00000100,
	 D3DTEXOPCAPS_SUBTRACT                   =0x00000200,
	 D3DTEXOPCAPS_ADDSMOOTH                  =0x00000400,
	 D3DTEXOPCAPS_BLENDDIFFUSEALPHA          =0x00000800,
	 D3DTEXOPCAPS_BLENDTEXTUREALPHA          =0x00001000,
	 D3DTEXOPCAPS_BLENDFACTORALPHA           =0x00002000,
	 D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        =0x00004000,
	 D3DTEXOPCAPS_BLENDCURRENTALPHA          =0x00008000,
	 D3DTEXOPCAPS_PREMODULATE                =0x00010000,
	 D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     =0x00020000,
	 D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     =0x00040000,
	 D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  =0x00080000,
	 D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  =0x00100000,
	 D3DTEXOPCAPS_BUMPENVMAP                 =0x00200000,
	 D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        =0x00400000,
	 D3DTEXOPCAPS_DOTPRODUCT3                =0x00800000,
} D3DTEXOPCAPSFLAGS;

typedef enum CONST_D3DDPFLAGS {
	 D3DDP_DEFAULT				=0x00000000,
	 D3DDP_WAIT					=0x00000001
	 //D3DDP_DONOTCLIP			=0x00000004,
	 //D3DDP_DONOTUPDATEEXTENTS	=0x00000008,
	 //D3DDP_DONOTLIGHT			=0x00000010

} D3DDPFLAGS;

//typedef enum CONST_D3DNEXTFLAGS {
//	 D3DNEXT_NEXT	=0x00000001,
//	 D3DNEXT_HEAD	=0x00000002,
//	 D3DNEXT_TAIL	=0x00000004
//} D3DNEXTFLAGS;

typedef enum CONST_D3DCLEARFLAGS {
	 D3DCLEAR_TARGET  =          0x00000001, /* Clear target surface */
	 D3DCLEAR_ZBUFFER =          0x00000002, /* Clear target z buffer */
	 D3DCLEAR_STENCIL =          0x00000004, /* Clear target z buffer */
	 D3DCLEAR_ALL =				 0x00000007
} D3DCLEARFLAGS;

typedef enum CONST_D3DLIGHTCAPSFLAGS {
	D3DLIGHTCAPS_POINT             = 0x00000001, /* Point lights supported */
	D3DLIGHTCAPS_SPOT              = 0x00000002, /* Spot lights supported */
	D3DLIGHTCAPS_DIRECTIONAL       = 0x00000004, /* Directional lights supported */
	//not supported D3DLIGHTCAPS_PARALLELPOINT     = 0x00000008 /* Parallel point lights supported */
} D3DLIGHTCAPSFLAGS;

//typedef enum CONST_D3DTRANSFORMFLAGS {
//	D3DTRANSFORM_CLIPPED      = 0x00000001,
//	D3DTRANSFORM_UNCLIPPED    = 0x00000002
//} D3DTRANSFORMFLAGS;


//typedef enum CONST_D3DTRANSFORMCAPS {
//	D3DTRANSFORMCAPS_CLIP =1
//} D3DTRANSFORMCAPS;

typedef enum CONST_D3DVOPFLAGS{
	/* Vertex Operations for ProcessVertices */
	D3DVOP_LIGHT     =  1024,
	D3DVOP_TRANSFORM   =1,
	D3DVOP_CLIP         =4,
	D3DVOP_EXTENTS     =8
} D3DVOPFLAGS;

typedef enum CONST_D3DCOLORMODEL {
	 D3DCOLOR_MONO   =1,
	 D3DCOLOR_RGB    =2,
} D3DCOLORMODEL;

typedef enum CONST_D3DLIGHTTYPE {
	D3DLIGHT_POINT = 1,
	D3DLIGHT_SPOT = 2,
	D3DLIGHT_DIRECTIONAL = 3,
	//not supported D3DLIGHT_PARALLELPOINT = 4
} D3DLIGHTTYPE;


typedef enum CONST_D3DLIGHTINGMODELFLAGS {
	D3DLIGHTINGMODEL_RGB       =    0x00000001,
	D3DLIGHTINGMODEL_MONO       =   0x00000002
} D3DLIGHTINGMODELFLAGS;

typedef enum CONST_D3DCAPSRASTER {


	/* D3DPRIMCAPS dwRasterCaps */
	 D3DPRASTERCAPS_DITHER                   =0x00000001,
	 D3DPRASTERCAPS_ROP2                     =0x00000002,
	 D3DPRASTERCAPS_XOR                      =0x00000004,
	 D3DPRASTERCAPS_PAT                      =0x00000008,
	 D3DPRASTERCAPS_ZTEST                    =0x00000010,
	 D3DPRASTERCAPS_SUBPIXEL                 =0x00000020,
	 D3DPRASTERCAPS_SUBPIXELX                =0x00000040,
	 D3DPRASTERCAPS_FOGVERTEX                =0x00000080,
	 D3DPRASTERCAPS_FOGTABLE                 =0x00000100,
	 D3DPRASTERCAPS_STIPPLE                  =0x00000200,
	 D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   =0x00000400,
	 D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT =0x00000800,
	 D3DPRASTERCAPS_ANTIALIASEDGES           =0x00001000,
	 D3DPRASTERCAPS_MIPMAPLODBIAS            =0x00002000,
	 D3DPRASTERCAPS_ZBIAS                    =0x00004000,
	 D3DPRASTERCAPS_ZBUFFERLESSHSR           =0x00008000,
	 D3DPRASTERCAPS_FOGRANGE                 =0x00010000,
	 D3DPRASTERCAPS_ANISOTROPY               =0x00020000,
         D3DPRASTERCAPS_WBUFFER                  =0x00040000,
	 //D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT=0x00080000,	b25684
	 D3DPRASTERCAPS_WFOG                     =0x00100000,
	 D3DPRASTERCAPS_ZFOG                     =0x00200000,
//	 D3DPRASTERCAPS_COLORKEYBLEND            =0x00400000	removed 
} D3DCAPSRASTER;

typedef enum CONST_D3DCAPSCMP {
	/* D3DPRIMCAPS dwZCmpCaps, dwAlphaCmpCaps */
	 D3DPCMPCAPS_NEVER		=0x00000001,
	 D3DPCMPCAPS_LESS         	=0x00000002,
	 D3DPCMPCAPS_EQUAL       	=0x00000004,
	 D3DPCMPCAPS_LESSEQUAL   	=0x00000008,
	 D3DPCMPCAPS_GREATER      	=0x00000010,
	 D3DPCMPCAPS_NOTEQUAL    	=0x00000020,
	 D3DPCMPCAPS_GREATEREQUAL	=0x00000040,
	 D3DPCMPCAPS_ALWAYS       	=0x00000080
} D3DCAPSCMP;

typedef enum CONST_D3DCAPSBLEND {
	/* D3DPRIMCAPS dwSourceBlendCaps, dwDestBlendCaps */

	 D3DPBLENDCAPS_ZERO              =0x00000001,
	 D3DPBLENDCAPS_ONE               =0x00000002,
	 D3DPBLENDCAPS_SRCCOLOR          =0x00000004,
	 D3DPBLENDCAPS_INVSRCCOLOR       =0x00000008,
	 D3DPBLENDCAPS_SRCALPHA          =0x00000010,
	 D3DPBLENDCAPS_INVSRCALPHA       =0x00000020,
	 D3DPBLENDCAPS_DESTALPHA         =0x00000040,
	 D3DPBLENDCAPS_INVDESTALPHA      =0x00000080,
	 D3DPBLENDCAPS_DESTCOLOR         =0x00000100,
	 D3DPBLENDCAPS_INVDESTCOLOR      =0x00000200,
	 D3DPBLENDCAPS_SRCALPHASAT       =0x00000400,
	 D3DPBLENDCAPS_BOTHSRCALPHA      =0x00000800,
	 D3DPBLENDCAPS_BOTHINVSRCALPHA   =0x00001000
} D3DCAPSBLEND;


typedef enum CONST_D3DCAPSSHADE {

	/* D3DPRIMCAPS dwShadeCaps */

	 D3DPSHADECAPS_COLORFLATMONO		=0x00000001,
	 D3DPSHADECAPS_COLORFLATRGB		=0x00000002,
	 D3DPSHADECAPS_COLORGOURAUDMONO		=0x00000004,
	 D3DPSHADECAPS_COLORGOURAUDRGB		=0x00000008,
	 D3DPSHADECAPS_COLORPHONGMONO		=0x00000010,
	 D3DPSHADECAPS_COLORPHONGRGB		=0x00000020,

	 D3DPSHADECAPS_SPECULARFLATMONO		=0x00000040,
	 D3DPSHADECAPS_SPECULARFLATRGB		=0x00000080,
	 D3DPSHADECAPS_SPECULARGOURAUDMONO	=0x00000100,
	 D3DPSHADECAPS_SPECULARGOURAUDRGB	=0x00000200,
	 D3DPSHADECAPS_SPECULARPHONGMONO		=0x00000400,
	 D3DPSHADECAPS_SPECULARPHONGRGB		=0x00000800,

	 D3DPSHADECAPS_ALPHAFLATBLEND		=0x00001000,
	 D3DPSHADECAPS_ALPHAFLATSTIPPLED		=0x00002000,
	 D3DPSHADECAPS_ALPHAGOURAUDBLEND		=0x00004000,
	 D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED	=0x00008000,
	 D3DPSHADECAPS_ALPHAPHONGBLEND		=0x00010000,
	 D3DPSHADECAPS_ALPHAPHONGSTIPPLED	=0x00020000,

	 D3DPSHADECAPS_FOGFLAT			=0x00040000,
	 D3DPSHADECAPS_FOGGOURAUD		=0x00080000,
	 D3DPSHADECAPS_FOGPHONG			=0x00100000
} D3DCAPSSHADE;

typedef enum CONST_D3DCAPSTEXTURE {
	/* D3DPRIMCAPS dwTextureCaps */

	 D3DPTEXTURECAPS_PERSPECTIVE	=0x00000001,
	 D3DPTEXTURECAPS_POW2		=0x00000002,
	 D3DPTEXTURECAPS_ALPHA		=0x00000004,
	 D3DPTEXTURECAPS_TRANSPARENCY	=0x00000008,
	 D3DPTEXTURECAPS_BORDER		=0x00000010,
	 D3DPTEXTURECAPS_SQUAREONLY	=0x00000020,
	 D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE =0x00000040,
	 D3DPTEXTURECAPS_ALPHAPALETTE    =0x00000080,
	 D3DPTEXTURECAPS_NONPOW2CONDITIONAL  =0x00000100,
	 D3DPTEXTURECAPS_TEXTURETRANSFORM  =0x00000200,
	 D3DPTEXTURECAPS_PROJECTED	=0x00000400,
	 D3DPTEXTURECAPS_CUBEMAP	=0x00000800,
	 D3DPTEXTURECAPS_COLORKEYBLEND   =  0x00001000,
	 
} D3DCAPSTEXTURE;


typedef enum CONST_D3DCAPSTEXTUREFILTER {

	/* D3DPRIMCAPS dwTextureFilterCaps */

	 D3DPTFILTERCAPS_NEAREST		=0x00000001,
	 D3DPTFILTERCAPS_LINEAR		=0x00000002,
	 D3DPTFILTERCAPS_MIPNEAREST	=0x00000004,
	 D3DPTFILTERCAPS_MIPLINEAR	=0x00000008,
	 D3DPTFILTERCAPS_LINEARMIPNEAREST =0x00000010,
	 D3DPTFILTERCAPS_LINEARMIPLINEAR	=0x00000020
} D3DCAPSTEXTUREFILTER;

/*
typedef enum CONST_D3DCAPSTEXTUREBLEND {
	 D3DPRIMCAPS dwTextureBlendCaps 

	 D3DPTBLENDCAPS_DECAL		=0x00000001,
	 D3DPTBLENDCAPS_MODULATE		=0x00000002,
	 D3DPTBLENDCAPS_DECALALPHA	=0x00000004,
	 D3DPTBLENDCAPS_MODULATEALPHA	=0x00000008,
	 D3DPTBLENDCAPS_DECALMASK	=0x00000010,
	 D3DPTBLENDCAPS_MODULATEMASK	=0x00000020,
	 D3DPTBLENDCAPS_COPY		=0x00000040,
	 D3DPTBLENDCAPS_ADD		=0x00000080
} D3DCAPSTEXTUREBLEND;
*/
typedef enum CONST_D3DCAPSTEXTUREADDRESS {
	/* D3DPRIMCAPS dwTextureAddressCaps */
	 D3DPTADDRESSCAPS_WRAP		=0x00000001,
	 D3DPTADDRESSCAPS_MIRROR		=0x00000002,
	 D3DPTADDRESSCAPS_CLAMP		=0x00000004,
	 D3DPTADDRESSCAPS_BORDER     =0x00000008,
	 D3DPTADDRESSCAPS_INDEPENDENTUV =0x00000010

} D3DCAPSTEXTUREADDRESS;

#if 0	
//not needed as D3DDEVICEDESC no longer has flags
typedef enum CONST_D3DDEVICEDESCFLAGS {
	/* D3DDEVICEDESC dwFlags indicating valid fields */
	 //D3DDD_COLORMODEL	    =0x00000001,/* dcmColorMode,is valid */
	 D3DDD_DEVCAPS		    =0x00000002,/* dwDevCaps is valid */
	 D3DDD_TRANSFORMCAPS         =0x00000004,/* dtcTransformCaps is valid */
	 D3DDD_LIGHTINGCAPS          =0x00000008,/* dlcLightingCaps is valid */
	 D3DDD_BCLIPPING             =0x00000010,/* bClipping is valid */
	 D3DDD_LINECAPS              =0x00000020,/* dpcLineCaps is valid */
	 D3DDD_TRICAPS               =0x00000040,/* dpcTriCaps is valid */
	 D3DDD_DEVICERENDERBITDEPTH  =0x00000080,	/* dwDeviceRenderBitDepth is valid */
	 D3DDD_DEVICEZBUFFERBITDEPTH =0x00000100,	/* dwDeviceZBufferBitDepth is valid */
	 D3DDD_MAXBUFFERSIZE         =0x00000200,/* dwMaxBufferSize is valid */
	 D3DDD_MAXVERTEXCOUNT        =0x00000400,/* dwMaxVertexCount is valid */
} D3DDEVICEDESCFLAGS;
#endif 

typedef enum CONST_D3DDEVICEDESCCAPS {
	/* D3DDEVICEDESC dwDevCaps flags */
	 D3DDEVCAPS_FLOATTLVERTEX        =0x00000001,/* Device accepts floating point */                                                    /* for post-transform vertex data */
	 D3DDEVCAPS_SORTINCREASINGZ      =0x00000002,/* Device needs data sorted for increasing Z*/
	 D3DDEVCAPS_SORTDECREASINGZ      =0x00000004,/* Device needs data sorted for decreasing Z*/
	 D3DDEVCAPS_SORTEXACT	        =0x00000008,/* Device needs data sorted exactly */

//	 D3DDEVCAPS_EXECUTESYSTEMMEMORY  =0x00000010,/* Device can use execute buffers from system memory */
//	 D3DDEVCAPS_EXECUTEVIDEOMEMORY   =0x00000020,/* Device can use execute buffers from video memory */
	 D3DDEVCAPS_TLVERTEXSYSTEMMEMORY =0x00000040,/* Device can use T,buffers from system memory */
	 D3DDEVCAPS_TLVERTEXVIDEOMEMORY  =0x00000080,/* Device can use T,buffers from video memory */
	 D3DDEVCAPS_TEXTURESYSTEMMEMORY  =0x00000100,/* Device can texture from system memory */
	 D3DDEVCAPS_TEXTUREVIDEOMEMORY	=0x00000200,/* Device can texture from device memory */
	 D3DDEVCAPS_DRAWPRIMTLVERTEX     =0x00000400,/* Device can draw TLVERTEX primitives */
	 D3DDEVCAPS_CANRENDERAFTERFLIP	=0x00000800,/* Device can render without waiting for flip to complete */
	 D3DDEVCAPS_TEXTURENONLOCALVIDMEM =0x00001000,/* Device can texture from nonloca,video memory */
         D3DDEVCAPS_SEPARATETEXTUREMEMORIES= 0x00004000,
	 D3DDEVCAPS_HWTRANSFORMANDLIGHT=0x00008000,
         D3DDEVCAPS_CANBLTSYSTONONLOCAL=0x00020000,
	 //D3DDEVCAPS_STRIDEDVERTICES=0x00010000,
	D3DDEVCAPS_HWRASTERIZATION         =0x00080000, /* Device has HW acceleration for rasterization */

} D3DDEVICEDESCCAPS;



// shanee thinks this is only needed for execute buffers
//
//typedef enum CONST_D3DSETSTATUSFLAGS {
//	 D3DSETSTATUS_STATUS	=	0x00000001,
//	 D3DSETSTATUS_EXTENTS	=	0x00000002,
//	 D3DSETSTATUS_ALL	= 3 //(D3DSETSTATUS_STATUS | D3DSETSTATUS_EXTENTS),
//} D3DSETSTATUSFLAGS;

typedef enum CONST_D3DCLIPFLAGS {
	D3DCLIP_LEFT  =              0x00000001,
	D3DCLIP_RIGHT =              0x00000002,
	D3DCLIP_TOP   =		         0x00000004,
	D3DCLIP_BOTTOM=              0x00000008,
	D3DCLIP_FRONT =              0x00000010,
	D3DCLIP_BACK  =              0x00000020,
	D3DCLIP_GEN0  =              0x00000040,
	D3DCLIP_GEN1  =              0x00000080,
	D3DCLIP_GEN2  =              0x00000100,
	D3DCLIP_GEN3  =              0x00000200,
	D3DCLIP_GEN4  =              0x00000400,
	D3DCLIP_GEN5  =              0x00000800,

	D3DSTATUS_CLIPINTERSECTIONLEFT   =   0x00001000,
	D3DSTATUS_CLIPINTERSECTIONRIGHT  =   0x00002000,
	D3DSTATUS_CLIPINTERSECTIONTOP    =   0x00004000,
	D3DSTATUS_CLIPINTERSECTIONBOTTOM =   0x00008000,
	D3DSTATUS_CLIPINTERSECTIONFRONT  =   0x00010000,
	D3DSTATUS_CLIPINTERSECTIONBACK   =   0x00020000,
	D3DSTATUS_CLIPINTERSECTIONGEN0   =   0x00040000,
	D3DSTATUS_CLIPINTERSECTIONGEN1   =   0x00080000,
	D3DSTATUS_CLIPINTERSECTIONGEN2   =   0x00100000,
	D3DSTATUS_CLIPINTERSECTIONGEN3   =   0x00200000,
	D3DSTATUS_CLIPINTERSECTIONGEN4   =   0x00400000,
	D3DSTATUS_CLIPINTERSECTIONGEN5   =   0x00800000,



	D3DSTATUS_CLIPUNIONLEFT       =  0x00000001,
	D3DSTATUS_CLIPUNIONRIGHT      =  0x00000002,
	D3DSTATUS_CLIPUNIONTOP        =  0x00000004,
	D3DSTATUS_CLIPUNIONBOTTOM     =  0x00000008,
	D3DSTATUS_CLIPUNIONFRONT      =  0x00000010,
	D3DSTATUS_CLIPUNIONBACK       =  0x00000020,
	D3DSTATUS_CLIPUNIONGEN0       =  0x00000040,
	D3DSTATUS_CLIPUNIONGEN1       =  0x00000080,
	D3DSTATUS_CLIPUNIONGEN2       =  0x00000100,
	D3DSTATUS_CLIPUNIONGEN3       =  0x00000200,
	D3DSTATUS_CLIPUNIONGEN4       =  0x00000400,
	D3DSTATUS_CLIPUNIONGEN5       =  0x00000800,

	D3DSTATUS_ZNOTVISIBLE            =   0x01000000,
	// Do not use 0x80000000 for any status flags in future as it is reserved 
	D3DSTATUS_CLIPUNIONALL =0x00FFF000,

	
//	D3DSTATUS_CLIPUNIONALL  (       \
//		D3DSTATUS_CLIPUNIONLEFT |   \
//		D3DSTATUS_CLIPUNIONRIGHT    |   \
//		D3DSTATUS_CLIPUNIONTOP  |   \
//		D3DSTATUS_CLIPUNIONBOTTOM   |   \
//		D3DSTATUS_CLIPUNIONFRONT    |   \
//		D3DSTATUS_CLIPUNIONBACK |   \
//		D3DSTATUS_CLIPUNIONGEN0 |   \
//		D3DSTATUS_CLIPUNIONGEN1 |   \
//		D3DSTATUS_CLIPUNIONGEN2 |   \
//		D3DSTATUS_CLIPUNIONGEN3 |   \
//		D3DSTATUS_CLIPUNIONGEN4 |   \
//		D3DSTATUS_CLIPUNIONGEN5     \
//		)
	

	D3DSTATUS_CLIPINTERSECTIONALL=0x00FFF000,
	 
//	D3DSTATUS_CLIPINTERSECTIONALL   (       \
//		D3DSTATUS_CLIPINTERSECTIONLEFT  |   \
//		D3DSTATUS_CLIPINTERSECTIONRIGHT |   \
//		D3DSTATUS_CLIPINTERSECTIONTOP   |   \
//		D3DSTATUS_CLIPINTERSECTIONBOTTOM    |   \
//		D3DSTATUS_CLIPINTERSECTIONFRONT |   \
//		D3DSTATUS_CLIPINTERSECTIONBACK  |   \
//		D3DSTATUS_CLIPINTERSECTIONGEN0  |   \
//		D3DSTATUS_CLIPINTERSECTIONGEN1  |   \
//		D3DSTATUS_CLIPINTERSECTIONGEN2  |   \
//		D3DSTATUS_CLIPINTERSECTIONGEN3  |   \
//		D3DSTATUS_CLIPINTERSECTIONGEN4  |   \
//		D3DSTATUS_CLIPINTERSECTIONGEN5      \
//		)

	D3DSTATUS_DEFAULT  =0x01FFF000

//	D3DSTATUS_DEFAULT   (           \
//        D3DSTATUS_CLIPINTERSECTIONALL   |   \
//        D3DSTATUS_ZNOTVISIBLE)
	
} D3DCLIPFLAGS;

#if 0

/*
	 * execute buffer flags

	 D3DTRIFLAG_START =			0x00000000,
	 D3DTRIFLAG_ODD	=			0x0000001e,
	 D3DTRIFLAG_EVEN=				0x0000001f,


	 D3DTRIFLAG_EDGEENABLE1 		=	0x00000100, // v0-v1 edge
	 D3DTRIFLAG_EDGEENABLE2 		=	0x00000200, // v1-v2 edge 
	 D3DTRIFLAG_EDGEENABLE3 		=	0x00000400, // v2-v0 edge 
	 D3DTRIFLAG_EDGEENABLETRIANGLE   =  0x00000700, 
	

	 D3DPROCESSVERTICES_TRANSFORMLIGHT	=0x00000000,
	 D3DPROCESSVERTICES_TRANSFORM		=0x00000001,
	 D3DPROCESSVERTICES_COPY			=0x00000002,
	 D3DPROCESSVERTICES_OPMASK		=0x00000007,

	 D3DPROCESSVERTICES_UPDATEEXTENTS	=0x00000008,
	 D3DPROCESSVERTICES_NOCOLOR		=0x00000010,

			//    (D3DTRIFLAG_EDGEENABLE1 | D3DTRIFLAG_EDGEENABLE2 | D3DTRIFLAG_EDGEENABLE3),
	

	
	
	 // Execute options.
	 //When calling using D3DEXECUTE_UNCLIPPED all the primitives 
	 //inside the buffer must be contained within the viewport.
	 //
	 D3DEXECUTE_CLIPPED     =  0x00000001,
	 D3DEXECUTE_UNCLIPPED   =  0x00000002,

	//
	//Amount to add to a state to generate the override for that state.
	
	D3DSTATE_OVERRIDE_BIAS	=	256,


*/
#endif

typedef enum CONST_D3DCLIPSTATUSFLAGS {
	 D3DCLIPSTATUS_STATUS    =    0x00000001,
	 D3DCLIPSTATUS_EXTENTS2  =    0x00000002,
	 D3DCLIPSTATUS_EXTENTS3  =    0x00000004
} D3DCLIPSTATUSFLAGS;


 
typedef enum CONST_D3DLIGHTFLAGS {
        D3DLIGHT_ACTIVE       =  0x00000001,
        D3DLIGHT_NO_SPECULAR  =  0x00000002,
		D3DLIGHT_ALL		=  0x00000003
} D3DLIGHTFLAGS;
	

typedef enum CONST_DDPALFLAGS {
	PC_DEFAULT=0,
	PC_RESERVED=1,
	PC_EXPLICIT=2,
	PC_NOCOLLAPSE=4
} DDPALFLAGS;


typedef enum CONST_DDDEVICEIDFLAGS {
	DDGDI_DEFAULT=0,
	DDGDI_GETHOSTIDENTIFIER=1	
} DDDEVICEIDFLAGS;

	
//typedef enum CONST_D3DPALFLAGS {
//	/*
//	 * Palette flags.
//	 * This are or'ed with the peFlags in the PALETTEENTRYs passed to DirectDraw.
//	 */
//	 D3DPAL_FREE=	0x00,	/* Renderer may use this entry freely */
//	 D3DPAL_READONLY=	0x40,	/* Renderer may not set this entry */
//	 D3DPAL_RESERVED= 0x80	/* Renderer may not use this entry */
//
//} D3DPALFLAGS;


typedef enum CONST_D3DVBCAPSFLAGS {
	D3DVBCAPS_SYSTEMMEMORY     = 0x00000800,
	D3DVBCAPS_WRITEONLY      =   0x00010000,
	D3DVBCAPS_OPTIMIZED      =   0x80000000,
	D3DVBCAPS_DONOTCLIP      =   0x00000001,
	D3DVBCAPS_DEFAULT		 =   0x00000000
} D3DVBCAPSFLAGS;


typedef enum CONST_D3DFVFCAPSFLAGS {
    D3DFVFCAPS_TEXCOORDCOUNTMASK    =0x0000ffff, /* mask for texture coordinate count field */
	D3DFVFCAPS_DONOTSTRIPELEMENTS   =0x00080000 /* Device prefers that vertex elements not be stripped */
} D3DFVFCAPSFLAGS;


typedef enum CONST_D3DFVFFLAGS {
	// Flexible vertex format bits
	//
//	  D3DFVF_RESERVED0        =0x001,
//	  D3DFVF_POSITION_MASK    =0x00E,
	  D3DFVF_XYZ              =0x002,
	  D3DFVF_XYZRHW           =0x004,
	  D3DFVF_XYZB1            =0x006,
	  D3DFVF_XYZB2            =0x008,
	  D3DFVF_XYZB3            =0x00a,
	  D3DFVF_XYZB4            =0x00c,
	  D3DFVF_XYZB5            =0x00e,

	  D3DFVF_NORMAL           =0x010,
//	  D3DFVF_RESERVED1        =0x020,
	  D3DFVF_DIFFUSE          =0x040,
	  D3DFVF_SPECULAR         =0x080,

//	  D3DFVF_TEXCOUNT_MASK    =0xf00,
//	  D3DFVF_TEXCOUNT_SHIFT   =8,
	  D3DFVF_TEX0            =0x000,
	  D3DFVF_TEX1            =0x100,
	  D3DFVF_TEX2            =0x200,
	  D3DFVF_TEX3             =0x300,
	  D3DFVF_TEX4             =0x400,
	  D3DFVF_TEX5             =0x500,
	  D3DFVF_TEX6             =0x600,
	  D3DFVF_TEX7             =0x700,
	  D3DFVF_TEX8             =0x800,

//	  D3DFVF_RESERVED2        =0xf000,  // 4 reserved bits
	  
        D3DFVF_VERTEX=0x112,
        D3DFVF_LVERTEX=0x1e2, 
        D3DFVF_TLVERTEX=0x1c4
 } D3DFVFFLAGS;

 /*
 typedef enum CONST_D3DVISFLAGS {
 
  	D3DVIS_INSIDE_FRUSTUM =      0,
  	D3DVIS_INTERSECT_FRUSTUM =   1,
      D3DVIS_OUTSIDE_FRUSTUM   =   2,
      D3DVIS_INSIDE_LEFT       =   0,
      D3DVIS_INTERSECT_LEFT    =   2,	//(1 << 2)
      D3DVIS_OUTSIDE_LEFT      =   4,	//(2 << 2)
      D3DVIS_INSIDE_RIGHT      =   0,
      D3DVIS_INTERSECT_RIGHT   =   16,	//(1 << 4)
      D3DVIS_OUTSIDE_RIGHT     =   32,	//(2 << 4)
      D3DVIS_INSIDE_TOP        =   0,
      D3DVIS_INTERSECT_TOP     =   64,	//(1 << 6)
  	D3DVIS_OUTSIDE_TOP       =   128,	//(2 << 6)
  	D3DVIS_INSIDE_BOTTOM     =   0,
  	D3DVIS_INTERSECT_BOTTOM  =   256,	//(1 << 8)
  	D3DVIS_OUTSIDE_BOTTOM    =   512,   //(2 << 8)
  	D3DVIS_INSIDE_NEAR       =   0,
  	D3DVIS_INTERSECT_NEAR    =   1024,	//(1 << 10)
  	D3DVIS_OUTSIDE_NEAR      =   2048,	//(2 << 10)
  	D3DVIS_INSIDE_FAR        =   0,
  	D3DVIS_INTERSECT_FAR     =   4096,	//(1 << 12)
  	D3DVIS_OUTSIDE_FAR       =   8192,	//(2 << 12)

  	//D3DVIS_MASK_FRUSTUM      =   3, 
  	//D3DVIS_MASK_LEFT         =   12, //(3 << 2)
  	//D3DVIS_MASK_RIGHT        =   40, // (3 << 4) 
  	//D3DVIS_MASK_TOP          =   192, //(3 << 6) 
  	//D3DVIS_MASK_BOTTOM       =   768, //(3 << 8)
	//D3DVIS_MASK_NEAR         =   3072, //(3 << 10)
    //D3DVIS_MASK_FAR          =   12288
} D3DVISFLAGS;

*/

typedef enum  CONST_D3DTAFLAGS {
	
	D3DTA_SELECTMASK     =   0x0000000f,  // mask for arg selector
	D3DTA_DIFFUSE        =   0x00000000,  // select diffuse color
	D3DTA_CURRENT        =   0x00000001,  // select result of previous stage
	D3DTA_TEXTURE        =   0x00000002,  // select texture color
	D3DTA_TFACTOR        =   0x00000003,  // select RENDERSTATE_TEXTUREFACTORur	
	D3DTA_COMPLEMENT      =  0x00000010,  // take 1.0 - x
	D3DTA_ALPHAREPLICATE  =  0x00000020,  // replicate alpha to color components
	//DX7
	D3DTA_SPECULAR		 =	 0x00000004
} D3DTAFLAGS;

typedef enum CONST_D3DCAPSMISC {
	D3DPMISCCAPS_MASKPLANES		=0x00000001,
	D3DPMISCCAPS_MASKZ		=0x00000002,
//	D3DPMISCCAPS_LINEPATTERNREP	=0x00000004,
	D3DPMISCCAPS_CONFORMANT		=0x00000008,
	D3DPMISCCAPS_CULLNONE		=0x00000010,
	D3DPMISCCAPS_CULLCW		=0x00000020,
	D3DPMISCCAPS_CULLCCW		=0x00000040
} D3DCAPSMISC;


typedef enum CONST_D3D {
	// Bias to apply to the texture coordinate set to apply a wrap to.
	D3DRENDERSTATE_WRAPBIAS =                128,

    D3DDP_MAXTEXCOORD =8,

	/* Flags to construct the WRAP render states */
	D3DWRAPCOORD_0=   0x00000001,
    D3DWRAPCOORD_1=   0x00000002,
	D3DWRAPCOORD_2=0x00000004,
	D3DWRAPCOORD_3=0x00000008

 	
 } D3DFLAGS;



/******************
* RM
*******************/
typedef enum CONST_D3DRMCREATEDEVICEFLAGS {
	D3DRMDEVICE_DEFAULT		=0,
	D3DRMDEVICE_NOZBUFFER	=1
} D3DRMCREATEDEVICEFLAGS;

typedef enum CONST_D3DRMADDFACESFLAGS{
	D3DRMADDFACES_DEFAULT				=0,
	D3DRMADDFACES_VERTICESONLY              =1
} D3DRMADDFACESFLAGS;

typedef enum CONST_D3DRMMESHBUILDERENABLEFLAGS {
	 D3DRMMESHBUILDER_RENDERENABLE   =1,
	 D3DRMMESHBUILDER_PICKENABLE     =2,
	 D3DRMMESHBUILDER_PICKANDRENDERENABLE     =3
} D3DRMMESHBUILDERFLAGS;

typedef enum CONST_D3DRMMESHBUILDERAGEFLAGS {
	D3DRMMESHBUILDERAGE_GEOMETRY    =0x00000001,
	D3DRMMESHBUILDERAGE_MATERIALS   =0x00000002,
    D3DRMMESHBUILDERAGE_TEXTURES    =0x00000004
}D3DRMMESHBUILDERAGEFLAGS;

typedef enum CONST_D3DRMPARENTINGFLAGS {
	D3DRMMESHBUILDER_DIRECTPARENT          = 1,
	D3DRMMESHBUILDER_ROOTMESH              = 2
} D3DRMPARENTINGFLAGS;

/*
typedef enum CONST_D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON;
*/
typedef enum CONST_D3DRMADDMESHBUILDERFLAGS {
	D3DRMADDMESHBUILDER_DONTCOPYAPPDATA =    1,
	D3DRMADDMESHBUILDER_FLATTENSUBMESHES =   2,
	D3DRMADDMESHBUILDER_NOSUBMESHES       =  4
} D3DRMADDMESHBUILDERFLAGS ;


typedef enum CONST_D3DRMGENERATENORMALSFLAGS {
	 D3DRMGENERATENORMALS_PRECOMPACT        = 1,
	D3DRMGENERATENORMALS_USECREASEANGLE     = 2
} D3DRMGENERATENORMALSFLAGS;

typedef enum CONST_D3DRMTEXTURECACHEFLAGS {
	D3DRMTEXTURE_FORCERESIDENT        =  0x00000001, /* texture should be kept in video memory */
	D3DRMTEXTURE_STATIC               =  0x00000002, /* texture will not change */
	D3DRMTEXTURE_DOWNSAMPLEPOINT      =  0x00000004, /* point filtering should be used when downsampling */
	D3DRMTEXTURE_DOWNSAMPLEBILINEAR   =  0x00000008, /* bilinear filtering should be used when downsampling */
	D3DRMTEXTURE_DOWNSAMPLEREDUCEDEPTH=  0x00000010, /* reduce bit depth when downsampling */
	D3DRMTEXTURE_DOWNSAMPLENONE       =  0x00000020 /* texture should never be downsampled */
} D3DRMTEXTURECACHEFLAGS;


typedef enum CONST_D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    // not supported D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE;

typedef enum CONST_D3DRMVIEWPORTCLEARFLAGS {
	D3DRMCLEAR_TARGET               =1,
	D3DRMCLEAR_ZBUFFER              =2,
	D3DRMCLEAR_DIRTYRECTS           =4,
	D3DRMCLEAR_ALL                  =7
} D3DRMVIEWPORTCLEARFLAGS;

typedef enum CONST_D3DRMRENDERQUALITY {


    D3DRMSHADE_FLAT	= 0,
    D3DRMSHADE_GOURAUD	= 1,
    D3DRMSHADE_PHONG	= 2,
    D3DRMSHADE_MASK	= 7,
    D3DRMSHADE_MAX      = 8,

    D3DRMLIGHT_OFF	= 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON	= 1 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MASK	= 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX      = 8 * D3DRMSHADE_MAX,
    
	D3DRMFILL_POINTS	= 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME	= 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID	= 2 * D3DRMLIGHT_MAX,
    D3DRMFILL_MASK	= 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX	= 8 * D3DRMLIGHT_MAX,

	D3DRMRENDER_WIREFRAME	=(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME),
	D3DRMRENDER_UNLITFLAT=	(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID),
	D3DRMRENDER_FLAT	=(D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID),
	D3DRMRENDER_GOURAUD	=(D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID),
	D3DRMRENDER_PHONG=	(D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

} D3DRMRENDERQUALITY;

typedef enum CONST_D3DRMTEXTURECHANGEDFLAGS {
	D3DRMTEXTURE_CHANGEDPIXELS        =  0x00000040, /* pixels have changed */
	D3DRMTEXTURE_CHANGEDPALETTE       =  0x00000080, /* palette has changed */
	D3DRMTEXTURE_INVALIDATEONLY       =  0x00000100 /* dirty regions are invalid */
} D3DRMTEXTURECHANGEDFLAGS;

typedef enum CONST_D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,		/* choose nearest texel */
    D3DRMTEXTURE_LINEAR,		/* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,		/* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,		/* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,	/* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR	/* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY;

typedef enum CONST_D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE;


typedef enum CONST_D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,			/* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,		/* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED		/* may not be used by renderer */
} D3DRMPALETTEFLAGS;



typedef enum CONST_D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME
} D3DRMWRAPTYPE;

typedef enum CONST_D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC,
    D3DRMPROJECT_RIGHTHANDPERSPECTIVE,
    D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC
} D3DRMPROJECTIONTYPE;

typedef enum CONST_D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT;

typedef enum CONST_D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE;

typedef enum CONST_D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,		/* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,		/* use only X and Z rotations */
    D3DRMCONSTRAIN_X		/* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT;

typedef enum CONST_D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE;

typedef enum CONST_D3DRMFOGMODE
{   D3DRMFOG_LINEAR,		/* linear between start and end */
    D3DRMFOG_EXPONENTIAL,	/* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED	/* density * exp(-distance*distance) */
} D3DRMFOGMODE;

typedef enum CONST_D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,	/* default */
    D3DRMZBUFFER_ENABLE,	/* enable zbuffering */
    D3DRMZBUFFER_DISABLE	/* disable zbuffering */
} D3DRMZBUFFERMODE;

typedef enum CONST_D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,	/* default */
    D3DRMSORT_NONE,		/* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,	/* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT	/* sort child frames back-to-front */
} D3DRMSORTMODE;


typedef enum CONST_D3DRMRAYPICKFLAGS {
	D3DRMRAYPICK_ONLYBOUNDINGBOXES		=1,
	D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES=	2,
	D3DRMRAYPICK_INTERPOLATEUV		=4,
	D3DRMRAYPICK_INTERPOLATECOLOR	=	8,
	D3DRMRAYPICK_INTERPOLATENORMAL	=	0x10
} D3DRMRAYPICKFLAGS;

typedef enum CONST_D3DRMADDTRIANGLESVT {
	D3DRMFVF_TYPE                   =0x00000001,
	D3DRMFVF_NORMAL                 =0x00000002,
	D3DRMFVF_COLOR                  =0x00000004,
	D3DRMFVF_TEXTURECOORDS          =0x00000008
} D3DRMADDTRIANGLESVT;

typedef enum CONST_D3DRMADDTRIANGLESFLAGS {
	D3DRMVERTEX_STRIP               =0x00000001,
	D3DRMVERTEX_FAN                 =0x00000002,
	D3DRMVERTEX_LIST                =0x00000004
} D3DRMADDTRIANGLESFLAGS;

typedef enum CONST_D3DRMFOGMETHOD {

	D3DRMFOGMETHOD_VERTEX         =1,
	D3DRMFOGMETHOD_TABLE          =2,
    D3DRMFOGMETHOD_ANY             =4
} D3DRMFOGMETHOD;

typedef enum CONST_D3DRMTRAVERALFLAGS {
	D3DRMFRAME_RENDERENABLE       = 0x00000001,
	D3DRMFRAME_PICKENABLE         = 0x00000002,
	D3DRMFRAME_RENDERANDPICKENABLE      = 0x00000003
} D3DRMTRAVERSALFLAGS;


typedef enum CONST_D3DRMINTERPOLATIONFLAGS {
	D3DRMINTERPOLATION_OPEN=0x01,
	D3DRMINTERPOLATION_CLOSED=0x02,
	D3DRMINTERPOLATION_NEAREST=0x0100,
	D3DRMINTERPOLATION_LINEAR=0x04,
	D3DRMINTERPOLATION_SPLINE=0x08,
	D3DRMINTERPOLATION_VERTEXCOLOR=0x40,
	D3DRMINTERPOLATION_SLERPNORMALS=0x80
} D3DRMINTERPOLATIONFLAGS;

typedef enum CONST_D3DRMHANDEDNESS {
      D3DRMOPTIONS_LEFTHANDED  =1,
	D3DRMOPTIONS_RIGHTHANDED =2
} D3DRMHANDEDNESS;

typedef enum CONST_D3DRMWIREFRAMEFLAGS {
	D3DRMWIREFRAME_CULL	=	1, /* cul,backfaces */
	D3DRMWIREFRAME_HIDDENLINE	=2, /* lines are obscured by closer objects */
	D3DRMWIREFRAME_CULLANDHIDELINES =3
} D3DRMWIREFRAMEFLAGS ;

typedef enum CONST_D3DRMCALLBACKORDERFLAGS {
	D3DRMCALLBACK_PREORDER		=0,
	D3DRMCALLBACK_POSTORDER		=1
} D3DRMCALLBACKORDERFLAGS;

typedef enum CONST_D3DRMRENDERMODEFLAGS {
	D3DRMRENDERMODE_DEFAULT=0,
	D3DRMRENDERMODE_BLENDEDTRANSPARENCY=1,
	D3DRMRENDERMODE_SORTEDTRANSPARENCY=2,
	D3DRMRENDERMODE_LIGHTINMODELSPACE= 8,
	D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR =16,
	D3DRMRENDERMODE_DISABLESORTEDALPHAZWRITE =32
} D3DRMRENDERMODEFLAGS;

typedef enum CONST_D3DRMPMESHSTATUSFLAGS {
	D3DRMPMESHSTATUS_VALID =0x01,
	D3DRMPMESHSTATUS_INTERRUPTED =0x02,
	D3DRMPMESHSTATUS_BASEMESHCOMPLETE =0x04,
	D3DRMPMESHSTATUS_COMPLETE =0x08,
	D3DRMPMESHSTATUS_RENDERABLE =0x10
} D3DRMPMESHSTATUSFLAGS ;

typedef enum  CONST_D3DRMPMESHEVENTFLAGS {
	D3DRMPMESHEVENT_BASEMESH =0x01,
	D3DRMPMESHEVENT_COMPLETE =0x02
} D3DRMPMESHEVENTFLAGS ;
	

typedef enum CONST_D3DRMFPTFFLAGS {
	D3DRMFPTF_ALPHA                           =0x00000001,
	D3DRMFPTF_NOALPHA                         =0x00000002,
	D3DRMFPTF_PALETTIZED                      =0x00000004,
	D3DRMFPTF_NOTPALETTIZED                   =0x00000008
} D3DRMFPTFFLAGS;

typedef enum CONST_D3DRMMAPPINGFLAGS {
	D3DRMMAP_WRAPU = 1,
	D3DRMMAP_WRAPV = 2,
	D3DRMMAP_PERSPCORRECT = 4
} D3DRMMAPPINGFLAGS;

typedef enum CONST_D3DRMSTATECHANGEFLAGS {
	D3DRMSTATECHANGE_UPDATEONLY               =0x000000001,
	D3DRMSTATECHANGE_VOLATILE                 =0x000000002,
	D3DRMSTATECHANGE_NONVOLATILE              =0x000000004,
	D3DRMSTATECHANGE_RENDER                   =0x000000020,
	D3DRMSTATECHANGE_LIGHT                    =0x000000040
} D3DRMSTATECHANGEFLAGS ;

typedef enum CONST_D3DRMLOADFLAGS {
	D3DRMLOAD_FROMFILE=0x00,
	D3DRMLOAD_FROMRESOURCE=0x01,
	D3DRMLOAD_FROMMEMORY=0x02,
	D3DRMLOAD_FROMSTREAM=0x04,
	D3DRMLOAD_FROMUR=0x08,
	D3DRMLOAD_BYNAME=0x10,
	D3DRMLOAD_BYPOSITION=0x20,
	D3DRMLOAD_BYGUID=0x40,
	D3DRMLOAD_FIRST =0x80,
	D3DRMLOAD_INSTANCEBYREFERENCE =0x100,
	D3DRMLOAD_INSTANCEBYCOPYING =0x200,
	D3DRMLOAD_ASYNCHRONOUS =0x400,
}D3DRMLOADFLAGS;

typedef enum CONST_D3DRMSAVEFLAGS {

	D3DRMXOFSAVE_NORMALS =1,
	D3DRMXOFSAVE_TEXTURECOORDINATES =2,
	D3DRMXOFSAVE_MATERIALS =4,
	D3DRMXOFSAVE_TEXTURENAMES =8,
	D3DRMXOFSAVE_ALL=15,
	D3DRMXOFSAVE_TEMPLATES =16,
	D3DRMXOFSAVE_TEXTURETOPOLOGY =32
} D3DRMSAVEFLAGS;

typedef enum CONST_D3DRMMATERIALOVERRIDEFLAGS {
	D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY     =0x00000001,
	D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY       =0x00000002,
	D3DRMMATERIALOVERRIDE_DIFFUSE               =0x00000003,
	D3DRMMATERIALOVERRIDE_AMBIENT               =0x00000004,
	D3DRMMATERIALOVERRIDE_EMISSIVE              =0x00000008,
	D3DRMMATERIALOVERRIDE_SPECULAR              =0x00000010,
	D3DRMMATERIALOVERRIDE_POWER                 =0x00000020,
	D3DRMMATERIALOVERRIDE_TEXTURE               =0x00000040,
	D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY =0x00000080,
	D3DRMMATERIALOVERRIDE_ALL                   =0x000000FF

} D3DRMMATERIALOVERRIDEFLAGS;


/************************/
/*	D3DIM STUFF	*/
/************************/


/*
 * Execute buffers are allocated via Direct3D.  These buffers may then
 * be filled by the application with instructions to execute along with
 * vertex data.
 */

#if 0
/*
 * Supported op codes for execute instructions.
 */
typedef enum CONST_D3DOPCODE {
    D3DOP_POINT             	= 1,
    D3DOP_LINE              	= 2,
    D3DOP_TRIANGLE		= 3,
    D3DOP_MATRIXLOAD       	= 4,
    D3DOP_MATRIXMULTIPLY   	= 5,
    D3DOP_STATETRANSFORM      	= 6,
    D3DOP_STATELIGHT      	= 7,
    D3DOP_STATERENDER      	= 8,
    D3DOP_PROCESSVERTICES    	= 9,
    D3DOP_TEXTURELOAD      	= 10,
    D3DOP_EXIT              	= 11,
    D3DOP_BRANCHFORWARD		= 12,
    D3DOP_SPAN			= 13,
    D3DOP_SETSTATUS		= 14    
} D3DOPCODE;

#endif 

/*
 * The following defines the rendering states which can be set in the
 * execute buffer.
 */

typedef enum CONST_D3DSHADEMODE {
    D3DSHADE_FLAT              = 1,
    D3DSHADE_GOURAUD           = 2,
    D3DSHADE_PHONG             = 3
    
} D3DSHADEMODE;

typedef enum CONST_D3DFILLMODE {
    D3DFILL_POINT	       = 1,
    D3DFILL_WIREFRAME	       = 2,
    D3DFILL_SOLID	       = 3    
} D3DFILLMODE;

/*
typedef enum CONST_D3DTEXTUREFILTER {
    D3DFILTER_NEAREST          = 1,
    D3DFILTER_LINEAR           = 2,
    D3DFILTER_MIPNEAREST       = 3,
    D3DFILTER_MIPLINEAR        = 4,
    D3DFILTER_LINEARMIPNEAREST = 5,
    D3DFILTER_LINEARMIPLINEAR  = 6    
} D3DTEXTUREFILTER;
*/

typedef enum CONST_D3DBLEND {
    D3DBLEND_ZERO              = 1,
    D3DBLEND_ONE               = 2,
    D3DBLEND_SRCCOLOR          = 3,
    D3DBLEND_INVSRCCOLOR       = 4,
    D3DBLEND_SRCALPHA          = 5,
    D3DBLEND_INVSRCALPHA       = 6,
    D3DBLEND_DESTALPHA         = 7,
    D3DBLEND_INVDESTALPHA      = 8,
    D3DBLEND_DESTCOLOR         = 9,
    D3DBLEND_INVDESTCOLOR      = 10,
    D3DBLEND_SRCALPHASAT       = 11,
    D3DBLEND_BOTHSRCALPHA      = 12,
    D3DBLEND_BOTHINVSRCALPHA   = 13    
} D3DBLEND;

/*
typedef enum CONST_D3DTEXTUREBLEND {
    D3DTBLEND_DECAL            = 1,
    D3DTBLEND_MODULATE         = 2,
    D3DTBLEND_DECALALPHA       = 3,
    D3DTBLEND_MODULATEALPHA    = 4,
    D3DTBLEND_DECALMASK        = 5,
    D3DTBLEND_MODULATEMASK     = 6,
    D3DTBLEND_COPY             = 7,
    D3DTBLEND_ADD              = 8    
} D3DTEXTUREBLEND;
*/

typedef enum CONST_D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP	       = 1,
    D3DTADDRESS_MIRROR	       = 2,
    D3DTADDRESS_CLAMP	       = 3,
    D3DTADDRESS_BORDER         = 4    
} D3DTEXTUREADDRESS;

typedef enum CONST_D3DCULL {
    D3DCULL_NONE               = 1,
    D3DCULL_CW                 = 2,
    D3DCULL_CCW                = 3    
} D3DCULL;

typedef enum CONST_D3DCMPFUNC {
    D3DCMP_NEVER               = 1,
    D3DCMP_LESS                = 2,
    D3DCMP_EQUAL               = 3,
    D3DCMP_LESSEQUAL           = 4,
    D3DCMP_GREATER             = 5,
    D3DCMP_NOTEQUAL            = 6,
    D3DCMP_GREATEREQUAL        = 7,
    D3DCMP_ALWAYS              = 8    
} D3DCMPFUNC;

typedef enum CONST_D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 1,
    D3DSTENCILOP_ZERO           = 2,
    D3DSTENCILOP_REPLACE        = 3,
    D3DSTENCILOP_INCRSAT        = 4,
    D3DSTENCILOP_DECRSAT        = 5,
    D3DSTENCILOP_INVERT         = 6,
    D3DSTENCILOP_INCR           = 7,
    D3DSTENCILOP_DECR           = 8    
} D3DSTENCILOP;

typedef enum CONST_D3DFOGMODE {
    D3DFOG_NONE                = 0,
    D3DFOG_EXP                 = 1,
    D3DFOG_EXP2                = 2,
    D3DFOG_LINEAR              = 3    
} D3DFOGMODE;

typedef enum CONST_D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2 // W buffering
   
} D3DZBUFFERTYPE;

typedef enum CONST_D3DANTIALIASMODE {
    D3DANTIALIAS_NONE          = 0,
    D3DANTIALIAS_SORTDEPENDENT = 1,
    D3DANTIALIAS_SORTINDEPENDENT = 2    
} D3DANTIALIASMODE;


typedef enum CONST_D3DPROCESSVERTICESFLAGS {
    D3DPV_DEFAULT=0,
    D3DPV_DONOTCOPYDATA=1
} D3DPROCESSVERTICESFLAGS;

// Vertex types supported by Direct3D
//typedef enum CONST_D3DVERTEXTYPE {
//    D3DVT_VERTEX        = 1,
//    D3DVT_LVERTEX       = 2,
//    D3DVT_TLVERTEX      = 3    
//} D3DVERTEXTYPE;

// Primitives supported by draw-primitive API
typedef enum CONST_D3DPRIMITIVETYPE {
    D3DPT_POINTLIST     = 1,
    D3DPT_LINELIST      = 2,
    D3DPT_LINESTRIP     = 3,
    D3DPT_TRIANGLELIST  = 4,
    D3DPT_TRIANGLESTRIP = 5,
    D3DPT_TRIANGLEFAN   = 6    
} D3DPRIMITIVETYPE;

typedef enum CONST_D3DTRANSFORMSTATETYPE {
    D3DTRANSFORMSTATE_WORLD           = 1,
    D3DTRANSFORMSTATE_VIEW            = 2,
    D3DTRANSFORMSTATE_PROJECTION      = 3
} D3DTRANSFORMSTATETYPE;

//typedef enum CONST_D3DLIGHTSTATETYPE {
//    D3DLIGHTSTATE_MATERIAL	      = 1,
//    D3DLIGHTSTATE_AMBIENT	      = 2,
//    D3DLIGHTSTATE_COLORMODEL	      = 3,
//    D3DLIGHTSTATE_FOGMODE	      = 4,
//    D3DLIGHTSTATE_FOGSTART	      = 5,
//    D3DLIGHTSTATE_FOGEND	      = 6,
//    D3DLIGHTSTATE_FOGDENSITY          = 7
//} D3DLIGHTSTATETYPE;


typedef enum CONST_D3DRENDERSTATETYPE {
    //D3DRENDERSTATE_TEXTUREHANDLE      = 1,    /* Texture handle */
    D3DRENDERSTATE_ANTIALIAS          = 2,    /* D3DANTIALIASMODE */
    //D3DRENDERSTATE_TEXTUREADDRESS     = 3,    /* D3DTEXTUREADDRESS	*/
    D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,    /* TRUE for perspective correction */
    //D3DRENDERSTATE_WRAPU	      = 5,    /* TRUE for wrapping in u */
    //D3DRENDERSTATE_WRAPV	      = 6,    /* TRUE for wrapping in v */
    D3DRENDERSTATE_ZENABLE            = 7,    /* TRUE to enable z test */
    D3DRENDERSTATE_FILLMODE           = 8,    /* D3DFILL_MODE		 */
    D3DRENDERSTATE_SHADEMODE          = 9,    /* D3DSHADEMODE */
    //REMOVING LINE PATERN BECUASE IT REQUIRES A STRUCTURE
	//ALL OTHER RENDER STATES JUST TAKE A LONG
	//Andrewke- added back in - use can be documented
	D3DRENDERSTATE_LINEPATTERN        = 10,   /* D3DLINEPATTERN */
    //D3DRENDERSTATE_MONOENABLE         = 11,   /* TRUE to enable mono rasterization */
    //D3DRENDERSTATE_ROP2               = 12,   /* ROP2 */
    //D3DRENDERSTATE_PLANEMASK          = 13,   /* DWORD physical plane mask */
    D3DRENDERSTATE_ZWRITEENABLE       = 14,   /* TRUE to enable z writes */
    D3DRENDERSTATE_ALPHATESTENABLE    = 15,   /* TRUE to enable alpha tests */
    D3DRENDERSTATE_LASTPIXEL          = 16,   /* TRUE for last-pixel on lines */
    //D3DRENDERSTATE_TEXTUREMAG         = 17,   /* D3DTEXTUREFILTER */
    //D3DRENDERSTATE_TEXTUREMIN         = 18,   /* D3DTEXTUREFILTER */
    D3DRENDERSTATE_SRCBLEND           = 19,   /* D3DBLEND */
    D3DRENDERSTATE_DESTBLEND          = 20,   /* D3DBLEND */
    //D3DRENDERSTATE_TEXTUREMAPBLEND    = 21,   /* D3DTEXTUREBLEND */
    D3DRENDERSTATE_CULLMODE           = 22,   /* D3DCULL */
    D3DRENDERSTATE_ZFUNC              = 23,   /* D3DCMPFUNC */
    D3DRENDERSTATE_ALPHAREF           = 24,   /* D3DFIXED */
    D3DRENDERSTATE_ALPHAFUNC          = 25,   /* D3DCMPFUNC */
    D3DRENDERSTATE_DITHERENABLE       = 26,   /* TRUE to enable dithering */
    D3DRENDERSTATE_ALPHABLENDENABLE   = 27,   /* TRUE to enable alpha blending */
    D3DRENDERSTATE_FOGENABLE          = 28,   /* TRUE to enable fog */
    D3DRENDERSTATE_SPECULARENABLE     = 29,   /* TRUE to enable specular */
    D3DRENDERSTATE_ZVISIBLE           = 30,   /* TRUE to enable z checking */
    //D3DRENDERSTATE_SUBPIXEL	      = 31,   /* TRUE to enable subpixel correction */
    //D3DRENDERSTATE_SUBPIXELX          = 32,   /* TRUE to enable correction in X only */
    D3DRENDERSTATE_STIPPLEDALPHA      = 33,   /* TRUE to enable stippled alpha */
    D3DRENDERSTATE_FOGCOLOR           = 34,   /* D3DCOLOR */
    D3DRENDERSTATE_FOGTABLEMODE       = 35,   /* D3DFOGMODE */
    //D3DRENDERSTATE_STIPPLEENABLE      = 39,   /* TRUE to enable stippling */
    D3DRENDERSTATE_EDGEANTIALIAS      = 40,   /* TRUE to enable edge antialiasing */
    D3DRENDERSTATE_COLORKEYENABLE     = 41,   /* TRUE to enable source colorkeyed textures */
    //D3DRENDERSTATE_BORDERCOLOR        = 43,   /* Border color for texturing w/border */
    //D3DRENDERSTATE_TEXTUREADDRESSU    = 44,   /* Texture addressing mode for U coordinate */
    //D3DRENDERSTATE_TEXTUREADDRESSV    = 45,   /* Texture addressing mode for V coordinate */
    //D3DRENDERSTATE_MIPMAPLODBIAS      = 46,   /* D3DVALUE Mipmap LOD bias */
    D3DRENDERSTATE_ZBIAS              = 47,   /* LONG Z bias */
    D3DRENDERSTATE_RANGEFOGENABLE     = 48,   /* Enables range-based fog */
    //D3DRENDERSTATE_ANISOTROPY         = 49,   /* Max. anisotropy. 1 = no anisotropy */
	//D3DRENDERSTATE_FLUSHBATCH		  = 50,   /* Explicit flush for DP batching (DX5 Only) */
    //D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT=51, /* BOOL enable sort-independent transparency */
    D3DRENDERSTATE_STENCILENABLE      = 52,   /* BOOL enable/disable stenciling */
    D3DRENDERSTATE_STENCILFAIL        = 53,   /* D3DSTENCILOP to do if stencil test fails */
    D3DRENDERSTATE_STENCILZFAIL       = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    D3DRENDERSTATE_STENCILPASS        = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    D3DRENDERSTATE_STENCILFUNC        = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    D3DRENDERSTATE_STENCILREF         = 57,   /* Reference value used in stencil test */
    D3DRENDERSTATE_STENCILMASK        = 58,   /* Mask value used in stencil test */
    D3DRENDERSTATE_STENCILWRITEMASK   = 59,   /* Write mask applied to values written to stencil buffer */
    D3DRENDERSTATE_TEXTUREFACTOR      = 60,   /* D3DCOLOR used for multi-texture blend */

	
	//D3DRENDERSTATE_STIPPLEPATTERN00   = 64,   /* Stipple pattern 01...	*/
    /*D3DRENDERSTATE_STIPPLEPATTERN01   = 65,
    D3DRENDERSTATE_STIPPLEPATTERN02   = 66,
    D3DRENDERSTATE_STIPPLEPATTERN03   = 67,
    D3DRENDERSTATE_STIPPLEPATTERN04   = 68,
    D3DRENDERSTATE_STIPPLEPATTERN05   = 69,
    D3DRENDERSTATE_STIPPLEPATTERN06   = 70,
    D3DRENDERSTATE_STIPPLEPATTERN07   = 71,
    D3DRENDERSTATE_STIPPLEPATTERN08   = 72,
    D3DRENDERSTATE_STIPPLEPATTERN09   = 73,
    D3DRENDERSTATE_STIPPLEPATTERN10   = 74,
    D3DRENDERSTATE_STIPPLEPATTERN11   = 75,
    D3DRENDERSTATE_STIPPLEPATTERN12   = 76,
    D3DRENDERSTATE_STIPPLEPATTERN13   = 77,
    D3DRENDERSTATE_STIPPLEPATTERN14   = 78,
    D3DRENDERSTATE_STIPPLEPATTERN15   = 79,
    D3DRENDERSTATE_STIPPLEPATTERN16   = 80,
    D3DRENDERSTATE_STIPPLEPATTERN17   = 81,
    D3DRENDERSTATE_STIPPLEPATTERN18   = 82,
    D3DRENDERSTATE_STIPPLEPATTERN19   = 83,
    D3DRENDERSTATE_STIPPLEPATTERN20   = 84,
    D3DRENDERSTATE_STIPPLEPATTERN21   = 85,
    D3DRENDERSTATE_STIPPLEPATTERN22   = 86,
    D3DRENDERSTATE_STIPPLEPATTERN23   = 87,
    D3DRENDERSTATE_STIPPLEPATTERN24   = 88,
    D3DRENDERSTATE_STIPPLEPATTERN25   = 89,
    D3DRENDERSTATE_STIPPLEPATTERN26   = 90,
    D3DRENDERSTATE_STIPPLEPATTERN27   = 91,
    D3DRENDERSTATE_STIPPLEPATTERN28   = 92,
    D3DRENDERSTATE_STIPPLEPATTERN29   = 93,
    D3DRENDERSTATE_STIPPLEPATTERN30   = 94,
    D3DRENDERSTATE_STIPPLEPATTERN31   = 95,
	*/

    D3DRENDERSTATE_WRAP0              = 128,  /* wrap for 1st texture coord. set */
    D3DRENDERSTATE_WRAP1              = 129,  /* wrap for 2nd texture coord. set */
    D3DRENDERSTATE_WRAP2              = 130,  /* wrap for 3rd texture coord. set */
    D3DRENDERSTATE_WRAP3              = 131,  /* wrap for 4th texture coord. set */
    D3DRENDERSTATE_WRAP4              = 132,  /* wrap for 5th texture coord. set */
    D3DRENDERSTATE_WRAP5              = 133,  /* wrap for 6th texture coord. set */
    D3DRENDERSTATE_WRAP6              = 134,  /* wrap for 7th texture coord. set */
    D3DRENDERSTATE_WRAP7              = 135,  /* wrap for 8th texture coord. set */

	
	//DX7STATE	
    D3DRENDERSTATE_CLIPPING            = 136,
    D3DRENDERSTATE_LIGHTING            = 137,
    D3DRENDERSTATE_EXTENTS             = 138,
    D3DRENDERSTATE_AMBIENT             = 139,
    D3DRENDERSTATE_FOGVERTEXMODE       = 140,
    D3DRENDERSTATE_COLORVERTEX         = 141,
    D3DRENDERSTATE_LOCALVIEWER         = 142,
    D3DRENDERSTATE_NORMALIZENORMALS    = 143,
    D3DRENDERSTATE_COLORKEYBLENDENABLE = 144,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE    = 145,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE   = 146,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE    = 147,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE   = 148,
    D3DRENDERSTATE_ALPHASOURCE              = 149,
    D3DRENDERSTATE_FOGFACTORSOURCE          = 150,
    D3DRENDERSTATE_VERTEXBLEND              = 151,
    D3DRENDERSTATE_CLIPPLANEENABLE          = 152,
    //D3DRENDERSTATE_POINTSIZE                = 153,   /* D3DVALUE Point size */
    //D3DRENDERSTATE_POINTATTENUATION_A       = 154,   /* D3DVALUE Point attenuation a value */
    //D3DRENDERSTATE_POINTATTENUATION_B       = 155,   /* D3DVALUE Point attenuation b value */
    //D3DRENDERSTATE_POINTATTENUATION_C       = 156,   /* D3DVALUE Point attenuation c value */
    //D3DRENDERSTATE_POINTSIZEMIN             = 157,   /* D3DVALUE Point size minimum threshold */
    //D3DRENDERSTATE_POINTSPRITEENABLE        = 158,   /* BOOL if true, render whole texture for point, */



} D3DRENDERSTATETYPE;


typedef enum CONST_D3DRENDERSTATESINGLE {
    D3DRENDERSTATE_FOGSTART      = 36,   /* Fog table start	*/
    D3DRENDERSTATE_FOGEND        = 37,   /* Fog table end		*/
    D3DRENDERSTATE_FOGDENSITY    = 38,   /* Fog table density	*/
} D3DRENDERSTATESINGLE;


typedef enum CONST_DDLOCKFLAGS {

	/****************************************************************************
	 *
	 * DIRECTDRAWSURFACE LOCK FLAGS
	 *
	 ****************************************************************************/

	/*
	 * The default.	 Set to indicate that Lock should return a valid memory pointer
	 * to the top of the specified rectangle.  If no rectangle is specified then a
	 * pointer to the top of the surface is returned.
	 */
	 DDLOCK_SURFACEMEMORYPTR			=0x00000000,	// default

	/*
	 * Set to indicate that Lock should wait until it can obtain a valid memory
	 * pointer before returning.  If this bit is set, Lock will never return
	 * DDERR_WASSTILLDRAWING.
	 */
	 DDLOCK_WAIT				=0x00000001,

	/*
	 * Set if an event handle is being passed to Lock.  Lock will trigger the event
	 * when it can return the surface memory pointer requested.
	 */
	 DDLOCK_EVENT				=0x00000002,

	/*
	 * Indicates that the surface being locked will only be read from.
	 */
	 DDLOCK_READONLY				=0x00000010,

	/*
	 * Indicates that the surface being locked will only be written to
	 */
	 DDLOCK_WRITEONLY			=0x00000020,


	/*
	 * Indicates that a system wide lock should not be taken when this surface
	 * is locked. This has several advantages (cursor responsiveness, ability
	 * to call more Windows functions, easier debugging) when locking video
	 * memory surfaces. However, an application specifying this flag must
	 * comply with a number of conditions documented in the help file.
	 * Furthermore, this flag cannot be specified when locking the primary.
	 */
	 DDLOCK_NOSYSLOCK                        =0x00000800,

	 DDLOCK_DONOTWAIT                        =0x00004000,

} DDLOCKFLAGS;

typedef enum CONST_DDPCAPSFLAGS {
	
	/****************************************************************************
	 *
	 * DIRECTDRAWPALETTE CAPABILITIES
	 *
	 ****************************************************************************/

	/*
	 * Index is 4 bits.  There are sixteen color entries in the palette table.
	 */
	 DDPCAPS_4BIT			=0x00000001,

	/*
	 * Index is onto a 8 bit color index.  This field is only valid with the
	 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
	 * surface is in 8bpp. Each color entry is one byte long and is an index
	 * into destination surface's 8bpp palette.
	 */
	 DDPCAPS_8BITENTRIES		=0x00000002,

	/*
	 * Index is 8 bits.  There are 256 color entries in the palette table.
	 */
	 DDPCAPS_8BIT			=0x00000004,

	/*
	 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
	 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
	 * object.
	 */
	 DDPCAPS_INITIALIZE		=0x00000008,

	/*
	 * This palette is the one attached to the primary surface.  Changing this
	 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
	 * and supported.
	 */
	 DDPCAPS_PRIMARYSURFACE		=0x00000010,

	/*
	 * This palette is the one attached to the primary surface left.  Changing
	 * this table has immediate effect on the display for the left eye unless
	 * DDPSETPAL_VSYNC is specified and supported.
	 */
	 DDPCAPS_PRIMARYSURFACELEFT	=0x00000020,

	/*
	 * This palette can have all 256 entries defined
	 */
	 DDPCAPS_ALLOW256		=0x00000040,

	/*
	 * This palette can have modifications to it synced with the monitors
	 * refresh rate.
	 */
	 DDPCAPS_VSYNC			=0x00000080,

	/*
	 * Index is 1 bit.  There are two color entries in the palette table.
	 */
	 DDPCAPS_1BIT			=0x00000100,

	/*
	 * Index is 2 bit.  There are four color entries in the palette table.
	 */
	 DDPCAPS_2BIT			=0x00000200,

	 DDPCAPS_ALPHA			=0x00000400

	

} DDPCAPSFLAGS;

typedef enum CONST_DDEDMFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
	 *
	 ****************************************************************************/

	DDEDM_DEFAULT				=0x00000000,
	/*
	 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
	 * that a particular mode will be enumerated only once.  This flag specifies whether
	 * the refresh rate is taken into account when determining if a mode is unique.
	 */
	 DDEDM_REFRESHRATES			=0x00000001,

	/*
	 * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
	 * modes such as mode =0x13 in addition to the usual ModeX modes (which are always
	 * enumerated if the application has previously called SetCooperativeLevel with the
	 * DDSCL_ALLOWMODEX flag set).
	 */
	 DDEDM_STANDARDVGAMODES                  =0x00000002


} DDEDMFLAGS;

typedef enum CONST_DDSCLFLAGS {
/****************************************************************************
	 *
	 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Exclusive mode owner will be responsible for the entire primary surface.
	 * GDI can be ignored. used with DD
	 */
	 DDSCL_FULLSCREEN			=0x00000001,

	/*
	 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
	 */
	 DDSCL_ALLOWREBOOT			=0x00000002,

	/*
	 * prevents DDRAW from modifying the application window.
	 * prevents DDRAW from minimize/restore the application window on activation.
	 */
	 DDSCL_NOWINDOWCHANGES			=0x00000004,

	/*
	 * app wants to work as a regular Windows application
	 */
	 DDSCL_NORMAL				=0x00000008,

	/*
	 * app wants exclusive access
	 */
	 DDSCL_EXCLUSIVE                        =0x00000010,


	/*
	 * app can deal with non-windows display modes
	 */
	 DDSCL_ALLOWMODEX                       =0x00000040,


	 DDSCL_CREATEDEVICEWINDOW				=0x00000200,
	 //DDSCL_FPUSETUP							=0x00000800,
         DDSCL_MULTITHREADED                                  =0x00000400,
	 DDSCL_SETDEVICEWINDOW					=0x00000100,
	 DDSCL_SETFOCUSWINDOW					=0x00000080


} DDSCLFLAGS;

typedef enum CONST_DDSDMFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW SETDISPLAYMODE FLAGS
	 *
	 ****************************************************************************/

	 DDSDM_DEFAULT                   =0x00000000,
	/*
	 * The desired mode is a standard VGA mode
	 */
	 DDSDM_STANDARDVGAMODE                   =0x00000001


} DDSDMFLAGS;

// ******** DDRAW * //

typedef enum CONST_DDBLTFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW BLT FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Use the alpha information in the pixel format or the alpha channel surface
	 * attached to the destination surface as the alpha channel for this blt.
	 */
	 //DDBLT_ALPHADEST				=0x00000001,

	/*
	 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
	 * for the destination surface for this blt.
	 */
	 //DDBLT_ALPHADESTCONSTOVERRIDE		=0x00000002,

	/*
	 * The NEG suffix indicates that the destination surface becomes more
	 * transparent as the alpha value increases. (0 is opaque)
	 */
	 //DDBLT_ALPHADESTNEG			=0x00000004,

	/*
	 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
	 * channel for the destination for this blt.
	 */
	 //DDBLT_ALPHADESTSURFACEOVERRIDE		=0x00000008,

	/*
	 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
	 * for the edges of the image that border the color key colors.
	 */
	 //DDBLT_ALPHAEDGEBLEND			=0x00000010,

	/*
	 * Use the alpha information in the pixel format or the alpha channel surface
	 * attached to the source surface as the alpha channel for this blt.
	 */
	 //DDBLT_ALPHASRC				=0x00000020,

	/*
	 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
	 * for the source for this blt.
	 */
	 //DDBLT_ALPHASRCCONSTOVERRIDE		=0x00000040,

	/*
	 * The NEG suffix indicates that the source surface becomes more transparent
	 * as the alpha value increases. (0 is opaque)
	 */
	 //DDBLT_ALPHASRCNEG			=0x00000080,

	/*
	 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
	 * for the source for this blt.
	 */
	 //DDBLT_ALPHASRCSURFACEOVERRIDE		=0x00000100,


	/*
	 * Z-buffered blt using the z-buffers attached to the source and destination
	 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
	 * z-buffer opcode.
	 */
	 //DDBLT_ZBUFFER				=0x00080000,

	/*
	 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
	 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
	 * for the destination.
	 */
	 //DDBLT_ZBUFFERDESTCONSTOVERRIDE		=0x00100000,

	/*
	 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
	 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
	 * respectively for the destination.
	 */
	 //DDBLT_ZBUFFERDESTOVERRIDE		=0x00200000,

	/*
	 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
	 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
	 * for the source.
	 */
	 //DDBLT_ZBUFFERSRCCONSTOVERRIDE		=0x00400000,

	/*
	 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
	 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
	 * respectively for the source.
	 */
	 //DDBLT_ZBUFFERSRCOVERRIDE                =0x00800000,

	/*
	 * Do this blt asynchronously through the FIFO in the order received.  If
	 * there is no room in the hardware FIFO fail the call.
	 */
	 DDBLT_ASYNC				=0x00000200,

	/*
	 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
	 * to fill the destination rectangle on the destination surface with.
	 */
	 DDBLT_COLORFILL				=0x00000400,

	/*
	 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
	 * to use for the blt.
	 */
	 DDBLT_DDFX				=0x00000800,

	/*
	 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
	 * that are not part of the Win32 API.
	 */
	 DDBLT_DDROPS				=0x00001000,

	/*
	 * Use the color key associated with the destination surface.
	 */
	 DDBLT_KEYDEST				=0x00002000,

	/*
	 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
	 * for the destination surface.
	 */
	 DDBLT_KEYDESTOVERRIDE			=0x00004000,

	/*
	 * Use the color key associated with the source surface.
	 */
	 DDBLT_KEYSRC				=0x00008000,

	/*
	 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
	 * for the source surface.
	 */
	 DDBLT_KEYSRCOVERRIDE			=0x00010000,

	/*
	 * Use the dwROP field in the DDBLTFX structure for the raster operation
	 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
	 */
	 DDBLT_ROP				=0x00020000,

	/*
	 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
	 * (specified in 1/100th of a degree) to rotate the surface.
	 */
	 DDBLT_ROTATIONANGLE			=0x00040000,


	/*
	 * wait until the device is ready to handle the blt
	 * this will cause blt to not return DDERR_WASSTILLDRAWING
	 */
	 DDBLT_WAIT                              =0x01000000,

	/*
	 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
	 * to fill the destination rectangle on the destination Z-buffer surface
	 * with.
	 */
	 DDBLT_DEPTHFILL				=0x02000000,

	 //DX7
	 DDBLT_DONOTWAIT                         =0x08000000,

} DDBLTFLAGS;

#if 0
typedef enum CONST_DDBASICBLTFLAGS;
	/*
	 * Do this blt asynchronously through the FIFO in the order received.  If
	 * there is no room in the hardware FIFO fail the call.
	 */
	 DDBLT_ASYNC				=0x00000200,

	/*
	 * Use the color key associated with the destination surface.
	 */
	 DDBLT_KEYDEST				=0x00002000,

	/*
	 * Use the color key associated with the source surface.
	 */
	 DDBLT_KEYSRC				=0x00008000,

	/*
	 * wait until the device is ready to handle the blt
	 * this will cause blt to not return DDERR_WASSTILLDRAWING
	 */
	 DDBLT_WAIT                              =0x01000000,

	/*
	 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
	 * to fill the destination rectangle on the destination Z-buffer surface
	 * with.
	 */
	 DDBLT_DEPTHFILL				=0x02000000


} DDBASICBLTFLAGS;
#endif 

typedef enum CONST_DDBLTFASTFLAGS {
	
	/****************************************************************************
	 *
	 * BLTFAST FLAGS
	 *
	 ****************************************************************************/

	 DDBLTFAST_NOCOLORKEY                    =0x00000000,
	 DDBLTFAST_SRCCOLORKEY                   =0x00000001,
	 DDBLTFAST_DESTCOLORKEY                  =0x00000002,
	 DDBLTFAST_WAIT                          =0x00000010,
	 DDBLTFAST_DONOTWAIT                     =0x00000020

} DDBLTFASTFLAGS;

#if 0
typedef enum CONST_DDABLTFLAGS {
	DDABLT_KEYSRC 					=0x40000000,
	DDABLT_MIRRORLEFTRIGHT 			=0x20000000,
	DDABLT_MIRRORUPDOWN 	  		=0x10000000,
	DDABLT_WAIT 					=0x08000000,
	DDABLT_HARDWAREONLY 			=0x04000000,
	DDABLT_NOBLEND 					=0x02000000,
	DDABLT_FILTERENABLE 			=0x01000000,
	DDABLT_FILTERDISABLE 			=0x00800000,
	DDABLT_DEGRADEARGBSCALING 		=0x00400000,
	DDABLT_DONOTWAIT				=0x00200000,
	DDABLT_USEFILLVALUE				=0x00100000,
	DDABLT_SOFTWAREONLY				=0x00080000,
	DDABLT_FILTERTRANSPBORDER		=0x00040000
} CONST_DDABLTFLAGS;
#endif


typedef enum CONST_DDFLIPFLAGS {
	/****************************************************************************
	 *
	 * FLIP FLAGS
	 *
	 ****************************************************************************/

	 DDFLIP_WAIT                          =0x00000001,

	/*
	 * Indicates that the target surface contains the even field of video data.
	 * This flag is only valid with an overlay surface.
	 */
	 DDFLIP_EVEN                          =0x00000002,

	/*
	 * Indicates that the target surface contains the odd field of video data.
	 * This flag is only valid with an overlay surface.
	 */
	 DDFLIP_ODD                           =0x00000004,

	 DDFLIP_NOVSYNC                       =0x00000008,
	 DDFLIP_STEREO						  =0x00000010,
	 DDFLIP_DONOTWAIT                     =0x00000020,

	 DDFLIP_INTERFVAL2                    =0x20000000,
	 DDFLIP_INTERFVAL3                    =0x30000000,
	 DDFLIP_INTERFVAL4                    =0x40000000

	 
} DDFLIPFLAGS;


typedef enum CONST_DDENUMOVERLAYZFLAGS {
	/*
	 *
	 * DIRECTDRAW ENUMOVERLAYZORDER FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Enumerate overlays back to front.
	 */
	 DDENUMOVERLAYZ_BACKTOFRONT	=0x00000000,

	/*
	 * Enumerate overlays front to back
	 */
	 DDENUMOVERLAYZ_FRONTTOBACK	=0x00000001,
} DDENUMOVERLAYZFLAGS;


typedef enum CONST_DDOVERFLAGS {

	/****************************************************************************
	 *
	 * DIRECTDRAW SURFACE OVERLAY FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Use the alpha information in the pixel format or the alpha channel surface
	 * attached to the destination surface as the alpha channel for the
	 * destination overlay.
	 */
	 DDOVER_ALPHADEST			=0x00000001,

	/*
	 * Use the dwConstAlphaDest field in the DDOVERLAYFX structure as the
	 * destination alpha channel for this overlay.
	 */
	 DDOVER_ALPHADESTCONSTOVERRIDE		=0x00000002,

	/*
	 * The NEG suffix indicates that the destination surface becomes more
	 * transparent as the alpha value increases.
	 */
	 DDOVER_ALPHADESTNEG			=0x00000004,

	/*
	 * Use the lpDDSAlphaDest field in the DDOVERLAYFX structure as the alpha
	 * channel destination for this overlay.
	 */
	 DDOVER_ALPHADESTSURFACEOVERRIDE		=0x00000008,

	/*
	 * Use the dwAlphaEdgeBlend field in the DDOVERLAYFX structure as the alpha
	 * channel for the edges of the image that border the color key colors.
	 */
	 DDOVER_ALPHAEDGEBLEND			=0x00000010,

	/*
	 * Use the alpha information in the pixel format or the alpha channel surface
	 * attached to the source surface as the source alpha channel for this overlay.
	 */
	 DDOVER_ALPHASRC				=0x00000020,

	/*
	 * Use the dwConstAlphaSrc field in the DDOVERLAYFX structure as the source
	 * alpha channel for this overlay.
	 */
	 DDOVER_ALPHASRCCONSTOVERRIDE		=0x00000040,

	/*
	 * The NEG suffix indicates that the source surface becomes more transparent
	 * as the alpha value increases.
	 */
	 DDOVER_ALPHASRCNEG			=0x00000080,

	/*
	 * Use the lpDDSAlphaSrc field in the DDOVERLAYFX structure as the alpha channel
	 * source for this overlay.
	 */
	 DDOVER_ALPHASRCSURFACEOVERRIDE		=0x00000100,

	/*
	 * Turn this overlay off.
	 */
	 DDOVER_HIDE				=0x00000200,

	/*
	 * Use the color key associated with the destination surface.
	 */
	 DDOVER_KEYDEST				=0x00000400,

	/*
	 * Use the dckDestColorkey field in the DDOVERLAYFX structure as the color key
	 * for the destination surface
	 */
	 DDOVER_KEYDESTOVERRIDE			=0x00000800,

	/*
	 * Use the color key associated with the source surface.
	 */
	 DDOVER_KEYSRC				=0x00001000,

	/*
	 * Use the dckSrcColorkey field in the DDOVERLAYFX structure as the color key
	 * for the source surface.
	 */
	 DDOVER_KEYSRCOVERRIDE			=0x00002000,

	/*
	 * Turn this overlay on.
	 */
	 DDOVER_SHOW				=0x00004000,

	/*
	 * Add a dirty rect to an emulated overlayed surface.
	 */
	 DDOVER_ADDDIRTYRECT                     =0x00008000,

	/*
	 * Redraw all dirty rects on an emulated overlayed surface.
	 */
	 DDOVER_REFRESHDIRTYRECTS		=0x00010000,

	/*
	 * Redraw the entire surface on an emulated overlayed surface.
	 */
	 DDOVER_REFRESHALL                      =0x00020000,


	/*
	 * Use the overlay FX flags to define special overlay FX
	 */
	 DDOVER_DDFX                       	=0x00080000,

	/*
	 * Autoflip the overlay when ever the video port autoflips
	 */
	 DDOVER_AUTOFLIP                       	=0x00100000,

	/*
	 * Display each field of video port data individually without
	 * causing any jittery artifacts
	 */
	 DDOVER_BOB                       	=0x00200000,

	/*
	 * Indicates that bob/weave decisions should not be overridden by other
	 * interfaces.
	 */
	 DDOVER_OVERRIDEBOBWEAVE			=0x00400000,

	/*
	 * Indicates that the surface memory is composed of interleaved fields.
	 */
	 DDOVER_INTERLEAVED					=0x00800000,

	/* DX7 */
	DDOVER_ARGBSCALEFACTORS				=0x02000000,
	DDOVER_DEGRADEARGBSCALING			=0x04000000



} DDOVERFLAGS;

typedef enum  CONST_DDOVERZFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW UPDATEOVERLAYZORDER FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Send overlay to front
	 */
	 DDOVERZ_SENDTOFRONT		=0x00000000,

	/*
	 * Send overlay to back
	 */
	 DDOVERZ_SENDTOBACK		=0x00000001,

	/*
	 * Move Overlay forward
	 */
	 DDOVERZ_MOVEFORWARD		=0x00000002,

	/*
	 * Move Overlay backward
	 */
	 DDOVERZ_MOVEBACKWARD		=0x00000003,

	/*
	 * Move Overlay in front of relative surface
	 */
	 DDOVERZ_INSERTINFRONTOF		=0x00000004,

	/*
	 * Move Overlay in back of relative surface
	 */
	 DDOVERZ_INSERTINBACKOF		=0x00000005,
} DDOVERZFLAGS;


typedef enum CONST_DDGFSFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW GETFLIPSTATUS FLAGS
	 *
	 ****************************************************************************/

	/*
	 * is it OK to flip now?
	 */
	 DDGFS_CANFLIP			=0x00000001,

	/*
	 * is the last flip finished?
	 */
	 DDGFS_ISFLIPDONE		=0x00000002
} DDGFSFLAGS;

typedef enum CONST_DDGBSFLAGS { 

	/****************************************************************************
	 *
	 * DIRECTDRAW GETBLTSTATUS FLAGS
	 *
	 ****************************************************************************/

	/*
	 * is it OK to blt now?
	 */
	 DDGBS_CANBLT			=0x00000001,

	/*
	 * is the blt to the surface finished?
	 */
	 DDGBS_ISBLTDONE			=0x00000002
} DDGBSFLAGS;


typedef enum CONST_DDCKEYFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Set if the structure contains a color space.	 Not set if the structure
	 * contains a single color key.
	 */
	 DDCKEY_COLORSPACE	=0x00000001,

	/*
	 * Set if the structure specifies a color key or color space which is to be
	 * used as a destination color key for blt operations.
	 */
	 DDCKEY_DESTBLT		=0x00000002,

	/*
	 * Set if the structure specifies a color key or color space which is to be
	 * used as a destination color key for overlay operations.
	 */
	 DDCKEY_DESTOVERLAY	=0x00000004,

	/*
	 * Set if the structure specifies a color key or color space which is to be
	 * used as a source color key for blt operations.
	 */
	 DDCKEY_SRCBLT		=0x00000008,

	/*
	 * Set if the structure specifies a color key or color space which is to be
	 * used as a source color key for overlay operations.
	 */
	 DDCKEY_SRCOVERLAY	=0x00000010

} DDCKEYFLAGS;

typedef enum CONST_DDSGRFLAGS {
	DDSGR_DEFAULT		= 0x00000000,
	DDSGR_CALIBRATE		= 0x00000001
} DDSGRFLAGS;
typedef enum CONST_DBOOLFLAGS {
	D_FALSE =0,
	D_TRUE =1
} DBOOLFLAGS;

typedef enum CONST_DDBITDEPTHFLAGS {
	/*
	 * 1 bit per pixel.
	 */
	 DDBD_1			=0x00004000,

	/*
	 * 2 bits per pixel.
	 */
	 DDBD_2			=0x00002000,

	/*
	 * 4 bits per pixel.
	 */
	 DDBD_4			=0x00001000,

	/*
	 * 8 bits per pixel.
	 */
	 DDBD_8			=0x00000800,

	/*
	 * 16 bits per pixel.
	 */
	 DDBD_16			=0x00000400,

	/*
	 * 24 bits per pixel.
	 */
	 DDBD_24			=0x00000200,

	/*
	 * 32 bits per pixel.
	 */
	 DDBD_32			=0x00000100,

} DDBITDEPTHFLAGS;

typedef enum CONST_DDSURFACEDESCFLAGS {
	/*
	 * ddsCaps field is valid.
	 */
	 DDSD_CAPS		=0x00000001,	// default

	/*
	 * dwHeight field is valid.
	 */
	 DDSD_HEIGHT		=0x00000002,

	/*
	 * dwWidth field is valid.
	 */
	 DDSD_WIDTH		=0x00000004,

	/*
	 * lPitch is valid.
	 */
	 DDSD_PITCH		=0x00000008,

	/*
	 * dwBackBufferCount is valid.
	 */
	 DDSD_BACKBUFFERCOUNT	=0x00000020,

	/*
	 * dwZBufferBitDepth is valid.
	 */
	 DDSD_ZBUFFERBITDEPTH	=0x00000040,

	/*
	 * dwAlphaBitDepth is valid.
	 */
	 DDSD_ALPHABITDEPTH	=0x00000080,


	 DDSD_TEXTURESTAGE       =0x00100000,

	/*
	 * lpSurface is valid.
	 */
	 DDSD_LPSURFACE		=0x00000800,

	/*
	 * ddpfPixelFormat is valid.
	 */
	 DDSD_PIXELFORMAT	=0x00001000,

	/*
	 * ddckCKDestOverlay is valid.
	 */
	 DDSD_CKDESTOVERLAY	=0x00002000,

	/*
	 * ddckCKDestBlt is valid.
	 */
	 DDSD_CKDESTBLT		=0x00004000,

	/*
	 * ddckCKSrcOverlay is valid.
	 */
	 DDSD_CKSRCOVERLAY	=0x00008000,

	/*
	 * ddckCKSrcBlt is valid.
	 */
	 DDSD_CKSRCBLT		=0x00010000,

	/*
	 * dwMipMapCount is valid.
	 */
	 DDSD_MIPMAPCOUNT        =0x00020000,

	 /*
	  * dwRefreshRate is valid
	  */
	 DDSD_REFRESHRATE	=0x00040000,

	/*
	 * dwLinearSize is valid
	 */
	 DDSD_LINEARSIZE		=0x00080000,

	/*
	 * All input fields are valid.
	 */
	 DDSD_ALL		=0x000ff9ee,

} DDSURFACEDESCFLAGS;

typedef enum CONST_DDCOLORFLAGS {

	/*
	 * lBrightness field is valid.
	 */
	 DDCOLOR_BRIGHTNESS		=0x00000001,

	/*
	 * lContrast field is valid.
	 */
	 DDCOLOR_CONTRAST		=0x00000002,

	/*
	 * lHue field is valid.
	 */
	 DDCOLOR_HUE			=0x00000004,

	/*
	 * lSaturation field is valid.
	 */
	 DDCOLOR_SATURATION		=0x00000008,

	/*
	 * lSharpness field is valid.
	 */
	 DDCOLOR_SHARPNESS		=0x00000010,

	/*
	 * lGamma field is valid.
	 */
	 DDCOLOR_GAMMA			=0x00000020,

	/*
	 * lColorEnable field is valid.
	 */
	 DDCOLOR_COLORENABLE		=0x00000040
} DDCOLORFLAGS;

typedef enum CONST_DDSURFACECAPSFLAGS {
	/*
	 * Indicates that this surface contains alpha-only information.
	 * (To determine if a surface is RGBA/YUVA, the pixel format must be
	 * interrogated.)
	 */
	 DDSCAPS_ALPHA				=0x00000002,

	/*
	 * Indicates that this surface is a backbuffer.	 It is generally
	 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
	 * It indicates that this surface is THE back buffer of a surface
	 * flipping structure.	DirectDraw supports N surfaces in a
	 * surface flipping structure.	Only the surface that immediately
	 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
	 * The other surfaces are identified as back buffers by the presence
	 * of the DDSCAPS_FLIP capability, their attachment order, and the
	 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
	 * capabilities.  The bit is sent to CreateSurface when a standalone
	 * back buffer is being created.  This surface could be attached to
	 * a front buffer and/or back buffers to form a flipping surface
	 * structure after the CreateSurface call.  See AddAttachments for
	 * a detailed description of the behaviors in this case.
	 */
	 DDSCAPS_BACKBUFFER			=0x00000004,

	/*
	 * Indicates a complex surface structure is being described.  A
	 * complex surface structure results in the creation of more than
	 * one surface.	 The additional surfaces are attached to the root
	 * surface.  The complex structure can only be destroyed by
	 * destroying the root.
	 */
	 DDSCAPS_COMPLEX				=0x00000008,

	/*
	 * Indicates that this surface is a part of a surface flipping structure.
	 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
	 * DDSCAP_BACKBUFFER bits are not set.	They are set by CreateSurface
	 * on the resulting creations.	The dwBackBufferCount field in the
	 * DDSURFACEDESC structure must be set to at least 1 in order for
	 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
	 * must always be set with creating multiple surfaces through CreateSurface.
	 */
	 DDSCAPS_FLIP				=0x00000010,

	/*
	 * Indicates that this surface is THE front buffer of a surface flipping
	 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
	 * capability bit is set.
	 * If this capability is sent to CreateSurface then a standalonw front buffer
	 * is created.	This surface will not have the DDSCAPS_FLIP capability.
	 * It can be attached to other back buffers to form a flipping structure.
	 * See AddAttachments for a detailed description of the behaviors in this
	 * case.
	 */
	 DDSCAPS_FRONTBUFFER			=0x00000020,

	/*
	 * Indicates that this surface is any offscreen surface that is not an overlay,
	 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
	 * to identify plain vanilla surfaces.
	 */
	 DDSCAPS_OFFSCREENPLAIN			=0x00000040,

	/*
	 * Indicates that this surface is an overlay.  It may or may not be directly visible
	 * depending on whether or not it is currently being overlayed onto the primary
	 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
	 * overlayed at the moment.
	 */
	 DDSCAPS_OVERLAY				=0x00000080,

	/*
	 * Indicates that unique DirectDrawPalette objects can be created and
	 * attached to this surface.
	 */
	 DDSCAPS_PALETTE				=0x00000100,

	/*
	 * Indicates that this surface is the primary surface.	The primary
	 * surface represents what the user is seeing at the moment.
	 */
	 DDSCAPS_PRIMARYSURFACE			=0x00000200,

	/*
	 * Indicates that this surface is the primary surface for the left eye.
	 * The primary surface for the left eye represents what the user is seeing
	 * at the moment with the users left eye.  When this surface is created the
	 * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
	 * right eye.
	 */
	 DDSCAPS_PRIMARYSURFACELEFT		=0x00000400,

	/*
	 * Indicates that this surface memory was allocated in system memory
	 */
	 DDSCAPS_SYSTEMMEMORY			=0x00000800,

	/*
	 * Indicates that this surface can be used as a 3D texture.  It does not
	 * indicate whether or not the surface is being used for that purpose.
	 */
	 DDSCAPS_TEXTURE			        =0x00001000,

	/*
	 * Indicates that a surface may be a destination for 3D rendering.  This
	 * bit must be set in order to query for a Direct3D Device Interface
	 * from this surface.
	 */
	 DDSCAPS_3DDEVICE                        =0x00002000,

	/*
	 * Indicates that this surface exists in video memory.
	 */
	 DDSCAPS_VIDEOMEMORY			=0x00004000,

	/*
	 * Indicates that changes made to this surface are immediately visible.
	 * It is always set for the primary surface and is set for overlays while
	 * they are being overlayed and texture maps while they are being textured.
	 */
	 DDSCAPS_VISIBLE				=0x00008000,

	/*
	 * Indicates that only writes are permitted to the surface.  Read accesses
	 * from the surface may or may not generate a protection fault, but the
	 * results of a read from this surface will not be meaningful.	READ ONLY.
	 */
	 DDSCAPS_WRITEONLY			=0x00010000,

	/*
	 * Indicates that this surface is a z buffer. A z buffer does not contain
	 * displayable information.  Instead it contains bit depth information that is
	 * used to determine which pixels are visible and which are obscured.
	 */
	 DDSCAPS_ZBUFFER				=0x00020000,

	/*
	 * Indicates surface will have a DC associated long term
	 */
	 DDSCAPS_OWNDC				=0x00040000,
  

	/*
	 * Indicates surface should be able to receive live video
	 */
	 DDSCAPS_LIVEVIDEO			=0x00080000,

	/*
	 * Indicates surface should be able to have a stream decompressed
	 * to it by the hardware.
	 */
	 DDSCAPS_HWCODEC				=0x00100000,

	/*
	 * Surface is a ModeX surface.
	 *
	 */
	 DDSCAPS_MODEX				=0x00200000,

	/*
	 * Indicates surface is one level of a mip-map. This surface will
	 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
	 * This can be done explicitly, by creating a number of surfaces and
	 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
	 * If this bit is set then DDSCAPS_TEXTURE must also be set.
	 */
	 DDSCAPS_MIPMAP                          =0x00400000,

	/*
	 * This bit is reserved. It should not be specified.
	 */
	 DDSCAPS_RESERVED2                       =0x00800000,


	/*
	 * Indicates that memory for the surface is not allocated until the surface
	 * is loaded (via the Direct3D texture Load() function).
	 */
	 DDSCAPS_ALLOCONLOAD                     =0x04000000,

	/*
	 * Indicates that the surface will recieve data from a video port.
	 */
	 DDSCAPS_VIDEOPORT			=0x08000000,

	/*
	 * Indicates that a video memory surface is resident in true, local video
	 * memory rather than non-local video memory. If this flag is specified then
	 * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
	 * DDSCAPS_NONLOCALVIDMEM.
	 */
	 DDSCAPS_LOCALVIDMEM                     =0x10000000,

	/*
	 * Indicates that a video memory surface is resident in non-local video
	 * memory rather than true, local video memory. If this flag is specified
	 * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
	 * DDSCAPS_LOCALVIDMEM.
	 */
	 DDSCAPS_NONLOCALVIDMEM                  =0x20000000,

	/*
	 * Indicates that this surface is a standard VGA mode surface, and not a
	 * ModeX surface. (This flag will never be set in combination with the
	 * DDSCAPS_MODEX flag).
	 */
	 DDSCAPS_STANDARDVGAMODE                 =0x40000000,

	/*
	 * Indicates that this surface will be an optimized surface. This flag is
	 * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
	 * will be created without any underlying video memory until loaded.
	 */
	 DDSCAPS_OPTIMIZED                       =0x80000000


	
} DDSURFACECAPSFLAGS;



typedef enum CONST_DDSURFACECAPS2FLAGS {
	  DDSCAPS2_HARDWAREDEINTERLACE    =0x00000002,
      DDSCAPS2_HINTDYNAMIC 			=0x00000004,
      DDSCAPS2_HINTSTATIC 			=0x00000008,
      DDSCAPS2_TEXTUREMANAGE        =0x00000010,
	  DDSCAPS2_OPAQUE				=0x00000080,
	  DDSCAPS2_HINTANTIALIASING		=0x00000100,

	  //DX7 FLAGS
	  DDSCAPS2_CUBEMAP              =0x00000200,
	  DDSCAPS2_CUBEMAP_POSITIVEX	  =		   0x00000400,
	  DDSCAPS2_CUBEMAP_NEGATIVEX      =        0x00000800,
	  DDSCAPS2_CUBEMAP_POSITIVEY      =        0x00001000,
	  DDSCAPS2_CUBEMAP_NEGATIVEY      =        0x00002000,
	  DDSCAPS2_CUBEMAP_POSITIVEZ      =        0x00004000,
	  DDSCAPS2_CUBEMAP_NEGATIVEZ      =        0x00008000,
	  DDSCAPS2_CUBEMAP_ALLFACES		  =		   0x0000FE00,	  
	  DDSCAPS2_MIPMAPSUBLEVEL         =        0x00010000,
          DDSCAPS2_D3DTEXTUREMANAGE       =        0x00020000,
	  DDSCAPS2_STEREOSURFACELEFT	  =		   0x00080000

	  

} DDSURFACECAPS2FLAGS;

typedef enum CONST_DDCAPS1FLAGS {
	 /****************************************************************************
	 *
	 * DIRECTDRAW DRIVER CAPABILITY FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Display hardware has 3D acceleration.
	 */
	 DDCAPS_3D			=0x00000001,

	/*
	 * Indicates that DirectDraw will support only dest rectangles that are aligned
	 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
	 * READ ONLY.
	 */
	 DDCAPS_ALIGNBOUNDARYDEST	=0x00000002,

	/*
	 * Indicates that DirectDraw will support only source rectangles  whose sizes in
	 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
	 */
	 DDCAPS_ALIGNSIZEDEST		=0x00000004,
	/*
	 * Indicates that DirectDraw will support only source rectangles that are aligned
	 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
	 * READ ONLY.
	 */
	 DDCAPS_ALIGNBOUNDARYSRC		=0x00000008,

	/*
	 * Indicates that DirectDraw will support only source rectangles  whose sizes in
	 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
	 */
	 DDCAPS_ALIGNSIZESRC		=0x00000010,

	/*
	 * Indicates that DirectDraw will create video memory surfaces that have a stride
	 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
	 */
	 DDCAPS_ALIGNSTRIDE		=0x00000020,

	/*
	 * Display hardware is capable of blt operations.
	 */
	 DDCAPS_BLT			=0x00000040,

	/*
	 * Display hardware is capable of asynchronous blt operations.
	 */
	 DDCAPS_BLTQUEUE			=0x00000080,

	/*
	 * Display hardware is capable of color space conversions during the blt operation.
	 */
	 DDCAPS_BLTFOURCC		=0x00000100,

	/*
	 * Display hardware is capable of stretching during blt operations.
	 */
	 DDCAPS_BLTSTRETCH		=0x00000200,

	/*
	 * Display hardware is shared with GDI.
	 */
	 DDCAPS_GDI			=0x00000400,

	/*
	 * Display hardware can overlay.
	 */
	 DDCAPS_OVERLAY			=0x00000800,

	/*
	 * Set if display hardware supports overlays but can not clip them.
	 */
	 DDCAPS_OVERLAYCANTCLIP		=0x00001000,

	/*
	 * Indicates that overlay hardware is capable of color space conversions during
	 * the overlay operation.
	 */
	 DDCAPS_OVERLAYFOURCC		=0x00002000,

	/*
	 * Indicates that stretching can be done by the overlay hardware.
	 */
	 DDCAPS_OVERLAYSTRETCH		=0x00004000,


	/*
	 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
	 * other than the primary surface.
	 */
	 DDCAPS_PALETTE			=0x00008000,

	/*
	 * Indicates that palette changes can be syncd with the veritcal refresh.
	 */
	 DDCAPS_PALETTEVSYNC		=0x00010000,

	/*
	 * Display hardware can return the current scan line.
	 */
	 DDCAPS_READSCANLINE		=0x00020000,

	/*
	 * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT
	 * can be created.
	 */
	 DDCAPS_STEREOVIEW		=0x00040000,

	/*
	 * Display hardware is capable of generating a vertical blank interrupt.
	 */
	 DDCAPS_VBI			=0x00080000,

	/*
	 * Supports the use of z buffers with blt operations.
	 */
	 DDCAPS_ZBLTS			=0x00100000,

	/*
	 * Supports Z Ordering of overlays.
	 */
	 DDCAPS_ZOVERLAYS		=0x00200000,

	/*
	 * Supports color key
	 */
	 DDCAPS_COLORKEY			=0x00400000,

	/*
	 * Supports alpha surfaces
	 */
	 DDCAPS_ALPHA			=0x00800000,

	/*
	 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
	 */
	 DDCAPS_COLORKEYHWASSIST		=0x01000000,

	/*
	 * no hardware support at all
	 */
	 DDCAPS_NOHARDWARE		=0x02000000,

	/*
	 * Display hardware is capable of color fill with bltter
	 */
	 DDCAPS_BLTCOLORFILL		=0x04000000,

	/*
	 * Display hardware is bank switched, and potentially very slow at
	 * random access to VRAM.
	 */
	 DDCAPS_BANKSWITCHED		=0x08000000,

	/*
	 * Display hardware is capable of depth filling Z-buffers with bltter
	 */
	 DDCAPS_BLTDEPTHFILL		=0x10000000,

	/*
	 * Display hardware is capable of clipping while bltting.
	 */
	 DDCAPS_CANCLIP			=0x20000000,

	/*
	 * Display hardware is capable of clipping while stretch bltting.
	 */
	 DDCAPS_CANCLIPSTRETCHED		=0x40000000,

	/*
	 * Display hardware is capable of bltting to or from system memory
	 */
	 DDCAPS_CANBLTSYSMEM		=0x80000000

} DDCAPS1FLAGS;
typedef enum CONST_DDCAPS2FLAGS {
	 /****************************************************************************
	 *
	 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
	 *
	 ****************************************************************************/

	/*
	 * Display hardware is certified
	 */
	 DDCAPS2_CERTIFIED		=0x00000001,

	/*
	 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
	 * Direct3D rendering operations between calls to BeginScene() and EndScene()
	 */
	 DDCAPS2_NO2DDURING3DSCENE       =0x00000002,

	/*
	 * Display hardware contains a video port
	 */
	 DDCAPS2_VIDEOPORT		=0x00000004,

	/*
	 * The overlay can be automatically flipped according to the video port
	 * VSYNCs, providing automatic doubled buffered display of video port
	 * data using an overlay
	 */
	 DDCAPS2_AUTOFLIPOVERLAY		=0x00000008,

	/*
	 * Overlay can display each field of interlaced data individually while
	 * it is interleaved in memory without causing jittery artifacts.
	 */
	 DDCAPS2_CANBOBINTERLEAVED	=0x00000010,

	/*
	 * Overlay can display each field of interlaced data individually while
	 * it is not interleaved in memory without causing jittery artifacts.
	 */
	 DDCAPS2_CANBOBNONINTERLEAVED	=0x00000020,

	/*
	 * The overlay surface contains color controls (brightness, sharpness, etc.)
	 */
	 DDCAPS2_COLORCONTROLOVERLAY	=0x00000040,

	/*
	 * The primary surface contains color controls (gamma, etc.)
	 */
	 DDCAPS2_COLORCONTROLPRIMARY	=0x00000080,

	/*
	 * RGBZ -> RGB supported for 16:16 RGB:Z
	 */
	 DDCAPS2_CANDROPZ16BIT		=0x00000100,

	/*
	 * Driver supports non-local video memory.
	 */
	 DDCAPS2_NONLOCALVIDMEM          =0x00000200,

	/*
	 * Dirver supports non-local video memory but has different capabilities for
	 * non-local video memory surfaces. If this bit is set then so must
	 * DDCAPS2_NONLOCALVIDMEM.
	 */
	 DDCAPS2_NONLOCALVIDMEMCAPS      =0x00000400,

	/*
	 * Driver neither requires nor prefers surfaces to be pagelocked when performing
	 * blts involving system memory surfaces
	 */
	 DDCAPS2_NOPAGELOCKREQUIRED      =0x00000800,

	/*
	 * Driver can create surfaces which are wider than the primary surface
	 */
	 DDCAPS2_WIDESURFACES            =0x00001000,

	/*
	 * Driver supports bob using software without using a video port
	 */
	 DDCAPS2_CANFLIPODDEVEN          =0x00002000,
	 DDCAPS2_CANBOBHARDWARE			 =0x00004000,
	 DDCAPS2_COPYFOURCC				 =0x00008000,
         DDCAPS2_PRIMARYGAMMA                    =0x00020000,
	 DDCAPS2_CANRENDERWINDOWED		 =0x00080000,
	 DDCAPS2_CANCALIBRATEGAMMA		 =0x00100000,
	 DDCAPS2_FLIPINTERVAL			 =0x00200000,
	 DDCAPS2_FLIPNOVSYNC			 =0x00400000,

	 //DX7
	 DDCAPS2_CANMANAGETEXTURE        =0x00800000,
	 DDCAPS2_STEREO                  =0x02000000	 
	 
} DDCAPS2FLAGS;

#if 0
typedef enum CONST_DDFXALPHACAPSFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Supports alpha blending around the edge of a source color keyed surface.
	 * For Blt.
	 */
	 DDFXALPHACAPS_BLTALPHAEDGEBLEND		=0x00000001,

	/*
	 * Supports alpha information in the pixel format.  The bit depth of alpha
	 * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
	 * more opaque as the alpha value increases.  (0 is transparent.)
	 * For Blt.
	 */
	 DDFXALPHACAPS_BLTALPHAPIXELS		=0x00000002,

	/*
	 * Supports alpha information in the pixel format.  The bit depth of alpha
	 * information in the pixel format can be 1,2,4, or 8.	The alpha value
	 * becomes more transparent as the alpha value increases.  (0 is opaque.)
	 * This flag can only be set if DDCAPS_ALPHA is set.
	 * For Blt.
	 */
	 DDFXALPHACAPS_BLTALPHAPIXELSNEG		=0x00000004,

	/*
	 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
	 * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
	 * (0 is transparent.)
	 * For Blt.
	 */
	 DDFXALPHACAPS_BLTALPHASURFACES		=0x00000008,

	/*
	 * The depth of the alpha channel data can range can be 1,2,4, or 8.
	 * The NEG suffix indicates that this alpha channel becomes more transparent
	 * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
	 * DDCAPS_ALPHA is set.
	 * For Blt.
	 */
	 DDFXALPHACAPS_BLTALPHASURFACESNEG	=0x00000010,

	/*
	 * Supports alpha blending around the edge of a source color keyed surface.
	 * For Overlays.
	 */
	 DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND	=0x00000020,

	/*
	 * Supports alpha information in the pixel format.  The bit depth of alpha
	 * information in the pixel format can be 1,2,4, or 8.	The alpha value becomes
	 * more opaque as the alpha value increases.  (0 is transparent.)
	 * For Overlays.
	 */
	 DDFXALPHACAPS_OVERLAYALPHAPIXELS	=0x00000040,

	/*
	 * Supports alpha information in the pixel format.  The bit depth of alpha
	 * information in the pixel format can be 1,2,4, or 8.	The alpha value
	 * becomes more transparent as the alpha value increases.  (0 is opaque.)
	 * This flag can only be set if DDCAPS_ALPHA is set.
	 * For Overlays.
	 */
	 DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG	=0x00000080,

	/*
	 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
	 * 1,2,4, or 8.	 The alpha value becomes more opaque as the alpha value increases.
	 * (0 is transparent.)
	 * For Overlays.
	 */
	 DDFXALPHACAPS_OVERLAYALPHASURFACES	=0x00000100,

	/*
	 * The depth of the alpha channel data can range can be 1,2,4, or 8.
	 * The NEG suffix indicates that this alpha channel becomes more transparent
	 * as the alpha value increases. (0 is opaque.)	 This flag can only be set if
	 * DDCAPS_ALPHA is set.
	 * For Overlays.
	 */
	 DDFXALPHACAPS_OVERLAYALPHASURFACESNEG	=0x00000200
} DDFXALPHACAPSFLAGS;
#endif 

typedef enum CONST_DDFXCAPSFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW FX CAPABILITY FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Uses arithmetic operations to stretch and shrink surfaces during blt
	 * rather than pixel doubling techniques.  Along the Y axis.
	 */
	 DDFXCAPS_BLTARITHSTRETCHY	=0x00000020,

	/*
	 * Uses arithmetic operations to stretch during blt
	 * rather than pixel doubling techniques.  Along the Y axis. Only
	 * works for x1, x2, etc.
	 */
	 DDFXCAPS_BLTARITHSTRETCHYN	=0x00000010,

	/*
	 * Supports mirroring left to right in blt.
	 */
	 DDFXCAPS_BLTMIRRORLEFTRIGHT	=0x00000040,

	/*
	 * Supports mirroring top to bottom in blt.
	 */
	 DDFXCAPS_BLTMIRRORUPDOWN	=0x00000080,

	/*
	 * Supports arbitrary rotation for blts.
	 */
	 DDFXCAPS_BLTROTATION		=0x00000100,

	/*
	 * Supports 90 degree rotations for blts.
	 */
	 DDFXCAPS_BLTROTATION90		=0x00000200,

	/*
	 * DirectDraw supports arbitrary shrinking of a surface along the
	 * x axis (horizontal direction) for blts.
	 */
	 DDFXCAPS_BLTSHRINKX		=0x00000400,

	/*
	 * DirectDraw supports integer shrinking (1x,2x,) of a surface
	 * along the x axis (horizontal direction) for blts.
	 */
	 DDFXCAPS_BLTSHRINKXN		=0x00000800,

	/*
	 * DirectDraw supports arbitrary shrinking of a surface along the
	 * y axis (horizontal direction) for blts.
	 */
	 DDFXCAPS_BLTSHRINKY		=0x00001000,

	/*
	 * DirectDraw supports integer shrinking (1x,2x,) of a surface
	 * along the y axis (vertical direction) for blts.
	 */
	 DDFXCAPS_BLTSHRINKYN		=0x00002000,

	/*
	 * DirectDraw supports arbitrary stretching of a surface along the
	 * x axis (horizontal direction) for blts.
	 */
	 DDFXCAPS_BLTSTRETCHX		=0x00004000,

	/*
	 * DirectDraw supports integer stretching (1x,2x,) of a surface
	 * along the x axis (horizontal direction) for blts.
	 */
	 DDFXCAPS_BLTSTRETCHXN		=0x00008000,

	/*
	 * DirectDraw supports arbitrary stretching of a surface along the
	 * y axis (horizontal direction) for blts.
	 */
	 DDFXCAPS_BLTSTRETCHY		=0x00010000,

	/*
	 * DirectDraw supports integer stretching (1x,2x,) of a surface
	 * along the y axis (vertical direction) for blts.
	 */
	 DDFXCAPS_BLTSTRETCHYN		=0x00020000,

	/*
	 * Uses arithmetic operations to stretch and shrink surfaces during
	 * overlay rather than pixel doubling techniques.  Along the Y axis
	 * for overlays.
	 */
	 DDFXCAPS_OVERLAYARITHSTRETCHY	=0x00040000,

	/*
	 * Uses arithmetic operations to stretch surfaces during
	 * overlay rather than pixel doubling techniques.  Along the Y axis
	 * for overlays. Only works for x1, x2, etc.
	 */
	 DDFXCAPS_OVERLAYARITHSTRETCHYN	=0x00000008,

	/*
	 * DirectDraw supports arbitrary shrinking of a surface along the
	 * x axis (horizontal direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSHRINKX		=0x00080000,

	/*
	 * DirectDraw supports integer shrinking (1x,2x,) of a surface
	 * along the x axis (horizontal direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSHRINKXN	=0x00100000,

	/*
	 * DirectDraw supports arbitrary shrinking of a surface along the
	 * y axis (horizontal direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSHRINKY		=0x00200000,

	/*
	 * DirectDraw supports integer shrinking (1x,2x,) of a surface
	 * along the y axis (vertical direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSHRINKYN	=0x00400000,

	/*
	 * DirectDraw supports arbitrary stretching of a surface along the
	 * x axis (horizontal direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSTRETCHX	=0x00800000,

	/*
	 * DirectDraw supports integer stretching (1x,2x,) of a surface
	 * along the x axis (horizontal direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSTRETCHXN	=0x01000000,

	/*
	 * DirectDraw supports arbitrary stretching of a surface along the
	 * y axis (horizontal direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSTRETCHY	=0x02000000,

	/*
	 * DirectDraw supports integer stretching (1x,2x,) of a surface
	 * along the y axis (vertical direction) for overlays.
	 */
	 DDFXCAPS_OVERLAYSTRETCHYN	=0x04000000,

	/*
	 * DirectDraw supports mirroring of overlays across the vertical axis
	 */
	 DDFXCAPS_OVERLAYMIRRORLEFTRIGHT	=0x08000000,

	/*
	 * DirectDraw supports mirroring of overlays across the horizontal axis
	 */
	 DDFXCAPS_OVERLAYMIRRORUPDOWN	=0x10000000,

	 DDFXCAPS_BLTALPHA				=0x00000001,
	 DDFXCAPS_BLTTRANSFORM			=0x00000002,
	 DDFXCAPS_BLTFILTER				=0x00000020,
	 DDFXCAPS_OVERLAYALPHA			=0x00000004,
	 DDFXCAPS_OVERLAYTRANSFORM		=0x20000000,
	 DDFXCAPS_OVERLAYFILTER			=0x00040000


} DDFXCAPSFLAGS;

typedef enum CONST_DDSTEREOCAPSFLAGS {

	/****************************************************************************
	 *
	 * DIRECTDRAW STEREO VIEW CAPABILITIES
	 *
	 ****************************************************************************/

	/*
	 * The stereo view is accomplished via enigma encoding.
	 */
	 DDSVCAPS_ENIGMA			=0x00000001,

	/*
	 * The stereo view is accomplished via high frequency flickering.
	 */
	 DDSVCAPS_FLICKER		=0x00000002,

	/*
	 * The stereo view is accomplished via red and blue filters applied
	 * to the left and right eyes.	All images must adapt their colorspaces
	 * for this process.
	 */
	 DDSVCAPS_REDBLUE		=0x00000004,

	/*
	 * The stereo view is accomplished with split screen technology.
	 */
	 DDSVCAPS_SPLIT			=0x00000008,

        DDSVCAPS_STEREOSEQUENTIAL      = 0x00000010

} DDSTEREOCAPSFLAGS;

typedef enum CONST_DDCKEYCAPSFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Supports transparent blting using a color key to identify the replaceable
	 * bits of the destination surface for RGB colors.
	 */
	 DDCKEYCAPS_DESTBLT			=0x00000001,

	/*
	 * Supports transparent blting using a color space to identify the replaceable
	 * bits of the destination surface for RGB colors.
	 */
	 DDCKEYCAPS_DESTBLTCLRSPACE		=0x00000002,

	/*
	 * Supports transparent blting using a color space to identify the replaceable
	 * bits of the destination surface for YUV colors.
	 */
	 DDCKEYCAPS_DESTBLTCLRSPACEYUV		=0x00000004,

	/*
	 * Supports transparent blting using a color key to identify the replaceable
	 * bits of the destination surface for YUV colors.
	 */
	 DDCKEYCAPS_DESTBLTYUV			=0x00000008,

	/*
	 * Supports overlaying using colorkeying of the replaceable bits of the surface
	 * being overlayed for RGB colors.
	 */
	 DDCKEYCAPS_DESTOVERLAY			=0x00000010,

	/*
	 * Supports a color space as the color key for the destination for RGB colors.
	 */
	 DDCKEYCAPS_DESTOVERLAYCLRSPACE		=0x00000020,

	/*
	 * Supports a color space as the color key for the destination for YUV colors.
	 */
	 DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV	=0x00000040,

	/*
	 * Supports only one active destination color key value for visible overlay
	 * surfaces.
	 */
	 DDCKEYCAPS_DESTOVERLAYONEACTIVE		=0x00000080,

	/*
	 * Supports overlaying using colorkeying of the replaceable bits of the
	 * surface being overlayed for YUV colors.
	 */
	 DDCKEYCAPS_DESTOVERLAYYUV		=0x00000100,

	/*
	 * Supports transparent blting using the color key for the source with
	 * this surface for RGB colors.
	 */
	 DDCKEYCAPS_SRCBLT			=0x00000200,

	/*
	 * Supports transparent blting using a color space for the source with
	 * this surface for RGB colors.
	 */
	 DDCKEYCAPS_SRCBLTCLRSPACE		=0x00000400,

	/*
	 * Supports transparent blting using a color space for the source with
	 * this surface for YUV colors.
	 */
	 DDCKEYCAPS_SRCBLTCLRSPACEYUV		=0x00000800,

	/*
	 * Supports transparent blting using the color key for the source with
	 * this surface for YUV colors.
	 */
	 DDCKEYCAPS_SRCBLTYUV			=0x00001000,

	/*
	 * Supports overlays using the color key for the source with this
	 * overlay surface for RGB colors.
	 */
	 DDCKEYCAPS_SRCOVERLAY			=0x00002000,

	/*
	 * Supports overlays using a color space as the source color key for
	 * the overlay surface for RGB colors.
	 */
	 DDCKEYCAPS_SRCOVERLAYCLRSPACE		=0x00004000,

	/*
	 * Supports overlays using a color space as the source color key for
	 * the overlay surface for YUV colors.
	 */
	 DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV	=0x00008000,

	/*
	 * Supports only one active source color key value for visible
	 * overlay surfaces.
	 */
	 DDCKEYCAPS_SRCOVERLAYONEACTIVE		=0x00010000,

	/*
	 * Supports overlays using the color key for the source with this
	 * overlay surface for YUV colors.
	 */
	 DDCKEYCAPS_SRCOVERLAYYUV		=0x00020000,

	/*
	 * there are no bandwidth trade-offs for using colorkey with an overlay
	 */
	 DDCKEYCAPS_NOCOSTOVERLAY		=0x00040000
} DDCKEYCAPSFLAGS;

typedef enum CONST_DDPIXELFORMATFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW PIXELFORMAT FLAGS
	 *
	 ****************************************************************************/

	/*
	 * The surface has alpha channel information in the pixel format.
	 */
	 DDPF_ALPHAPIXELS			=0x00000001,

	/*
	 * The pixel format contains alpha only information
	 */
	 DDPF_ALPHA				=0x00000002,

	/*
	 * The FourCC code is valid.
	 */
	 DDPF_FOURCC				=0x00000004,

	/*
	 * The surface is 4-bit color indexed.
	 */
	 DDPF_PALETTEINDEXED4			=0x00000008,

	/*
	 * The surface is indexed into a palette which stores indices
	 * into the destination surface's 8-bit palette.
	 */
	 DDPF_PALETTEINDEXEDTO8			=0x00000010,

	/*
	 * The surface is 8-bit color indexed.
	 */
	 DDPF_PALETTEINDEXED8			=0x00000020,

	/*
	 * The RGB data in the pixel format structure is valid.
	 */
	 DDPF_RGB				=0x00000040,

	/*
	 * The surface will accept pixel data in the format specified
	 * and compress it during the write.
	 */
	 DDPF_COMPRESSED				=0x00000080,

	/*
	 * The surface will accept RGB data and translate it during
	 * the write to YUV data.  The format of the data to be written
	 * will be contained in the pixel format structure.  The DDPF_RGB
	 * flag will be set.
	 */
	 DDPF_RGBTOYUV				=0x00000100,

	/*
	 * pixel format is YUV - YUV data in pixel format struct is valid
	 */
	 DDPF_YUV				=0x00000200,

	/*
	 * pixel format is a z buffer only surface
	 */
	 DDPF_ZBUFFER				=0x00000400,

	/*
	 * The surface is 1-bit color indexed.
	 */
	 DDPF_PALETTEINDEXED1			=0x00000800,

	/*
	 * The surface is 2-bit color indexed.
	 */
	 DDPF_PALETTEINDEXED2			=0x00001000,

	/*
	 * The surface contains Z information in the pixels
	 */
	 DDPF_ZPIXELS				=0x00002000,


	 DDPF_STENCILBUFFER			=0x00004000,
	 DDPF_ALPHAPREMULT			=0x00008000,
	 DDPF_LUMINANCE				=0x00020000,
	 DDPF_BUMPLUMINANCE			=0x00040000,
	 DDPF_BUMPDUDV				=0x00080000


} DDPIXELFORMATFLAGS;

typedef enum CONST_DDENUMSURFACESFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAW ENUMSURFACES FLAGS
	 *
	 ****************************************************************************/

	/*
	 * Enumerate all of the surfaces that meet the search criterion.
	 */
	 DDENUMSURFACES_ALL			=0x00000001,

	/*
	 * A search hit is a surface that matches the surface description.
	 */
	 DDENUMSURFACES_MATCH			=0x00000002,

	/*
	 * A search hit is a surface that does not match the surface description.
	 */
	 DDENUMSURFACES_NOMATCH			=0x00000004,

	/*
	 * Enumerate the first surface that can be created which meets the search criterion.
	 */
	 DDENUMSURFACES_CANBECREATED		=0x00000008,

	/*
	 * Enumerate the surfaces that already exist that meet the search criterion.
	 */
	 DDENUMSURFACES_DOESEXIST		=0x00000010

} DDENUMSURFACESFLAGS;

typedef enum CONST_DDRAW {

	 DD_ROP_SPACE		=(256/32),	// space required to store ROP array


} DDRAWFLAGS;

typedef enum CONST_DDBLTFXFLAGS {

	/****************************************************************************
	 *
	 * DIRECTDRAWSURFACE BLT FX FLAGS
	 *
	 ****************************************************************************/

	/*
	 * If stretching, use arithmetic stretching along the Y axis for this blt.
	 */
	 DDBLTFX_ARITHSTRETCHY			=0x00000001,

	/*
	 * Do this blt mirroring the surface left to right.  Spin the
	 * surface around its y-axis.
	 */
	 DDBLTFX_MIRRORLEFTRIGHT			=0x00000002,

	/*
	 * Do this blt mirroring the surface up and down.  Spin the surface
	 * around its x-axis.
	 */
	 DDBLTFX_MIRRORUPDOWN			=0x00000004,

	/*
	 * Schedule this blt to avoid tearing.
	 */
	 DDBLTFX_NOTEARING			=0x00000008,

	/*
	 * Do this blt rotating the surface one hundred and eighty degrees.
	 */
	 DDBLTFX_ROTATE180			=0x00000010,

	/*
	 * Do this blt rotating the surface two hundred and seventy degrees.
	 */
	 DDBLTFX_ROTATE270			=0x00000020,

	/*
	 * Do this blt rotating the surface ninety degrees.
	 */
	 DDBLTFX_ROTATE90			=0x00000040,

	/*
	 * Do this z blt using dwZBufferLow and dwZBufferHigh as  range values
	 * specified to limit the bits copied from the source surface.
	 */
	 DDBLTFX_ZBUFFERRANGE			=0x00000080,

	/*
	 * Do this z blt adding the dwZBufferBaseDest to each of the sources z values
	 * before comparing it with the desting z values.
	 */
	 DDBLTFX_ZBUFFERBASEDEST			=0x00000100
} DDBLTFXFLAGS;

#if 0
typedef enum CONST_DDOVERLAYFXFLAGS {
	/****************************************************************************
	 *
	 * DIRECTDRAWSURFACE OVERLAY FX FLAGS
	 *
	 ****************************************************************************/

	/*
	 * If stretching, use arithmetic stretching along the Y axis for this overlay.
	 */
	 DDOVERFX_ARITHSTRETCHY			=0x00000001,

	/*
	 * Mirror the overlay across the vertical axis
	 */
	 DDOVERFX_MIRRORLEFTRIGHT		=0x00000002,

	/*
	 * Mirror the overlay across the horizontal axis
	 */
	 DDOVERFX_MIRRORUPDOWN			=0x00000004
} DDOVERLAYFXFLAGS;
#endif

typedef enum CONST_DDWAITVBFLAGS {

	/****************************************************************************
	 *
	 * DIRECTDRAW WAITFORVERTICALBLANK FLAGS
	 *
	 ****************************************************************************/

	/*
	 * return when the vertical blank interval begins
	 */
	 DDWAITVB_BLOCKBEGIN			=0x00000001,

	/*
	 * set up an event to trigger when the vertical blank begins
	 */
	 DDWAITVB_BLOCKBEGINEVENT		=0x00000002,

	/*
	 * return when the vertical blank interval ends and display begins
	 */
	 DDWAITVB_BLOCKEND			=0x00000004
} DDWAITVBFLAGS;








/************************************************/
// DINPUT
/************************************************/

typedef enum CONST_DIENUMDEVICESFLAGS {
	DIEDFL_ALLDEVICES       =0x00000000,
	DIEDFL_ATTACHEDONLY     =0x00000001,	
	DIEDFL_FORCEFEEDBACK    =0x00000100,
	DIEDFL_INCLUDEALIASES   =0x00010000,
	DIEDFL_INCLUDEPHANTOMS  =0x00020000
 
} DIENUMDEVICESFLAGS;

typedef enum CONST_DIDEVICETYPE {
	DIDEVTYPE_DEVICE    =1,
	DIDEVTYPE_MOUSE     =2,
	DIDEVTYPE_KEYBOARD  =3,
	DIDEVTYPE_JOYSTICK  =4,
	DIDEVTYPE_HID       =0x00010000,
	DIDEVTYPEMOUSE_UNKNOWN        =  0x100,
	DIDEVTYPEMOUSE_TRADITIONAL    =  0x200,
	DIDEVTYPEMOUSE_FINGERSTICK    =  0x300,
	DIDEVTYPEMOUSE_TOUCHPAD       =  0x400,
	DIDEVTYPEMOUSE_TRACKBALL      =  0x500,
	DIDEVTYPEKEYBOARD_UNKNOWN     =  0x000,
	DIDEVTYPEKEYBOARD_PCXT        =  0x100,
	DIDEVTYPEKEYBOARD_OLIVETTI    =  0x200,
	DIDEVTYPEKEYBOARD_PCAT        =  0x300,
	DIDEVTYPEKEYBOARD_PCENH       =  0x400,
	DIDEVTYPEKEYBOARD_NOKIA1050   =  0x500,
	DIDEVTYPEKEYBOARD_NOKIA9140   =  0x600,
	DIDEVTYPEKEYBOARD_NEC98       =  0x700,
	DIDEVTYPEKEYBOARD_NEC98LAPTOP =  0x800,
	DIDEVTYPEKEYBOARD_NEC98106    =  0x900,
	DIDEVTYPEKEYBOARD_JAPAN106    = 0xA00,
	DIDEVTYPEKEYBOARD_JAPANAX     = 0xB00,
	DIDEVTYPEKEYBOARD_J3100       = 0xC00,
	DIDEVTYPEJOYSTICK_UNKNOWN     =  0x100,
	DIDEVTYPEJOYSTICK_TRADITIONAL =  0x200,
	DIDEVTYPEJOYSTICK_FLIGHTSTICK =  0x300,
	DIDEVTYPEJOYSTICK_GAMEPAD     =  0x400,
	DIDEVTYPEJOYSTICK_RUDDER      =  0x500,
	DIDEVTYPEJOYSTICK_WHEEL       =  0x600,
	DIDEVTYPEJOYSTICK_HEADTRACKER =  0x700
} DIDEVICETYPE;

typedef enum CONST_DIDFTFLAGS {
	DIDFT_ALL           =0x00000000,
	DIDFT_RELAXIS       =0x00000001,
	DIDFT_ABSAXIS       =0x00000002,
	DIDFT_AXIS          =0x00000003,
	DIDFT_PSHBUTTON     =0x00000004,
	DIDFT_TGLBUTTON     =0x00000008,
	DIDFT_BUTTON        =0x0000000C,
	DIDFT_POV           =0x00000010,
	DIDFT_COLLECTION    =0x00000040,
	DIDFT_NODATA        =0x00000080,
	DIDFT_ANYINSTANCE   =0x00FFFF00,
	DIDFT_INSTANCEMASK  =DIDFT_ANYINSTANCE,
	DIDFT_FFACTUATOR        =0x01000000,
	DIDFT_FFEFFECTTRIGGER   =0x02000000,
        DIDFT_NOCOLLECTION      =0x00FFFF00
} DIDFTFLAGS;

typedef enum CONST_DIDGDDFLAGS {
	DIGDD_DEFAULT          =0x00000000,
	DIGDD_PEEK          =0x00000001
} DIDGDDFLAGS;

typedef enum CONST_DIPHFLAGS { 
	DIPH_DEVICE             =0,
	DIPH_BYOFFSET           =1,
	DIPH_BYID               =2
} DIPHFLAGS;

typedef enum CONST_DISCLFLAGS {
	DISCL_EXCLUSIVE     =0x00000001,
	DISCL_NONEXCLUSIVE  =0x00000002,
	DISCL_FOREGROUND    =0x00000004,
	DISCL_BACKGROUND    =0x00000008
} DISCLFLAGS;

typedef enum CONST_DIDEVCAPSFLAGS {
	DIDC_ATTACHED           =0x00000001,
	DIDC_POLLEDDEVICE       =0x00000002,
	DIDC_EMULATED           =0x00000004,
	DIDC_POLLEDDATAFORMAT   =0x00000008,
	DIDC_FORCEFEEDBACK      =0x00000100,
	DIDC_FFATTACK           =0x00000200,
	DIDC_FFFADE             =0x00000400,
	DIDC_SATURATION         =0x00000800,
	DIDC_POSNEGCOEFFICIENTS =0x00001000,
	DIDC_POSNEGSATURATION   =0x00002000,
        DIDC_DEADBAND           =0x00004000,
	DIDC_ALIAS              =0x00010000,
	DIDC_PHANTOM            =0x00020000
} DIDEVCAPSFLAGS;

typedef enum CONST_DIDATAFORMATFLAGS {
	DIDF_ABSAXIS            =0x00000001,
	DIDF_RELAXIS            =0x00000002
} DIDATAFORMATFLAGS;

typedef enum CONST_DIDEVICEOBJINSTANCEFLAGS {
	DIDOI_FFACTUATOR        =0x00000001,
	DIDOI_FFEFFECTTRIGGER   =0x00000002,
	DIDOI_POLLED            =0x00008000,
	DIDOI_ASPECTPOSITION    =0x00000100,
	DIDOI_ASPECTVELOCITY    =0x00000200,
	DIDOI_ASPECTACCEL       =0x00000300,
	DIDOI_ASPECTFORCE       =0x00000400,
	DIDOI_ASPECTMASK        =0x00000F00
} DIDEVICEOBJINSTANCEFLAGS;

/*
typedef enum CONST_DIPROPERTYFLAGS {

	DIPROP_BUFFERSIZE       =1,
	DIPROP_AXISMODE         =2,
	DIPROPAXISMODE_ABS      =0,
	DIPROPAXISMODE_REL      =1,
	DIPROP_GRANULARITY      =3,
	DIPROP_RANGE            =4,
	DIPROP_DEADZONE         =5,
	DIPROP_SATURATION       =6,
	DIPROP_FFGAIN           =7,
	DIPROP_FFLOAD           =8,
	DIPROP_AUTOCENTER       =9,
	DIPROPAUTOCENTER_OFF    =0,
	DIPROPAUTOCENTER_ON     =1,
	DIPROP_CALIBRATIONMODE  =10,
	DIPROPCALIBRATIONMODE_COOKED=    0,
	DIPROPCALIBRATIONMODE_RAW    =   1
} DIPROPERTYFLAGS;
*/

	
typedef enum CONST_DIKEYFLAGS {
	DIK_ESCAPE        =  0x01,
	DIK_1             =  0x02,
	DIK_2             =  0x03,
	DIK_3             =  0x04,
	DIK_4             =  0x05,
	DIK_5             =  0x06,
	DIK_6             =  0x07,
	DIK_7             =  0x08,
	DIK_8             =  0x09,
	DIK_9             =  0x0A,
	DIK_0             =  0x0B,
	DIK_MINUS         =  0x0C ,   /* - on main keyboard */
	DIK_EQUALS        =  0x0D,
	DIK_BACK          =  0x0E ,   /* backspace */
	DIK_TAB           =  0x0F,
	DIK_Q             =  0x10,
	DIK_W             =  0x11,
	DIK_E             =  0x12,
	DIK_R             =  0x13,
	DIK_T             =  0x14,
	DIK_Y             =  0x15,
	DIK_U             =  0x16,
	DIK_I             =  0x17,
	DIK_O             =  0x18,
	DIK_P             =  0x19,
	DIK_LBRACKET      =  0x1A,
	DIK_RBRACKET      =  0x1B,
	DIK_RETURN        =  0x1C ,   /* Enter on main keyboard */
	DIK_LCONTROL      =  0x1D,
	DIK_A             =  0x1E,
	DIK_S             =  0x1F,
	DIK_D             =  0x20,
	DIK_F             =  0x21,
	DIK_G             =  0x22,
	DIK_H             =  0x23,
	DIK_J             =  0x24,
	DIK_K             =  0x25,
	DIK_L             =  0x26,
	DIK_SEMICOLON     =  0x27,
	DIK_APOSTROPHE    =  0x28,
	DIK_GRAVE         =  0x29 ,   /* accent grave */
	DIK_LSHIFT        =  0x2A,
	DIK_BACKSLASH     =  0x2B,
	DIK_Z             =  0x2C,
	DIK_X             =  0x2D,
	DIK_C             =  0x2E,
	DIK_V             =  0x2F,
	DIK_B             =  0x30,
	DIK_N             =  0x31,
	DIK_M             =  0x32,
	DIK_COMMA         =  0x33,
	DIK_PERIOD        =  0x34  ,  /* . on main keyboard */
	DIK_SLASH         =  0x35 ,   /* / on main keyboard */
	DIK_RSHIFT        =  0x36,
	DIK_MULTIPLY      =  0x37  ,  /* * on numeric keypad */
	DIK_LMENU         =  0x38 ,   /* left Alt */
	DIK_SPACE         =  0x39,
	DIK_CAPITAL       =  0x3A,
	DIK_F1            =  0x3B,
	DIK_F2            =  0x3C,
	DIK_F3            =  0x3D,
	DIK_F4            =  0x3E,
	DIK_F5            =  0x3F,
	DIK_F6            =  0x40,
	DIK_F7            =  0x41,
	DIK_F8            =  0x42,
	DIK_F9            =  0x43,
	DIK_F10           =  0x44,
	DIK_NUMLOCK       =  0x45,
	DIK_SCROLL        =  0x46 ,   /* Scroll Lock */
	DIK_NUMPAD7       =  0x47,
	DIK_NUMPAD8       =  0x48,
	DIK_NUMPAD9       =  0x49,
	DIK_SUBTRACT      =  0x4A ,   /* - on numeric keypad */
	DIK_NUMPAD4       =  0x4B,
	DIK_NUMPAD5       =  0x4C,
	DIK_NUMPAD6       =  0x4D,
	DIK_ADD           =  0x4E ,   /* + on numeric keypad */
	DIK_NUMPAD1       =  0x4F,
	DIK_NUMPAD2       =  0x50,
	DIK_NUMPAD3       =  0x51,
	DIK_NUMPAD0       =  0x52,
	DIK_DECIMAL       =  0x53,    /* . on numeric keypad */
	DIK_F11           =  0x57, 
	DIK_F12           =  0x58 ,
	DIK_F13            = 0x64 ,   /*                     (NEC PC98) */
	DIK_F14            = 0x65 ,   /*                     (NEC PC98) */
	DIK_F15            = 0x66 ,  /*                     (NEC PC98) */
	DIK_KANA          =  0x70 ,   /* (Japanese keyboard)            */
	DIK_CONVERT       =  0x79 ,   /* (Japanese keyboard)            */
	DIK_NOCONVERT     =  0x7B ,   /* (Japanese keyboard)            */
	DIK_YEN           =  0x7D ,   /* (Japanese keyboard)            */
	DIK_NUMPADEQUALS  =  0x8D ,   /* = on numeric keypad (NEC PC98) */
	DIK_CIRCUMFLEX    =  0x90 ,   /* (Japanese keyboard)            */
	DIK_AT            =  0x91 ,   /*                     (NEC PC98) */
	DIK_COLON         =  0x92 ,   /*                     (NEC PC98) */
	DIK_UNDERLINE     =  0x93 ,   /*                     (NEC PC98) */
	DIK_KANJI         =  0x94 ,   /* (Japanese keyboard)            */
	DIK_STOP          =  0x95 ,   /*                     (NEC PC98) */
	DIK_AX            =  0x96 ,   /*                     (Japan AX) */
	DIK_UNLABELED     =  0x97 ,   /*                        (J3100) */
	DIK_NUMPADENTER   =  0x9C ,   /* Enter on numeric keypad */
	DIK_RCONTROL      =  0x9D ,
	DIK_NUMPADCOMMA   =  0xB3,    /* , on numeric keypad (NEC PC98) */
	DIK_DIVIDE        =  0xB5,    /* / on numeric keypad */
	DIK_SYSRQ         =  0xB7,
	DIK_RMENU         =  0xB8,    /* right Al t */
	DIK_PAUSE		  =  0xC5,	  /* Pause */
	DIK_HOME          =  0xC7,    /* Home on arrow keypad */
	DIK_UP            =  0xC8,    /* UpArrow on arrow keypad */
	DIK_PRIOR         =  0xC9,    /* PgUp on arrow keypad */
	DIK_LEFT          =  0xCB,    /* LeftArrow on arrow keypad */
	DIK_RIGHT         =  0xCD,    /* RightArrow on arrow keypad */
	DIK_END           =  0xCF,    /* End on arrow keypad */
	DIK_DOWN          =  0xD0,    /* DownArrow on arrow keypad */
	DIK_NEXT          =  0xD1,    /* PgDn on arrow keypad */
	DIK_INSERT        =  0xD2,    /* Insert on arrow keypad */
	DIK_DELETE        =  0xD3,    /* Delete on arrow keypad */
	DIK_LWIN          =  0xDB,    /* Left Windows key */
	DIK_RWIN          =  0xDC,    /* Right Windows key */
	DIK_APPS          =  0xDD,    /* AppMenu key */
} DIKEYFLAGS;

typedef enum CONST_DINPUT {	

	DIPROPRANGE_NOMIN       =0x80000000,
    DIPROPRANGE_NOMAX       =0x7FFFFFFF,

/*	
	DIEFT_ALL                 =  0x00000000,
	DIEFT_CONSTANTFORCE       =  0x00000001,
	DIEFT_RAMPFORCE           =  0x00000002,
	DIEFT_PERIODIC            =  0x00000003,
	DIEFT_CONDITION           =  0x00000004,
	DIEFT_CUSTOMFORCE         =  0x00000005,
	DIEFT_HARDWARE            =  0x000000FF,
	DIEFT_FFATTACK            =  0x00000200,
	DIEFT_FFFADE              =  0x00000400,
	DIEFT_SATURATION          =  0x00000800,
	DIEFT_POSNEGCOEFFICIENTS  =  0x00001000,
	DIEFT_POSNEGSATURATION    =  0x00002000,
	DIEFT_DEADBAND            =  0x00004000,

	DI_DEGREES                =  100,
	DI_FFNOMINALMAX           =  10000,
	DI_SECONDS                =  1000000,

	DIEFF_OBJECTIDS           =  0x00000001,
	DIEFF_OBJECTOFFSETS       =  0x00000002,
	DIEFF_CARTESIAN           =  0x00000010,
	DIEFF_POLAR               =  0x00000020,
	DIEFF_SPHERICAL           =  0x00000040,
	DIEP_DURATION             =  0x00000001,
	DIEP_SAMPLEPERIOD         =  0x00000002,
	DIEP_GAIN                 =  0x00000004,
	DIEP_TRIGGERBUTTON        =  0x00000008,
	DIEP_TRIGGERREPEATINTERVAL=  0x00000010,
	DIEP_AXES                =   0x00000020,
	DIEP_DIRECTION           =   0x00000040,
	DIEP_ENVELOPE            =   0x00000080,
	DIEP_TYPESPECIFICPARAMS  =   0x00000100,
	DIEP_ALLPARAMS       =       0x000001FF,
	DIEP_START           =       0x20000000,
	DIEP_NORESTART       =       0x40000000,
	DIEP_NODOWNLOAD      =       0x80000000,
	DIEB_NOTRIGGER       =       0xFFFFFFFF,
	DIES_SOLO            =       0x00000001,
	DIES_NODOWNLOAD      =       0x80000000,
	DIEGES_PLAYING       =       0x00000001,
	DIEGES_EMULATED      =       0x00000002,


	DISFFC_RESET        =    0x00000001,
	DISFFC_STOPALL      =    0x00000002,
	DISFFC_PAUSE        =    0x00000004,
	DISFFC_CONTINUE     =    0x00000008,
	DISFFC_SETACTUATORSON  = 0x00000010,
	DISFFC_SETACTUATORSOFF = 0x00000020,
	DIGFFS_EMPTY        =    0x00000001,
	DIGFFS_STOPPED      =    0x00000002,
	DIGFFS_PAUSED       =    0x00000004,
	DIGFFS_ACTUATORSON  =    0x00000010,
	DIGFFS_ACTUATORSOFF =    0x00000020,
	DIGFFS_POWERON      =    0x00000040,
	DIGFFS_POWEROFF     =    0x00000080,
	DIGFFS_SAFETYSWITCHON =  0x00000100,
	DIGFFS_SAFETYSWITCHOFF = 0x00000200,
	DIGFFS_USERFFSWITCHON  = 0x00000400,
	DIGFFS_USERFFSWITCHOFF = 0x00000800,
	DIGFFS_DEVICELOST      = 0x80000000,
*/	


	/*
	  Alternate names for keys, to facilitate transition from DOS.
	DIK_BACKSPACE     =  DIK_BACK    ,        // backspace 
	DIK_NUMPADSTAR    =  DIK_MULTIPLY,        // * on numeric keypad 
	DIK_LALT          =  DIK_LMENU   ,        // left Alt 
	DIK_CAPSLOCK      =  DIK_CAPITAL ,        // CapsLock 
	DIK_NUMPADMINUS   =  DIK_SUBTRACT,        // - on numeric keypad 
	DIK_NUMPADPLUS    =  DIK_ADD    ,         // + on numeric keypad 
	DIK_NUMPADPERIOD  =  DIK_DECIMAL,         // . on numeric keypad 
	DIK_NUMPADSLASH   =  DIK_DIVIDE,          // / on numeric keypad 
	DIK_RALT          =  DIK_RMENU ,          // right Alt 
	DIK_UPARROW       =  DIK_UP    ,          // UpArrow on arrow keypad 
	DIK_PGUP          =  DIK_PRIOR ,          // PgUp on arrow keypad 
	DIK_LEFTARROW     =  DIK_LEFT  ,          // LeftArrow on arrow keypad 
	DIK_RIGHTARROW    =  DIK_RIGHT ,          // RightArrow on arrow keypad
	DIK_DOWNARROW     =  DIK_DOWN  ,          // DownArrow on arrow keypad 
	DIK_PGDN          =  DIK_NEXT  ,          // PgDn on arrow keypad 
	*/


//	DIENUM_STOP             =0,
//	DIENUM_CONTINUE         =1,

	/*
	* Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
	* contains mini-driver specific data to be passed by VJoyD to the mini-
	* driver instead of doing a poll.
	*/
//	JOY_PASSDRIVERDATA          =0x10000000,

	
	/*
	* Hardware Setting indicating that the device is a headtracker
	*/
//	JOY_HWS_ISHEADTRACKER       =0x02000000,

	/*
	* Hardware Setting indicating that the VxD is used to replace
	* the standard analog polling
	*/
//	JOY_HWS_ISGAMEPORTDRIVER    =0x04000000,

	/*
	* Hardware Setting indicating that the driver needs a standard
	* gameport in order to communicate with the device.
	*/
//	JOY_HWS_ISANALOGPORTDRIVER  =0x08000000, 

	/*
	* Hardware Setting indicating that VJoyD should not load this 
	* driver, it will be loaded externally and will register with
	* VJoyD of it's own accord.
	*/
//	JOY_HWS_AUTOLOAD            =0x10000000,

	/*
	* Hardware Setting indicating that the driver acquires any 
	* resources needed without needing a devnode through VJoyD.
	*/
//	JOY_HWS_NODEVNODE           =0x20000000,

	/*
	* Hardware Setting indicating that the VxD can be used as
	* a port 201h emulator.
	*/
//	JOY_HWS_ISGAMEPORTEMULATOR  =0x40000000,


	/*
	* Usage Setting indicating that the settings are volatile and
	* should be removed if still present on a reboot.
	*/
//	JOY_US_VOLATILE             =0x00000008,


	DIPROPAXISMODE_ABS =0,
	DIPROPAXISMODE_REL =1,
	DIPROPCALIBRATIONMODE_COOKED=0,
	DIPROPCALIBRATIONMODE_RAW=1,
	DIPROPAUTOCENTER_OFF    =0,
	DIPROPAUTOCENTER_ON     =1,
	DIEB_NOTRIGGER       =       0xFFFFFFFF
} DINPUTCONSTANTS;



/****************** DIRECT PLAY********************/

typedef enum CONST_DSSCLFLAGS {
	 DSSCL_NORMAL                =0x00000001,
	 DSSCL_PRIORITY              =0x00000002,
	 DSSCL_EXCLUSIVE             =0x00000003,
	 DSSCL_WRITEPRIMARY          =0x00000004
} DSSCLFLAGS;

typedef enum CONST_DSSPEAKERFLAGS {
	 DSSPEAKER_HEADPHONE         =0x00000001,
	 DSSPEAKER_MONO              =0x00000002,
	 DSSPEAKER_QUAD              =0x00000003,
	 DSSPEAKER_STEREO            =0x00000004,
	 DSSPEAKER_SURROUND          =0x00000005,
	 DSSPEAKER_GEOMETRY_MIN      =0x00000005,  //   5 degrees
	 DSSPEAKER_GEOMETRY_NARROW   =0x0000000A,  //  10 degrees
	 DSSPEAKER_GEOMETRY_WIDE     =0x00000014,  //  20 degrees
	 DSSPEAKER_GEOMETRY_MAX      =0x000000B4  // 180 degrees
} DSSPEAKERFLAGS;

typedef enum CONST_DSBPLAYFLAGS{
	DSBPLAY_DEFAULT             =0x00000000,
	DSBPLAY_LOOPING             =0x00000001
} DSBPLAYFLAGS;

typedef enum CONST_DSBLOCKFLAGS {
	DSBLOCK_DEFAULT			    =0x00000000,
	DSBLOCK_FROMWRITECURSOR     =0x00000001,
	DSBLOCK_ENTIREBUFFER        =0x00000002
} DSBLOCKFLAGS;

typedef enum CONST_DSCBLOCKFLAGS {
	DSCBLOCK_DEFAULT            =0x00000000,
	DSCBLOCK_ENTIREBUFFER       =0x00000001
} DSCBLOCKFLAGS;

typedef enum CONST_DSBSTATUSFLAGS {       
	DSBSTATUS_PLAYING           =0x00000001,
	DSBSTATUS_BUFFERLOST        =0x00000002,
	DSBSTATUS_LOOPING           =0x00000004,
} DSBSTATUSFLAGS;

typedef enum CONST_DS3DAPPLYFLAGS {
	DS3D_IMMEDIATE              =0x00000000,
	DS3D_DEFERRED               =0x00000001
} DS3DAPPLYFLAGS;

typedef enum CONST_DS3DMODEFLAGS {
	DS3DMODE_NORMAL             =0x00000000,
	DS3DMODE_HEADRELATIVE       =0x00000001,
	DS3DMODE_DISABLE            =0x00000002
} DS3DMODEFLAGS;

typedef enum CONST_DSCBSTATUSFLAGS {
	DSCBSTATUS_CAPTURING        =0x00000001,
	DSCBSTATUS_LOOPING          =0x00000002
} DSCBSTATUSFLAGS;

typedef enum CONST_DSCBSTARTFLAGS {
	DSCBSTART_DEFAULT           =0x00000000, 
	DSCBSTART_LOOPING           =0x00000001
}  DSCBSTARTFLAGS;

typedef enum CONST_DSCAPSFLAGS {
 DSCAPS_PRIMARYMONO          =0x00000001,
 DSCAPS_PRIMARYSTEREO        =0x00000002,
 DSCAPS_PRIMARY8BIT          =0x00000004,
 DSCAPS_PRIMARY16BIT         =0x00000008,
 DSCAPS_CONTINUOUSRATE       =0x00000010,
 DSCAPS_EMULDRIVER           =0x00000020,
 DSCAPS_CERTIFIED            =0x00000040,
 DSCAPS_SECONDARYMONO        =0x00000100,
 DSCAPS_SECONDARYSTEREO      =0x00000200,
 DSCAPS_SECONDARY8BIT        =0x00000400,
 DSCAPS_SECONDARY16BIT       =0x00000800
} DSCAPSFLAGS;

typedef enum CONST_DSBCAPSFLAGS {
	 DSBCAPS_PRIMARYBUFFER       =0x00000001,
	 DSBCAPS_STATIC              =0x00000002,
	 DSBCAPS_LOCHARDWARE         =0x00000004,
	 DSBCAPS_LOCSOFTWARE         =0x00000008,
	 DSBCAPS_CTRL3D              =0x00000010,
	 DSBCAPS_CTRLFREQUENCY       =0x00000020,
	 DSBCAPS_CTRLPAN             =0x00000040,
	 DSBCAPS_CTRLVOLUME          =0x00000080,
	 DSBCAPS_CTRLPOSITIONNOTIFY  =0x00000100,
	 //DSBCAPS_CTRLDEFAULT         =0x000000E0,
	 //DSBCAPS_CTRLALL             =0x000001F0,
	 DSBCAPS_STICKYFOCUS         =0x00004000,
	 DSBCAPS_GLOBALFOCUS         =0x00008000,
	 DSBCAPS_GETCURRENTPOSITION2 =0x00010000,
	 DSBCAPS_MUTE3DATMAXDISTANCE =0x00020000
	} DSBCAPSFLAGS;

typedef enum CONST_DSCBCAPSFLAGS {
	DSCBCAPS_DEFAULT          =0x00000000,
	 DSCBCAPS_WAVEMAPPED         =0x80000000
} DSCBCAPSFLAGS;

typedef enum CONST_DSCCAPSFLAGS {
  DSCCAPS_DEFAULT           =0x00000000,
  DSCCAPS_EMULDRIVER          =0x00000020  
} DSCCAPSFLAGS;

typedef enum CONST_DSOUND {


	 //KSPROPERTY_SUPPORT_GET  =0x00000001,
	 //KSPROPERTY_SUPPORT_SET  =0x00000002,


	 DS3D_MINDISTANCEFACTOR      =0,
	 DS3D_MAXDISTANCEFACTOR      =10,
	 DS3D_DEFAULTDISTANCEFACTOR  =1,

	 DS3D_MINROLLOFFFACTOR       =0,
	 DS3D_MAXROLLOFFFACTOR       =10,
	 DS3D_DEFAULTROLLOFFFACTOR   =1,

	 DS3D_MINDOPPLERFACTOR       =0,
	 DS3D_MAXDOPPLERFACTOR       =10,
	 DS3D_DEFAULTDOPPLERFACTOR   =1,

	 DS3D_DEFAULTMINDISTANCE     =1,
	 DS3D_DEFAULTMAXDISTANCE     =1000000000,

	 DS3D_MINCONEANGLE           =0,
	 DS3D_MAXCONEANGLE           =360,
	 DS3D_DEFAULTCONEANGLE       =360,

	 DS3D_DEFAULTCONEOUTSIDEVOLUME  = 0,

	 DSBFREQUENCY_MIN            =100,
	 DSBFREQUENCY_MAX            =100000,
	 DSBFREQUENCY_ORIGINAL       =0,

	 DSBPAN_LEFT                 =-10000,
	 DSBPAN_CENTER               =0,
	 DSBPAN_RIGHT                =10000,

	 DSBVOLUME_MIN               =-10000,
	 DSBVOLUME_MAX               =0,

	 DSBSIZE_MIN                 =4,
	 DSBSIZE_MAX                 =0x0FFFFFFF,

	 DSBPN_OFFSETSTOP            =0xFFFFFFFF,

	 WAVE_FORMAT_PCM		=1
} DSOUNDCONSTANTS;


/*
 * State enumerants for per-stage texture processing.
 */
typedef enum CONST_D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP        =  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
    D3DTSS_COLORARG1      =  2, /* D3DTA_* (texture arg) */
    D3DTSS_COLORARG2      =  3, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAOP        =  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
    D3DTSS_ALPHAARG1      =  5, /* D3DTA_* (texture arg) */
    D3DTSS_ALPHAARG2      =  6, /* D3DTA_* (texture arg) */
    D3DTSS_TEXCOORDINDEX  = 11, /* identifies which set of texture coordinates index this texture */
    D3DTSS_ADDRESS        = 12, /* D3DTEXTUREADDRESS for both coordinates */
    D3DTSS_ADDRESSU       = 13, /* D3DTEXTUREADDRESS for U coordinate */
    D3DTSS_ADDRESSV       = 14, /* D3DTEXTUREADDRESS for V coordinate */
    D3DTSS_BORDERCOLOR    = 15, /* D3DCOLOR */
    D3DTSS_MAGFILTER      = 16, /* D3DTEXTUREMAGFILTER filter to use for magnification */
    D3DTSS_MINFILTER      = 17, /* D3DTEXTUREMINFILTER filter to use for minification */
    D3DTSS_MIPFILTER      = 18, /* D3DTEXTUREMIPFILTER filter to use between mipmaps during minification */
    D3DTSS_MAXMIPLEVEL    = 20, /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
    D3DTSS_MAXANISOTROPY  = 21, /* DWORD maximum anisotropy */
    D3DTSS_TEXTURETRANSFORMFLAGS = 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */

	//should be in own enum
	//D3DTSS_TCI_PASSTHRU                           =  0x00000000,
	//D3DTSS_TCI_CAMERASPACENORMAL                  =  0x00010000,
	//D3DTSS_TCI_CAMERASPACEPOSITION                =  0x00020000,
	//D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR        =  0x00030000,

} D3DTEXTURESTAGESTATETYPE;


typedef enum  CONST_D3DTEXCOORDINDEXFLAGS 
{
    D3DTSS_TCI_CAMERASPACENORMAL = 65536,
    D3DTSS_TCI_CAMERASPACEPOSITION = 131072,
    D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR = 196608,
    D3DTSS_TCI_PASSTHRU = 0,
} D3DTEXCOORDINDEXFLAGS ;

typedef enum CONST_D3DTEXTURESTAGESINGLE 
{
    D3DTSS_BUMPENVMAT00   =  7, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT01   =  8, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT10   =  9, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_BUMPENVMAT11   = 10, /* D3DVALUE (bump mapping matrix) */
    D3DTSS_MIPMAPLODBIAS  = 19, /* D3DVALUE Mipmap LOD bias */
    D3DTSS_BUMPENVLSCALE  = 22, /* D3DVALUE scale for bump map luminance */
    D3DTSS_BUMPENVLOFFSET = 23, /* D3DVALUE offset for bump map luminance */

}  D3DTEXTURESTAGESINGLE ;


/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum CONST_D3DTEXTUREOP
{
// Control
    D3DTOP_DISABLE    = 1,      // disables stage
    D3DTOP_SELECTARG1 = 2,      // the default
    D3DTOP_SELECTARG2 = 3,

// Modulate
    D3DTOP_MODULATE   = 4,      // multiply args together
    D3DTOP_MODULATE2X = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X = 6,      // multiply and  2 bits

// Add
    D3DTOP_ADD          =  7,   // add arguments together
    D3DTOP_ADDSIGNED    =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X  =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT     = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH    = 11,   // add 2 args, subtract product
                                // Arg1 + Arg2 - Arg1*Arg2
                                // = Arg1 + (1-Arg1)*Arg2

// Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRENDERSTATE_TEXTUREFACTOR
    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color

// Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

// Bump mapping
    D3DTOP_BUMPENVMAP           = 22, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 23, // with luminance channel
    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 24    
} D3DTEXTUREOP;


typedef enum CONST_D3DTEXTUREMAGFILTER
{
    D3DTFG_POINT        = 1,    // nearest
    D3DTFG_LINEAR       = 2,    // linear interpolation
    D3DTFG_FLATCUBIC    = 3,    // cubic
    D3DTFG_GAUSSIANCUBIC = 4,   // different cubic kernel
    D3DTFG_ANISOTROPIC  = 5    
} D3DTEXTUREMAGFILTER;

typedef enum CONST_D3DTEXTUREMINFILTER
{
    D3DTFN_POINT        = 1,    // nearest
    D3DTFN_LINEAR       = 2,    // linear interpolation
    D3DTFN_ANISOTROPIC  = 3,        
} D3DTEXTUREMINFILTER;

typedef enum CONST_D3DTEXTUREMIPFILTER
{
    D3DTFP_NONE         = 1,    // mipmapping disabled (use MAG filter)
    D3DTFP_POINT        = 2,    // nearest
    D3DTFP_LINEAR       = 3    // linear interpolation
    
} D3DTEXTUREMIPFILTER;


typedef enum CONST_DSETUPFLAGS {


	// DSETUP flags. DirectX 5.0 apps should use these flags only.
	DSETUP_DDRAWDRV        = 0x00000008,
	DSETUP_DSOUNDDRV       = 0x00000010,
	DSETUP_DXCORE          = 0x00010000,
	DSETUP_DIRECTX  		=0x00010018,
	DSETUP_TESTINSTALL      =0x00020000    
} DSETUPFLAGS;


typedef enum CONST_DSETUPCALLBACKFLAGS {

	// DSETUP Message Info Codes, passed to callback as Reason parameter.
	DSETUP_CB_MSG_NOMESSAGE                 =    0,
	DSETUP_CB_MSG_CANTINSTALL_UNKNOWNOS     =    1,
	DSETUP_CB_MSG_CANTINSTALL_NT            =    2,
	DSETUP_CB_MSG_CANTINSTALL_BETA          =    3,
	DSETUP_CB_MSG_CANTINSTALL_NOTWIN32      =    4,
	DSETUP_CB_MSG_CANTINSTALL_WRONGLANGUAGE =    5,
	DSETUP_CB_MSG_CANTINSTALL_WRONGPLATFORM =    6,
	DSETUP_CB_MSG_PREINSTALL_NT             =    7,
	DSETUP_CB_MSG_NOTPREINSTALLEDONNT       =    8,
	DSETUP_CB_MSG_SETUP_INIT_FAILED         =    9,
	DSETUP_CB_MSG_INTERNAL_ERROR            =    10,
	DSETUP_CB_MSG_CHECK_DRIVER_UPGRADE      =    11,
	DSETUP_CB_MSG_OUTOFDISKSPACE            =    12,
	DSETUP_CB_MSG_BEGIN_INSTALL             =    13,
	DSETUP_CB_MSG_BEGIN_INSTALL_RUNTIME     =    14,
	DSETUP_CB_MSG_BEGIN_INSTALL_DRIVERS     =    15,
	DSETUP_CB_MSG_BEGIN_RESTORE_DRIVERS     =    16,
	DSETUP_CB_MSG_FILECOPYERROR             =    17,

	DSETUP_CB_UPGRADE_TYPE_MASK             =0x000F,
	DSETUP_CB_UPGRADE_KEEP                  =0x0001,
	DSETUP_CB_UPGRADE_SAFE                  =0x0002,
	DSETUP_CB_UPGRADE_FORCE                 =0x0004,
	DSETUP_CB_UPGRADE_UNKNOWN               =0x0008,

	DSETUP_CB_UPGRADE_HASWARNINGS           =0x0100,
	DSETUP_CB_UPGRADE_CANTBACKUP            =0x0200,

	DSETUP_CB_UPGRADE_DEVICE_ACTIVE         =0x0800,

	DSETUP_CB_UPGRADE_DEVICE_DISPLAY        =0x1000,
	DSETUP_CB_UPGRADE_DEVICE_MEDIA          =0x2000

} DSETUPCALLBACKFLAGS;

typedef enum CONST_D3DRMANIMATIONFLAGS {

	D3DRMANIMATION_OPEN =0x01,
	D3DRMANIMATION_CLOSED= 0x02,
	D3DRMANIMATION_LINEARPOSITION= 0x04,
	D3DRMANIMATION_SPLINEPOSITION= 0x08,
	D3DRMANIMATION_SCALEANDROTATION= 0x00000010,
	D3DRMANIMATION_POSITION= 0x00000020
} D3DRMANIMATIONOPTIONS ;

typedef enum CONST_D3DRMANIMATIONKEYFLAGS {
	D3DRMANIMATION_ROTATEKEY = 0x01, 
	D3DRMANIMATION_SCALEKEY = 0x02, 
	D3DRMANIMATION_POSITIONKEY = 0x03 
} D3DRMANIMATIONKEYFLAGS;



typedef enum CONST_DPGROUPFLAGS {
	DPGROUP_DEFAULT=0x0,
	DPGROUP_LOCAL=0x08,
	DPGROUP_STAGINGAREA=0x0800,
	DPGROUP_HIDDEN=0x1000
} DPGROUPFLAGS;

typedef enum CONST_DPPLAYERFLAGS {
	DPPLAYER_DEFAULT=0x0,
	DPPLAYER_SERVERPLAYER=0x100,
	DPPLAYER_SPECTATOR=0x200,
	DPPLAYER_LOCAL=0x08,
	//DPPLAYER_OWNER=0x2000	this is an internal dplay flag..
} DPPLAYERFLAGS;

typedef enum CONST_DPENUMCONNECTIONFLAGS {
	DPCONNECTION_DIRECTPLAY=1,
	DPCONNECTION_DIRECTPLAYLOBBY=2
} DPENUMCONNECTIONFLAGS;


typedef enum CONST_DPCONNECTFLAGS {
	DPCONNECTION_DEFAULT=0,
	DPCONNECTION_RETURNSTATUS=0x80
} DPCONNECTFLAGS;

typedef enum CONST_DPENUMPLAYERFLAGS {

	 DPENUMPLAYERS_ALL           =0x00000000,
	 DPENUMPLAYERS_LOCAL         =0x00000008,
	 DPENUMPLAYERS_REMOTE        =0x00000010,
	 DPENUMPLAYERS_GROUP         =0x00000020,
	 DPENUMPLAYERS_SESSION       =0x00000080,
	 DPENUMPLAYERS_SERVERPLAYER  =0x00000100,
	 DPENUMPLAYERS_SPECTATOR     =0x00000200,
   	 DPENUMPLAYERS_OWNER=0x2000,

} DPENUMPLAYERFLAGS;



typedef enum CONST_DPENUMGROUPFLAGS {
	DPENUMGROUPS_ALL=0x00,
	DPENUMGROUPS_HIDDEN=0x1000,
	DPENUMGROUPS_LOCAL=0x8,
	DPENUMGROUPS_REMOTE=0x10,
	DPENUMGROUPS_SESSION=0x80,
	DPENUMGROUPS_STAGINGAREA=0x0800,
	DPENUMGROUPS_SHORTCUT       =0x00000400
} DPENUMGROUPFLAGS;


	 


typedef enum CONST_DPENUMSESSIONFLAGS {
	DPENUMSESSIONS_ALL=2,
	DPENUMSESSIONS_ASYNC=0x10,
	DPENUMSESSIONS_AVAILABLE=1,
	DPENUMSESSIONS_PASSWORDREQUIRED=0x40,
	DPENUMSESSIONS_RETURNSTATUS=0x80,
	DPENUMSESSIONS_STOPASYNC=0x10
} DPENUMSESSIONFLAGS;

typedef enum CONST_DPGETCAPSFLAGS {
	DPGETCAPS_DEFAULT =0,
	DPGETCAPS_GUARANTEED =1
} DPGETCAPSFLAGS;

typedef enum CONST_DPGETFLAGS {
	DPGET_REMOTE =0,
	DPGET_LOCAL = 1	
} DPGETFLAGS;


typedef enum CONST_DPSETFLAGS {
	DPSET_REMOTE =0,
	DPSET_LOCAL = 1,
	DPSET_GUARANTEED = 2	
} DPSETFLAGS;


typedef enum CONST_DPMESSAGEQUEUEFLAGS {
	DPMESSAGEQUEUE_SEND = 1,
	DPMESSAGEQUEUE_RECEIVE= 2
} DPMESSAGEQUEUEFLAGS;


typedef enum CONST_DPOPENFLAGS {
	DPOPEN_JOIN=0x01,
	DPOPEN_CREATE=0x02,
	DPOPEN_RETURNSTATUS=0x80
} DPOPENFLAGS;


typedef enum CONST_DPRECEIVEFLAGS {
	DPRECEIVE_ALL=1,
	DPRECEIVE_PEEK=8,
	DPRECEIVE_TOPLAYER=2,
	DPRECEIVE_FROMPLAYER=4
} DPRECEIVEFLAGS;


typedef enum CONST_DPSENDFLAGS {
	 DPSEND_DEFAULT				 =0x00000000,
	 DPSEND_GUARANTEED           =0x00000001,
	 DPSEND_SIGNED               =0x00000020,
	 DPSEND_ENCRYPTED            =0x00000040,
	 DPSEND_NOSENDCOMPLETEMSG    =0x00000400,
	 DPSEND_ASYNC				 =0x00000200

} DPSENDFLAGS;
 

typedef enum CONST_DPLMSG 
{

	/*
	 *	This is a message flag used by ReceiveLobbyMessage.  It can be
	 *	returned in the dwMessageFlags parameter to indicate a message from
	 *	the system.
	 */
	 DPLMSG_SYSTEM					=0x00000001,

	/*
	 *	This is a message flag used by ReceiveLobbyMessage and SendLobbyMessage.
	 *  It is used to indicate that the message is a standard lobby message.
	 *  DPLMSG_SETPROPERTY, DPLMSG_SETPROPERTYRESPONSE, DPLMSG_GETPROPERTY,
	 *	DPLMSG_GETPROPERTYRESPONSE
	 */
	 DPLMSG_STANDARD					=0x00000002,

	 DPLMSG_USERDEFINED					=0x00000000
} DPLMSG;


typedef enum CONST_DPLWAIT {
	DPLWAIT_DEFAULT =0,
	DPLWAIT_CANCEL =1
} DPLWAIT;


typedef enum CONST_DPIDFLAGS {
	 DPID_SYSMSG         =0,
	 DPID_ALLPLAYERS     =0,
	 DPID_SERVERPLAYER	=1,
	 DPID_UNKNOWN		=0xFFFFFFFF
} DPIDFLAGS;


	
typedef enum CONST_DPSESSIONFLAGS {

	 DPSESSION_NEWPLAYERSDISABLED    =0x00000001 ,
	 DPSESSION_MIGRATEHOST           =0x00000004,
	 DPSESSION_NOMESSAGEID           =0x00000008,
	 DPSESSION_JOINDISABLED          =0x00000020,
	 DPSESSION_KEEPALIVE             =0x00000040,
	 DPSESSION_NODATAMESSAGES        =0x00000080,
	 DPSESSION_SECURESERVER          =0x00000100,
	 DPSESSION_PRIVATE               =0x00000200,
	 DPSESSION_PASSWORDREQUIRED      =0x00000400,
	 DPSESSION_MULTICASTSERVER		=0x00000800,
	 DPSESSION_CLIENTSERVER			=0x00001000,
	 DPSESSION_DIRECTPLAYPROTOCOL	=0x00002000,
     DPSESSION_NOPRESERVEORDER		=0x00004000,
     DPSESSION_OPTIMIZELATENCY		=0x00008000


} DPSESSIONFLAGS;


typedef enum CONST_DPLCONNECTIONFLAGS { 
	 DPLCONNECTION_CREATESESSION		=				DPOPEN_CREATE,
	 DPLCONNECTION_JOINSESSION			=		DPOPEN_JOIN,
} DPLCONNECTIONFLAGS;



	 



typedef enum CONST_DPSYSMSGTYPES {

	/****************************************************************************
	 *
	 * DirectPlay system messages and message data structures
	 *
	 * All system message come 'From' player DPID_SYSMSG.  To determine what type 
	 * of message it is, cast the lpData from Receive to DPMSG_GENERIC and check
	 * the dwType member against one of the following DPSYS_xxx constants. Once
	 * a match is found, cast the lpData to the corresponding of the DPMSG_xxx
	 * structures to access the data of the message.
	 *
	 ****************************************************************************/

	/*
	 * A new player or group has been created in the session
	 * Use DPMSG_CREATEPLAYERORGROUP.  Check dwPlayerType to see if it
	 * is a player or a group.
	 */
	 DPSYS_CREATEPLAYERORGROUP   =0x0003 , 

	/*
	 * A player has been deleted from the session
	 * Use DPMSG_DESTROYPLAYERORGROUP
	 */
	 DPSYS_DESTROYPLAYERORGROUP  =0x0005  ,

	/*
	 * A player has been added to a group
	 * Use DPMSG_ADDPLAYERTOGROUP
	 */
	 DPSYS_ADDPLAYERTOGROUP      =0x0007  ,

	/*
	 * A player has been removed from a group
	 * Use DPMSG_DELETEPLAYERFROMGROUP
	 */
	 DPSYS_DELETEPLAYERFROMGROUP =0x0021  ,

	/*
	 * This DirectPlay object lost its connection with all the
	 * other players in the session.
	 * Use DPMSG_SESSIONLOST.
	 */
	 DPSYS_SESSIONLOST           =0x0031,

	/*
	 * The current host has left the session.
	 * This DirectPlay object is now the host.
	 * Use DPMSG_HOST.
	 */
	 DPSYS_HOST                  =0x0101,

	/*
	 * The remote data associated with a player or
	 * group has changed. Check dwPlayerType to see
	 * if it is a player or a group
	 * Use DPMSG_SETPLAYERORGROUPDATA
	 */
	 DPSYS_SETPLAYERORGROUPDATA  =0x0102,

	/*
	 * The name of a player or group has changed.
	 * Check dwPlayerType to see if it is a player
	 * or a group.
	 * Use DPMSG_SETPLAYERORGROUPNAME
	 */
	 DPSYS_SETPLAYERORGROUPNAME  =0x0103,

	/*
	 * The session description has changed.
	 * Use DPMSG_SETSESSIONDESC
	 */
	 DPSYS_SETSESSIONDESC        =0x0104,

	/*
	 * A group has been added to a group
	 * Use DPMSG_ADDGROUPTOGROUP
	 */
	 DPSYS_ADDGROUPTOGROUP      	=0x0105  ,

	/*
	 * A group has been removed from a group
	 * Use DPMSG_DELETEGROUPFROMGROUP
	 */
	 DPSYS_DELETEGROUPFROMGROUP 	=0x0106,

	/*
	 * A secure player-player message has arrived.
	 * Use DPMSG_SECUREMESSAGE
	 */
	 DPSYS_SECUREMESSAGE         =0x0107,

	/*
	 * Start a new session.
	 * Use DPMSG_STARTSESSION
	 */
	 DPSYS_STARTSESSION          =0x0108,

	/*
	 * A chat message has arrived
	 * Use DPMSG_CHAT
	 */
	 DPSYS_CHAT                  =0x0109,

	/*
	* The owner of a group has changed
	* Use DPMSG_SETGROUPOWNER
	*/
	DPSYS_SETGROUPOWNER         =0x010A,

	/*
	* An async send has finished, failed or been cancelled
	* Use DPMSG_SENDCOMPLETE
	*/
	DPSYS_SENDCOMPLETE          =0x010d,



	/*
	 *  The application has read the connection settings.
	 *  It is now O.K. for the lobby client to release
	 *  its IDirectPlayLobby interface.
	 */
	 DPLSYS_CONNECTIONSETTINGSREAD   =0x00000001,

	/*
	 *  The application's call to DirectPlayConnect failed
	 */
	 DPLSYS_DPLAYCONNECTFAILED       =0x00000002,

	/*
	 *  The application has created a DirectPlay session.
	 */
	 DPLSYS_DPLAYCONNECTSUCCEEDED    =0x00000003,

	/*
	 *  The application has terminated.
	 */
	 DPLSYS_APPTERMINATED            =0x00000004,

	/*
	 *  The message is a DPLMSG_SETPROPERTY message.
	 */
	 DPLSYS_SETPROPERTY				=0x00000005,

	/*
	 *  The message is a DPLMSG_SETPROPERTYRESPONSE message.
	 */
	 DPLSYS_SETPROPERTYRESPONSE		=0x00000006,

	/*
	 *  The message is a DPLMSG_GETPROPERTY message.
	 */
	 DPLSYS_GETPROPERTY				=0x00000007,

	/*
	 *  The message is a DPLMSG_GETPROPERTYRESPONSE message.
	 */
	 DPLSYS_GETPROPERTYRESPONSE		=0x00000008,

	 DPLSYS_NEWCONNECTIONSETTINGS =0x0000000A,

	 DPLSYS_NEWSESSIONHOST =0x00000009

} DPSYSMSGTYPES;


typedef enum CONST_DPPLAYERTYPEFLAGS{
	 DPPLAYERTYPE_GROUP          =0x00000000,
	 DPPLAYERTYPE_PLAYER         =0x00000001

} DPPLAYERTYPEFLAGS;





#if 0 
	 DPESC_TIMEDOUT          =0x00000001,
	 DPCPA_NOFLOW       = 0           ,// no flow control
	 DPCPA_XONXOFFFLOW  = 1           ,// software flow control
	 DPCPA_RTSFLOW      = 2           ,// hardware flow control with RTS
	 DPCPA_DTRFLOW      = 3           ,// hardware flow control with DTR
	 DPCPA_RTSDTRFLOW   = 4           ,// hardware flow control with RTS and DTR
	 DPLAD_SYSTEM       =   DPLMSG_SYSTEM
#endif 

typedef enum CONST_D3DSTENCILCAPSFLAGS {
	 D3DSTENCILCAPS_KEEP     =0x00000001,
	 D3DSTENCILCAPS_ZERO     =0x00000002,
	 D3DSTENCILCAPS_REPLACE  =0x00000004,
	 D3DSTENCILCAPS_INCRSAT  =0x00000008,
	 D3DSTENCILCAPS_DECRSAT  =0x00000010,
	 D3DSTENCILCAPS_INVERT   =0x00000020,
	 D3DSTENCILCAPS_INCR     =0x00000040,
	 D3DSTENCILCAPS_DECR     =0x00000080

} D3DSTENCILCAPSFLAGS;

typedef enum CONST_WAVEFORMATFLAGS {
      WAVE_FORMAT_1M08       =0x00000001,       /* 11.025 kHz, Mono,   8-bit  */
      WAVE_FORMAT_1S08       =0x00000002,       /* 11.025 kHz, Stereo, 8-bit  */
      WAVE_FORMAT_1M16       =0x00000004,       /* 11.025 kHz, Mono,   16-bit */
      WAVE_FORMAT_1S16       =0x00000008,       /* 11.025 kHz, Stereo, 16-bit */
      WAVE_FORMAT_2M08       =0x00000010,       /* 22.05  kHz, Mono,   8-bit  */
      WAVE_FORMAT_2S08       =0x00000020,       /* 22.05  kHz, Stereo, 8-bit  */
      WAVE_FORMAT_2M16       =0x00000040,       /* 22.05  kHz, Mono,   16-bit */
      WAVE_FORMAT_2S16       =0x00000080,       /* 22.05  kHz, Stereo, 16-bit */
      WAVE_FORMAT_4M08       =0x00000100,       /* 44.1   kHz, Mono,   8-bit  */
      WAVE_FORMAT_4S08       =0x00000200,       /* 44.1   kHz, Stereo, 8-bit  */
      WAVE_FORMAT_4M16       =0x00000400,       /* 44.1   kHz, Mono,   16-bit */
      WAVE_FORMAT_4S16      = 0x00000800       /* 44.1   kHz, Stereo, 16-bit */	  
} WAVEFORMATFLAGS;

typedef enum CONST_DPCAPSFLAGS {

	/*
	 * Current Open settings supports all forms of Cancel
	 */
	DPCAPS_ASYNCCANCELSUPPORTED    =0x00001000,

	/*
	 * Current Open settings supports CancelAll, but not Cancel
	 */
	DPCAPS_ASYNCCANCELALLSUPPORTED =0x00002000,

	/*
	 *  Current Open settings supports Send Timeouts for sends
	 */
	DPCAPS_SENDTIMEOUTSUPPORTED   =0x00004000,

	/*
	 *  Current Open settings supports send priority
	 */
	DPCAPS_SENDPRIORITYSUPPORTED   =0x00008000,

	/*
	 *  Current Open settings supports DPSEND_ASYNC flag
	 */
	DPCAPS_ASYNCSUPPORTED 		   =0x00010000,

	DPCAPS_ISHOST               =0x00000002,
	DPCAPS_GROUPOPTIMIZED       =0x00000008,
	DPCAPS_KEEPALIVEOPTIMIZED   =0x00000010,
	DPCAPS_GUARANTEEDOPTIMIZED  =0x00000020,
	DPCAPS_GUARANTEEDSUPPORTED  =0x00000040,
	DPCAPS_SIGNINGSUPPORTED     =0x00000080,
	DPCAPS_ENCRYPTIONSUPPORTED  =0x00000100

} DPCAPSFLAGS;


typedef enum CONST_DSETUPERR {
    DSETUPERR_SUCCESS_RESTART = 1,
    DSETUPERR_SUCCESS = 0,
    DSETUPERR_BADWINDOWSVERSION = -1,
    DSETUPERR_SOURCEFILENOTFOUND = -2,
    DSETUPERR_BADSOURCESIZE = -3,
    DSETUPERR_BADSOURCETIME = -4,
    DSETUPERR_NOCOPY = -5,
    DSETUPERR_OUTOFDISKSPACE = -6,
    DSETUPERR_CANTFINDINF = -7,
    DSETUPERR_CANTFINDDIR = -8,
    DSETUPERR_INTERNAL = -9,
    DSETUPERR_NTWITHNO3D = -10,
    DSETUPERR_UNKNOWNOS = -11,
    DSETUPERR_USERHITCANCEL = -12,
    DSETUPERR_NOTPREINSTALLEDONNT = -13
} DSETUPERR;

typedef enum CONST_DSOUNDERR {
    DS_OK = 0,
    DSERR_ALLOCATED = -2005401590,
    DSERR_CONTROLUNAVAIL = -2005401570,
    DSERR_INVALIDPARAM = -2147024809,
    DSERR_INVALIDCALL = -2005401550,
    DSERR_GENERIC = -2147467259,
    DSERR_PRIOLEVELNEEDED = -2005401530,
    DSERR_OUTOFMEMORY = 7, // -2147024882,
    DSERR_BADFORMAT = -2005401500,
    DSERR_UNSUPPORTED = -2147467263,
    DSERR_NODRIVER = -2005401480,
    DSERR_ALREADYINITIALIZED = -2005401470,
    //DSERR_NOAGGREGATION = -2147467262,
    DSERR_BUFFERLOST = -2005401450,
    DSERR_OTHERAPPHASPRIO = -2005401440,
    DSERR_UNINITIALIZED = -2005401430,
    DSERR_NOINTERFACE =  430 //-2147467262
} DSOUNDERR;

typedef enum CONST_DDRAWERR {
    DD_OK = 0,
    //DD_FALSE = 1,
    DDENUMRET_CANCEL = 0,
    DDENUMRET_OK = 1,
    DDERR_ALREADYINITIALIZED = -2005532667,
    DDERR_CANNOTATTACHSURFACE = -2005532662,
    DDERR_CANNOTDETACHSURFACE = -2005532652,
    DDERR_CURRENTLYNOTAVAIL = -2005532632,
    DDERR_EXCEPTION = -2005532617,
    DDERR_GENERIC = -2147467259,		//E_FAIL
    DDERR_HEIGHTALIGN = -2005532582,
    DDERR_INCOMPATIBLEPRIMARY = -2005532577,
    DDERR_INVALIDCAPS = -2005532572,
    DDERR_INVALIDCLIPLIST = -2005532562,
    DDERR_INVALIDMODE = -2005532552,
    DDERR_INVALIDOBJECT = -2005532542,
    DDERR_INVALIDPARAMS = 5,                     //-2147024809, E_INVALIDARG
    DDERR_INVALIDPIXELFORMAT = -2005532527,
    DDERR_INVALIDRECT = -2005532522,
    DDERR_LOCKEDSURFACES = -2005532512,
    DDERR_NO3D = -2005532502,
    DDERR_NOALPHAHW = -2005532492,
    DDERR_NOCLIPLIST = -2005532467,
    DDERR_NOCOLORCONVHW = -2005532462,
    DDERR_NOCOOPERATIVELEVELSET = -2005532460,
    DDERR_NOCOLORKEY = -2005532457,
    DDERR_NOCOLORKEYHW = -2005532452,
    DDERR_NODIRECTDRAWSUPPORT = -2005532450,
    DDERR_NOEXCLUSIVEMODE = -2005532447,
    DDERR_NOFLIPHW = -2005532442,
    DDERR_NOGDI = -2005532432,
    DDERR_NOMIRRORHW = -2005532422,
    DDERR_NOTFOUND = -2005532417,
    DDERR_NOOVERLAYHW = -2005532412,
    DDERR_OVERLAPPINGRECTS = -2005532402,
    DDERR_NORASTEROPHW = -2005532392,
    DDERR_NOROTATIONHW = -2005532382,
    DDERR_NOSTRETCHHW = -2005532362,
    DDERR_NOT4BITCOLOR = -2005532356,
    DDERR_NOT4BITCOLORINDEX = -2005532355,
    DDERR_NOT8BITCOLOR = -2005532352,
    DDERR_NOTEXTUREHW = -2005532342,
    DDERR_NOVSYNCHW = -2005532337,
    DDERR_NOZBUFFERHW = -2005532332,
    DDERR_NOZOVERLAYHW = -2005532322,
    DDERR_OUTOFCAPS = -2005532312,
    DDERR_OUTOFMEMORY = 7,               //-2147024882, E_OUTOFMEMORY
    DDERR_OUTOFVIDEOMEMORY = -2005532292,
    DDERR_OVERLAYCANTCLIP = -2005532290,
    DDERR_OVERLAYCOLORKEYONLYONEACTIVE = -2005532288,
    DDERR_PALETTEBUSY = -2005532285,
    DDERR_COLORKEYNOTSET = -2005532272,
    DDERR_SURFACEALREADYATTACHED = -2005532262,
    DDERR_SURFACEALREADYDEPENDENT = -2005532252,
    DDERR_SURFACEBUSY = -2005532242,
    DDERR_CANTLOCKSURFACE = -2005532237,
    DDERR_SURFACEISOBSCURED = -2005532232,
    DDERR_SURFACELOST = -2005532222,
    DDERR_SURFACENOTATTACHED = -2005532212,
    DDERR_TOOBIGHEIGHT = -2005532202,
    DDERR_TOOBIGSIZE = -2005532192,
    DDERR_TOOBIGWIDTH = -2005532182,
    DDERR_UNSUPPORTED = -2147467263,
    DDERR_UNSUPPORTEDFORMAT = -2005532162,
    DDERR_UNSUPPORTEDMASK = -2005532152,
    DDERR_INVALIDSTREAM = -2005532151,
    DDERR_VERTICALBLANKINPROGRESS = -2005532135,
    DDERR_WASSTILLDRAWING = -2005532132,
    DDERR_XALIGN = -2005532112,
    DDERR_INVALIDDIRECTDRAWGUID = -2005532111,
    DDERR_DIRECTDRAWALREADYCREATED = -2005532110,
    DDERR_NODIRECTDRAWHW = -2005532109,
    DDERR_PRIMARYSURFACEALREADYEXISTS = -2005532108,
    DDERR_NOEMULATION = -2005532107,
    DDERR_REGIONTOOSMALL = -2005532106,
    DDERR_CLIPPERISUSINGHWND = -2005532105,
    DDERR_NOCLIPPERATTACHED = -2005532104,
    DDERR_NOHWND = -2005532103,
    DDERR_HWNDSUBCLASSED = -2005532102,
    DDERR_HWNDALREADYSET = -2005532101,
    DDERR_NOPALETTEATTACHED = -2005532100,
    DDERR_NOPALETTEHW = -2005532099,
    DDERR_BLTFASTCANTCLIP = -2005532098,
    DDERR_NOBLTHW = -2005532097,
    DDERR_NODDROPSHW = -2005532096,
    DDERR_OVERLAYNOTVISIBLE = -2005532095,
    DDERR_NOOVERLAYDEST = -2005532094,
    DDERR_INVALIDPOSITION = -2005532093,
    DDERR_NOTAOVERLAYSURFACE = -2005532092,
    DDERR_EXCLUSIVEMODEALREADYSET = -2005532091,
    DDERR_NOTFLIPPABLE = -2005532090,
    DDERR_CANTDUPLICATE = -2005532089,
    DDERR_NOTLOCKED = -2005532088,
    DDERR_CANTCREATEDC = -2005532087,
    DDERR_NODC = -2005532086,
    DDERR_WRONGMODE = -2005532085,
    DDERR_IMPLICITLYCREATED = -2005532084,
    DDERR_NOTPALETTIZED = -2005532083,
    DDERR_UNSUPPORTEDMODE = -2005532082,
    DDERR_NOMIPMAPHW = -2005532081,
    DDERR_INVALIDSURFACETYPE = -2005532080,
    DDERR_NOOPTIMIZEHW = -2005532072,
    DDERR_NOTLOADED = -2005532071,
    DDERR_NOFOCUSWINDOW = -2005532070,
    DDERR_DCALREADYCREATED = -2005532052,
    DDERR_NONONLOCALVIDMEM = -2005532042,
    DDERR_CANTPAGELOCK = -2005532032,
    DDERR_CANTPAGEUNLOCK = -2005532012,
    DDERR_NOTPAGELOCKED = -2005531992,
    DDERR_MOREDATA = -2005531982,
    DDERR_EXPIRED = -2005531981,
    DDERR_VIDEONOTACTIVE = -2005531977,
    DDERR_DEVICEDOESNTOWNSURFACE = -2005531973,
    DDERR_NOTINITIALIZED = -2147221008,
	DDERR_NOSTEREOHARDWARE   = 0x887600B5,
	DDERR_NOSURFACELEFT		 =0x887600B6
	
} DDRAWERR;

typedef enum CONST_D3DIMERR {
    D3D_OK = 0,
    D3DERR_BADMAJORVERSION = -2005531972,
    D3DERR_BADMINORVERSION = -2005531971,
    D3DERR_INVALID_DEVICE = -2005531967,
    D3DERR_INITFAILED = -2005531966,
    D3DERR_DEVICEAGGREGATED = -2005531965,
	//D3DERR_EXECUTE_CREATE_FAILED = -2005531962,
    //D3DERR_EXECUTE_DESTROY_FAILED = -2005531961,
    //D3DERR_EXECUTE_LOCK_FAILED = -2005531960,
    //D3DERR_EXECUTE_UNLOCK_FAILED = -2005531959,
    //D3DERR_EXECUTE_LOCKED = -2005531958,
    //D3DERR_EXECUTE_NOT_LOCKED = -2005531957,
    //D3DERR_EXECUTE_FAILED = -2005531956,
    //D3DERR_EXECUTE_CLIPPED_FAILED = -2005531955,
    D3DERR_TEXTURE_NO_SUPPORT = -2005531952,
    D3DERR_TEXTURE_CREATE_FAILED = -2005531951,
    D3DERR_TEXTURE_DESTROY_FAILED = -2005531950,
    D3DERR_TEXTURE_LOCK_FAILED = -2005531949,
    D3DERR_TEXTURE_UNLOCK_FAILED = -2005531948,
    D3DERR_TEXTURE_LOAD_FAILED = -2005531947,
    D3DERR_TEXTURE_SWAP_FAILED = -2005531946,
    D3DERR_TEXTURE_LOCKED = -2005531945,
    D3DERR_TEXTURE_NOT_LOCKED = -2005531944,
    D3DERR_TEXTURE_GETSURF_FAILED = -2005531943,
    D3DERR_MATRIX_CREATE_FAILED = -2005531942,
    D3DERR_MATRIX_DESTROY_FAILED = -2005531941,
    D3DERR_MATRIX_SETDATA_FAILED = -2005531940,
    D3DERR_MATRIX_GETDATA_FAILED = -2005531939,
    D3DERR_SETVIEWPORTDATA_FAILED = -2005531938,
    D3DERR_INVALIDCURRENTVIEWPORT = -2005531937,
    D3DERR_INVALIDPRIMITIVETYPE = -2005531936,
    D3DERR_INVALIDVERTEXTYPE = -2005531935,
    D3DERR_TEXTURE_BADSIZE = -2005531934,
    D3DERR_INVALIDRAMPTEXTURE = -2005531933,
    D3DERR_MATERIAL_CREATE_FAILED = -2005531932,
    D3DERR_MATERIAL_DESTROY_FAILED = -2005531931,
    D3DERR_MATERIAL_SETDATA_FAILED = -2005531930,
    D3DERR_MATERIAL_GETDATA_FAILED = -2005531929,
    D3DERR_INVALIDPALETTE = -2005531928,
    D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY = -2005531927,
    D3DERR_ZBUFF_NEEDS_VIDEOMEMORY = -2005531926,
    D3DERR_SURFACENOTINVIDMEM = -2005531925,
    D3DERR_LIGHT_SET_FAILED = -2005531922,
    D3DERR_LIGHTHASVIEWPORT = -2005531921,
    D3DERR_LIGHTNOTINTHISVIEWPORT = -2005531920,
    D3DERR_SCENE_IN_SCENE = -2005531912,
    D3DERR_SCENE_NOT_IN_SCENE = -2005531911,
    D3DERR_SCENE_BEGIN_FAILED = -2005531910,
    D3DERR_SCENE_END_FAILED = -2005531909,
    D3DERR_INBEGIN = -2005531902,
    D3DERR_NOTINBEGIN = -2005531901,
    D3DERR_NOVIEWPORTS = -2005531900,
    D3DERR_VIEWPORTDATANOTSET = -2005531899,
    D3DERR_VIEWPORTHASNODEVICE = -2005531898,
    D3DERR_NOCURRENTVIEWPORT = -2005531897,
    D3DERR_INVALIDVERTEXFORMAT = -2005530624,
    D3DERR_COLORKEYATTACHED = -2005530622,
    D3DERR_VERTEXBUFFEROPTIMIZED = -2005530612,
    D3DERR_VBUF_CREATE_FAILED = -2005530611,
    D3DERR_VERTEXBUFFERLOCKED = -2005530610,
    D3DERR_ZBUFFER_NOTPRESENT = -2005530602,
    D3DERR_STENCILBUFFER_NOTPRESENT = -2005530601,
    D3DERR_WRONGTEXTUREFORMAT = -2005530600,
    D3DERR_UNSUPPORTEDCOLOROPERATION = -2005530599,
    D3DERR_UNSUPPORTEDCOLORARG = -2005530598,
    D3DERR_UNSUPPORTEDALPHAOPERATION = -2005530597,
    D3DERR_UNSUPPORTEDALPHAARG = -2005530596,
    D3DERR_TOOMANYOPERATIONS = -2005530595,
    D3DERR_CONFLICTINGTEXTUREFILTER = -2005530594,
    D3DERR_UNSUPPORTEDFACTORVALUE = -2005530593,
    D3DERR_CONFLICTINGRENDERSTATE = -2005530591,
    D3DERR_UNSUPPORTEDTEXTUREFILTER = -2005530590,
    D3DERR_TOOMANYPRIMITIVES = -2005530589,
    D3DERR_INVALIDMATRIX = -2005530588,
    D3DERR_TOOMANYVERTICES = -2005530587,
    D3DERR_CONFLICTINGTEXTUREPALETTE = -2005530586,

	D3DERR_INVALIDSTATEBLOCK        =0x88760834,
	D3DERR_INBEGINSTATEBLOCK        =0x88760835,
	D3DERR_NOTINBEGINSTATEBLOCK     =0x88760836,
	D3DERR_VERTEXBUFFERUNLOCKFAILED =0x8876080F,

} D3DIMERR;

typedef enum CONST_DPLAYERR {
    DP_OK = 0,
    DPERR_ALREADYINITIALIZED = -2005467131,
    DPERR_ACCESSDENIED = -2005467126,
    DPERR_ACTIVEPLAYERS = -2005467116,
    DPERR_BUFFERTOOSMALL = -2005467106,
    DPERR_CANTADDPLAYER = -2005467096,
    DPERR_CANTCREATEGROUP = -2005467086,
    DPERR_CANTCREATEPLAYER = -2005467076,
    DPERR_CANTCREATESESSION = -2005467066,
    DPERR_CAPSNOTAVAILABLEYET = -2005467056,
    DPERR_EXCEPTION = -2005467046,
    DPERR_GENERIC = -2147467259,	//E_FAIL
    DPERR_INVALIDFLAGS = -2005467016,
    DPERR_INVALIDOBJECT = -2005467006,
    DPERR_INVALIDPARAM = -2147024809,
    DPERR_INVALIDPARAMS = -2147024809,
    DPERR_INVALIDPLAYER = -2005466986,
    DPERR_INVALIDGROUP = -2005466981,
    DPERR_NOCAPS = -2005466976,
    DPERR_NOCONNECTION = -2005466966,
    //DPERR_NOMEMORY = 7, //2147024882, E_OUTOFMEMORY
    DPERR_OUTOFMEMORY =7, // -2147024882,
    DPERR_NOMESSAGES = -2005466946,
    DPERR_NONAMESERVERFOUND = -2005466936,
    DPERR_NOPLAYERS = -2005466926,
    DPERR_NOSESSIONS = -2005466916,
    DPERR_PENDING = -2147024889,		//0x8007007
    DPERR_SENDTOOBIG = -2005466906,
    DPERR_TIMEOUT = -2005466896,
    DPERR_UNAVAILABLE = -2005466886,
    DPERR_UNSUPPORTED = 445, //-2147467263, E_NOTIMPL
    DPERR_BUSY = -2005466866,
    DPERR_USERCANCEL = -2005466856,
    DPERR_NOINTERFACE = 430,//-2147467262,
    DPERR_CANNOTCREATESERVER = -2005466846,
    DPERR_PLAYERLOST = -2005466836,
    DPERR_SESSIONLOST = -2005466826,
    DPERR_UNINITIALIZED = -2005466816,
    DPERR_NONEWPLAYERS = -2005466806,
    DPERR_INVALIDPASSWORD = -2005466796,
    DPERR_CONNECTING = -2005466786,
    DPERR_CONNECTIONLOST = -2005466776,
    DPERR_UNKNOWNMESSAGE = -2005466766,
    DPERR_CANCELFAILED = -2005466756,
    DPERR_INVALIDPRIORITY = -2005466746,
    //DPERR_NOTHANDLED = -2005466736,
    DPERR_CANCELLED = -2005466726,
    DPERR_ABORTED = -2005466716,
    DPERR_BUFFERTOOLARGE = -2005466136,
    DPERR_CANTCREATEPROCESS = -2005466126,
    DPERR_APPNOTSTARTED = -2005466116,
    DPERR_INVALIDINTERFACE = -2005466106,
    //DPERR_NOSERVICEPROVIDER = -2005466096,
    DPERR_UNKNOWNAPPLICATION = -2005466086,
    DPERR_NOTLOBBIED = -2005466066,
    //DPERR_SERVICEPROVIDERLOADED = -2005466056,
    //DPERR_ALREADYREGISTERED = -2005466046,
    //DPERR_NOTREGISTERED = -2005466036,
    DPERR_AUTHENTICATIONFAILED = -2005465136,
    DPERR_CANTLOADSSPI = -2005465126,
    DPERR_ENCRYPTIONFAILED = -2005465116,
    DPERR_SIGNFAILED = -2005465106,
    DPERR_CANTLOADSECURITYPACKAGE = -2005465096,
    DPERR_ENCRYPTIONNOTSUPPORTED = -2005465086,
    DPERR_CANTLOADCAPI = -2005465076,
    DPERR_NOTLOGGEDIN = -2005465066,
    DPERR_LOGONDENIED = -2005465056,
	//E_NO_AUTHENTICATING_AUTHORITY=0x80090311,
} DPLAYERR;

typedef enum CONST_DINPUTERR{
    DI_OK = 0,
    
	  DI_BUFFEROVERFLOW = 0x80040260,
	//DI_NOTATTACHED = 1,
    //DI_BUFFEROVERFLOW = 1,
    //DI_PROPNOEFFECT = 1,
    //DI_NOEFFECT = 1,
    //DI_POLLEDDEVICE = 2,
    //DI_DOWNLOADSKIPPED = 3,
    //DI_EFFECTRESTARTED = 4,
    //DI_TRUNCATED = 8,
    //DI_TRUNCATEDANDRESTARTED = 12,
	DIERR_INVALIDHANDLE			= 0x80070006,
    DIERR_OLDDIRECTINPUTVERSION = 0x8007047E,
	DIERR_BETADIRECTINPUTVERSION = 0x80070481,
	DIERR_BADDRIVERVER = 0x80070077,
    DIERR_DEVICENOTREG = 0x80040154,
	DIERR_NOTFOUND = 0x80070002,
    DIERR_OBJECTNOTFOUND = 0x80070002,
    DIERR_INVALIDPARAM = 5, //0x80070057,    
	DIERR_NOINTERFACE =430,// 0x80004002,    
	DIERR_GENERIC =  0x80004005,
    DIERR_OUTOFMEMORY = 7, //0x8007000E,    
    DIERR_UNSUPPORTED = 445 ,//0x80004001,
	DIERR_NOTINITIALIZED = 0x80070015,    
	DIERR_ALREADYINITIALIZED = 0x800704DF,
    
    
    DIERR_INPUTLOST = 0x8007001E,
    DIERR_ACQUIRED = 0x800700AA,
	DIERR_NOTACQUIRED = 0x8007000C,

	DIERR_NOAGGREGATION = 0x80004002,
    DIERR_OTHERAPPHASPRIO = 0x80070005,
    DIERR_READONLY = 0x80070005,
    DIERR_HANDLEEXISTS = 0x80070005,
    E_PENDING = 0x80070007,
    DIERR_INSUFFICIENTPRIVS = 0x80040200,
    DIERR_DEVICEFULL = 0x80040201,
    DIERR_MOREDATA = 0x80040202,
    DIERR_NOTDOWNLOADED = 0x80040203,
    DIERR_HASEFFECTS = 0x80040204,
    DIERR_NOTEXCLUSIVEACQUIRED = 0x80040205,
    DIERR_INCOMPLETEEFFECT = 0x80040206,
    DIERR_NOTBUFFERED = 0x80040207,
    DIERR_EFFECTPLAYING = 0x80040208


} DINPUTERR;

typedef enum CONST_D3DRMERR {
    D3DRM_OK = 0,
    D3DRMERR_BADOBJECT = -2005531891,
    D3DRMERR_BADTYPE = -2005531890,
    D3DRMERR_BADALLOC = -2005531889,
    D3DRMERR_FACEUSED = -2005531888,
    D3DRMERR_NOTFOUND = -2005531887,
    D3DRMERR_NOTDONEYET = -2005531886,
    D3DRMERR_FILENOTFOUND = -2005531885,
    D3DRMERR_BADFILE = -2005531884,
    D3DRMERR_BADDEVICE = -2005531883,
    D3DRMERR_BADVALUE = -2005531882,
    D3DRMERR_BADMAJORVERSION = -2005531881,
    D3DRMERR_BADMINORVERSION = -2005531880,
    D3DRMERR_UNABLETOEXECUTE = -2005531879,
    D3DRMERR_LIBRARYNOTFOUND = -2005531878,
    D3DRMERR_INVALIDLIBRARY = -2005531877,
    D3DRMERR_PENDING = -2005531876,
    D3DRMERR_NOTENOUGHDATA = -2005531875,
    D3DRMERR_REQUESTTOOLARGE = -2005531874,
    D3DRMERR_REQUESTTOOSMALL = -2005531873,
    D3DRMERR_CONNECTIONLOST = -2005531872,
    D3DRMERR_LOADABORTED = -2005531871,
    D3DRMERR_NOINTERNET = -2005531870,
    D3DRMERR_BADCACHEFILE = -2005531869,
    D3DRMERR_BOXNOTSET = -2005531868,
    D3DRMERR_BADPMDATA = -2005531867,
    D3DRMERR_CLIENTNOTREGISTERED = -2005531866,
    D3DRMERR_NOTCREATEDFROMDDS = -2005531865,
    D3DRMERR_NOSUCHKEY = -2005531864,
    D3DRMERR_INCOMPATABLEKEY = -2005531863,
    D3DRMERR_ELEMENTINUSE = -2005531862,
    D3DRMERR_TEXTUREFORMATNOTFOUND = -2005531861,
    D3DRMERR_NOTAGGREGATED = -2005531860
} D3DRMERR;

typedef enum CONST_DICOMMONDATAFORMATS
{
	DIFORMAT_KEYBOARD=1,
	DIFORMAT_MOUSE=2,
	DIFORMAT_JOYSTICK=3,
	DIFORMAT_JOYSTICK2=4

} DICOMMONDATAFORMATS;


typedef enum CONST_D3DVERTEXCOMPONENT {
    D3DVERTCOMP_POSITION =1,
    D3DVERTCOMP_NORMAL   =2,
    D3DVERTCOMP_DIFFUSE  =3,
    D3DVERTCOMP_SPECULAR =4,
    D3DVERTCOMP_TEXTURE1 =5,
    D3DVERTCOMP_TEXTURE2 =6,
    D3DVERTCOMP_TEXTURE3 =7,
    D3DVERTCOMP_TEXTURE4 =8,
    D3DVERTCOMP_TEXTURE5 =9,
    D3DVERTCOMP_TEXTURE6 =10,
    D3DVERTCOMP_TEXTURE7 =11,
    D3DVERTCOMP_TEXTURE8 =12
} D3DVERTEXCOMPONENT;

typedef enum CONST_D3DMATERIALCOLORSOURCE
{
	D3DMCS_MATERIAL=0,
	D3DMCS_COLOR1=1,
	D3DMCS_COLOR2=2
} CONST_D3DMATERIALCOLORSOURCE;


#if 0
typedef enum CONST_DDALPHACAPSFLAGS 
{

	DDALPHACAPS_BLTALPHAPIXELS	=	0x00000001,
	DDALPHACAPS_BLTSATURATE 	=	0x00000002,
	DDALPHACAPS_BLTPREMULT 		=	0x00000004,
	DDALPHACAPS_BLTNONPREMULT 	=	0x00000008,
	DDALPHACAPS_BLTARGBSCALE1F 	=	0x00000010,
	DDALPHACAPS_BLTARGBSCALE2F 	=	0x00000020,
	DDALPHACAPS_BLTARGBSCALE4F 	=	0x00000040,
	DDALPHACAPS_BLTALPHAFILL 	=	0x00000080,
	DDALPHACAPS_BLTALPHAANDARGBSCALING=	0x00000100,
	DDALPHACAPS_OVERLAYALPHAPIXELS	  =	0x00010000,
	DDALPHACAPS_OVERLAYSATURATE 	  =	0x00020000,
	DDALPHACAPS_OVERLAYPREMULT 		  =	0x00040000,
	DDALPHACAPS_OVERLAYNONPREMULT 	  =	0x00080000,
	DDALPHACAPS_OVERLAYARGBSCALE1F 	  =	0x00100000,
	DDALPHACAPS_OVERLAYARGBSCALE2F 	  =	0x00200000,
	DDALPHACAPS_OVERLAYARGBSCALE4F 	  =	0x00400000,
	DDALPHACAPS_OVERLAYALPHAANDKEYDEST     = 0x00800000,
	DDALPHACAPS_OVERLAYALPHAANDARGBSCALING = 0x01000000

} CONST_DDALPHACAPSFLAGS;
#endif

#if 0
typedef enum CONST_DDFILTCAPSFLAGS 
{
	DDFILTCAPS_BLTQUALITYFILTER 		=0x00000001,
	DDFILTCAPS_BLTCANDISABLEFILTER 		=0x00000002,
	DDFILTCAPS_BLTTRANSPBORDER 			=0x00000004

} CONST_DDFILTCAPSFLAGS;
#endif 


typedef enum  CONST_DMUS
{ 
    DMUS_MAXSUBCHORD=8,
    DMUS_TEMPO_MAX  =350,
    DMUS_TEMPO_MIN  = 10
//    DMUSB_LOADED =0,	not needed according to a-perterd
//    DMUSB_DEFAULT =2,
} CONST_DMUS;

typedef enum  CONST_DMUS_CURVES
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
} CONST_DMUS_CURVES;

typedef enum CONST_DMUS_CURVET 
{
    DMUS_CURVET_PBCURVE     = 0x03,
    DMUS_CURVET_CCCURVE     = 0x04,
    DMUS_CURVET_MATCURVE    = 0x05,
    DMUS_CURVET_PATCURVE    = 0x06
} CONST_DMUS_CURVET;

/* The following correspond to GUID_NOTIFICATION_SEGMENT */


typedef enum CONST_DMUS_NOTIFICATION_SUBTYPE
{
	DMUS_NOTIFICATION_MUSICSTARTED  =0,
	DMUS_NOTIFICATION_MUSICSTOPPED  =1,
	DMUS_NOTIFICATION_MEASUREBEAT   =0,
	DMUS_NOTIFICATION_CHORD         =0,
	DMUS_NOTIFICATION_GROOVE        =0,
	DMUS_NOTIFICATION_EMBELLISHMENT =1,
	DMUS_NOTIFICATION_SEGSTART      =0,
	DMUS_NOTIFICATION_SEGEND        =1,
	DMUS_NOTIFICATION_SEGALMOSTEND  =2,
	DMUS_NOTIFICATION_SEGLOOP       =3,
	DMUS_NOTIFICATION_SEGABORT      =4	
} CONST_DMUS_NOTIFICATION_SUBTYPE;


typedef enum CONST_DMUS_COMMANDT_TYPES
{
    DMUS_COMMANDT_GROOVE            = 0,
    DMUS_COMMANDT_FILL              = 1,
    DMUS_COMMANDT_INTRO             = 2,
    DMUS_COMMANDT_BREAK             = 3,
    DMUS_COMMANDT_END               = 4,
    DMUS_COMMANDT_ENDANDINTRO       = 5
} CONST_DMUS_COMMANDT_TYPES;

typedef enum CONST_DMUS_SHAPET_TYPES
{
    DMUS_SHAPET_FALLING             = 0,
    DMUS_SHAPET_LEVEL               = 1,
    DMUS_SHAPET_LOOPABLE            = 2,
    DMUS_SHAPET_LOUD                = 3,
    DMUS_SHAPET_QUIET               = 4,
    DMUS_SHAPET_PEAKING             = 5,
    DMUS_SHAPET_RANDOM              = 6,
    DMUS_SHAPET_RISING              = 7,
    DMUS_SHAPET_SONG                = 8
}   CONST_DMUS_SHAPET_TYPES;

typedef enum CONST_DMUS_COMPOSEF_FLAGS
{       
    DMUS_COMPOSEF_NONE              = 0,
    DMUS_COMPOSEF_ALIGN             = 0x1,
    DMUS_COMPOSEF_OVERLAP           = 0x2,
    DMUS_COMPOSEF_IMMEDIATE         = 0x4,
    DMUS_COMPOSEF_GRID              = 0x8,
    DMUS_COMPOSEF_BEAT              = 0x10,
    DMUS_COMPOSEF_MEASURE           = 0x20,
    DMUS_COMPOSEF_AFTERPREPARETIME  = 0x40,
    DMUS_COMPOSEF_MODULATE          = 0x1000,
    DMUS_COMPOSEF_LONG              = 0x2000
}   CONST_DMUS_COMPOSEF_FLAGS;

typedef enum CONST_DMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 16,     /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 32      /* if PMSG is being flushed */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} CONST_DMUS_PMSGF_FLAGS;

#if 0
// NOT NEEDED
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_USER             = 255     /* User message */
} CONST_DMUS_PMSGT_TYPES;
#endif 

typedef enum CONST_DMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 64,     /* time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 128,    /* secondary segment */
    DMUS_SEGF_QUEUE             = 256,    /* queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 512,    /* play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 0x400,  /* play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 0x800,  /* play on grid boundary */
    DMUS_SEGF_BEAT              = 0x1000,  /* play on beat boundary */
    DMUS_SEGF_MEASURE           = 0x2000,  /* play on measure boundary */
    DMUS_SEGF_DEFAULT           = 0x4000,  /* use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 0x8000   /* play without invalidating the currently playing segment(s) */
} CONST_DMUS_SEGF_FLAGS;

#if 0 
//NOT NEEDED
typedef enum enumDMUS_TRACKF_FLAGS
{
    DMUS_TRACKF_SEEK            = 1,      /* set on a seek */
    DMUS_TRACKF_LOOP            = 2,      /* set on a loop (repeat) */
    DMUS_TRACKF_START           = 4,      /* set on first call to Play */
    DMUS_TRACKF_FLUSH           = 8,      /* set when this call is in response to a flush on the perfomance */
    DMUS_TRACKF_DIRTY           = 16,     /* set when the track should consider any cached values from a previous call to GetParam to be invalidated */
} CONST_DMUS_TRACKF_FLAGS;
#endif

typedef enum CONST_DMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,     /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
} CONST_DMUS_NOTEF_FLAGS;


typedef enum CONST_DMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */

    //derived flags
    DMUS_PLAYMODE_FIXED             =0,  
    DMUS_PLAYMODE_FIXEDTOKEY        =1,
    DMUS_PLAYMODE_FIXEDTOCHORD      =2,
    DMUS_PLAYMODE_PEDALPOINT        =5,
    DMUS_PLAYMODE_MELODIC           =6,
    DMUS_PLAYMODE_NORMALCHORD       =10,
    DMUS_PLAYMODE_ALWAYSPLAY        =14 ,
    //DMUS_PLAYMODE_PURPLEIZED        =14,
    //DMUS_PLAYMODE_SCALE_ROOT        =1,
    //DMUS_PLAYMODE_FIXEDTOSCALE      =1,
} CONST_DMUS_PLAYMODE_FLAGS;

typedef enum CONST_DMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,           /* Set if the curve needs to be reset. */
} CONST_DMUS_CURVE_FLAGS;




typedef enum CONST_DMUSERR {

	//DMUS_S_PARTIALLOAD        =0x08781091,
	//DMUS_S_REQUEUE            =0x08781200,
    //DMUS_S_FREE=                      0x08781201,
	//DMUS_S_END                     =0x08781202,
	//DMUS_S_STRING_TRUNCATED        =0x08781210,
	//DMUS_S_LAST_TOOL               =0x08781211,
	//DMUS_S_OVER_CHORD              =0x08781212,
	//DMUS_S_UP_OCTAVE               =0x08781213,
	//DMUS_S_DOWN_OCTAVE             =0x08781214,
	DMUS_E_DRIVER_FAILED            =0x88781101,
	DMUS_E_PORTS_OPEN               =0x88781102,
	DMUS_E_DEVICE_IN_USE            =0x88781103,
	DMUS_E_INSUFFICIENTBUFFER       =0x88781104,
	DMUS_E_BUFFERNOTSET             =0x88781105,
	DMUS_E_BUFFERNOTAVAILABLE       =0x88781106,
	DMUS_E_NOTADLSCOL               =0x88781108,
	DMUS_E_INVALIDOFFSET            =0x88781109,
	DMUS_E_ALREADY_LOADED           =0x88781111,
	DMUS_E_INVALIDPOS               =0x88781113,
	DMUS_E_INVALIDPATCH             =0x88781114,
	DMUS_E_CANNOTSEEK               =0x88781115,
	DMUS_E_CANNOTWRITE              =0x88781116,
	DMUS_E_CHUNKNOTFOUND            =0x88781117,
	DMUS_E_INVALID_DOWNLOADID       =0x88781119,
	DMUS_E_NOT_DOWNLOADED_TO_PORT   =0x88781120,
	DMUS_E_ALREADY_DOWNLOADED       =0x88781121,
	DMUS_E_UNKNOWN_PROPERTY         =0x88781122,
	DMUS_E_SET_UNSUPPORTED          =0x88781123,
	DMUS_E_GET_UNSUPPORTED          =0x88781124,
	DMUS_E_NOTMONO                  =0x88781125,
	DMUS_E_BADARTICULATION          =0x88781126,
	DMUS_E_BADINSTRUMENT            =0x88781127,
	DMUS_E_BADWAVELINK              =0x88781128,
	DMUS_E_NOARTICULATION           =0x88781129,
	DMUS_E_NOTPCM                   =0x8878112A,
	DMUS_E_BADWAVE                  =0x8878112B,
	DMUS_E_BADOFFSETTABLE           =0x8878112C,
	DMUS_E_UNKNOWNDOWNLOAD          =0x8878112D,
	DMUS_E_NOSYNTHSINK              =0x8878112E,
	DMUS_E_ALREADYOPEN              =0x8878112F,
	DMUS_E_ALREADYCLOSED            =0x88781130,
	DMUS_E_SYNTHNOTCONFIGURED       =0x88781131,
	DMUS_E_SYNTHACTIVE              =0x88781132,
	DMUS_E_CANNOTREAD               =0x88781133,
	DMUS_E_DMUSIC_RELEASED          =0x88781134,
	DMUS_E_BUFFER_EMPTY             =0x88781135,
	DMUS_E_BUFFER_FULL              =0x88781136,
	DMUS_E_PORT_NOT_CAPTURE         =0x88781137,
	DMUS_E_PORT_NOT_RENDER          =0x88781138,
	DMUS_E_DSOUND_NOT_SET           =0x88781139,
	DMUS_E_ALREADY_ACTIVATED        =0x8878113A,
	DMUS_E_INVALIDBUFFER            =0x8878113B,
	DMUS_E_WAVEFORMATNOTSUPPORTED   =0x8878113C,
	DMUS_E_SYNTHINACTIVE            =0x8878113D,
	DMUS_E_DSOUND_ALREADY_SET       =0x8878113E,
	DMUS_E_INVALID_EVENT            =0x8878113F,
	DMUS_E_UNSUPPORTED_STREAM       =0x88781150,
	DMUS_E_ALREADY_INITED           =0x88781151,
	DMUS_E_INVALID_BAND             =0x88781152,
	DMUS_E_TRACK_HDR_NOT_FIRST_CK   =0x88781155,
	DMUS_E_TOOL_HDR_NOT_FIRST_CK    =0x88781156,
	DMUS_E_INVALID_TRACK_HDR        =0x88781157,
	DMUS_E_INVALID_TOOL_HDR         =0x88781158,
	DMUS_E_ALL_TOOLS_FAILED         =0x88781159,
	DMUS_E_ALL_TRACKS_FAILED        =0x88781160,
	DMUS_E_NOT_FOUND                =0x88781161,
	DMUS_E_NOT_INIT                 =0x88781162,
	DMUS_E_TYPE_DISABLED            =0x88781163,
	DMUS_E_TYPE_UNSUPPORTED         =0x88781164,
	DMUS_E_TIME_PAST                =0x88781165,
	DMUS_E_TRACK_NOT_FOUND			=0x88781166,
	DMUS_E_NO_MASTER_CLOCK          =0x88781170,
	DMUS_E_LOADER_NOCLASSID         =0x88781180,
	DMUS_E_LOADER_BADPATH           =0x88781181,
	DMUS_E_LOADER_FAILEDOPEN        =0x88781182,
	DMUS_E_LOADER_FORMATNOTSUPPORTED    =0x88781183,
	DMUS_E_LOADER_FAILEDCREATE      =0x88781184,
	DMUS_E_LOADER_OBJECTNOTFOUND    =0x88781185,
	DMUS_E_LOADER_NOFILENAME	    =0x88781186,
	DMUS_E_INVALIDFILE              =0x88781200,
	DMUS_E_ALREADY_EXISTS           =0x88781201,
	DMUS_E_OUT_OF_RANGE             =0x88781202,
	DMUS_E_SEGMENT_INIT_FAILED      =0x88781203,
	DMUS_E_ALREADY_SENT             =0x88781204,
	DMUS_E_CANNOT_FREE              =0x88781205,
	DMUS_E_CANNOT_OPEN_PORT         =0x88781206,
	DMUS_E_CONNOT_CONVERT           =0x88781207,
	DMUS_E_DESCEND_CHUNK_FAIL       =0x88781210,
	DMUS_E_FAIL							=0x80070057,
	DMUS_E_INVALIDARG							=5,
	DMUS_E_NOINTERFACE					=430,
	DMUS_E_OUTOFMEMORY					=7,
	DMUS_E_NOTIMPL						=445
} DMUSERR;


/* For DMUS_PORTCAPS dwClass
 */ 
typedef enum CONST_DMUS_PC_CLASS{
	DMUS_PC_INPUTCLASS       =0,
	DMUS_PC_OUTPUTCLASS      =1,
} CONST_DMUS_PC_CLASS;

/* For DMUS_PORTCAPS dwFlags
 */
typedef enum CONST_DMUS_PC_FLAGS{
DMUS_PC_DLS              =0x00000001,
DMUS_PC_EXTERNAL         =0x00000002,
DMUS_PC_SOFTWARESYNTH    =0x00000004,
DMUS_PC_MEMORYSIZEFIXED  =0x00000008,
DMUS_PC_GMINHARDWARE     =0x00000010,
DMUS_PC_GSINHARDWARE     =0x00000020,
DMUS_PC_XGINHARDWARE     =0x00000040,
DMUS_PC_DIRECTSOUND      =0x00000080,
DMUS_PC_SHAREABLE        =0x00000100,
DMUS_PC_SYSTEMMEMORY     =0x7FFFFFFF
} CONST_DMUS_PC_FLAGS;

typedef enum CONST_DMUS_PORT_TYPE {
	DMUS_PORT_WINMM_DRIVER      =0,
	DMUS_PORT_USER_MODE_SYNTH   =1,
	DMUS_PORT_KERNEL_MODE       =2
} CONST_DMUS_PORT_TYPE;

typedef enum CONST_DMUS_PORTPARAMS_FLAGS {
	DMUS_PORTPARAMS_VOICES           =0x00000001,
	DMUS_PORTPARAMS_CHANNELGROUPS    =0x00000002,
	DMUS_PORTPARAMS_AUDIOCHANNELS    =0x00000004,
	DMUS_PORTPARAMS_SAMPLERATE       =0x00000008,
	DMUS_PORTPARAMS_EFFECTS          =0x00000020,
	DMUS_PORTPARAMS_SHARE            =0x00000040
} CONST_DMUS_PORTPARAMS_FLAGS;

typedef enum CONST_DIMOUSEOFS {
	DIMOFS_X        =0,
	DIMOFS_Y        =4,
	DIMOFS_Z        =8,
	DIMOFS_BUTTON0 =12,
	DIMOFS_BUTTON1 =13,
	DIMOFS_BUTTON2 =14,
	DIMOFS_BUTTON3 =15
}  CONST_DIMOUSEOFS;

typedef enum CONST_DIJOYSTICKOFS {
 DIJOFS_X            =0,
 DIJOFS_Y            =4,
 DIJOFS_Z            =8,
 DIJOFS_RX           =12,
 DIJOFS_RY           =16,
 DIJOFS_RZ           =20,
 DIJOFS_SLIDER0	     =24,
 DIJOFS_SLIDER1      =28,                                                     
 DIJOFS_POV0		 =32,
 DIJOFS_POV1		 =36,
 DIJOFS_POV2		 =40,
 DIJOFS_POV3		 =44,
 DIJOFS_BUTTON0      =48,
 DIJOFS_BUTTON1      =49,
 DIJOFS_BUTTON2      =50,
 DIJOFS_BUTTON3      =51,
 DIJOFS_BUTTON4      =52,
 DIJOFS_BUTTON5      =53,
 DIJOFS_BUTTON6      =54,
 DIJOFS_BUTTON7      =55,
 DIJOFS_BUTTON8      =56,
 DIJOFS_BUTTON9      =57,
 DIJOFS_BUTTON10     =58,
 DIJOFS_BUTTON11     =59,
 DIJOFS_BUTTON12     =60,
 DIJOFS_BUTTON13     =61,
 DIJOFS_BUTTON14     =62,
 DIJOFS_BUTTON15     =63,
 DIJOFS_BUTTON16     =64,
 DIJOFS_BUTTON17     =65,
 DIJOFS_BUTTON18     =66,
 DIJOFS_BUTTON19     =67,
 DIJOFS_BUTTON20     =68,
 DIJOFS_BUTTON21     =69,
 DIJOFS_BUTTON22     =70,
 DIJOFS_BUTTON23     =71,
 DIJOFS_BUTTON24     =72,
 DIJOFS_BUTTON25     =73,
 DIJOFS_BUTTON26     =74,
 DIJOFS_BUTTON27     =75,
 DIJOFS_BUTTON28     =76,
 DIJOFS_BUTTON29     =77,
 DIJOFS_BUTTON30     =78,
 DIJOFS_BUTTON31     =79
} CONST_DIJOYSTICKOFS;

typedef enum CONST_DIEFTFLAGS {
	DIEFT_ALL                 =  0x00000000,
	DIEFT_CONSTANTFORCE       =  0x00000001,
	DIEFT_RAMPFORCE           =  0x00000002,
	DIEFT_PERIODIC            =  0x00000003,
	DIEFT_CONDITION           =  0x00000004,
	DIEFT_CUSTOMFORCE         =  0x00000005,
	DIEFT_HARDWARE            =  0x000000FF,
	DIEFT_FFATTACK            =  0x00000200,
	DIEFT_FFFADE              =  0x00000400,
	DIEFT_SATURATION          =  0x00000800,
	DIEFT_POSNEGCOEFFICIENTS  =  0x00001000,
	DIEFT_POSNEGSATURATION    =  0x00002000,
	DIEFT_DEADBAND            =  0x00004000
} DIEFTFLAGS;


//	DI_DEGREES                =  100,
//	DI_FFNOMINALMAX           =  10000,
//	DI_SECONDS                =  1000000,

typedef enum CONST_DIEFFFLAGS {

	//DIEFF_OBJECTIDS           =  0x00000001,
	DIEFF_OBJECTOFFSETS       =  0x00000002,
	DIEFF_CARTESIAN           =  0x00000010,
	DIEFF_POLAR               =  0x00000020
	//DIEFF_SPHERICAL           =  0x00000040,
} DIEFFFLAGS;

typedef enum CONST_DIEPFLAGS {

	DIEP_DURATION             =  0x00000001,
	DIEP_SAMPLEPERIOD         =  0x00000002,
	DIEP_GAIN                 =  0x00000004,
	DIEP_TRIGGERBUTTON        =  0x00000008,
	DIEP_TRIGGERREPEATINTERVAL=  0x00000010,
	DIEP_AXES                =   0x00000020,
	DIEP_DIRECTION           =   0x00000040,
	DIEP_ENVELOPE            =   0x00000080,
	DIEP_TYPESPECIFICPARAMS  =   0x00000100,
	DIEP_ALLPARAMS       =       0x000001FF,
	DIEP_START           =       0x20000000,
	DIEP_NORESTART       =       0x40000000,
	DIEP_NODOWNLOAD      =       0x80000000,
} DIEPFLAGS;


typedef enum CONST_DIEGESFLAGS {
	DIEGES_PLAYING       =       0x00000001,
	DIEGES_EMULATED      =       0x00000002
} DIEGESFLAGS;


	

typedef enum CONST_DIESFLAGS {
	DIES_SOLO            =       0x00000001,
	DIES_NODOWNLOAD      =       0x80000000
} DIESFLAGS;
	

typedef enum CONST_DISFFCFLAGS {
	DISFFC_RESET        =    0x00000001,
	DISFFC_STOPALL      =    0x00000002,
	DISFFC_PAUSE        =    0x00000004,
	DISFFC_CONTINUE     =    0x00000008,
	DISFFC_SETACTUATORSON  = 0x00000010,
	DISFFC_SETACTUATORSOFF = 0x00000020,
} DISFFCFLAGS;

typedef enum CONST_DIGFFSFLAGS {
	DIGFFS_EMPTY        =    0x00000001,
	DIGFFS_STOPPED      =    0x00000002,
	DIGFFS_PAUSED       =    0x00000004,
	DIGFFS_ACTUATORSON  =    0x00000010,
	DIGFFS_ACTUATORSOFF =    0x00000020,
	DIGFFS_POWERON      =    0x00000040,
	DIGFFS_POWEROFF     =    0x00000080,
	DIGFFS_SAFETYSWITCHON =  0x00000100,
	DIGFFS_SAFETYSWITCHOFF = 0x00000200,
	DIGFFS_USERFFSWITCHON  = 0x00000400,
	DIGFFS_USERFFSWITCHOFF = 0x00000800,
	DIGFFS_DEVICELOST      = 0x80000000
} DIGFFSFLAGS;

typedef enum CONST_DISDDFLAGS {
        DISDD_DEFAULT  =0,
        DISDD_CONTINUE = 1
} DISDDFLAGS;


typedef enum CONST_DMUS_EFFECT_FLAGS {
	DMUS_EFFECT_NONE=0,
	DMUS_EFFECT_REVERB=1,
	DMUS_EFFECT_CHORUS=2
} CONST_DMUS_EFFECT_FLAGS;



typedef enum CONST_D3DDEVINFOID  {
   D3DDEVINFOID_D3DTEXTUREMANAGER = 2,
   D3DDEVINFOID_TEXTUREMANAGER = 1,
   D3DDEVINFOID_TEXTURING = 3
} D3DDEVINFOID;

typedef  enum CONST_DDOVERFXFLAGS {
	DDOVERFX_ARITHSTRETCHY  = 1,
	DDOVERFX_MIRRORLEFTRIGHT  =2,
	DDOVERFX_MIRRORUPDOWN =4
} DDOVERFXFLAGS;

typedef enum CONST_D3DRMSHADOWFLAGS {		
	D3DRMSHADOW_TRUEALPHA=1
} D3DRMSHADOWFLAGS;

typedef enum CONST_DICONDITIONFLAGS {		
	DICONDITION_USE_BOTH_AXES=1,
	DICONDITION_USE_DIRECTION =2
} DICONDITIONFLAGS;

typedef enum CONST_D3DSTATEBLOCKTYPE{
    D3DSBT_ALL           = 1, 
    D3DSBT_PIXELSTATE    = 2, 
    D3DSBT_VERTEXSTATE   = 3, 
} D3DSTATEBLOCKTYPE;

typedef enum  CONST_D3DCLIPPLANEFLAGS {
    D3DCPF_DISABLEALL = 0,
    D3DCPF_ENABLEPLANE0 = 1,
    D3DCPF_ENABLEPLANE1 = 2,
    D3DCPF_ENABLEPLANE2 = 4,
    D3DCPF_ENABLEPLANE3 = 8,
    D3DCPF_ENABLEPLANE4 = 16,
    D3DCPF_ENABLEPLANE5 = 32,
    D3DCPF_ENABLEPLANE6 = 64,
    D3DCPF_ENABLEPLANE7 = 128,
	D3DCPF_ENABLEPLANE8 = 256,
	D3DCPF_ENABLEPLANE9 = 512,
	D3DCPF_ENABLEPLANE10 = 1024,
	D3DCPF_ENABLEPLANE11 = 2048,
	D3DCPF_ENABLEPLANE12 = 4096,
	D3DCPF_ENABLEPLANE13 = 8192,
	D3DCPF_ENABLEPLANE14 = 16384,
	D3DCPF_ENABLEPLANE15 = 32768,
	D3DCPF_ENABLEPLANE16 = 0x10000,
	D3DCPF_ENABLEPLANE17 = 0x20000,
	D3DCPF_ENABLEPLANE18 = 0x40000,
	D3DCPF_ENABLEPLANE19 = 0x80000,
	D3DCPF_ENABLEPLANE20 = 0x100000,
	D3DCPF_ENABLEPLANE21 = 0x200000,
	D3DCPF_ENABLEPLANE22 = 0x400000,
	D3DCPF_ENABLEPLANE23 = 0x800000,
	D3DCPF_ENABLEPLANE24 = 0x1000000,
	D3DCPF_ENABLEPLANE25 = 0x2000000,
	D3DCPF_ENABLEPLANE26 = 0x4000000,
	D3DCPF_ENABLEPLANE27 = 0x8000000,
	D3DCPF_ENABLEPLANE28 = 0x10000000,
	D3DCPF_ENABLEPLANE29 = 0x20000000,
	D3DCPF_ENABLEPLANE30 = 0x40000000,
	D3DCPF_ENABLEPLANE31 = 0x80000000,

 } D3DCLIPPLANEFLAGS;
