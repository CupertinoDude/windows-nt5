/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       namesrv.c
 *  Content:	name management code
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  1/96		andyco	created it
 *	4/15/96		andyco	added handledeadnameserver
 *	6/19/96		kipo	Fixed a problem in GrowTable() with MemReAlloc() returning
 *						NULL, which caused a memory leak and possibly a crash if someone
 *						was not expecting this->pNameTable to ever be NULL.
 *	6/22/96		andyco	indicate whether we're asking for player or group id
 *						in sendnsnewidrequest.
 *	8/1/96		andyco	changed dp_destroyplayer to internaldestroy
 *	8/6/96		andyco	version in commands.  extensible on the wire support. 
 *						id mangling.
 *	8/8/96		andyco	 get playerid timeout from sp (by calling getdefaultimeout).
 *	10/9/96		andyco	got rid of race condition in handlereply by adding
 *						gbWaitingForReply
 *	10/14/96	andyco	check nametable index BEFORE using it...bug 3946
 *	12/18/96	andyco	moved bogus assert on additemtonametable 
 *  01/17/97    sohailm now we send player flags in request player id message
 *	1/15/98		andyco	cleaned up handledeadnameserver - no longer nukes
 *						old sysplayer.
 *  3/14/97     sohailm integrated security code into SendNewIDRequest, 
 *                      added functions IsValidID and DataFromID. Updated function NameFromID
 *                      to use IsValidID.
 *	3/17/97		myronth	Fixed AddItemToNameTable to work from lobby objects
 * 3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 *  3/24/97     sohailm Updated SendCreateMessage call to pass NULL for session password
 *  3/28/97     sohailm Request group id message is being signed now if session is secure
 *  4/14/97     sohailm Updated calls to SetupCredentials() to reflect change in params.
 *	5/8/97		myronth	Fixed comment to better reflect the state of affairs
 *  5/12/97     sohialm Updated SendNSNewIDRequest() to process the new PLAYERIDREPLY format
 *	5/17/97		kipo	There was a bug in SendNSNewIDRequest() where it was setting
 *						the ghReplyProcessed event twice on the way out,
 *						which would let handler.c in, trashing the buffer
 *						that SendNSNewIDRequest() was using.
  *	5/18/97		andyco	changed nameserver migration to always send delete / create messages
 *						for new host. nuke item in table if  we add something new
 *						to non-empty spot.
 *	6/16/97		andyco	reset ping timer when we become host
 *  6/22/97     sohailm added support to store security desc in the dplay object on the client
 *	8/19/97		myronth	Send lobby system message when we become the host
 *	8/19/97		myronth	Changed to different lobby system message function
 *	9/29/97		myronth	Fixed group ID on DeleteGroup msgs generated by the
 *						corrupt nametable fixup code (#12533)
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	12/29/97	myronth	Nametable corruption fixes (#15234, #15254)
 *	12/29/97	sohailm	Don't migrate the host in client server or secure sessions (#15224)
 *	1/5/97		myronth	Fixed error paths for client/server (#15891)
 *	1/20/98		myronth	Changed PRV_SendStandardSystemMessage
 *	1/27/98		myronth	Moved debug spew for nametable corruption
 *  2/13/98     aarono  Added flag to internal destroy player calls for async
 *  2/18/98     aarono  changed to direct calls to protocol
 *  8/04/99     aarono  added HOSTMIGRATION notification for DirectVoice
 *  8/10/99		rodtoll	Fixed host migration notification (For DXVoice)
 * 04/06/00     rodtoll Updated to match new approach to having only 1 voice server and 1 client attached to object 
 * 08/03/2000	rodtoll	Bug #41475 - Leave locks before calling notification
 ***************************************************************************/


#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"NS_AllocNameTableEntry"


HRESULT GrowTable(LPDPLAYI_DPLAY this) 
{
	LPVOID	pvTempNameTable;

    pvTempNameTable = DPMEM_REALLOC(this->pNameTable,sizeof(NAMETABLE)*this->uiNameTableSize*2);
    if (!pvTempNameTable) 
    {
    	DPF_ERR("COULD NOT GROW NAME TABLE");	
        return E_OUTOFMEMORY;
    }

    this->pNameTable = pvTempNameTable;
    this->uiNameTableSize *= 2;
    DPF(1,"Grew name table to %d entries\n",this->uiNameTableSize);
    return DP_OK;

}

// this code only executes on the NameServer

DPID MangleID(DWORD index,DWORD dwUnique,DWORD dwKey)
{
	DPID id;

    // construct a mangled id, = dwUnique<<16 | index ^ key
    id = dwUnique<<16;
    id |= index;
   	id ^= dwKey;

	return id;
} // MangleID

HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY this,DWORD * pID)
{
    DWORD index;
    BOOL bFoundSlot=FALSE;
    HRESULT hr = DP_OK;
	BOOL bInvalidID = TRUE; // set to FALSE only when we decide this is not
							// not a restricted id
	
    // find the first unoccupied bucket
    index = this->uiNameTableLastUsed;

    // search fron lastused to end. we do this to keep the
    // bucket usage uniformly distributed in the list (i.e. don't
    // always search from beginning for empty slot...)
    while (!bFoundSlot && (index < this->uiNameTableSize))
    {
        // is this slot empty?
        bFoundSlot = (0 == this->pNameTable[index].dwItem);
        if (!bFoundSlot) index++;
    }
    if (!bFoundSlot) 
    {
        index = 0;
        // search from beginning to last used
        while (!bFoundSlot && (index < this->uiNameTableLastUsed))
        {
            // is this slot empty?
            bFoundSlot = (0 == this->pNameTable[index].dwItem);
            if (!bFoundSlot) index++;
        }
            	
    }
    if (!bFoundSlot) 
    {
    	hr = GrowTable(this);
        if (FAILED(hr)) 
        {
                return hr;
        }
        // try again
    	return NS_AllocNameTableEntry(this,pID);
    }

    // make sure we don't reuse b4 client has time to set item
    this->pNameTable[index].dwItem = NAMETABLE_PENDING;
	this->pNameTable[index].dwUnique++;

    this->uiNameTableLastUsed = index;

    while (bInvalidID)
    {
		// mangle it!
		*pID = MangleID(index,this->pNameTable[index].dwUnique,(DWORD)this->lpsdDesc->dwReserved1);

		// EEEK!  make sure the mangled id is not one of our reserved id's 
		if ( (DPID_SERVERPLAYER == *pID ) || (DPID_ALLPLAYERS == *pID) || 
			(DPID_UNKNOWN == *pID) )
		{
			// bump the unique count, and try again
			DPF(2,"NS_AllocNameTableEntry  --  found invalid id - trying again");
			this->pNameTable[index].dwUnique++;
		}
		else 
		{
			// this id is ok
			bInvalidID = FALSE;
		}
    
    } // while
	
    return DP_OK;
        
} // NS_AllocNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"SendNSNewIDRequest"

/*
 ** CopySecurityDesc
 *
 *  CALLED BY: SendNSNewIDRequest()
 *
 *  PARAMETERS: pSecDescDest - security description ptr (destination)
 *				pSecDescSrc - security descrption ptr (source, UNICODE)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies a security description while allocating memory for SSPIProvider 
 *                and CAPIProvider strings. These strings need to be freed by the calling 
 *                function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopySecurityDesc(LPDPSECURITYDESC pSecDescDest, 
                         LPCDPSECURITYDESC pSecDescSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pSecDescDest && pSecDescSrc);

    memcpy(pSecDescDest, pSecDescSrc, sizeof(DPSECURITYDESC));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pSecDescDest->lpszSSPIProviderA), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pSecDescDest->lpszCAPIProviderA), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pSecDescDest->lpszSSPIProvider), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pSecDescDest->lpszCAPIProvider), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeSecurityDesc(pSecDescDest, bAnsi);
    return hr;
} // CopySecurityDesc

// copies the security desc into the dplay object
HRESULT StoreSecurityDesc(LPDPLAYI_DPLAY this, LPCDPSECURITYDESC pInSecDesc)
{
    LPDPSECURITYDESC pSecDesc;
    HRESULT hr;

    pSecDesc = DPMEM_ALLOC(sizeof(DPSECURITYDESC));
    if (!pSecDesc)
    {
        DPF_ERR("Failed to store security desc - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    hr = CopySecurityDesc(pSecDesc, pInSecDesc, FALSE);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to copy security desc - hr=0x%08x",hr);
        goto ERROR_EXIT;
    }

    DPF(1,"SSPI provider: %ls",pSecDesc->lpszSSPIProvider);
    if (pSecDesc->lpszCAPIProvider)
    {
        DPF(1,"CAPI provider: %ls",pSecDesc->lpszCAPIProvider);
    }
    else
    {
        DPF(1,"CAPI provider: Microsoft's RSA Base Provider");
    }

    // success
    this->pSecurityDesc = pSecDesc;
    return DP_OK;

    // NOT a fall through

ERROR_EXIT:

    if (pSecDesc) 
    {
        FreeSecurityDesc(pSecDesc,FALSE);
        DPMEM_FREE(pSecDesc);
    }
    return hr;
}

// send a request for a new id to the namesrvr
// reply will include the id
// hmm, we should send the player stuff w/ the id request,  so ns doesn't get out of sync
HRESULT SendNSNewIDRequest(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer) 
{
    LPMSG_REQUESTPLAYERID pmsg; // the request we will send
    LPMSG_PLAYERIDREPLY pReply=NULL;
	DWORD dwMessageSize;
    HRESULT hr=DP_OK;
	LPBYTE pBuffer;
	DWORD dwTimeout, dwVersion;
    BOOL fLogin=FALSE;
		
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_REQUESTPLAYERID);
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	pmsg = (LPMSG_REQUESTPLAYERID)(pBuffer + this->dwSPHeaderSize);

	// set up msg
    SET_MESSAGE_HDR(pmsg);
    if (fPlayer) SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTPLAYERID);
	else SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTGROUPID);

    // need to send flags to name server so it can verify permissions
    // before creating an ID for this player
    pmsg->dwFlags = ((LPDPLAYI_PLAYER)dwItem)->dwFlags;
	
	// get the appropriate timeout
	dwTimeout = GetDefaultTimeout( this, TRUE);
	dwTimeout *= DP_GETID_SCALE;

	if(dwTimeout < 30000){
		dwTimeout=30000;
	}

	ASSERT(!(this->dwFlags & DPLAYI_DPLAY_PENDING));

	DPF(2,"sending new player id request :: flags = %d,timeout = %d\n",((LPDPLAYI_GROUP)dwItem)->dwFlags,dwTimeout);

	if(this->pSysPlayer){
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
	}	

	SetupForReply(this, DPSP_MSG_REQUESTPLAYERREPLY);
	
    // call send
	// note that this->pNameServer will be NULL when we're requesting our
	// sysplayers id.  it will be non-null for subsequent requests.
	hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pBuffer,
						dwMessageSize,DPSEND_GUARANTEED,FALSE);

	DPMEM_FREE(pBuffer);
	if (FAILED(hr)) 
	{
		DPF_ERR("could not send newplayerid request");
		UnSetupForReply(this);
		return hr;
	}
	
	#ifdef DEBUG
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	#endif 
	// we're protected by the service crit section here, so we can leave dplay
	// (so reply can be processed)
	LEAVE_DPLAY();

    // wait for the answer
    hr = WaitForReply(this,(PCHAR *)&pReply,NULL,dwTimeout);

	ENTER_DPLAY();

	if(FAILED(hr)){
		goto CLEANUP_EXIT;
	}

	ASSERT(pReply);

    // get the message version
    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReply);

	// In DX6 and later versioned messages, there is a return code in the
	// reply.  We need to make sure it wasn't an error (#15891)
	if(dwVersion >= DPSP_MSG_DX6VERSION)
	{
		// If we fail, 
		if(FAILED(pReply->hr))
		{
			hr = pReply->hr;
			goto CLEANUP_EXIT;
		}
	}

    *pid = pReply->dwID;

    // If server is DX5 or later and is secure, the reply will contain a security 
	// description detailing the security packages needed for establishing a secure channel
	// with the server.
    if (( dwVersion >= DPSP_MSG_DX5VERSION ) && (pReply->dwSSPIProviderOffset))
    {
        // fix up pointers in security desc in the reply buffer        
		pReply->dpSecDesc.lpszSSPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwSSPIProviderOffset);
		if (pReply->dwCAPIProviderOffset)
		{
			pReply->dpSecDesc.lpszCAPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwCAPIProviderOffset);
		}

        hr = StoreSecurityDesc(this, &(pReply->dpSecDesc));
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to store security desc: hr=0x%08x",hr);
            goto CLEANUP_EXIT;
        }

        // we need to login
        fLogin = TRUE;

        // set the system player id here, so authentication routines can use it
    	ASSERT(this->pSysPlayer);
        this->pSysPlayer->dwID = *pid;

		// Initialize SSPI and CAPI providers
		hr = LoadSecurityProviders(this, SSPI_CLIENT);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to setup security providers");

			// let handler.c continue
            goto CLEANUP_EXIT;
        }
    }

    if (fLogin)
    {
        hr = Login(this);
        if (FAILED(hr))
        {
            DPF_ERR("User authentication failed...Exiting");
        }
    }


    DPF(2,"received id # %d from name server\n",*pid);

	if(this->pSysPlayer){
		ExecutePendingCommands(this);
	}	

CLEANUP_EXIT:	
    // done
    if(pReply){
		FreeReplyBuffer((PCHAR)pReply);
	}	
    return hr;

} // SendNSNewIDRequest 
	
#undef DPF_MODNAME
#define DPF_MODNAME	"AddItemToNameTable"

// NukeNameTable (below) is about to nuke a player from our (corrupted) nametable
// this routine puts a delete message for that player in our apps message q
// we build a DPSP_MSG_PLAYERMGMT w/ just enough info for BuildDeleteMessage to 
// do it's thing
void QDeleteMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	
	if (fPlayer)
	{
		DPF(5, "Queueing DESTROYPLAYER message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYER);
		msg.dwPlayerID = pPlayer->dwID;
	}
	else
	{
		DPF(5, "Queueing DESTROYGROUP message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUP);
		msg.dwGroupID = pPlayer->dwID;
	}
	
	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteMessage


void QDeletePlayerFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_PLAYER pPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYERFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pPlayer->dwID;
	
	DPF(5, "Queueing DELETEPLAYERFROMGROUP message idGroupFrom = %lx, idPlayer = %lx", pGroup->dwID, pPlayer->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeletePlayerFromGroupMessage


void QDeleteGroupFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_GROUP pSubgroup)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUPFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pSubgroup->dwID;
	
	DPF(5, "Queueing DELETEGROUPFROMGROUP message idGroupFrom = %lx, idGroup = %lx", pGroup->dwID, pSubgroup->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteGroupFromGroupMessage


void QDeleteAndDestroyMessagesForPlayer(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom)
    {
		// Only walk the list if it's not the system group	
		if(!(pGroupFrom->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			// Next walk the list of players in the group
			pGroupnode = pGroupFrom->pGroupnodes;
			while(pGroupnode)
			{
				if(pGroupnode->pPlayer->dwID == pPlayer->dwID)
				{
					// Queue the DeletePlayerFromGroup message
					QDeletePlayerFromGroupMessage(this, pGroupFrom, pGroupnode->pPlayer);
				}

				// Move to the next one
				pGroupnode = pGroupnode->pNextGroupnode;
			}
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Now queue the final destroy message for the player
	QDeleteMessage(this,pPlayer,TRUE);

} // QDeleteAndDestroyMessagesForPlayer


void QDestroyMessageForGroupAndFamily(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP pGroup)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom && (pGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP))
    {
		// Walk the subgroups for this group and see if the group being
		// destroyed is among them.  If it is, send a message.		
		pSubgroup = pGroupFrom->pSubgroups;
		while(pSubgroup)
		{
			// If the ID's match, send the message, but also
			// make sure we don't send a DeleteGroupFromGroup message for
			// a real parent/child relationship
			if((pSubgroup->pGroup->dwID == pGroup->dwID) &&
				(pGroupFrom->dwID != pGroup->dwIDParent))
			{
				QDeleteGroupFromGroupMessage(this, pGroupFrom, pGroup);
			}

			// Move to the next one
			pSubgroup = pSubgroup->pNextSubgroup;
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Next walk the list of players in the group
    pGroupnode = pGroup->pGroupnodes;
    while (pGroupnode)
    {
		// Queue the DeletePlayerFromGroup message
		QDeletePlayerFromGroupMessage(this, pGroup, pGroupnode->pPlayer);

		// Move to the next one
		pGroupnode = pGroupnode->pNextGroupnode;
	}

	// Next walk the list of subgroups (this includes both childres & shortcuts)
	pSubgroup = pGroup->pSubgroups;
	while(pSubgroup)
	{
		// See if the group is just a shortcut or a real child
		if(!(pSubgroup->dwFlags & DPGROUP_SHORTCUT))
		{
			// It's a real child, so just setup the destroy messages
			// NOTE: This goes recursive right here
			QDestroyMessageForGroupAndFamily(this, pSubgroup->pGroup);
		}
		else
		{
			// It's a shortcut, so just queue the deletegroupfromgroup message
			QDeleteGroupFromGroupMessage(this, pGroup, pSubgroup->pGroup);
		}

		// Move to the next one
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	// Now queue the destroy message for the group itself
	QDeleteMessage(this,(LPDPLAYI_PLAYER)pGroup,FALSE);

} // QDestroyMessageForGroupAndFamily


void NukeNameTableItem(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	HRESULT hr;
	BOOL fPlayer;
	LPDPLAYI_GROUP pGroup;
	

    TRY
    {
		if (VALID_DPLAY_PLAYER(pPlayer)) fPlayer = TRUE;
		else 
		{
			pGroup = (LPDPLAYI_GROUP)pPlayer;
			if (!VALID_DPLAY_GROUP(pGroup))
			{
				DPF_ERR("found item in nametable - it's not a player or a group - AAAAGH - it's a creepy monster");
				return;
			}
		 	fPlayer = FALSE;
		}
		DPF(0," invalid item found - fPlayer = %d  id = %lx\n",fPlayer,pPlayer->dwID);		
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		ASSERT(FALSE); // ACK!
		return ;
    }

	// now, delete it!	
	if (fPlayer)
	{
		// put a  mesage in the apps message q that the player is being deleted
		QDeleteAndDestroyMessagesForPlayer(this,pPlayer);

		// destroy the player
		hr = InternalDestroyPlayer(this,pPlayer,FALSE,FALSE);	
	}
	else
	{
		// put messages in the apps message q that the group and all it's
		// children (and shortcuts) are being destroyed
		QDestroyMessageForGroupAndFamily(this, (LPDPLAYI_GROUP)pPlayer);
		
		// destroy the group
		hr = InternalDestroyGroup(this,(LPDPLAYI_GROUP)pPlayer,FALSE);
	}
	if (FAILED(hr))
	{
		DPF(0,"COULD NOT NUKE ITEM hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	return;
	
}  // NukeNameTableItem


HRESULT AddItemToNameTable(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer,DWORD dwLobbyID)
{
    HRESULT hr=DP_OK;
	DWORD dwUnmangledID;
    DWORD index,unique;
  	BOOL bLocal;
	LPDPLAYI_PLAYER pPlayer = (LPDPLAYI_PLAYER)dwItem;

	// we can cast either a group or a player to a player, since the flags are 
	// in the same place...
	bLocal = (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE : FALSE;

	// non-local players don't need a new index
	if(bLocal)
	{
	  	// If this object is lobby owned, we won't be a nameserver,
		// but we always want to alloc the ID locally anyway
		if(IS_LOBBY_OWNED(this))
		{
			hr = NS_AllocNameTableEntry(this, pid);
		}
		else
		{
			ASSERT(this->pSysPlayer);

			// ask ns for an index
			// if we're the namesrvr, just go get it
			if(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
			{
				hr = NS_AllocNameTableEntry(this,pid);    	
			}
			else 
			{
				hr = SendNSNewIDRequest(this,dwItem,pid,fPlayer);
			}
		}

		if (FAILED(hr)) 
		{
			DPF_ERR("could not get new id for item");
			return hr;	
		}
	}

	dwUnmangledID = *pid ^ (DWORD)this->lpsdDesc->dwReserved1;
	
	// if it's not local, assume pid was set when / wherever item was created
    index = dwUnmangledID & INDEX_MASK; 
	unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

	// do we need to grow the table?
	// if so, keep growing it until its big enough...
    while (index >= this->uiNameTableSize) 
    {
        hr = GrowTable(this);
        if (FAILED(hr)) 
        {
            return hr;
        }

    }

    if (index > this->uiNameTableSize ) 
    {
        ASSERT(FALSE); // ??? rut ro
        return E_UNEXPECTED;
    }

	// if there is already something here, we're in trouble.
	// this means we missed a system message (e.g. deleteplayer or deletegroup)
	// and our nametable is corrupt.  we will hope for the best, and delete the
	// item here. andyco.
	if (this->pNameTable[index].dwItem &&  (NAMETABLE_PENDING != this->pNameTable[index].dwItem))
	{
		DPF(5,"		!!!   NAMETABLE CORRUPTION DETECTED.  DPLAY WILL CORRECT ITSELF	!!!");
		NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
	} 

	this->pNameTable[index].dwItem = dwItem;
	this->pNameTable[index].dwUnique = unique;

	// If this is a lobby session, we need to make the ID be the lobby ID
	if(IS_LOBBY_OWNED(this))
	{
		hr = PRV_AddMapIDNode(this->lpLobbyObject, dwLobbyID, *pid);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to add an entry to the map table, hr = 0x%08x", hr);
			NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
			return hr;
		}

		// Fix the output dpid to be the lobby ID
		*pid = dwLobbyID;
	}

	return hr;
} // AddItemToNameTable

#undef DPF_MODNAME
#define DPF_MODNAME	"FreeNameTableEntry"

// mark this spot in the name table as unused
HRESULT FreeNameTableEntry(LPDPLAYI_DPLAY this,DWORD dpid)
{
    HRESULT hr=DP_OK;
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DWORD id;

	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return E_UNEXPECTED;
	}

	// don't get upset if they try to free the system group or server player id	
	if (DPID_ALLPLAYERS == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_ALLPLAYERS - ignoring");
		return DP_OK;
	}
	
	if (DPID_SERVERPLAYER == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_SERVERPLAYER - ignoring");
		return DP_OK;
	}
	
	
	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF_ERRVAL("Unable to unmap id %lu, not freeing nametable entry", dpid);
			ASSERT(FALSE);
			return DPERR_INVALIDPARAM;
		}
	}
	else
		id = dpid;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;
	
    index = dwUnmangledID & INDEX_MASK;
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	ASSERT(FALSE); 	// ACK!!!
    	// this should *NEVER* happen!
    	// should almost be an int 3 here ?
    	// andyco. 10/14/96
    	DPF_ERR("asked for element outside table!");
        return E_UNEXPECTED;
    }

    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF_ERR("asked for invalid element");
        return E_UNEXPECTED;	 
    }

    if (NAMETABLE_PENDING == this->pNameTable[index].dwItem)
    {
        // remove client info
        if (this->pNameTable[index].pvData)
        {
            DPMEM_FREE(this->pNameTable[index].pvData);
        }
    }

    this->pNameTable[index].dwItem = 0;
    this->pNameTable[index].pvData = NULL;

	// Now delete them from the map table if this is a lobby session
	if(IS_LOBBY_OWNED(this))
	{
		PRV_DeleteMapIDNode(this->lpLobbyObject, dpid);
	}

    return hr;
}// FreeNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"IsValidID"

// check the element at location index in the nametable.
// (if its unique code matches) 
BOOL IsValidID(LPDPLAYI_DPLAY this,DWORD id) 
{	
	if (DPID_ALLPLAYERS == id)
	{
		// it's ok.  they tried to resolve the system group to a player
		DPF(8,"asked for id == DPID_ALLPLAYERS - failing");
		return FALSE;
	}
	
	if (DPID_SERVERPLAYER == id)
	{
		// it's ok.  they tried to resolve the server player to a group.
		DPF(8,"asked for id == DPID_SERVERPLAYER - failing");
		return FALSE;
	}
	
	if (!(this->lpsdDesc))
	{
		DPF(1,"unable to resolve player id - session closed");
		return FALSE;
	}	
	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return FALSE;
	}

    return TRUE;

} // IsValidID

#undef DPF_MODNAME
#define DPF_MODNAME	"DataFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
LPVOID DataFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return NULL;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id))
        return NULL;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"DataFromID:asked for element outside table - id = %d!",id);
        return NULL;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"DataFromID:asked for element w/ invalid tag - id = %d!",id);
        return NULL;
    }

    return this->pNameTable[index].pvData;
} // DataFromID

#undef DPF_MODNAME
#define DPF_MODNAME	"NameFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
DWORD_PTR NameFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return 0;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id)) return 0;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"NameFromID:asked for element outside table - id = %d!",id);
        return 0;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"NameFromID:asked for element w/ invalid tag - id = %d!",id);
        return 0;
    }

    return this->pNameTable[index].dwItem;
} // NameFromID
    
// return a dplay group corresponding to id.
// return null if id not valid
LPDPLAYI_GROUP GroupFromID(LPDPLAYI_DPLAY this,DWORD idGroupID) 
{
	if (DPID_ALLPLAYERS == idGroupID)
	{
		if (!this->pSysGroup)
		{
			DPF_ERR("System group not found");
			return NULL;	
		} 
		return this->pSysGroup;
	}
    return (LPDPLAYI_GROUP)NameFromID(this,idGroupID);	
} // GroupFromID
// return a dplay player corresponding to id.
// return null if id not valid
LPDPLAYI_PLAYER PlayerFromID(LPDPLAYI_DPLAY this,DWORD idPlayerID)
{
	if (DPID_SERVERPLAYER == idPlayerID)
	{
		if (!this->pServerPlayer)
		{
			DPF_ERR(" server player not found");
			return NULL;	
		} 
		return this->pServerPlayer;
	}
    return (LPDPLAYI_PLAYER)NameFromID(this,idPlayerID);		
} // PlayerFromID

DPID PlayerIDFromSysPlayerID(LPDPLAYI_DPLAY this,DPID dpidSysPlayer)
{
	LPDPLAYI_PLAYER pPlayerWalker=this->pPlayers;
	
	while(pPlayerWalker)
	{
		if(pPlayerWalker->dwIDSysPlayer == dpidSysPlayer){
			return pPlayerWalker->dwID;
		}
		pPlayerWalker = pPlayerWalker->pNextPlayer;
	}
	return 0;
}

// Someone is telling us they are the new nameserver.
HRESULT NS_HandleIAmNameServer(LPDPLAYI_DPLAY this,LPMSG_IAMNAMESERVER pmsg, LPVOID pvSPHeader)
{
	LPDPLAYI_PLAYER pPlayer;
	HRESULT hr;
	DPSP_DELETEPLAYERDATA dd;

	pPlayer=PlayerFromID(this, pmsg->dwIDHost);

	if(!pPlayer){
		return DPERR_INVALIDPLAYER;
	}

	if(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL){
		return DP_OK;
	}

	dd.idPlayer       = pPlayer->dwID;
	dd.dwFlags        = pPlayer->dwFlags;
	dd.lpISP          = this->pISP;

	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer, &dd);

	if(FAILED(hr)){
		DPF_ERR("SP Could Not Delete Player in preparation for flags change in NS_HandleIamNameServer\n");
	}

	pPlayer->dwFlags = ((pPlayer->dwFlags & DPLAYI_PLAYER_NONPROP_FLAGS) | pmsg->dwFlags);
	
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR);
	
	pPlayer->dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;//paranoia
	this->pNameServer = pPlayer;

	// NOTE: blows away the header.  May not be compatible with all SPs.
	if(pPlayer->pvSPData){
		DPMEM_FREE(pPlayer->pvSPData);
	}

	pPlayer->pvSPData=DPMEM_ALLOC(pmsg->dwSPDataSize+1);
	if(!pPlayer->pvSPData){
		DPF_ERR("Ran out of memory trying to allocate spdata block\n");
		hr=DPERR_OUTOFMEMORY;
		return hr;
	}
	memcpy(pPlayer->pvSPData, pmsg->SPData, pmsg->dwSPDataSize);
	pPlayer->dwSPDataSize=pmsg->dwSPDataSize;
	
	hr = CallSPCreatePlayer(this,pPlayer,FALSE,pvSPHeader,FALSE);
	
	if(FAILED(hr)){
		DPF_ERR("SP Couldn't Recreate Player in NS_HandleIamNameServer\n");
		return hr;
	}
	
	this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;

	LEAVE_DPLAY();

	DVoiceNotify(this,DVEVENT_MIGRATEHOST,PlayerIDFromSysPlayerID(this,pPlayer->dwID),0, DVTRANSPORT_OBJECTTYPE_BOTH);
	
	ENTER_ALL();

	TRY 
	{
	
		hr = VALID_DPLAY_PTR( this );
		
		if (FAILED(hr))	{
			LEAVE_SERVICE();
			return hr;
	    }
	    
	} 
	EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_SERVICE();
        return DPERR_INVALIDPARAMS;
	}
	
	
	LEAVE_SERVICE();
	
	return hr;

}


// the nameserver has migrated to this client
// we need to recreate our sysplayer as  the nameserver
// we don't actually destroy the sysplayer, we just call the sp's
// destroy for the old (non-nameserver) and then create for the
// new (nameserver)
HRESULT MakeMeNameServer(LPDPLAYI_DPLAY this)
{
    DPSP_DELETEPLAYERDATA dd;
	HRESULT hr;

	DPF(0,"the name server has migrated to this client!");
	ASSERT(this->pSysPlayer);

	if (!this->pSysPlayer)
		return E_FAIL;

	// call sp delete player
	if (this->pcbSPCallbacks->DeletePlayer)
    {
	    // call sp
		dd.idPlayer = this->pSysPlayer->dwID;
		dd.dwFlags = this->pSysPlayer->dwFlags;
		dd.lpISP = this->pISP;

 	 	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer,&dd);
 	 	
		if (FAILED(hr)) 
		{
			DPF_ERR(" SP could not delete sysplayer in preparation for migration"); 
			ASSERT(FALSE);
			// keep trying...
		}
	}
	
	// free up the sp data
	if (this->pSysPlayer->pvSPData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPData);
		this->pSysPlayer->pvSPData = NULL;
	}
	
	if (this->pSysPlayer->pvSPLocalData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPLocalData);	
		this->pSysPlayer->pvSPLocalData = NULL;
	}
	this->pSysPlayer->dwSPLocalDataSize = 0;
	this->pSysPlayer->dwSPDataSize = 0;

	// get the sp to make us a nameserver (poof - you're a nameserver!)	
	this->pSysPlayer->dwFlags |= DPLAYI_PLAYER_NAMESRVR;
	// now, call the sp to create our nameserver
	hr = CallSPCreatePlayer(this,this->pSysPlayer,TRUE,NULL,FALSE);
	if (FAILED(hr))
	{
		DPF(0,"could not migrate nameserver - sp create player failed hr = 0x%08lx\n",hr);
		DPF(0,"game play should continue normally, but there is no more nameserver");
		// we should be ok to keep going here.  the nameserver is toast, but the game should go on...
		return hr;
	}

	// a-josbor: make sure the dplay thread is running to care for the reservation count
	StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	

	// remember that we are the system player
	this->pNameServer = this->pSysPlayer;

	if((this->dwMinVersion >= DPSP_MSG_DX61VERSION) && 
	   (this->dwMinVersion >= DPSP_MSG_DX61AVERSION || this->pProtocol)){
		// we used to tell everyone that the system player was deleted and then
		// recreated.  This is a very bad thing to do with the protocol running
		// so we instead send an IAMHOST message to give the other players a chance
		// to update their information on who is the name server.
		hr=SendIAmNameServer(this);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
		}
		
	} else {
		// tell the world about our new player
		// 1st, delete the non-nameserver old player
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYER|DPSP_MSG_ASYNC, 
			this->pSysPlayer->dwID,0);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		
		// now, create the new nameserver player
		hr = SendCreateMessage( this, this->pSysPlayer,TRUE,NULL);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

	}
	// tell our local players we're the nameserver
	hr = SendMeNameServer(this);
	if (FAILED(hr))
	{
		DPF(0,"could not send name server message - hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	// Send a system message to the lobby server, telling them the
	// host just migrated to this client
	PRV_SendStandardSystemMessage(this->lpLaunchingLobbyObject,
			DPLSYS_NEWSESSIONHOST, DPLOBBYPR_GAMEID);

	// reset our ping counter, so we don't start sending pings
	// until things have settled down...
	this->dwLastPing = GetTickCount();
	
	return DP_OK;
	
} // MakeMeNameServer

// called by handler.c when it gets a dp_deleteplayer on 
// the namesrvr
HRESULT HandleDeadNameServer(LPDPLAYI_DPLAY this)
{
	DWORD IDMin; // the minimum player id, and the index of that id
	BOOL bFound = FALSE;
	LPDPLAYI_PLAYER pPlayer,pNewServer = NULL;	
	HRESULT hr = DP_OK;

	// In a client-server or secure session, don't migrate the host
	if ( (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) 
		||  (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) 
		|| !(this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) )
	{
		DPF(0,"Name server is dead.  Game over!");
		return HandleSessionLost(this);
	}

	DPF(0,"Name server dead.  Finding new name server");

	IDMin = (DWORD) -1;

	// search the name table, looking for a new namesrvr
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		if (DPLAYI_PLAYER_SYSPLAYER & pPlayer->dwFlags )
		{
			if (pPlayer->dwID < IDMin) 
			{
				bFound=TRUE;
				IDMin = pPlayer->dwID;
				pNewServer = pPlayer;
			} // id < idMin
		} // sysplayer
		pPlayer = pPlayer->pNextPlayer;
	} // while

	if (!bFound) 
	{
		DPF(0,"Could not find new name srvr - ack!");
		return E_FAIL;
	}

	DPF(0,"found new name srvr - id = %d\n",IDMin);

	if (this->pSysPlayer && (this->pSysPlayer->dwID == IDMin)) 
	{
		this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
		hr = MakeMeNameServer(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// we should be ok to keep going here
		}
	} // id == idmin
	else {
		// Mark no nameserver and do keepalives until we find one.
		this->dwFlags |= DPLAYI_DPLAY_NONAMESERVER;
		StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	
	}

	return hr;

} // HandleDeadNameServer

