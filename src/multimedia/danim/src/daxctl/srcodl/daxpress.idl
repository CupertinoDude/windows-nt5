/*++

Module:
    daxpress.idl

Description:
    Contains enums, interfaces and classes for the DA/IHammer controls.  Processed
    by MIDL to produce a type library, a .C file which defines the GUIDs, and a .H file.

Author:
    IHammer Team (SimonB)

History:
    05-27-1997    Created (SimonB)


--*/

#include <olectl.h>
#include <dispids.h> // DISPIDs for all items in this library

#pragma midl_echo("#include \"danim.h\"")

#define DANIM_TLB "danim.tlb"

[
    uuid(139DD5D1-D6E2-11d0-89D4-00A0C90833E6),  // LIBID_DAExpressLib
    version(1.0),
    lcid(0x0),
    helpstring("Microsoft DirectAnimation Media Controls"),
    control
]

library DAExpressLib
{
    importlib(STDOLE_TLB);
    importlib(STDTYPE_TLB);
    importlib(DANIM_TLB);

////////////////////////////////////////////////////////////////////////
// Enumerations and constants
//


    typedef  // PlayState
    [
        uuid(572F8950-D49A-11d0-89D3-00A0C90833E6),
        helpstring("Constants for PlayState")
    ]
    enum
    {
        Stopped = 0,
        Playing = 1,
        Paused  = 2
    } PlayStateConstant;

    typedef   // Direction
    [
        uuid(572F8951-D49A-11d0-89D3-00A0C90833E6),
        helpstring("Constants for Direction")
    ]
    enum
    {
        Forward  = 0,
        Backward = 1
    } DirectionConstant;


    typedef  // CoordSystem
    [
        uuid(753E5420-D7B8-11d0-89D5-00A0C90833E6),
        helpstring("Constants for CoordinateSystem")
    ]
    enum
    {
        LeftHanded  = 0,
        RightHanded = 1
    } CoordSystemConstant;


//
// Interfaces and coclasses
//


////////////////////////////////////////////////////////////////////////
// Path control
//

    [
        uuid(D7A7D7C1-D47F-11d0-89D3-00A0C90833E6), // IID_IPathCtl
        helpstring("Dual interface for Path Control"),
        oleautomation,
        hidden,
        nonextensible,
        dual,
        odl
    ]

    //
    // Custom interface definition

    interface IPathCtl : IDispatch
    {
        //
        // Properties
        //

// Target
        [propget,
            helpstring("Sets or returns the name of the object to move"),
            id(DISPID_PATH_PROP_TARGET)
        ]
        HRESULT Target ([out, retval] BSTR* bstrTarget);

        [propput,
            helpstring("Sets or returns the name of the object to move"),
            id(DISPID_PATH_PROP_TARGET)
        ]
        HRESULT Target ([in] BSTR bstrTarget);

// Duration
        [propget,
            helpstring("Specifies the duration of the path playback"),
            id(DISPID_PATH_PROP_DURATION)
        ]
        HRESULT Duration ([out, retval] double* dblDuration);

        [propput,
            helpstring("Specifies the duration of the path playback"),
            id(DISPID_PATH_PROP_DURATION)
        ]
        HRESULT Duration ([in] double dblDuration);

// Library
        [propget,
            helpstring("Gets the Direct Animation Library"),
            id(DISPID_PATH_PROP_LIBRARY)
        ]
        HRESULT Library ([out, retval] IDAStatics **ppLibrary);

// Loopcount
        [propget,
            helpstring("Sets or returns the number of times to loop playback.  Specify -1 to loop infinitely"),
            id(DISPID_PATH_PROP_REPEAT)
        ]
        HRESULT Repeat ([out, retval] long* iRepeat);

        [propput,
            helpstring("Sets or returns the number of times to loop playback.  Specify -1 to loop infinitely"),
            id(DISPID_PATH_PROP_REPEAT)
        ]
        HRESULT Repeat([in] long iRepeat);

// Bounce
        [propget,
            helpstring("Sets the path to either stop at the end of the path or reverse direction and continue playback"),
            id(DISPID_PATH_PROP_BOUNCE)
        ]
        HRESULT Bounce ([out, retval] VARIANT_BOOL* fBounce);

        [propput,
            helpstring("Sets the path to either stop at the end of the path or reverse direction and continue playback"),
            id(DISPID_PATH_PROP_BOUNCE)
        ]
        HRESULT Bounce ([in] VARIANT_BOOL fBounce);

// AutoStart
        [propget,
            id(DISPID_PATH_PROP_AUTOSTART),
            hidden
        ]
        HRESULT AutoStart ([out, retval] VARIANT_BOOL* fAutoStart);

        [propput,
            id(DISPID_PATH_PROP_AUTOSTART),
            hidden
        ]
        HRESULT AutoStart ([in] VARIANT_BOOL fAutoStart);

// PlayState
        [propget,
            helpstring("Returns the current playback state of the path"),
            id(DISPID_PATH_PROP_PLAYSTATE)
        ]
        HRESULT PlayState ([out, retval] PlayStateConstant* State);

// Time
        [propget,
            helpstring("Returns the elapsed playback time of the path"),
            id(DISPID_PATH_PROP_TIME)
        ]
        HRESULT Time ([out, retval] double *pdblTime);

// Direction
        [propget,
            helpstring("Sets or returns the direction of the path playback, either forward or reverse"),
            id(DISPID_PATH_PROP_DIRECTION)
        ]
        HRESULT Direction ([out, retval] DirectionConstant* Dir);

        [propput,
            helpstring("Sets or returns the direction of the path playback, either forward or reverse"),
            id(DISPID_PATH_PROP_DIRECTION)
        ]
        HRESULT Direction ([in] DirectionConstant Dir);

// Relative
        [propget,
            helpstring("Sets or returns path coordinate positioning; absolute position or relative to the target"),
            id(DISPID_PATH_PROP_RELATIVE)
        ]
        HRESULT Relative ([out, retval] VARIANT_BOOL* bRelative);

        [propput,
            helpstring("Sets or returns path coordinate positioning; absolute position or relative to the target"),
            id(DISPID_PATH_PROP_RELATIVE)
        ]
        HRESULT Relative ([in] VARIANT_BOOL bRelative);

// TimerInterval
        [propget,
            helpstring("Sets or returns the interval between path updates"),
            id(DISPID_PATH_PROP_TIMERINTERVAL)
        ]
        HRESULT TimerInterval([out, retval] double* Interval);

        [propput,
            helpstring("Sets or returns the interval between path updates"),
            id(DISPID_PATH_PROP_TIMERINTERVAL)
        ]
        HRESULT TimerInterval([in] double Interval);

// Path
        [propget,
            helpstring("Sets or returns the current path as a DirectAnimation behavior"),
            id(DISPID_PATH_PROP_PATH)
        ]
        HRESULT Path([out, retval] IDAPath2** ppPath);

        [propput,
            helpstring("Sets or returns the current path as a DirectAnimation behavior"),
            id(DISPID_PATH_PROP_PATH)
        ]
        HRESULT Path([in] IDAPath2* pPath);

        //
        // Methods
        //

// Stop
        [
            helpstring("Stops playback and resets the path to the beginning"),
            id(DISPID_PATH_METH_STOP)
        ]
        HRESULT Stop();

// Pause
        [
            helpstring("Stops playback of the path and maintains current position"),
            id(DISPID_PATH_METH_PAUSE)
        ]
        HRESULT Pause();

// Play
        [
            helpstring("Starts playback of the path"),
            id(DISPID_PATH_METH_PLAY)
        ]
        HRESULT Play();

// Seek
        [
            helpstring("Jumps to a new position along the path"),
            id (DISPID_PATH_METH_SEEK)
        ]
        HRESULT Seek ([in] double dblTime);

// Oval
        [
            helpstring("Defines an oval-shaped path"),
            id(DISPID_PATH_METH_OVAL)
        ]
        HRESULT Oval(
            [in] double StartX, [in] double StartY,
            [in] double Width, [in] double Height);

// Rectangle
        [
            helpstring("Defines a rectangle-shaped path"),
            id(DISPID_PATH_METH_RECT)
        ]
        HRESULT Rect(
            [in] double StartX, [in] double StartY,
            [in] double Width, [in] double Height);

// Polyline
        [
            helpstring("Defines an open multipoint path"),
            id(DISPID_PATH_METH_POLYLINE)
        ]
        HRESULT Polyline(long nPoints, VARIANT Points);

// Polygon
        [
            helpstring("Defines a closed multipoint path"),
            id(DISPID_PATH_METH_POLYGON)
        ]
        HRESULT Polygon(long nPoints, VARIANT Points);

// AddTimeMarker
        [
            helpstring("Creates a marker that fires an event at a specific time"),
            id(DISPID_PATH_METH_ADDTIMEMARKER)
        ]
        HRESULT AddTimeMarker([in] double dblTime, [in] BSTR bstrMarkerName, [in, optional] VARIANT bAbsolute);

// KeyFrame
        [
            helpstring("Defines X and Y coordinates along a path and the time to reach each point"),
            id(DISPID_PATH_METH_KEYFRAME)
        ]
        HRESULT KeyFrame([in]unsigned int iNumPoints, [in]VARIANT varPoints, [in]VARIANT varTimePoints);

// Spline
        [
            helpstring("Defines a cubic, uniform knot vector spline path"),
            id(DISPID_PATH_METH_SPLINE)
        ]
        HRESULT Spline([in]unsigned int iNumPoints, [in]VARIANT varPoints);

    }

//
// Event dispatch interface for PathCtl
//

    [
        uuid(D7A7D7C2-D47F-11d0-89D3-00A0C90833E6),
        helpstring ("Event interface for PathCtl")

    ]
    dispinterface IPathCtlEvents
    {
        properties:
        methods:

// OnStop
            [
                id(DISPID_PATH_EVENT_ONSTOP),
                helpstring("Occurs when path playback stops")
            ]
            void onstop();

// OnPlay
            [
                id(DISPID_PATH_EVENT_ONPLAY),
                helpstring("Occurs when path playback starts")
            ]
            void onplay();

// OnPause
            [
                id(DISPID_PATH_EVENT_ONPAUSE),
                helpstring("Occurs when path playback is paused")
            ]
            void onpause();

// OnSeek
            [
                id(DISPID_PATH_EVENT_ONSEEK),
                helpstring("Occurs when the path seeks to a new position")
            ]
            void onseek(double dblTime);

// OnPlayMarker
            [
                id(DISPID_PATH_EVENT_ONPLAYMARKER),
                helpstring("Occurs when a marker is reached during path playback")
            ]
            void onplaymarker(BSTR name);

// OnMarker
            [
                id(DISPID_PATH_EVENT_ONMARKER),
                helpstring("Occurs when a marker is reached")
            ]
            void onmarker(BSTR name);
    };


//
//  Class information for PathCtl
//

    [
        uuid(D7A7D7C3-D47F-11d0-89D3-00A0C90833E6), // CLSID_IHCtl
        helpstring("Path Control"), control //TODO: Change this string
    ]

    coclass PathControl
    {
        [default] interface IPathCtl;
        [default, source] dispinterface IPathCtlEvents;
    };

#ifdef INCLUDESOUND
////////////////////////////////////////////////////////////////////////
// Sound control
//

    [
        uuid(9ED97A71-D6E0-11d0-89D4-00A0C90833E6), // IID_ISoundCtl
        helpstring("Dual interface for Sound Control"),
        oleautomation,
        hidden,
        nonextensible,
        dual,
        odl
    ]


    //
    // Custom interface definition

    interface ISoundCtl : IDispatch
    {
        //
        // Properties
        //

// SourceURL
        [propget,
            // helpstring("Set or returns the property to modify"),
            id(DISPID_SND_PROP_SOURCEURL)
        ]
        HRESULT SourceURL ([out, retval] BSTR* bstrSourceURL);

        [propput,
            // helpstring("Set or returns the property to modify"),
            id(DISPID_SND_PROP_SOURCEURL)
        ]
        HRESULT SourceURL ([in] BSTR bstrSourceURL);

// Clock
        [propget,
            helpstring("When the path reaches the end of the control bounce back"),
            id(DISPID_SND_PROP_CLOCK)
        ]
        HRESULT Clock ([out, retval] double* dblClock);

// PlayState
        [propget,
            helpstring("Returns the state of the control"),
            id(DISPID_SND_PROP_PLAYSTATE)
        ]
        HRESULT PlayState ([out, retval] PlayStateConstant* State);

// AutoStart
        [propget,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_AUTOSTART)
        ]
        HRESULT AutoStart ([out, retval] VARIANT_BOOL* fAutoStart);

        [propput,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_AUTOSTART)
        ]
        HRESULT AutoStart ([in] VARIANT_BOOL fAutoStart);

// AutoDownload
        [propget,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_AUTODOWNLOAD)
        ]
        HRESULT AutoDownload ([out, retval] VARIANT_BOOL* fAutoDownload);

        [propput,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_AUTODOWNLOAD)
        ]
        HRESULT AutoDownload([in] VARIANT_BOOL fAutoDownload);

// Repeat
        [propget,
            //helpstring("Gets/sets the current DA transform"),
            id(DISPID_SND_PROP_REPEAT)
        ]
        HRESULT Repeat ([out, retval] long* iRepeat);

        [propput,
            //helpstring("Gets/sets the current DA transform"),
            id(DISPID_SND_PROP_REPEAT)
        ]
        HRESULT Repeat ([in] long iRepeat);

// PrerollAmount
        [propget,
            //helpstring("Gets/sets the current DA transform"),
            id(DISPID_SND_PROP_PREROLLAMOUNT)
        ]
        HRESULT PrerollAmount ([out, retval] long* iPrerollAmount);

        [propput,
            //helpstring("Gets/sets the current DA transform"),
            id(DISPID_SND_PROP_PREROLLAMOUNT)
        ]
        HRESULT PrerollAmount ([in] long iPrerollAmount);

// InitialVolume
        [propget,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_INITIALVOLUME)
        ]
        HRESULT InitialVolume ([out, retval] unsigned int* iInitialVolume);

        [propput,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_INITIALVOLUME)
        ]
        HRESULT InitialVolume ([in] unsigned int iInitialVolume);

// Library
        [propget,
            helpstring("Get the Direct Animation Library"),
            id(DISPID_SND_PROP_LIBRARY)
        ]
        HRESULT Library ([out, retval] IDAStatics **ppLibrary);

// Sound
        [propget,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_SOUND)
        ]
        HRESULT Sound([out, retval] IDASound** DASound);

        [propput,
            //helpstring("Specifies the direction"),
            id(DISPID_SND_PROP_SOUND)
        ]
        HRESULT Sound([in] IDASound *DASound);

        //
        // Methods
        //

// AddSound
        [
            helpstring("Adds a new sound to the mix"),
            id(DISPID_SND_METH_ADDSOUND)
        ]
        HRESULT AddSound([in] IDASound *DASound);

// Stop
        [
            helpstring("Stops and resets the sound to the beginning"),
            id(DISPID_SND_METH_STOP)
        ]
        HRESULT Stop();

// Pause
        [
            helpstring("Stops the sound"),
            id(DISPID_SND_METH_PAUSE)
        ]
        HRESULT Pause();

// Play
        [
            helpstring("Plays the sound"),
            id(DISPID_SND_METH_PLAY)
        ]
        HRESULT Play();

// Rewind
        [
            helpstring("Rewinds the sound"),
            id(DISPID_SND_METH_REWIND)
        ]
        HRESULT Rewind();

// Seek
        [
            helpstring(""),
            id (DISPID_SND_METH_SEEK)
        ]
        HRESULT Seek ([in] double dblTime);


// AddTimeMarker
        [
            // helpstring(""),
            id(DISPID_SND_METH_ADDTIMEMARKER)
        ]
        HRESULT AddTimeMarker([in] double dblTime, [in] BSTR bstrMarkerName);

    }

    //
    // Event dispatch interface for SoundCtl
    //

    [
        uuid(9ED97A72-D6E0-11d0-89D4-00A0C90833E6),
        helpstring ("Event interface for SoundCtl")

    ]
    dispinterface ISoundCtlEvents
    {
        properties:
        methods:

// OnStop
            [
                id(DISPID_SND_EVENT_ONSTOP)
            ]
            void onstop();

// OnPlay
            [
                id(DISPID_SND_EVENT_ONPLAY)
            ]
            void onplay();

// OnPause
            [
                id(DISPID_SND_EVENT_ONPAUSE)
            ]
            void onpause();

// OnMediaLoaded
            [
                id(DISPID_SND_EVENT_ONMEDIALOADED)
            ]
            void onmedialoaded();


    };


    //
    //  Class information for SoundCtl

    [
        uuid(9ED97A73-D6E0-11d0-89D4-00A0C90833E6), // CLSID_SoundCtl
        helpstring("Sound Control"), control //TODO: Change this string
    ]

    coclass SoundCtl
    {
        [default] interface ISoundCtl;
        [default, source] dispinterface ISoundCtlEvents;
    };

#endif // INCLUDESOUND
////////////////////////////////////////////////////////////////////////
// Structured Graphics control
//

    [
        uuid(369303C0-D7AC-11d0-89D5-00A0C90833E6), // IID_ISoundCtl
        helpstring("Dual interface for SGrfx Control"),
        oleautomation,
        hidden,
        nonextensible,
        dual,
        odl
    ]



    //
    // Custom interface definition

    interface ISGrfxCtl : IDispatch
    {
        //
        // Properties
        //

// SourceURL
        [propget,
            helpstring("Sets or returns the URL of a file containing Structured Graphics drawing primitives"),
            id(DISPID_SG_PROP_SOURCEURL)
        ]
        HRESULT SourceURL ([out, retval] BSTR* bstrSourceURL);

        [propput,
            helpstring("Sets or returns the URL of a file containing Structured Graphics drawing primitives"),
            id(DISPID_SG_PROP_SOURCEURL)
        ]
        HRESULT SourceURL ([in] BSTR bstrSourceURL);

// CoordinateSystem

        [propget,
            helpstring("Sets or returns the coordinate system to use for the world"),
            id(DISPID_SG_PROP_COORDSYSTEM)
        ]
        HRESULT CoordinateSystem ([out, retval] CoordSystemConstant* CoordSystem);

        [propput,
            helpstring("Sets or returns the coordinate system to use for the world"),
            id(DISPID_SG_PROP_COORDSYSTEM)
        ]
        HRESULT CoordinateSystem ([in] CoordSystemConstant CoordSystem);


// MouseEventsEnabled
        [propget,
            helpstring("Enables or disables mouse events"),
            id(DISPID_SG_PROP_ENABLEMOUSEEVENTS)
        ]
        HRESULT MouseEventsEnabled ([out, retval] VARIANT_BOOL *fEnabled);

        [propput,
            helpstring("Enables or disables mouse events"),
            id(DISPID_SG_PROP_ENABLEMOUSEEVENTS)
        ]
        HRESULT MouseEventsEnabled ([in] VARIANT_BOOL fEnabled);

// ExtentTop
        [propget,
            helpstring("Sets or returns the vertical coordinates for the top edge of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTTOP)
        ]
        HRESULT ExtentTop ([out, retval] int* iExtentTop);

        [propput,
            helpstring("Sets or returns the vertical coordinates for the top edge of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTTOP)
        ]
        HRESULT ExtentTop ([in] int iExtentTop);

// ExtentLeft
        [propget,
            helpstring("Sets or returns the horizontal coordinates for the left edge of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTLEFT)
        ]
        HRESULT ExtentLeft ([out, retval] int* iExtentLeft);

        [propput,
            helpstring("Sets or returns the horizontal coordinates for the left edge of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTLEFT)
        ]
        HRESULT ExtentLeft ([in] int iExtentLeft);

// ExtentWidth
        [propget,
            helpstring("Sets or returns the width of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTWIDTH)
        ]
        HRESULT ExtentWidth ([out, retval] int* iExtentWidth);

        [propput,
            helpstring("Sets or returns the width of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTWIDTH)
        ]
        HRESULT ExtentWidth ([in] int iExtentWidth);

// ExtentHeight
        [propget,
            helpstring("Sets or returns the height of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTHEIGHT)
        ]
        HRESULT ExtentHeight ([out, retval] int* iExtentHeight);

        [propput,
            helpstring("Sets or returns the height of the logical coordinate system"),
            id(DISPID_SG_PROP_EXTENTHEIGHT)
        ]
        HRESULT ExtentHeight ([in] int iExtentHeight);

// HighQuality
        [propget,
            helpstring("Enables or disables anti-aliasing"),
            id(DISPID_SG_PROP_HIQUALITY)
        ]
        HRESULT HighQuality ([out, retval] VARIANT_BOOL *pfHighQuality);

        [propput,
            helpstring("Enables or disables anti-aliasing"),
            id(DISPID_SG_PROP_HIQUALITY)
        ]
        HRESULT HighQuality ([in] VARIANT_BOOL fHighQuality);

// Library
        [propget,
            helpstring("Gets the Direct Animation Library"),
            id(DISPID_SG_PROP_LIBRARY)
        ]
        HRESULT Library ([out, retval] IDAStatics **ppLibrary);

// Image
        [propget,
            helpstring("Sets or returns the current DirectAnimation Image"),
            id(DISPID_SG_PROP_IMAGE)
        ]
        HRESULT Image([out, retval] IDAImage ** ppImage);

        [propput,
            helpstring("Sets or returns the current DirectAnimation Image"),
            id(DISPID_SG_PROP_IMAGE)
        ]
        HRESULT Image([in] IDAImage *pImage);


// Transform
        [propget,
            helpstring("Sets or returns the current DirectAnimation transform"),
            id(DISPID_SG_PROP_TRANSFORM)
        ]
        HRESULT Transform([out, retval] IDATransform3 ** ppTransform);

        [propput,
            helpstring("Sets or returns the current DirectAnimation transform"),
            id(DISPID_SG_PROP_TRANSFORM)
        ]
        HRESULT Transform([in] IDATransform3 *pTransform);


// DrawingSurface
        [propget,
            helpstring("Sets or returns the current DirectAnimation Drawing Surface"),
            id(DISPID_SG_PROP_DRAWINGSURFACE)
        ]
        HRESULT DrawingSurface([out, retval] IDADrawingSurface **ppDrawingSurface);

        [propput,
            helpstring("Sets or returns the current DirectAnimation Drawing Surface"),
            id(DISPID_SG_PROP_DRAWINGSURFACE)
        ]
        HRESULT DrawingSurface([in] IDADrawingSurface *pDrawingSurface);


// DrawSurface - backwards compatibility (hidden)
        [propget,
            id(DISPID_SG_PROP_DRAWSURFACE),
            hidden
        ]
        HRESULT DrawSurface([out, retval] IDADrawingSurface **ppDrawingSurface);

        [propput,
            id(DISPID_SG_PROP_DRAWSURFACE),
            hidden
        ]
        HRESULT DrawSurface([in] IDADrawingSurface *pDrawingSurface);


// PreserveAspectRatio
        [propget,
            helpstring("Sets or returns a value indicating if aspect ratio should be preserved when extents are set"),
            id(DISPID_SG_PROP_PRESERVEASPECTRATIO),
        ]
        HRESULT PreserveAspectRatio([out, retval] VARIANT_BOOL *fPreserve);

        [propput,
            helpstring("Sets or returns a value indicating if aspect ratio should be preserved when extents are set"),
            id(DISPID_SG_PROP_PRESERVEASPECTRATIO),
        ]
        HRESULT PreserveAspectRatio([in] VARIANT_BOOL fPreserve);

        //
        // Methods
        //

// Clear
        [
            helpstring("Clears the drawing area"),
            id(DISPID_SG_METH_CLEAR)
        ]
        HRESULT Clear();

// Rotate
        [
            helpstring("Rotates the coordinate space"),
            id(DISPID_SG_METH_ROTATE)
        ]
        HRESULT Rotate([in] double dblXRot, [in] double dblYRot, [in] double dblZRot, [in, optional] VARIANT varReserved);


// Scale
        [
            helpstring("Scales the coordinate space"),
            id(DISPID_SG_METH_SCALE)
        ]
        HRESULT Scale([in] double dblXScale, [in] double dblYScale, [in] double dblZScale, [in, optional] VARIANT varReserved);

// SetIdentity
        [
            helpstring("Clears any transforms, restoring the control to its initial settings"),
            id(DISPID_SG_METH_SETIDENTITY)
        ]
        HRESULT SetIdentity();

// Transform4x4
        [
            helpstring("Sets scaling, rotation, and translation information all at once, using a transform matrix"),
            id(DISPID_SG_METH_TRANSFORM4X4)
        ]
        HRESULT Transform4x4([in] VARIANT matrix);

// Translate
        [
            helpstring("Sets the X, Y and Z location of the world"),
            id(DISPID_SG_METH_TRANSLATE)
        ]
        HRESULT Translate([in] double dblXOrigin, [in] double dblYOrigin, [in] double dblZOrigin, [in, optional] VARIANT varReserved);

#ifdef INCLUDESHEAR
// ShearX
        [
            helpstring("Shear the X axis"),
            id(DISPID_SG_METH_XSHEAR)
        ]
        HRESULT ShearX([in] double dblShearAmount);

// ShearY
        [
            helpstring("Shear the Y axis"),
            id(DISPID_SG_METH_YSHEAR)
        ]
        HRESULT ShearY([in] double dblShearAmount);
#endif // INCLUDESHEAR
    }

    //
    // Event dispatch interface for SGrfxCtl
    //

    [
        uuid(369303C1-D7AC-11d0-89D5-00A0C90833E6),
        helpstring ("Event interface for SGrfxCtl")

    ]
    dispinterface ISGrfxCtlEvents
    {
        properties:
        methods:
// OnMouseMove
            [
                id(DISPID_SG_EVENT_MOUSEMOVE),
                helpstring("Occurs when the mouse moves over an opaque region of the control")
            ]
            void onmousemove(long Button, long Shift, long X, long Y);

// OnMouseOver
            [
                id(DISPID_SG_EVENT_MOUSEENTER),
                helpstring("Occurs when the mouse enters an opaque region of the control")
            ]
            void onmouseover();

// OnMouseOut
            [
                id(DISPID_SG_EVENT_MOUSELEAVE),
                helpstring("Occurs when the mouse leaves an opaque region of the control")
            ]
            void onmouseout();

// OnMouseDown
            [
                id(DISPID_SG_EVENT_MOUSEDOWN),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and a mouse button is depressed")
            ]
            void onmousedown(long Button, long Shift, long X, long Y);

// OnMouseUp
            [
                id(DISPID_SG_EVENT_MOUSEUP),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and a mouse button is released")
            ]
            void onmouseup(long Button, long Shift, long X, long Y);

// OnDblClick
            [
                id(DISPID_SG_EVENT_DBLCLICK),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and the mouse button is double-clicked")
            ]
            void ondblclick();

// OnClick
            [
                id(DISPID_SG_EVENT_CLICK),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and the mouse button is clicked once")
            ]
            void onclick();

    };


    //
    //  Class information for SGrfxCtl

    [
        uuid(369303C2-D7AC-11d0-89D5-00A0C90833E6), // CLSID_SgrfxCtl
        helpstring("Structured Graphics Control"), control //TODO: Change this string
    ]

    coclass StructuredGraphicsControl
    {
        [default] interface ISGrfxCtl;
        [default, source] dispinterface ISGrfxCtlEvents;
    };


//////////////////////////////////////////////////////////////////////////////////
// Sprite control
//

    [
        uuid(FD179531-D86E-11d0-89D6-00A0C90833E6), // IID_ISpriteCtl
        helpstring("Dual interface for Sprite Control"),
        oleautomation,
        hidden,
        nonextensible,
        dual,
        odl
    ]

    //
    // Custom interface definition

    interface ISpriteCtl : IDispatch
    {
        //
        // Properties
        //

// AutoStart
        [propget,
            helpstring("Sets or returns a value indicating whether or not the sprite starts playback upon loading"),
            id(DISPID_SPRITE_PROP_AUTOSTART)
        ]
        HRESULT AutoStart ([out, retval] VARIANT_BOOL* fAutoStart);

        [propput,
            helpstring("Sets or returns a value indicating whether or not the sprite starts playback upon loading"),
            id(DISPID_SPRITE_PROP_AUTOSTART)
        ]
        HRESULT AutoStart ([in] VARIANT_BOOL fAutoStart);

// Frame
        [propget,
            helpstring("Sets or returns the sprite image frame currently being displayed"),
            id(DISPID_SPRITE_PROP_FRAME)
        ]
        HRESULT Frame ([out, retval] unsigned int* iFrame);

        [propput,
            helpstring("Sets or returns the sprite image frame currently being displayed"),
            id(DISPID_SPRITE_PROP_FRAME)
        ]
        HRESULT Frame ([in] unsigned int iFrame);

// FrameMap
        [propget,
            helpstring("Sets or returns the order in which frames play back and the length of time each frame is displayed"),
            id(DISPID_SPRITE_PROP_FRAMEMAP)
        ]
        HRESULT FrameMap ([out, retval] BSTR* FrameMap);

        [propput,
            helpstring("Sets or returns the order in which frames play back and the length of time each frame is displayed"),
            id(DISPID_SPRITE_PROP_FRAMEMAP)
        ]
        HRESULT FrameMap ([in] BSTR FrameMap);

// InitialFrame
        [propget,
            helpstring("Sets or returns the number of the frame that is displayed initially"),
            id (DISPID_SPRITE_PROP_INITIALFRAME)
        ]
        HRESULT InitialFrame ([out, retval] int* iFrame);

        [propput,
            helpstring("Sets or returns the number of the frame that is displayed initially"),
            id (DISPID_SPRITE_PROP_INITIALFRAME)
        ]
        HRESULT InitialFrame ([in] int iFrame);

// FinalFrame
        [propget,
            helpstring("Sets or returns the frame to be displayed when playback is stopped"),
            id (DISPID_SPRITE_PROP_FINALFRAME)
        ]
        HRESULT FinalFrame ([out, retval] int* iFrame);

        [propput,
            helpstring("Sets or returns the frame to be displayed when playback is stopped"),
            id (DISPID_SPRITE_PROP_FINALFRAME)
        ]
        HRESULT FinalFrame ([in] int iFrame);

// Iterations
        [propget,
            helpstring("(Backwards compatible) Please use 'Repeat' property"),
            id (DISPID_SPRITE_PROP_ITERATIONS)
        ]
        HRESULT Iterations ([out, retval] int* iRepeat);

        [propput,
            helpstring("(Backwards compatible) Please use 'Repeat' property"),
            id (DISPID_SPRITE_PROP_ITERATIONS)
        ]
        HRESULT Iterations ([in] int iRepeat);

// Library
        [propget,
            helpstring("Gets the Direct Animation Library"),
            id(DISPID_SPRITE_PROP_LIBRARY)
        ]
        HRESULT Library ([out, retval] IDAStatics **ppLibrary);

// Repeat
        [propget,
            helpstring("Sets or returns the number of times the sprite is to loop during playback"),
            id (DISPID_SPRITE_PROP_REPEAT)
        ]
        HRESULT Repeat ([out, retval] int* iRepeat);

        [propput,
            helpstring("Sets or returns the number of times the sprite is to loop during playback"),
            id (DISPID_SPRITE_PROP_REPEAT)
        ]
        HRESULT Repeat ([in] int iRepeat);

// PlayRate
        [propget,
            helpstring("Sets or returns the playback speed of the sprite"),
            id (DISPID_SPRITE_PROP_PLAYRATE)
        ]
        HRESULT PlayRate ([out, retval] double* dblSpeed);

        [propput,
            helpstring("Sets or returns the playback speed of the sprite"),
            id (DISPID_SPRITE_PROP_PLAYRATE)
        ]
        HRESULT PlayRate ([in] double dblSpeed);

// Time
        [propget,
            helpstring("Returns the elapsed playback time of the sprite"),
            id (DISPID_SPRITE_PROP_TIME)
        ]
        HRESULT Time ([out, retval] double * pdblTime);

// MaximumRate
        [propget,
            helpstring("Sets or returns the maximum rendering speed of the sprite (number of times the control will render per second)"),
            id (DISPID_SPRITE_PROP_MAXIMUMRATE)
        ]
        HRESULT MaximumRate ([out, retval] unsigned int* iFps);

        [propput,
            helpstring("Sets or returns the maximum rendering speed of the sprite (number of times the control will render per second)"),
            id (DISPID_SPRITE_PROP_MAXIMUMRATE)
        ]
        HRESULT MaximumRate ([in] unsigned int iFps);


// NumFrames
        [propget,
            helpstring("Sets or returns the number of frames in the Sprite source"),
            id (DISPID_SPRITE_PROP_NUMFRAMES)
        ]
        HRESULT NumFrames ([out, retval] unsigned int* iNumFrames);

        [propput,
            helpstring("Sets or returns the number of frames in the Sprite source"),
            id (DISPID_SPRITE_PROP_NUMFRAMES)
        ]
        HRESULT NumFrames ([in] unsigned int iNumFrames);

// PlayState
        [propget,
            helpstring("Returns the current playback state of the sprite"),
            id (DISPID_SPRITE_PROP_PLAYSTATE)
        ]
        HRESULT PlayState ([out, retval] PlayStateConstant* State);

// NumFramesAcross
        [propget,
            helpstring("Sets or returns the width (in frames) of the sprite source image"),
            id (DISPID_SPRITE_PROP_NUMFRAMESACROSS)
        ]
        HRESULT NumFramesAcross ([out, retval] unsigned int* iFrames);

        [propput,
            helpstring("Sets or returns the width (in frames) of the sprite source image"),
            id (DISPID_SPRITE_PROP_NUMFRAMESACROSS)
        ]
        HRESULT NumFramesAcross ([in] unsigned int iFrames);

// NumFramesDown
        [propget,
            helpstring("Sets or returns the height (in frames) of the sprite source image"),
            id (DISPID_SPRITE_PROP_NUMFRAMESDOWN)
        ]
        HRESULT NumFramesDown ([out, retval] unsigned int* iFrames);

        [propput,
            helpstring("Sets or returns the height (in frames) of the sprite source image"),
            id (DISPID_SPRITE_PROP_NUMFRAMESDOWN)
        ]
        HRESULT NumFramesDown ([in] unsigned int iFrames);

// UseColorKey
        [propget,
            helpstring("Sets or returns whether or not to use the sprite's transparency information"),
            id (DISPID_SPRITE_PROP_USECOLORKEY)
        ]
        HRESULT UseColorKey ([out, retval] VARIANT_BOOL* Solid);

        [propput,
            helpstring("Sets or returns whether or not to use the sprite's transparency information"),
            id (DISPID_SPRITE_PROP_USECOLORKEY)
        ]
        HRESULT UseColorKey ([in] VARIANT_BOOL Solid);

// Image
        [propget,
            helpstring("Sets or returns the current DirectAnimation Image"),
            id (DISPID_SPRITE_PROP_IMAGE)
        ]
        HRESULT Image ([out, retval] IDAImage ** pImage);

        [propput,
            helpstring("Sets or returns the current DirectAnimation Image"),
            id (DISPID_SPRITE_PROP_IMAGE)
        ]
        HRESULT Image ([in] IDAImage* pImage);

// ColorKey
        [propget,
            helpstring("Sets or returns the transparency color for a source image"),
            id (DISPID_SPRITE_PROP_COLORKEY)
        ]
        HRESULT ColorKey ([out, retval] IDAColor ** pColorKey);

        [propput,
            helpstring("Sets or returns the transparency color for a source image"),
            id (DISPID_SPRITE_PROP_COLORKEY)
        ]
        HRESULT ColorKey ([in] IDAColor * pColorKey);


// ColorKeyRGB
        [propget,
            id (DISPID_SPRITE_PROP_COLORKEYRGB),
            hidden
        ]
        HRESULT ColorKeyRGB ([out, retval] COLORREF* pColorKeyRGB);

        [propput,
            id (DISPID_SPRITE_PROP_COLORKEYRGB),
            hidden
        ]
        HRESULT ColorKeyRGB ([in] COLORREF ColorKeyRGB);


// SourceURL
        [propget,
            helpstring("Sets or returns the URL that points to the sprite source image"),
            id(DISPID_SPRITE_PROP_SOURCEURL)
        ]
        HRESULT SourceURL ([out, retval] BSTR* bstrSourceURL);

        [propput,
            helpstring("Sets or returns the URL that points to the sprite source image"),
            id(DISPID_SPRITE_PROP_SOURCEURL)
        ]
        HRESULT SourceURL ([in] BSTR bstrSourceURL);

// MouseEventsEnabled
        [propget,
            helpstring("Enables or disables mouse events"),
            id (DISPID_SPRITE_PROP_MOUSEEVENTSENABLED)
        ]
        HRESULT MouseEventsEnabled ([out, retval] VARIANT_BOOL* Enabled);

        [propput,
            helpstring("Enables or disables mouse events"),
            id (DISPID_SPRITE_PROP_MOUSEEVENTSENABLED)
        ]
        HRESULT MouseEventsEnabled ([in] VARIANT_BOOL Enabled);

// TimerInterval
        [propget,
            helpstring("Sets or returns the interval between sprite frame updates"),
            id(DISPID_SPRITE_PROP_TIMERINTERVAL)
        ]
        HRESULT TimerInterval([out, retval] double* Interval);

        [propput,
            helpstring("Sets or returns the interval between sprite frame updates"),
            id(DISPID_SPRITE_PROP_TIMERINTERVAL)
        ]
        HRESULT TimerInterval([in] double Interval);

        //
        // Methods
        //

// AddFrameMarker
        [
            helpstring("Creates a marker that fires an event when playback reaches the designated frame"),
            id (DISPID_SPRITE_METH_ADDFRAMEMARKER)
        ]
        HRESULT AddFrameMarker ([in] unsigned int iFrame, [in] BSTR MarkerName, [in,optional] VARIANT Absolute);

// AddTimeMarker
        [
            helpstring("Creates a marker that fires an event at a specific time"),
            id (DISPID_SPRITE_METH_ADDTIMEMARKER)
        ]
        HRESULT AddTimeMarker ([in] double dblTime, [in] BSTR MarkerName, [in,optional] VARIANT Absolute);

// Play
        [
            helpstring("Starts playback of the sprite"),
            id (DISPID_SPRITE_METH_PLAY)
        ]
        HRESULT Play ();

// Stop
        [
            helpstring("Stops playback and resets the sprite to the beginning"),
            id (DISPID_SPRITE_METH_STOP)
        ]
        HRESULT Stop ();

// Pause
        [
            helpstring("Stops playback of the sprite and maintains current position"),
            id (DISPID_SPRITE_METH_PAUSE)
        ]
        HRESULT Pause ();

// Seek
        [
            helpstring("Sets the sprite playback position to a specific elapsed time"),
            id (DISPID_SPRITE_METH_SEEK)
        ]
        HRESULT Seek ([in] double dblTime);

// FrameSeek
        [
            helpstring("Sets the sprite playback position to a specific frame"),
            id (DISPID_SPRITE_METH_FRAMESEEK)
        ]
        HRESULT FrameSeek ([in] unsigned int iFrame);
    }

    //
    // Event dispatch interface for SpriteCtl
    //

    [
        uuid(FD179532-D86E-11d0-89D6-00A0C90833E6),  //DIID_ISpriteCtlEvents
        helpstring ("Event interface for SpriteCtl")

    ]
    dispinterface ISpriteCtlEvents
    {
        properties:
        methods:

// OnPlayMarker
            [
                id(DISPID_SPRITE_EVENT_ONPLAYMARKER),
                helpstring("Occurs when a marker is reached during sprite playback"),
            ]
            void onplaymarker(BSTR MarkerName);

// OnMarker
            [
                id(DISPID_SPRITE_EVENT_ONMARKER),
                helpstring("Occurs when a marker is reached"),
            ]
            void onmarker(BSTR MarkerName);

// OnMouseMove
            [
                id(DISPID_SPRITE_EVENT_MOUSEMOVE),
                helpstring("Occurs when the mouse moves over an opaque region of the control")
            ]
            void onmousemove(long Button, long Shift, long X, long Y);

// OnMouseOver
            [
                id(DISPID_SPRITE_EVENT_MOUSEENTER),
                helpstring("Occurs when the mouse enters an opaque region of the control")
            ]
            void onmouseover();

// OnMouseOut
            [
                id(DISPID_SPRITE_EVENT_MOUSELEAVE),
                helpstring("Occurs when the mouse leaves an opaque region of the control")
            ]
            void onmouseout();

// OnMouseDown
            [
                id(DISPID_SPRITE_EVENT_MOUSEDOWN),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and a mouse button is depressed")
            ]
            void onmousedown(long Button, long Shift, long X, long Y);

// OnMouseUp
            [
                id(DISPID_SPRITE_EVENT_MOUSEUP),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and a mouse button is released")
            ]
            void onmouseup(long Button, long Shift, long X, long Y);

// OnDblClick
            [
                id(DISPID_SPRITE_EVENT_DBLCLICK),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and the mouse button is double-clicked")
            ]
            void ondblclick();

// OnClick
            [
                id(DISPID_SPRITE_EVENT_CLICK),
                helpstring("Occurs when the mouse pointer is over an opaque region of the control and the mouse button is clicked once")
            ]
            void onclick();

// OnMediaLoaded
            [
                id(DISPID_SPRITE_EVENT_ONMEDIALOADED),
                helpstring("Occurs when the sprite media is completely downloaded")
            ]
            void onmedialoaded(BSTR URL);

// OnSeek
            [
                id(DISPID_SPRITE_EVENT_ONSEEK),
                helpstring("Occurs after the Seek method is called")
            ]
            void onseek(double Time);

// OnFrameSeek
            [
                helpstring("Occurs after the FrameSeek method is called"),
                id (DISPID_SPRITE_EVENT_ONFRAMESEEK)
            ]
            HRESULT onframeseek(unsigned int Frame);

// OnStop
            [
                helpstring("Occurs when sprite playback stops"),
                id (DISPID_SPRITE_EVENT_ONSTOP)
            ]
            HRESULT onstop();

// OnPause
            [
                helpstring("Occurs when sprite playback is paused"),
                id (DISPID_SPRITE_EVENT_ONPAUSE)
            ]
            HRESULT onpause();

// OnPlay
            [
                helpstring("Occurs when sprite playback starts"),
                id (DISPID_SPRITE_EVENT_ONPLAY)
            ]
            HRESULT onplay();

    };


    //
    //  Class information for SpriteCtl

    [
        uuid(FD179533-D86E-11d0-89D6-00A0C90833E6), // CLSID_SpriteCtl
        helpstring("Sprite Control"), control //TODO: Change this string
    ]

    coclass SpriteControl
    {
        [default] interface ISpriteCtl;
        [default, source] dispinterface ISpriteCtlEvents;
    };


////////////////////////////////////////////////////////////////////////
// Sequencer control
//
    [
        uuid(4F241DB0-EE9F-11d0-9824-006097C99E51), // IID_IMMSeq
        helpstring("Dual interface for MMSeq Control"),
        oleautomation,
        hidden,
        nonextensible,
        dual,
        odl
    ]

    //
    // Custom interface definition
    //

    interface IMMSeq : IDispatch
    {
    //
    // Properties

// Time
        [propget,
            //helpstring("Returns the current time value"),
            id(DISPID_SEQ_PROP_TIME)
        ]
        HRESULT Time ([out, retval] double * pdblCurrentTime);

//PlayState
        [propget,
            //helpstring("Returns the current play state"),
            id(DISPID_SEQ_PROP_PLAYSTATE)
        ]
        HRESULT PlayState ([out, retval] int * piPlayState);

// _Cookie
        [propput,
            restricted,
            id(DISPID_SEQ_PROP_COOKIE)
        ]
        HRESULT _Cookie([in] long lCookie);

        [propget,
            restricted,
            id(DISPID_SEQ_PROP_COOKIE)
        ]
        HRESULT _Cookie([out, retval] long*plCookie);

        //
        // Methods

// Play
        [
            //helpstring("Play the Sequencer"),
            id(DISPID_SEQ_METH_PLAY)
        ]
        HRESULT Play();

// Pause
        [
            //helpstring("Pause the Sequencer"),
            id(DISPID_SEQ_METH_PAUSE)
        ]
        HRESULT Pause();

// Stop
        [
            //helpstring("Stop the Sequencer"),
            id(DISPID_SEQ_METH_STOP)
        ]
        HRESULT Stop();

// At
        [
            //helpstring("Add an Action to the sequencer"),
            id(DISPID_SEQ_METH_AT)
        ]
        HRESULT At([in] VARIANT varStartTime, [in] BSTR bstrScriptlet,
                   [in, optional] VARIANT varRepeatCount, [in,optional] VARIANT varSampleRate,
                   [in,optional] VARIANT varTiebreakNumber, [in,optional] VARIANT varDropTolerance);

// Clear
        [
            //helpstring("Clear the Sequencer Actions"),
            id(DISPID_SEQ_METH_CLEAR)
        ]
        HRESULT Clear();

// Seek
        [
            //helpstring("Seek to a particular time"),
            id(DISPID_SEQ_METH_SEEK)
        ]
        HRESULT Seek([in]double dblSeekTime);

    }


    //
    // Event dispatch interface for MMSeq
    //

    [
        uuid(4F241DB2-EE9F-11d0-9824-006097C99E51),
        helpstring ("Event interface for MMSeq")
    ]
    dispinterface IMMSeqEvents
    {
        properties:
        methods:

// OnPlay
        [
            id(DISPID_SEQ_EVENT_ONPLAY)
        ]
        void onplay(long lCookie);

// OnStop
        [
            id(DISPID_SEQ_EVENT_ONSTOP)
        ]
        void onstop(long lCookie);

// OnPause
        [
            id(DISPID_SEQ_EVENT_ONPAUSE)
        ]
        void onpause(long lCookie);

// OnSeek
        [
            id(DISPID_SEQ_EVENT_ONSEEK)
        ]
        void onseek(long lCookie, double dblSeekTime);

    };


    //
    //  Class information for CMMSeq
    //

    [
        uuid(4F241DB1-EE9F-11d0-9824-006097C99E51), // CLSID_MMSeq
        helpstring("MMSeq Control"),
        control,
        hidden
    ]

    coclass MMSeq
    {
        [default] interface IMMSeq;
        [default, source] dispinterface IMMSeqEvents;
    };

////////////////////////////////////////////////////////////////////////
// Sequencer manager control
//
    [
        uuid(B0A6BAE0-AAF0-11d0-A152-00A0C908DB96), // IID_IMMSeqMgr
        helpstring("Dual interface for MMSeqMgr Control"),
        oleautomation,
        dual,
        odl
    ]

    //
    // Custom interface definition

    interface IMMSeqMgr : IDispatch
    {

        // Properties
        [propget,
            id(DISPID_VALUE),
            helpstring("Returns an Action Set")
        ]
        HRESULT Item([in] VARIANT variant, [out, retval] IDispatch** ppdispatch);

        [propget,
            id(DISPID_NEWENUM),
            hidden
        ]
        HRESULT _NewEnum([out, retval] IUnknown** pUnk);

        [propget,
            helpstring("Returns the number of Action Sets in the collection"),
            id(DISPID_SEQMGR_PROP_COUNT)
        ]
        HRESULT Count([out, retval] long* plCount);

        // Methods
        [
            id(DISPID_SEQMGR_METH_RELAYEVENT),
            restricted
        ]
        HRESULT RelayEvent([in]long dispid, [in]long lCookie, [in]double dblSeekTime);
    }


    [
        uuid(B0A6BAE1-AAF0-11d0-A152-00A0C908DB96),
        helpstring ("Event interface for MMSeq")
    ]
    dispinterface IMMSeqMgrEvents
    {
        properties:
        methods:

// OnInit
        [
            id(DISPID_SEQMGR_EVENT_INIT),
            helpstring("Occurs when the sequencer is ready to be initialized")
        ]
        void oninit(void);

// OnPlay
        [
            id(DISPID_SEQMGR_EVENT_ONPLAY),
            helpstring("Occurs when an Action Set starts playback")
        ]
        void onplay([in]BSTR bstrTimeline);

// OnStop
        [
            id(DISPID_SEQMGR_EVENT_ONSTOP),
            helpstring("Occurs when an Action Set stops playing")
        ]
        void onstop([in]BSTR bstrTimeline);

// OnPause
        [
            id(DISPID_SEQMGR_EVENT_ONPAUSE),
            helpstring("Occurs when playback of an Action Set is paused")
        ]
        void onpause([in]BSTR bstrTimeline);

// OnSeek
        [
            id(DISPID_SEQMGR_EVENT_ONSEEK),
            helpstring("Occurs when an Action Set seeks to a new time")
        ]
        void onseek([in]BSTR bstrTimeline, [in] double dblSeekTime);
    };


    //
    //  Class information for CMMSeqMgr

    [
        uuid(B0A6BAE2-AAF0-11d0-A152-00A0C908DB96), // CLSID_MMSeqMgr
        helpstring("MMSeqMgr Control"), control
    ]

    coclass SequencerControl
    {
        [default] interface IMMSeqMgr;
        [default, source] dispinterface IMMSeqMgrEvents;
    };

};
