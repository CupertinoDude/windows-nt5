<chp id=avr_ref><ti>ActiveVRML Reference Manual
<if rid=HTML>
<h1><ti></ti>
<p>This document contains the ActiveVRML reference. 

<list>
<i><art name=yeldot.gif align=inline></art><xref rid=intro></xref>
<d><art name=yeldot.gif align=inline></art><xref rid=single_user_interactivity></xref>
<i><art name=yeldot.gif align=inline></art><xref rid=expr_dec></xref>
<d><art name=yeldot.gif align=inline></art><xref rid=picking_images_and_geometry></xref>
<i><art name=yeldot.gif align=inline></art><xref rid=basic_types></xref>
<d><art name=yeldot.gif align=inline></art><xref rid=pattern_matching></xref>
<i><art name=yeldot.gif align=inline></art><xref rid=reactive_behaviors></xref>
<d><art name=yeldot.gif align=inline></art><xref rid=world_wide_web_browsing></xref>
<i><art name=yeldot.gif align=inline></art><xref rid=reactive_types></xref>
<d><art name=yeldot.gif align=inline></art><xref rid=viewer_conventions_and_information></xref>
<i><art name=yeldot.gif align=inline></art><xref rid=modeling_types></xref>
<d><art name=yeldot.gif align=inline></art><xref rid=grammar_and_lexical_conventions></xref>
<i><art name=yeldot.gif align=inline></art><xref rid=integration_differentiation_and_interpolation></xref>
</list>
<endif rid=HTML>

<h1 id=intro><ti>Introduction

<p>This document presents a technical summary of the Active Virtual Reality Modeling Language (ActiveVRML). It provides a brief but reasonably precise definition of ActiveVRML version 1.0. Those seeking an introduction to ActiveVRML should consult the companion paper, <e>An Introduction To ActiveVRML</e>.

<p>ActiveVRML is intended to provide a framework for constructing models that manipulate media including sound, two dimensional (2D) images, and three dimensional (3D) geometry. There are two characteristics that make ActiveVRML unique and especially well suited for this task: all values in ActiveVRML potentially vary with time, and values may change in reaction to events. 

<p>Every value in ActiveVRML may change with time. For example, there is an image type in ActiveVRML. An image object is not like a static photograph, but more like a video, continuously changing with time. Similarly, geometry in ActiveVRML is not like a static geometry model, but is (potentially) animated, moving, and reacting to events. This is an important principle in ActiveVRML; <e>every value</e> may change with time. Even simple objects, like numbers, may change with time. Values that can vary with time are called <e>behaviors</e> in ActiveVRML. A reactive behavior is one that (potentially) varies in response to events.

<p>One way that values change with time is in response to particular events. For example, a user input event, or a mouse event. Events may be caused by internal events (to the ActiveVRML model) as well. For example, a particular number value being zero may cause an event.

<p>Finally, ActiveVRML is a language for describing media via reactive behaviors. The language part of ActiveVRML is actually very small. The bulk of this document is spent describing a large collection of useful library functions for manipulating media types.

<h1 id=expr_dec><ti>Expressions and Declarations

<p>ActiveVRML is fundamentally very simple; it has just a handful of expression forms and only two forms for declaring identifiers. This section describes these forms. The power of ActiveVRML comes from the underlying model which includes time varying values, reactivity, and a rich set of media types. These are described in subsequent sections.

<h2 id=lit_con><ti>Literal and Constructor Expressions

<p>Associated with most types in ActiveVRML is a literal or constructor form for each. Examples include 17 which represents a literal number, and [1, 2, 3], which uses the constructor form for lists to build a list of numbers. Allowable constructor forms are defined below in the sections defining each type.

<h2 id=var><ti>Variable Expressions

<p>An identifier in ActiveVRML is an arbitrarily long string of alpha-numeric characters beginning with a letter. Identifiers are case sensitive and there are some keywords (listed in Appendix A) that may not be used as identifiers.

<p>Variables in ActiveVRML are statically scoped. 

<h2><ti>Application Expressions

<p>An expression of the form <e>expression1 expression2</e> is an application expression and represents the value of applying the function value of <e>expression1</e> to the value of <e>expression2</e>. ActiveVRML is strict; that is, it obeys call by value semantics for argument evaluation. The order of the evaluation of arguments is not specified. Argument application associates left; for example, f(x)(y) equates to (f(x))(y).

<h2><ti>Parenthetical Expressions

<p>Parentheses may be used to group expressions and override operator precedence. Parentheses are also useful for improving the readability and presentation of ActiveVRML models. Operator precedence in ActiveVRML is listed in Appendix A.

<h2><ti>If Expressions

<p>A construct of the form 

<ex>if expression1 then expression2 else expression3 
</ex>

<p>is an <k>IF</k> expression. It represents the value returned by evaluating the boolean test of <e>expression1</e> and selecting <e>expression2</e> or <e>expression3</e> depending upon the true value of <e>expression1</e>. The types of the two branches of the <k>IF</k> expression are required to match (or unify). There is no corresponding <e S>IF THEN</e> statement; all <k>IF</k> statements have both branches. Since ActiveVRML is functional (operations do not have side effects), such one-armed <k>IF</k> statements would not be very useful.

<h2><ti>Let Expressions

<p>A construct of the form
<ex>let 
	declaration1;
		.
		.
		.
	declaration[n];
in
	expression
</ex>


<p>is a <k>LET</k> expression. It represents the value of an expression when evaluated in a context that includes the bindings for <e>declaration1</e> through <e>declarationn</e>. The <k>LET</k> expression is used to introduce a local scope. The declarations are evaluated simultaneously. The names are in scope of the right hand sides of the declarations, allowing for forward declarations and mutual recursion automatically. All of the declared identifiers are required to be distinct. The scope of the declarations is limited to the <k>LET</k> expression itself. The semicolon following the last declaration is optional.

<h2><ti>Declarations

<p>The simplest declarations declare an identifier to have a value:
<ex>identifier = expression
</ex>


<p>Or, they declare a function:
<ex>identifier(identifier, ..., identifier) = expression
</ex>


<p>The following is an example function declaration:
<ex>swizzle(seed) = 
	if seed = 1 then
		1
	else if odd(seed) then
		swizzle(seed * 3 + 1) + seed
	else
		swizzle(seed / 2) + seed
</ex>


<p>This declares a function, <e>swizzle</e>, that takes one formal argument, <e>seed</e>. The function is recursive. All function declarations are assumed to be recursive. When you use the name of the function you are declaring within the expression, you are referring to the function itself, not a new or different function.

<p>The following is an example variable declaration:
<ex>swizit = swizzle(27)
</ex>


<p>This declares the variable <e>swizit</e> to be the evaluation of the expression <e>swizzle</e>(<e>27</e>). We can illustrate scoping in <k>LET</k> expressions by combining these declarations along with a declaration for the predicate <e>odd</e> used in the declaration of <e>swizzle</e>:
<ex>let 
	swizzle(seed) = 
		if seed = 1 then
			1
		else if odd(seed) then
			swizzle(seed * 3 + 1) + seed
		else
			swizzle(seed / 2) + seed;
	odd(i) = (mod(i, 2) = 1);
	swizit = swizzle(27)
in
	swizit
</ex>


<p>Notice that the declaration for <e>odd</e> comes after its use in the declaration of <e>swizzle</e>. Since all of the declarations within a <k>LET</k> expression are assumed to be mutually recursive, this is legal. However, for better readability and because the declarations are not truly mutually recursive, the definition of <e>odd</e> should probably appear first.

<p>Within the scope of the <k>LET</k> expression, three identifiers are declared, <e>swizzle</e>, <e>odd</e>, and <e>swizit</e>. Beyond the scope of this expression, the three declarations are not available. The value of the <k>LET</k> expression is the value of <e>swizit</e> which evaluates to 101440.

<p>In addition to these simple forms of variable and function declarations, it is also possible to use pattern matching to specify the destructuring of values within a declaration. This is described later in this document.

<p>In addition to the local declarations in an ActiveVRML file, it's possible to augment the environment with declarations from a second file with the <k>use</k> keyword:
<ex>use (pathname)
</ex>
<p>This keyword must be used as a top level declaration.

<h1 id=basic_types><ti>Basic Types

<p>ActiveVRML includes a very powerful and useful typing system. Each expression and declaration in ActiveVRML is given a type either explicitly by the user, or implicitly by the system. Consider the following example declaration:
<ex>successor(nat) = nat + 1
</ex>


<p>ActiveVRML assigns <e>successor</e> the type <e>number -> number</e>, meaning it will map any value of type number to another value of type number. This typing is <e>strong</e> in the sense that ActiveVRML will catch all type errors during authoring. It is also convenient; the user did not have to explicitly give the type as the system inferred it.

<p>Finally, types are <e>polymorphic</e>, meaning that a given type may stand for many different type instances. Consider the following declaration:
<ex>nada(val) = val
</ex>


<p>When applied, <e>nada</e> will return its actual argument unchanged. Thus <e>nada</e>(<e>3</e>) evaluates to the number 3 and <e>nada</e>(<e>"hello"</e>) evaluates to the string "hello". The type that ActiveVRML infers for nada is polymorphic: <e>&alpha; -> &alpha; </e>. Here &alpha; is a <e>type identifier</e> and may be replaced everywhere uniformly to create an instance of a polymorphic type. Thus, <e>number -> number</e> is an instance of <e>&alpha; -> &alpha;</e>, and so is <e>string -> string</e>.

<p>Note that <e>number -> string</e> is not an instance of <e>&alpha; -> &alpha; </e>, since one <e>&alpha; </e>  was replaced by a number and the other by a string (not uniformly). A polymorphic type can contain more than one type identifier, for example, <e>&alpha; -> &beta;</e>. In this case, each identifier can be replaced separately. Thus, <e>number -> &beta;</e>, <e>&alpha; -> string</e>, <e>number -> string</e>, <e>number -> number</e>, and <e>&gamma; -> string</e> are all instances of the polymorphic type <e>&alpha; -> &beta;</e>.

<note><ti>Note
<p>In deference to the typographically-challenged ASCII character set, the type assigned to nada is actually written 'a -> 'a. In typeset ActiveVRML documents, including this one, Greek letters are often used instead of the ASCII syntax for type identifiers in order to improve readability.
</note>

<p>Every expression and declaration in ActiveVRML is assigned a type by the system using a standard Milner-Damas polymorphic type checker. Except to improve exposition and occasionally to resolve ambiguity with an overloaded operator, it is not necessary for the programmer to explicitly give types. An expression may be qualified with a type using the syntax like the following: 

<ex>expression: type-expression
</ex>

<p>For example, the following syntax can be used to restrict <e>nada</e> to a particular type (desirable for clarity):
<ex>nada(val: string) = val
</ex>


<p>This will assign <e>nada</e> the <e>monomorphic</e> type <e>string -> string</e>.

<p>The following sections define the basic types for ActiveVRML and list the constructor forms and functions for these types. Later sections define types for reactivity and for modeling (geometry, images, and associated types).


<ref>Unit Type: unit

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>unit</kd>
	<d>The <k>unit</k> type is a trivial type containing only one member. This type is often used for functions that take or return uninteresting data, similar to the way that the <e>void</e> type is used in C++ programs.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i>()
	<d>The unique member of the unit type, pronounced "trivial."
</list>
</ref>

<ref>Function Type: type -> type

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>type -> type</kd>
	<d>The function type <e>&alpha; -> &beta;</e> represents mappings from type <e>&alpha;</e> to type <e>&beta;</e>. Functions in ActiveVRML may be <e>higher-order</e>, meaning that a function can take another function as an argument or return a function as its result. For example, function <e>f</e> might have type (<e>number -> number</e>)<e> -> number</e>. This means that <e>f</e> can be applied to a function with type <e>number -> number</e> to produce a result of type <e>number</e>. Another function <e>g</e> might have type <e>number-</e>>(<e>number -> number</e>). This means that <e>g</e> will take a number as an argument, and produce a function with type <e>number -> number</e> as its result.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>function pattern</kd> . <k>expression</k>
	<d>This constructor is used to create anonymous function values. The pattern part of this constructor (described in the "Pattern Matching" section) may be thought of as a list for formal arguments. For example, the declaration
<ex>f (x, y) = x * y + 1
</ex>

	<d>can be thought of as an abbreviation for:
<ex>f = function (x, y). x * y + 1
</ex>

	<d>Function declarations are value declarations where the value is a function value.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd id=composition>infix o </kd>: (<e>&alpha; -> &beta;</e>) <e>*</e> (<e>&beta; -> &gamma;</e>) <e>-</e>> (<e>&alpha; -> &gamma;</e>)
	<d>The expression <e>f o g</e> is the <e>composition</e> of the functions <e>f</e> and <e>g</e>. The notation <k>infix</k> <k>o</k> means that <k>o</k> is an infix operator (like the familiar <k>+</k> as in 14 <k>+</k> 3). The value of (<e>f o g</e>)(<e>x</e>) is <e>f</e>(<e>g</e>(<e>x</e>)). Note that <k>o</k> has a type like a higher-order function. It takes two functions as arguments and returns a function as its result. Its type can be written as ((<e>&alpha; -> &beta;</e>) <e>*</e> (<e>&beta; -> &gamma;</e>)) <e>-</e>> (<e>&alpha; -> &gamma;</e>) since <e>*</e> has higher precedence than <e>-</e>> in ActiveVRML types. (See ActiveVRML Type Precedence later in this document.)

</list>
</ref>
<ref>Product Type: type * type

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>type * type</kd>
	<d>The product type <e>&alpha; * &beta;</e> represents pairs of elements: for example, (<e>e1</e>, <e>e2</e>) where <e>e1</e> has type <e>&alpha;</e> and <e>e2</e> has type <e>&beta;</e>.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd id=pairing>expression</kd>, <k>expression</k>
	<d>The pairing constructor is a comma. The precedence of the comma is extremely low in ActiveVRML, so it is usually desirable (and visually clearer) to write pairing with parentheses: (<e>3</e>, <e>"hello"</e>).
	<d>The pairing operator associates to the right. Thus, (<e>3</e>, <e>"hello"</e>, <e>17</e>) is the same as (<e>3</e>, (<e>"hello"</e>, <e>17</e>)). It is a pair, the second element of which is also a pair.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>first</kd>: <e>&alpha; * &beta; -> &alpha;</e>
	<d><k>first</k>(<e>&alpha;</e>, <e>&beta;</e>) returns the first element of a pair, <e>&alpha;</e>. 
<i><kd>second</kd>: <e>&alpha; * &beta; -> &beta;</e>
	<d><k>second</k>(<e>&alpha; </e>, <e>&beta;</e>) returns the second element of a pair, <e>&beta;</e>.

</list>
</ref>
<ref>List Type: list

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><e>&alpha; </e> <kd>list</kd>
	<d>The type <e>&alpha; </e> <k>list</k> is a list (or finite sequence). Each element is of type <e>&alpha; </e>. For example, <e>number list</e> is a list of numbers, and (<e>string list</e>) <e>list</e> is a list where each element is a list of strings. 
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd id=expression_list>[expression-list]</kd>
	<d>A list of expressions (zero or more) separated by commas. For example, <e>[]</e> is the null list (of type <e>&alpha; list</e>) and <e>[1</e>, <e>2</e>, <e>3]</e> is a number list.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>head</kd>: <e>&alpha; list -> &alpha; </e>
	<d><k>head</k>(<e>list</e>) returns the first element of the <e>list</e> list. It is illegal to apply <kd>head</kd> to an empty list.
<i><kd>tail</kd>: <e>&alpha; list -> &alpha; list</e>
	<d><k>tail</k>(<e>list</e>) returns a list comprising all but the first element of the original list. It is illegal to apply <k>tail</k> to an empty list.
<i><kd id=constructor>infix:: </kd>: <e>&alpha; * &alpha; list -> &alpha; list</e>
	<d>The operator <k>:: i</k>s read as "cons." The expression <e>elt</e><k>:: l</k>is<e>t</e> returns a new list formed by prepending ("cons'ing") <e>elt</e> to <e>list</e>.
<i><kd>empty</kd>: <e>&alpha; list -> boolean</e>
	<d><k>empty</k>(<e>list</e>) is true if and only if <e>list</e> is an empty list.
<i><kd>length</kd>: <e>&alpha; list -> number</e>
	<d><k>length</k>(<e>list</e>) returns the length of <e>list</e>.
<i><kd>map</kd>: (<e>&alpha; -> &beta;</e>) <e>*</e> (<e>&alpha; list</e>) <e>-> &beta;list</e>
	<d><k>map</k>(<e>fun</e>, <e>list</e>) returns a list by applying <e>fun</e> to each element of <e>list</e>.
<i><kd>reduce</kd>: (<e>&alpha; * &beta; -> &beta;</e>) * <e>&beta;</e> * (<e>&alpha; </e> list) -> <e>&beta;</e>
	<d><k>reduce</k>(<e>[e1</e>,<e>...</e>,<e>en]</e>, <e>base</e>, <e>fun</e>) returns:
<ex>fun(e1, fun(e2, fun(...,fun(en-1, fun(en, base))...)))
</ex>

<i><kd>nth</kd>: <e>&alpha; list * number -> &alpha; </e>
	<d><k>nth</k>(<e>list</e>, <e>n</e>) returns the <e>n</e>th element of <e>list</e>, where the first element of the list is 1.

</list>
</ref>
<ref>Boolean Type: boolean

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>boolean</kd>
	<d>The <k>boolean</k> type represents true and false values in ActiveVRML.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>true</kd>
	<d>Constructs a true value.
<i><kd>false</kd>
	<d>Constructs a false value.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>infix and</kd>: <e>boolean * boolean -> boolean</e>
	<d>The expression <e>x</e> <k>and</k> <e>y</e> is true if <e>x</e> and <e>y</e> are true.
<i><kd>infix or</kd>: <e>boolean * boolean -> boolean</e>
	<d>The expression <e>x</e> <k>or</k> <e>y</e> is true if either <e>x</e> or <e>y</e> are true.
<i><kd>not</kd>: <e>boolean -> boolean</e>
	<d>The expression <k>not</k> <e>x</e> is true if <e>x</e> is false.
<i><kd id=equality>infix =</kd>: <e>&alpha; * &alpha; -> boolean</e>
	<d>Equality may be used to compare any two values with the same type. Equality in ActiveVRML is structural: pairs are equal if each side of the pair is equal; lists are equal if their lengths are the same and corresponding elements of each list are equal. Equality applied to functions and modeling types is not defined (since it is not always possible to determine equality on these types).

<i><kd id=inequality>infix</kd> <>: <e>&alpha; * &alpha; -> boolean</e> 
	<d>The expression <e>x</e> <> <e>y</e> is true if <e>x</e> is not equal to <e>y</e>.

</list>
</ref>
<ref>Number Type: number

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>number</kd>
	<d>The <k>number</k> type in ActiveVRML does not distinguish between "fixed point" and "floating point" numbers; both are considered numbers. The implementation will choose an appropriate representation.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>number-literal</kd>
	<d>The <k>number-literal</k> constructor is any sequence of characters satisfying the following regular expression:
<ex>digit+ ('.' digit*)? (['e' 'E'] ['+' '-']?digit+)?
</ex>

<i><kd>time</kd>
	<d>A time-varying number representing the local time of a behavior. This important constructor is the basis for many interesting time-varying behaviors. 
<i><kd>random</kd>
	<d>A pseudo-random number in <e>[0</e>, <e>1]</e> that is time-varying. All instances of <k>random</k> that start at the same global time have the same time-varying value.
<i><kd>pi</kd>
	<d>A constant number representing &pi;.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd id=addition>infix +</kd>: <e>number * number -> number</e>
	<d>The expression <e>x</e> <k>+</k> <e>y</e> returns the value of <e>x</e> added to <e>y</e>.
<i><kd id=multiplication>infix *</kd>: <e>number * number -> number</e>
	<d>The expression <e>x</e> <k>*</k> <e>y</e> returns the value of <e>x</e> multiplied to <e>y</e>.
<i><kd id=subtraction>infix -</kd>: <e>number * number -> number</e>
	<d>The expression <e>x</e> <k>-</k> <e>y</e> returns the value of <e>y</e> subtracted from <e>x</e>.
<i><kd id=division>infix</kd> /: <e>number * number -> number</e>
	<d>The expression <e>x</e> /<e>y</e> returns the value of <e>x</e> divided by <e>y</e>. Division by zero is an error.
<i><kd id=negative>prefix -</kd>: <e>number -> number</e>
	<d>The expression <k>-</k>x returns the value of <e>x</e> multiplied by <e>-1</e>.
<i><kd id=positive>prefix +</kd>: <e>number -> number</e>
	<d>The prefix <k>+</k> operator does not change the value of a number.
<i><kd id=less_than>infix</kd> <: <e>number * number -> boolean</e>
	<d>The expression <e>x</e> < <e>y</e> returns true if the value of <e>x</e> is less than the value of <e>y</e>.
<i><kd id=less_than_equal>infix</kd> <=: <e>number * number -> boolean</e>
	<d>The expression <e>x</e> <<k>=</k> <e>y</e> returns true if the value of <e>x</e> is less than or equal to the value of <e>y</e>.
<i><kd id=greater_than>infix</kd> >: <e>number * number -> boolean</e>
	<d>The expression <e>x</e> ><e>y</e> returns true if the value of <e>x</e> is greater than the value of <e>y</e>.
<i><kd id=greather_than_equal>infix >=</kd>: <e>number * number -> boolean</e>
	<d>The expression <e>x</e> >=<e>y</e> returns true if the value of <e>x</e> is greater than or equal to the value of <e>y</e>.
<i><kd>abs</kd>: <e>number -> number</e>
	<d><k>abs</k>(<e>x</e>) returns the absolute value of <e>x</e>.
<i><kd>sqrt</kd>: <e>number -> number</e>
	<d><k>sqrt</k>(<e>x</e>) returns the square root of <e>x</e>.
<i><kd>mod</kd>: <e>number * number -> number</e> 
	<d><k>mod</k>(<e>x</e>, <e>y</e>) returns the modulus of <e>x</e> divided by <e>y</e>.
<i><kd>ceiling</kd>: <e>number -> number</e>
	<d><k>ceiling</k>(<e>x</e>) returns the smallest integer that is greater than or equal to <e>x</e>.
<i><kd>floor</kd>: <e>number -> number</e>
	<d><k>floor</k>(<e>x</e>) returns the largest integer that is less than or equal to <e>x</e>.
<i><kd>round</kd>: <e>number -> number</e>
	<d><k>round</k>(<e>x</e>) returns the nearest integer to <e>x</e>.
<i><kd>radiansToDegrees</kd>: <e>number -> number</e>
	<d><k>radiansToDegrees</k>(<e>x</e>) returns <e>x</e> expressed in degrees.
<i><kd>degreesToRadians</kd>: <e>number -> number</e>
	<d><k>degreesToRadians</k>(<e>x</e>) returns <e>x</e> expressed in radians.
<i><kd>asin</kd>: <e>number -> number</e>
	<d><k>asin</k>(<e>x</e>) returns the arcsine of <e>x</e>.
<i><kd>acos</kd>: <e>number -> number</e>
	<d><k>acos</k>(<e>x</e>) returns the arccosine of <e>x</e>.
<i><kd>atan</kd>: <e>number * number -> number</e>
	<d><k>atan</k>(<e>h</e>, <e>w</e>) returns the arctangent of <e>h divided by w</e> in radians.
<i><kd>atan</kd>: <e>number -> number</e>
	<d><k>atan</k>(<e>x</e>) returns the arctangent of <e>x</e>.
<i><kd>cos</kd>: <e>number -> number</e>
	<d><k>cos</k>(<e>x</e>) returns the cosine of <e>x</e> in radians.
<i><kd>sin</kd>: <e>number -> number</e>
	<d><k>sin</k>(<e>x</e>) returns the sine of <e>x</e> in radians.
<i><kd>tan</kd>: <e>number -> number</e>
	<d><k>tan</k>(<e>x</e>) returns the tangent of <e>x</e> in radians.
<i><kd id=power>infix ^</kd>: <e>number * number -> number</e>	
	<d>The expression <e>x</e> <k>^</k> <e>y</e> returns <e>x</e> raised to the power of <e>y</e>.
<i><kd>exp</kd>: <e>number -> number</e>
	<d><k>exp</k>(<e>x</e>) returns the exponential value of <e>x</e>.
<i><kd>ln</kd>: <e>number -> number</e>
	<d><k>ln</k>(<e>x</e>) returns the natural logarithm of <e>x</e>.
<i><kd>log10</kd>: <e>number -> number</e>
	<d><k>log10</k>(<e>x</e>) returns the base 10 logarithm of <e>x</e>.
<i><kd>seededRandom</kd>: <e>number -> number</e>
	<d>Pseudorandom behavior is parameterized by a random seed. <k>SeededRandom</k> returns <e>x</e> in <e>[0</e>, <e>1]</e>, implicitly parameterized by time.
<i><kd>cubicBSpline</kd>: <e>number list * number list -> (number -> number)</e>
	<d>cubicBSpline(<e>knots, control points</e>) creates a polynomial, real-valued B-spline function of degree three. 
<i><kd>nurb</kd>: <e>number list * number list * number list -> (number -> number)</e>
	<d>nurb(<e>knots, control points, weights</e>) creates a rational, real-valued B-spline function of degree three.
</list></ref>

<h1 id=reactive_behaviors><ti>Reactive Behaviors

<p>Recall that all values in ActiveVRML are potentially time-varying. Variation is achieved by specifying the time explicitly (for example, <e>3 + time</e>), input such as mouse motion, or by reactivity. This section defines reactivity and the constructs used to build reactive behaviors.

<h2><ti>Reactivity

<p>A reactive behavior is one that can potentially react to an event. The following is a very simple reactive behavior:
<ex>red until leftButtonPress => green
</ex>


<p>In this expression, <k>UNTIL</k> is the main operator. The expression is parsed into the following:
<ex>red until (leftButtonPress => green)
</ex>


<p>The reactive behavior changes the color from red to green when the mouse button is pressed.

<p>The subexpression <e>leftButtonPress => green</e> is called a handler. It pairs up an event, <e>leftButtonPress</e>, with a value, <e>green</e>. The value is the action taken when the event occurs.

<p>The <k>UNTIL</k> construct can also be used to watch for more than one event, reacting to the first one that occurs. For example:
<ex>red until leftButtonPress => green | rightButtonPress => yellow
</ex>


<p>This is parsed into the following:
<ex>red until ( (leftButtonPress => green) 
		| (rightButtonPress => yellow) )
</ex>


<p>The color remains red until either the left or right mouse buttons are pressed. If the left button is pressed, the color changes to green. If the right button is pressed, the color changes to yellow.

<p>In general, the logic of the <k>UNTIL</k> operator follows this pattern:
<ex>b0 until e1 => b1
	| e2 => b2
	.
	.
	.
	| en => bn
</ex>


<p>The reactive behavior is <e>b0</e> until any one of the events occurs, <e>e1</e> through <e>en</e>. The first event to occur, <e>ei</e>, results in the behavior, <e>bi</e>. 

<p>A more advanced form of events uses event data to produce the next behavior. For example:
<ex>0 until numEvent => function x. x + 1
</ex>


<p>In this case, <e>numEvent</e> is an event that produces a number. The value of this behavior is zero until the event occurs, and then becomes the value associated with the event plus 1.

<p>The type checking of an <k>UNTIL</k> expression is as follows: If <e>b</e> is an <e>&alpha;</e> behavior and <e>e</e> is an <e>&alpha;</e> event, then <e>b until e</e> is a reactive behavior with type <e>&alpha;</e> behavior.

<p>The next section describes events in more detail.

<h2><ti>Events and Reactivity

<p>An event can trigger a discrete change in a behavior. In addition to marking the occurrence of an event at a particular time, an event may also produce data. An <e>&alpha; </e> event produces some data of type <e>&alpha; </e> that can be used as new behavior after the event.

<p>Events are constructed from one of the following types of events.

<h3><ti>System Events

<p>System events represent user input events. All of the following are system events:

<ul>
<li>LeftButtonPress: <e>unit event</e>
<li>RightButtonPress: <e>unit event</e>
<li>KeyPress: <e>character event</e>
</ul>

<h3><ti>Boolean Events

<p>Events corresponding to a boolean behavior occur as soon as the boolean value is evaluated as true. The predicate function is used to construct an event from a boolean behavior. For example, <e>predicate</e>(<e>x = 0</e>) is a unit event (one that returns a unit as its data) that occurs the first time that behavior <e>x</e> is zero.

<h3><ti>Simple Handler Events

<p>New events may be constructed from other events. If <e>e</e> is a unit event (an event that does not produce interesting data) and <e>b</e> is an <e>&alpha; </e> behavior, then <e>e=>b</e> is a simple handler. In this example, the behavior is to wait for event <e>e</e> and before becoming <e>b</e>.

<h3><ti>Handler Events
<!--One reviewer suggested that these be renamed "handled events"?  What is your opinion?
Nate's opinion: Firstly, I see no big difference between the simple and complex handler events; I'd combine the two and not note the difference. Secondly, it seems like handler events are more like contingent events in that they are contingent on the event preceding them and the resulting data.-->

<p>More complex handler events use the data produced by an event to construct the resulting behavior. If <e>e</e> is an <e>&alpha; </e> event and <e>f</e> is a function with type <e>&alpha; -> &beta;</e>, then <e>e=>f</e> is a <e>&beta;</e> event. In this example, the behavior is to wait for event <e>e</e>, and then use the data produced by the event to run function <e>f</e>. The result is an event, <e>e=>f</e>, that occurs at the same time that <e>e</e> does and produces <e>f</e>(<e>x</e>) as the data, where <e>x</e> is the data produces by event <e>e</e>.

<h3><ti>Alternative Events

<p>If <e>e</e> and <e>e'</e> are <e>&alpha; </e> events, then <e>e | e'</e> is an <e>&alpha; </e> event. This means to choose whichever event, <e>e</e> or <e>e'</e>, happens first, and then return the corresponding data for the event. If <e>e</e> and <e>e'</e> happen at the same time, it is undefined which will be chosen.

<h3><ti>Filtered Events

<p>If <e>e</e> is an <e>&alpha;</e> event, and <e>p</e> is a function that maps <e>&alpha; </e> values to boolean values, then <e>suchThat</e>(<e>e</e>, <e>p</e>) is an <e>&alpha; </e> event that allows through only occurrences of <e>e</e> whose data satisfies the predicate <e>p</e>.

<h3><ti>Snapshot Events
<p>The snapshot construct may be used to make a time varying behavior into a static one (i.e., no longer varying with time). This is useful when one wishes to record the instantaneous value of a time varying behavior for some other use. For example,

<ex>0 until snapshot(xComponent(mousePosition), leftButtonPress,)
</ex>

<p>is the static behavior 0 until the left mouse button is pressed, and then becomes the static value of the x coordinate of the mouse position at the time of the press. The behavior 
<ex>0 until leftButtonPress => xComponent(mousePosition) 
</ex>

<p>is different in that it produces a behavior that continues to vary with time and track the x coordinate of the mouse after the button event occurs. The following subsections define the types and operators used in constructing reactive values. 


<h2><ti>Behavior Termination

<p>Behaviors can terminate. The end construct is of type <e>&alpha; </e> (any type) and means to immediately terminate the behavior. For example:
<ex>b = time until leftButtonPress => end 
</ex>


<p>This behavior varies with time until the <e>leftButtonPress</e> event occurs. Then it terminates.

<p>A behavior will also terminate if one of its defining behaviors terminates. For example, consider 
<ex>b' = f(b, 3)
</ex>


<p>If behavior <e>b</e> terminates, then <e>b'</e> terminates at the same time.

<p>The <k>DONE</k> construct is a unit event that can be used to detect when a behavior has terminated and react accordingly. Consider the following: 
<ex>repeat(b) =	b until	done => repeat(b)
</ex>


<p>This function takes behavior <e>b</e> and runs it until it terminates. Then it starts <e>b</e> again. (Note: This a built-in function in ActiveVRML.)

<p>Does this last note mean that the example is a built-in function or that there is another function available that does the same thing?

<h2><ti>Behaviors and Time

<p>To improve modularity, all behaviors are defined to begin at local time zero. That is, when a behavior begins, no matter what the system time is, the time for the behavior starts at zero. Consider the following:
<ex>b until e => b'
</ex>


<p>When <e>b</e> is performed, there are two times to consider, the system time and the local time for <e>b</e>. Let the system time be <e>tg</e>. Whatever the value of <e>tg</e> is, at the time <e>b</e> is performed, it represents time zero for <e>b</e>. Event <e>e</e> occurs some time after <e>tg</e>. Let this time be <e>te</e>. This behavior can then be broken down by time: Do behavior <e>b</e> from time <e>tg</e> to <e>te</e>. Then do behavior <e>b'</e>. The local time for <e>b</e> is zero to (<e>te -tg</e>). When <e>b'</e> starts, its local time is zero as well.

<p>Here is a simple behavior that uses the local time as its events:
<ex>green until time = 2 => (blue until time = 1 => red)
</ex>


<p>This behavior makes the color green for 2 seconds, blue for 1 second, and then red.

<h3><ti>The TimeTransform Construct

<p>The <k>timeTransform</k> construct can be used to change the interpretation of local time. The function has the type <k>timeTransform</k>: <e>&alpha; * number -> &alpha; </e>. It uses the number to redefine how local time is interpreted within a behavior. Consider the following:

<ex>doubleSpeed = time * 2;
b = playVideo(video);

doubleVideo = timeTransform(b, doubleSpeed)
</ex>

<p>In this example, the video is played at twice its original speed. From the perspective of global time, each 1 second interval corresponds to 2 seconds of local time. The effects of time transformation are cumulative. For example:

<ex>timeTransform(doubleVideo, doubleSpeed)
</ex>


<p>This line would play the video at four times its original speed.

<p>To be consistent and predictable, the number argument (<e>n</e>) for the time transformation must satisfy two rules:
<ul>
<li>Monotone&em;For all times <e>t0</e> and <e>t1</e> when <e>t0</e> is less than <e>t1</e>, <e>n</e> at time <e>t0</e> must be less than <e>n</e> at time <e>t1</e>.
<li>Nonnegative&em;For all times <e>t</e>, <e>n</e> at time <e>t</e> is nonnegative.
</ul>

<p>Monotonicity is required to make event reaction sensible (event transitions cannot be undone). Nonnegativity is required to prevent definition of a behavior before local time zero; that is, it may not make sense to sample a behavior like a video before local zero.

<p>Certain behaviors, principally those defined by system or user input devices, may not be transformed in time in the same way that artificial behaviors can be. Such devices ignore user-defined time transformations when they are sampled.


<h1 id=reactive_types><ti>Reactive Types

<p>Following are definitions for the basic types for events, reactivity, and time.


<ref>Event Type: event

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><e>&alpha</e>; <k>event</k>
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>done</kd>: <e>unit event</e>
	<d>The <k>done</k> constructor detects the termination of a behavior.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd id=alternate>infix |</kd>: <e>&alpha; event * &alpha; event -> &alpha; event</e>
	<d>The expression <e>e1</e> <k>|</k> <e>e2</e> is an alternative event. The first of the two events is chosen, and the data associated with that event becomes the data for the alternative event.
<i><kd>predicate</kd>: <e>boolean -> unit event</e>
	<d><k>predicate</k>(<e>b</e>) turns a boolean value into an event with trivial (unit) data. The event occurs the first time after local time 0 that the predicate <e>b</e> is true.
<i><kd id=handler>infix =</kd>>: <e>&alpha; event *</e> (<e>&alpha; -> &beta;</e>) <e>-> &beta;event</e>
	<d>The expression <e>e</e> <e S>=</e>> <e>h</e> is a handler event. It occurs the same time that <e>e</e> does, and returns as the function <e>h</e> applied to the data produced by <e>e</e>.
<i><kd>infix =</kd>>: <e>&alpha; event * &beta; -> &beta;event</e>
	<d>This second form of <e>e</e> <e S>=</e>> <e>b</e> is a syntactic convenience, valid only when <e>b</e> is not a function. It is roughly equivalent to <e>e</e> <e S>=</e>> <e>function x</e>.<e>b</e> and is useful when the handler does not need the value of the data produced by the event. This is a special form and does not immediately evaluate the second argument. 
<i><kd>suchThat</kd>: <e>&alpha; event *</e> (<e>&alpha; -> boolean</e>) <e>-> &alpha; event</e>
	<d><k>suchThat</k>(<e>e</e>, <e>p</e>) is a filter event that occurs when <e>e</e> does, producing the data that <e>e</e> would, but only if the predicate <e>p</e> is true on that data.
<i><kd>andEvent</kd>: <e>&alpha; event * &beta;event -> (&alpha; * &beta;)event</e>
	<d><k>andEvent</k>(<e>e1</e>, <e>e2</e>) occurs when <e>e1</e> and <e>e2</e> occur simultaneously. The data returned is the pair of data from <e>e1</e> and <e>e2</e>.
<i><kd>snapshot</kd>: <e>&alpha; * unit event -> &alpha; event</e>
	<d><k>snapshot</k>(<e>b</e>, <e>e</e>) creates a new event that happens at the same time as the <e>e</e> event, and associates a static snapshot of the <e>b</e> behavior with the event. When the <e>e</e> event occurs, <e>b</e> is sampled. A new event with the static sampled value of <e>b</e> associated with the <e>e</e> event is created. Snapshot is a special form that does not immediately evaluate the second argument.
</list>
</ref>
<ref>Reactivity Type

<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>end</kd> : <e>&alpha; </e>
	<d>The <k>end</k> constructor causes the behavior to finish immediately.
<i><kd>infix until</kd>: <e>&alpha; * &alpha; event -> &alpha; </e>
	<d>The expression <e>b</e> <k>until</k> <e>e</e> is equivalent to the behavior is <e>b</e> until the event <e>e</e> occurs, in which case, the behavior becomes <e>b'</e>.
<i><kd>repeat</kd>: <e>&alpha; -> &alpha; </e>
	<d><k>repeat</k>(<e>b</e>) is equal to <e>b</e> until <e>b</e> ends. Then it restarts with <e>b</e> at that time.

</list>
</ref>
<ref>Time Type

<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>timeTransform</kd>: <e>&alpha; * number -> &alpha; </e>
	<d><k>timeTransform</k>(<e>b</e>, <e>timeTrans</e>) adjusts the local time line for behavior <e>b</e> to follow the (time-varying) number <e>timeTrans</e>. For example, <kd>timeTransform</kd>(<e>b</e>,<e>time * 2</e>) makes a behavior that runs twice as fast as <e>b</e> normally would. See the "Behaviors and Time" section above for more information.
</list>
</ref>
<h1 id=modeling_types><ti>Modeling Types

<p>This section defines a broad range of types and associated functions that are useful for creating and manipulating ActiveVRML media values.

<p>ActiveVRML uses the following conventions:

<ul>
<li>Time is specified in seconds.
<li>Angles are specified in radians.
<li>Distances are specified in meters.
<li>Coordinate system conventions:
<li>The three-dimensional coordinate system used is a right-handed system with positive <e>X</e> to the right, positive <e>Y</e> up, and negative <e>Z</e> into the screen.
<li>Canonical 3D objects that are used (lights, cameras, microphones) are all positioned at the origin, facing <e>-Z</e> with <e>+Y</e> up.
<li>The two-dimensional coordinate system used has positive <e>X</e> to the right and positive <e>Y</e> up.
<li>The window in which images are viewed has its center at (0,0).

</ul>

<ref>2D Point Type: point2

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>point2</kd>
	<d>A two dimensional point.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>origin2</kd>: <e>point2</e>
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>point2Xy</kd>: <e>number * number -> point2</e> 
	<d><k>point2Xy</k>(<e>x</e>, <e>y</e>) takes two Cartesian coordinates, <e>x</e> and <e>y</e>, and returns a <k>point2</k> type.
<i><kd>point2Polar</kd>: <e>number * number -> point2</e>
	<d><k>point2Polar</k>(<e>theta</e>, <e>rho</e>) takes two polar coordinates, <e>theta</e> and <e>rho</e>, and returns a <k>point2</k> type.
<i><kd id=add_vector>infix +</kd>: <e>point2 * vector2 -> point2</e>
	<d>Adds <e>vector</e> to <e>point</e> and returns a <k>point2</k> type.
<i><kd id=subtract_vector>infix -</kd>: <e>point2 * vector2 -> point2</e>
	<d>Subtracts <e>vector</e> from <e>point</e> and returns a <k>point2</k> type.
<i><kd id=create_vector>infix -</kd>: <e>point2 * point2 -> vector2</e>
	<d>The expression <e>p1</e> <k>-</k> <e>p2</e> creates a vector from <e>p1</e> to <e>p2</e>.
<i><kd>distance</kd>: <e>point2 * point2 -> number</e>
	<d><k>distance</k>(<e>p1</e>, <e>p2</e>) returns the distance between <e>p1</e> and <e>p2</e> by finding the square root of the <e>x</e> and <e>y</e> coordinates of <e>p1</e> and <e>p2</e> squared.
<i><kd>distanceSquared</kd>: <e>point2 * point2 -> number</e>
	<d><k>distanceSquared</k>(<e>p1</e>, <e>p2</e>) returns only the <e>x</e> and <e>y</e> coordinates of <e>p1</e> and <e>p2</e> squared. Use <k>distanceSquared</k> when you need to compare the distance between one set of points and another.
<i><kd>xComponent</kd>: <e>point2 -> number</e>
	<d><k>xComponent</k>(<e>point</e>) returns the first coordinate of <e>point</e> (Cartesian).
<i><kd>yComponent</kd>: <e>point2 -> number</e>
	<d><k>yComponent</k>(<e>point</e>) returns the second coordinate of <e>point</e> (Cartesian).
<i><kd>transformPoint2</kd>: <e>transform2 -> (point2 -> point2)</e>
	<d><k>transformPoint2</k>(<e>transformation</e>) (<e>point</e>) returns a <k>point2</k> type by applying <e>transformation</e> to <e>point</e>.
<i><kd>thetaComponent</kd>: <e>point2 -> number</e>
	<d><k>thetaComponent</k>(<e>point</e>) returns the theta component of <e>point</e> (polar).
<i><kd>phiComponent</kd>: <e>point2 -> number</e>
	<d><k>phiComponent</k>(<e>point</e>) returns the phi component of <e>point</e> (polar)

</list>
</ref>
<ref>2D Vector Type: vector2

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>vector2</kd>
	<d>A two dimensional vector.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>xVector2</kd>: <e>vector2</e>
<i><kd>yVector2</kd>: <e>vector2</e>
<i><kd>zeroVector2</kd>: <e>vector2</e>
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>vector2Xy</kd>: <e>number * number -> vector2</e> 
	<d><k>vector2Xy</k>(<e>x</e>, <e>y</e>) constructs a <k>vector2</k> type from two Cartesian coordinates, <e>x</e> and <e>y</e>.
<i><kd>vector2Polar</kd>: <e>number * number -> vector2</e>
	<d><k>vector2Polar</k>(<e>theta</e>, <e>rho</e>) constructs a <k>vector2</k> type from two polar coordinates, <e>theta</e> and <e>rho</e>.
<i><kd>normal</kd>: <e>vector2 -> vector2</e>
	<d><k>normal</k>(<e>vector</e>) normalizes <e>vector</e> such that its length is equal to 1.
<i><kd>length</kd>: <e>vector2 -> number</e>
	<d><k>length</k>(<e>vector</e>) returns the length of <e>vector</e> by finding the square root of the <e>x</e> and <e>y</e> coordinates squared.
<i><kd>lengthSquared</kd>: <e>vector2 -> number</e>
	<d><k>lengthSquared</k>(<e>vector</e>) returns from <e>vector</e> only the <e>x</e> and <e>y</e> coordinates squared. Use <k>lengthSquared</k> when you need to compare the length of one vector to another.
<i><kd id=vector_add2>infix +</kd>: <e>vector2 * vector2 -> vector2</e>
	<d>The expression <e>v1</e> <k>+</k> <e>v2</e> adds the two vectors to form a third vector.
<i><kd id=vector_subtract2>infix -</kd>: <e>vector2 * vector2 -> vector2</e>
	<d>The expression <e>v1 - v2</e> subtracts <e>v2</e> from <e>v1</e> to form a third vector.
<i><kd id=scale_vector1>infix *</kd>: <e>vector2 * number -> vector2</e>
	<d>Multiplies <e>vector2</e> by <e>scale</e> and returns a <k>vector2</k> type.
<i><kd id=scalar_division1>infix /</kd>: <e>vector2 * number -> vector2</e>
	<d>Divides <e>vector2</e> by <e>scale</e> and returns a <k>vector2</k> type.
<i><kd id=scale_vector2>infix *</kd>: <e>number * vector2 -> vector2</e>
	<d>Multiplies <e>scale</e> by <e>vector2</e> and returns a <k>vector2</k> type.
<i><kd>dot</kd>: <e>vector2 * vector2 -> number</e>
	<d><k>dot</k>(<e>v1</e>, <e>v2</e>) returns the dot product of the two vectors, <e>v1</e> and <e>v2</e>.
<i><kd>xComponent</kd>: <e>vector2 -> number</e>
	<d><k>xComponent</k>(<e>vector</e>) returns the <e>x</e> component of <e>vector</e> (Cartesian).
<i><kd>yComponent</kd>: <e>vector2 -> number</e>
	<d><k>yComponent</k>(<e>vector</e>) returns the <e>y</e> component of <e>vector</e> (Cartesian).
<i><kd>transformVector2</kd>: <e>transform2 -> (vector2 -> vector2)</e>
	<d><k>transformVector2</k>(<e>transformation</e>) (<e>vector</e>) returns a <k>point2</k> type by applying <e>transformation</e> to <e>vector</e>.
<i><kd>thetaComponent</kd>: <e>vector2 -> number</e>
	<d><k>thetaComponent</k>(<e>vector</e>) returns the <e>theta</e> component of <e>vector</e> (polar).
<i><kd>rhoComponent</kd>: <e>vector2 -> number</e>
	<d><k>rhoComponent</k>(<e>vector</e>) returns the <e>rho</e> component of <e>vector</e> (polar).

</list>
</ref>
<ref>2D Transformation Type: transform2

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>transform2</kd>
	<d>2D transformations represent a mapping between 2D-space and 2D-space. They are used to transform various 2D objects, including <k>point2</k>, <k>vector2</k>, and <k>image</k>, all by the overloaded <k>apply</k> function listed in their relevant sections.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>identityTransform2</kd>: <e>transform2</e>
	<d>Creates a transformation that does not change the object it is applied to.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>infix o</kd>: <e>transform2 * transform2 -> transform2</e>
	<d>The expression <e>t1</e> <k>o</k> <e>t2</e> composes two transformations into a single <k>transform2</k> type.
<i><kd>translate</kd>: <e>number * number -> transform2</e>
	<d><k>translate</k>(<e>tx</e>, <e>ty</e>) moves an object by adding <e>tx</e> and <e>ty</e> to the object's <e>x</e> and <e>y</e> coordinates.
<i><kd>translate</kd>: <e>vector2 -> transform2</e>
	<d><k>translate</k>(<e>vector</e>) moves an object by adding the <e>x</e> and <e>y</e> coordinates from <e>vector</e> to the object's <e>x</e> and <e>y</e> coordinates.
<i><kd>scale</kd>: <e>number * number -> transform2</e>
	<d><k>scale</k>(<e>sx</e>, <e>sy</e>) scales an object by multiplying <e>sx</e> and <e>sy</e> by the object's <e>x</e> and <e>y</e> coordinates.
<i><kd>scale</kd>: <e>vector2 -> transform2</e>
	<d><k>scale</k>(<e>vector</e>) scales an object by multiplying the <e>x</e> and <e>y</e> coordinates from <e>vector</e> by the object's <e>x</e> and <e>y</e> coordinates.
<i><kd>scale2</kd>: <e>number -> transform2</e>
	<d><k>scale</k>(<e>number</e>) scales an object by multiplying <e>number</e> by the object's <e>x</e> and <e>y</e> coordinates.
<i><kd>rotate2</kd>: <e>number -> transform2</e>
	<d><k>rotate2</k>(<e>number</e>) rotates an object <e>number</e> radians ccw. 
<i><kd>shear2</kd>: <e>number -> transform2</e> 
	<d><k>shear2</k>(<e>number</e>) shears an object in the <e>x</e> direction such that the object's x coordinate is increased by the product of its <e>y</e> coordinate multiplied by <e>number</e>.
<i><kd>transform3x2</kd>: <e>number * number * number * number * number * number -> transform2</e>
	<d><k>transform3x2</k> converts a matrix of two rows and three columns to two coordinates, <e>x</e> and <e>y</e>. The third column contains the translation components.
<i><kd>inverse</kd>: <e>transform2 -> transform2</e>
	<d><k>inverse</k>(<e>trans</e>) creates a transformation that is inverse to <e>trans</e>.
<i><kd>isSingular</kd>: <e>transform2 -> boolean</e>
	<d><k>isSingular</k>(<e>trans</e>) returns true if  <e>trans</e> does not contain an inverse transformation.

</list>
</ref>
<ref>Image Type: image

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>image</kd>
	<d>A value of type <k>image</k> is a spatially continuous image behavior of infinite spatial extent. Operations on it include the application of 2D transforms and opacity, and overlaying images. Continuous images are constructed by importing bitmap files, projecting 3D geometry, or by rendering text into an image.
	<d>
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>emptyImage</kd>: <e>image</e>
<i><kd>import</kd>(pathname.[bmp | jpeg | gif]): <e>image * vector2 * number</e>
	<d>Import a bitmap file.  The return value <e>image</e> is the imported image, centered at (0,0).  <e>point2</e> is the upper-righthand coordinate of the resultant image, and <e>number</e> is the resolution of the image in pixels per meter.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>renderedImage</kd>: <e>geometry * camera -> image</e> 
	<d>The <k>renderedImage</k>(<e>geometry</e>, <e>viewingCamera</e>) function is the primary 3D to 2D interface. The <e>viewingCamera</e> parameter determines the projection by which the <e>geometry</e> will be imaged. The resultant image is spatially infinite, and the camera performs no cropping. Cropping, if desired, can be achieved by using the <e>crop</e> function below.  It may be useful to think of this function as returning the entire projection plane as an image.  The description of the <kd>camera</kd> type discusses the projection plane and projection point.
<i><e S>infix over</e>: <e>image * image -> image</e>
	<d>The expression <e>top</e> <k>over</k> <e>bottom</e> constructs a new image by placing the <e>top</e> image over the <e>bottom</e> image.
	<d>Is this a continuation of renderedImage definiation above or a typo?
<i><kd>opacity2</kd>: <e>number </e>* <e>image -> image</e>
	<d><k>opacity2</k>(<e>value</e>, <e>img</e>), given a value from 0.0 to 1.0, returns a new image identical to <e>img</e>, but with a certain percentage of opacity, determined by <e>value</e>: <e>percentage opacity = value * 100</e>. This function composes multiplicatively; thus <kd>opacity2</kd>(<e>0</e>.<e>5</e>, <e>opacity2</e>(<e>0</e>.<e>2</e>, <e>myOpaqueImg</e>)) results in an image with opacity of 0.1 (or 90% transparent). The default opacity is 1 (fully opaque).
<i><kd>crop</kd>: <e>point2 * point2 </e>* <e>image -> image</e>
	<d><k>crop</k>(<e>min</e>, <e>max</e>, <e>img</e>) returns an image identical to <e>img</e> inside of the box defined by <e>min</e> and <e>max</e>, and a transparent layer outside of this box.
<i><kd>tile</kd>: <e>point2 * point2 </e>* <e>image -> image</e>
	<d><k>tile</k>(<e>min</e>, <e>max</e>, <e>img</e>) returns an infinitely tiled image given by cropping <e>img</e> to the region (<e>min</e>,<e>max</e>), and then replicating that region infinitely in all directions.
<i><kd>transformImage</kd>: <e>transform2 -> (image -> image)</e>
	<d><k>transformImage</k>(<e>transformation</e>) (<e>image</e>) returns an <k>image</k> type by applying <e>transformation</e> to <e>image</e>.

</list>
</ref>
<ref>Composite 2.5D Image Type: montage

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>montage</kd>
	<d>A <k>montage</k> is a set of images with associated depth values. Montages are useful for creating multilayered, image-based (cel) animation.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>emptyMontage</kd>
	<d>Constructs a <k>montage</k> object with no images.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>imageMontage</kd>: <e>image * number -> montage</e>
	<d><k>imageMontage</k>(<e>image</e>, <e>depth</e>) builds a 2.5D image set with a single image at <e>depth</e>.
<i><kd>infix union</kd>: <e>montage * montage -> montage</e>
	<d>The expression <e>m1</e> <k>union</k> <e>m2</e> combines the contents of two image sets, <e>m1</e> and <e>m2</e>, into a single collection.
<i><kd>renderedImage</kd>: <e>montage -> image</e>
	<d><k>renderedMontage</k>(<e>montage</e>) converts the set of images and depths encapsulated in <e>montage</e> into a flattened image. Image elements with larger depths will be layered underneath.

</list>
</ref>
<ref>3D Point Type: point3

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>point3</kd>
	<d>A three dimensional point.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>origin3</kd>
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>point3Xyz</kd>: <e>number * number * number -> point3</e> 
	<d><k>point3Xyz</k>(<e>x</e>, <e>y</e>, <e>z</e>) constructs a <k>point3</k> type from three Cartesian coordinates.
<i><kd>point3Spherical</kd>: <e>number * number * number -> point3</e>
	<d><k>point3Spherical</k>(<e>theta</e>, <e>phi</e>, <e>rho</e>) constructs a <k>point3</k> type from three polar coordinates.
<i><kd>infix -</kd>: <e>point3 * point3 -> vector3</e>
	<d>The expression <e>p1</e> <k>-</k> <e>p2</e> creates a vector from <e>p1</e> to <e>p2</e>.
<i><kd>distance</kd>: <e>point3 * point3 -> number</e>
	<d><k>distance</k>(<e>p1</e>, <e>p2</e>) returns the distance between <e>p1</e> and <e>p2</e> by finding the square root of the <e>x</e>, <e>y</e>, and <e>z</e> coordinates of <e>p1</e> and <e>p2</e> squared.
<i><kd>distanceSquared</kd>: <e>point3 * point3 -> number</e>
	<d><k>distanceSquared</k>(<e>p1</e>, <e>p2</e>) returns only the <e>x</e>, <e>y</e>, and <e>z</e> coordinates of <e>p1</e> and <e>p2</e> squared. Use <k>distanceSquared</k> when you need to compare the distance between one set of points and another.
<i><kd id=3d_vector_add>infix +</kd>: <e>point3 * vector3 -> point3</e>
	<d>Adds <e>vector</e> to <e>point</e> to return a new <k>point3</k> type.
<i><kd id=3d_vector_subtract>infix -</kd>: <e>point3 * vector3 -> point3</e>
	<d>Subtracts <e>vector</e> to <e>point</e> to return a new <k>point3</k> type.
<i><kd>transformPoint3</kd>: <e>transform3 -> (point3 -> point3)</e>
	<d><k>transformPoint3</k>(<e>transformation</e>) (<e>point</e>) returns a <k>point3</k> type by applying <e>transformation</e> to <e>point</e>.
<i><kd>xComponent</kd>: <e>point3 -> number</e>
	<d><k>xComponent</k>(<e>point</e>) returns the <e>x</e> component of <e>point</e> (Cartesian).
<i><kd>yComponent</kd>: <e>point3 -> number</e>
	<d><k>yComponent</k>(<e>point</e>) returns the <e>y</e> component of <e>point</e> (Cartesian).
<i><kd>zComponent</kd>: <e>point3 -> number</e>
	<d><k>zComponent</k>(<e>point</e>) returns the <e>z</e> component of <e>point</e> (Cartesian).
<i><kd>thetaComponent</kd>: <e>point3 -> number</e>
	<d><k>thetaComponent</k>(<e>point</e>) returns the <e>theta</e> component of <e>point</e> (Polar).
<i><kd>phiComponent</kd>: <e>point3 -> number</e>
	<d><k>phiComponent</k>(<e>point</e>) returns the <e>phi</e> component of <e>point</e> (Polar).
<i><kd>rhoComponent</kd>: <e>point3 -> number</e>
	<d><k>rhoComponent</k>(<e>point</e>) returns the <e>rho</e> component of <e>point</e> (Polar).

</list>
</ref>
<ref>3D Vector Type: vector3

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>vector3</kd>
	<d>A three dimensional vector. Direction and magnitude. ???
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>xVector3</kd>: <e>vector3</e>
<i><kd>yVector3</kd>: <e>vector3</e>
<i><kd>zVector3</kd>: <e>vector3</e>
<i><kd>zeroVector3</kd>: <e>vector3</e>
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>vector3Xyz</kd>: <e>number * number * number -> vector3</e>
	<d><k>vector3Xyz</k>(<e>x</e>, <e>y</e>, <e>z</e>) constructs a <k>vector3</k> type from three Cartesian coordinates, <e>x</e>, <e>y</e>, and <e>z</e>.
<i><kd>vector3Spherical</kd>: <e>number * number * number -> vector3</e>
	<d><k>vector3Spherical</k>(<e>theta</e>, <e>phi</e>, <e>rho</e>) constructs a <k>vector3</k> type from three polar coordinates, <e>theta</e>, <e>phi</e>, and <e>rho</e>.
<i><kd>normal</kd>: <e>vector3 -> vector3</e>
	<d><k>normal</k>(<e>vector</e>) normalizes <e>vector</e> such that its length is equal to 1.
<i><kd>length</kd>: <e>vector3 -> number</e>
	<d><k>length</k>(<e>vector</e>) returns the length of <e>vector</e> by finding the square root of the <e>x</e>, <e>y</e>, and <e>z</e> coordinates squared.
<i><kd>lengthSquared</kd>: <e>vector3 -> number</e>
	<d><k>lengthSquared</k>(<e>vector</e>) returns from <e>vector</e> only the <e>x</e>, <e>y</e>, and <e>z</e> coordinates squared. Use <k>lengthSquared</k> when you need to compare the length of one vector to another.
<i><kd id=vector_add3>infix +</kd>: <e>vector3 * vector3 -> vector3</e>
	<d>The expression <e>v1</e> <k>+</k> <e>v2</e> adds the two vectors to form a third vector.
<i><kd id=vector_subtract3>infix -</kd>: <e>vector3 * vector3 -> vector3</e>
	<d>The expression <e>v1 - v2</e> subtracts <e>v2</e> from <e>v1</e> to form a third vector.
<i><kd id=scale_vector3>infix *</kd>: <e>vector3 * number -> vector3</e>
	<d>Multiplies <e>vector</e> by <e>scale</e> and returns a <k>vector3</k> type.
<i><kd id=scale_vector4>infix *</kd>: <e>number * vector3 *-> vector3</e>
	<d>Multiplies <e>scale</e> by <e>vector</e> and returns a <k>vector3</k> type.
<i><kd id=scalar_division2>infix /</kd>: <e>vector3 * number-> vector3</e>
	<d>Divides<e>vector</e> by <e>scale</e> and returns a <k>vector3</k> type.
<i><kd>dot</kd>: <e>vector3 * vector3 -> number</e>
	<d><k>dot</k>(<e>v1</e>, <e>v2</e>) returns the dot product of the two vectors, <e>v1</e> and <e>v2</e>.
<i><kd>cross</kd>: <e>vector3 * vector3 -> vector3</e>
	<d><k>dot</k>(<e>v1</e>, <e>v2</e>) returns the cross product of the two vectors, <e>v1</e> and <e>v2</e>.
<i><kd>transformVector3</kd>: <e>transform3 -> (vector3 -> vector3)</e>
	<d><k>transformVector3</k>(<e>transformation</e>) (<e>vector</e>) returns a <k>vector3</k> type by applying <e>transformation</e> to <e>vector</e>.
<i><kd>xComponent</kd>: <e>vector3 -> number</e>
	<d><k>xComponent</k>(<e>vector</e>) returns the <e>x</e> component of <e>vector</e> (Cartesian).
<i><kd>yComponent</kd>: <e>vector3 -> number</e>
	<d><k>yComponent</k>(<e>vector</e>) returns the <e>y</e> component of <e>vector</e> (Cartesian).
<i><kd>zComponent</kd>: <e>vector3 -> number</e>
	<d><k>zComponent</k>(<e>vector</e>) returns the <e>z</e> component of <e>vector</e> (Cartesian).
<i><kd>thetaComponent</kd>: <e>vector3 -> number</e>
	<d><k>thetaComponent</k>(<e>vector</e>) returns the <e>theta</e> component of <e>vector</e> (polar).
<i><kd>phiComponent</kd>: <e>vector3 -> number</e>
	<d><k>phiComponent</k>(<e>vector</e>) returns the <e>phi</e> component of <e>vector</e> (polar).
<i><kd>rhoComponent</kd>: <e>vector3 -> number</e>
	<d><k>rhoComponent</k>(<e>vector</e>) returns the <e>rho</e> component of <e>vector</e> (polar).

</list>
</ref>
<ref>3D Transformation Type: transform3

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>transform3</kd>
	<d>3D transformations represent a mapping between 3D-space and 3D-space and are used to transform various 3D entities, including <k>point3</k>, <k>vector3</k>, <k>geometry</k>, <k>microphone</k>, and <k>camera</k>, all by using the overloaded <k>apply</k> function listed in their relevant sections.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>identityTransform3</kd>:<e>transform3</e>
	<d>Creates a transformation that does not change the object it is applied to.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd id=combine_transform>infix o</kd>: <e>transform3 * transform3 -> transform3</e>
	<d>The expression <e>t1</e> <k>o</k> <e>t2</e> composes two transformations into a single <k>transform3</k> type.
<i><kd>translate</kd>: <e>number * number * number -> transform3</e>
	<d><k>translate</k>(<e>tx</e>, <e>ty</e>, <e>tz</e>) moves an object by adding <e>tx</e>, <e>ty</e>, and <e>tz</e> to the object's <e>x</e>, <e>y</e>, and <e>z</e> coordinates.
<i><kd>translate</kd>: <e>vector3 -> transform3</e>
	<d><k>translate</k>(<e>vector</e>) moves an object by adding the <e>x</e>, <e>y</e>, and <e>z</e> coordinates from <e>vector</e> to the object's <e>x</e>, <e>y</e>, and <e>z</e> coordinates.
<i><kd>scale</kd>: <e>number * number * number -> transform3</e>
	<d><k>scale</k>(<e>sx</e>, <e>sy</e>, <e>sz</e>) scales an object by multiplying <e>sx</e>, <e>sy</e>, and <e>sz</e> by the object's <e>x</e>, <e>y</e>, and <e>z</e> coordinates.
<i><kd>scale</kd>: <e>vector3 -> transform3</e>
	<d><k>scale</k>(<e>vector</e>) scales an object by multiplying the <e>x</e>, <e>y</e>, and <e>z</e> coordinates from <e>vector</e> by the object's <e>x</e>, <e>y</e>, and <e>z</e> coordinates.
<i><kd>scale3</kd>: <e>number -> transform3</e>
	<d><k>scale</k>(<e>number</e>) scales an object by multiplying <e>number</e> by the object's <e>x</e>, <e>y</e>, and <e>z</e> coordinates.
<i><kd>rotate</kd>: <e>vector3 * number -> transform3</e>
	<d><k>rotate</k>(<e>vector</e>, <e>number</e>) rotates an object <e>number</e> radians about the axis specified by <e>vector</e>.
<i><kd>xyShear</kd>: <e>number -> transform3</e> 
	<d><k>xyShear2</k>(<e>number</e>) shears an object in the <e>x</e> direction such that the object's x coordinate is increased by the product of its <e>y</e> coordinate multiplied by <e>number</e>.
<i><kd>yzShear</kd>: <e>number -> transform3</e> 
	<d><k>yzShear2</k>(<e>number</e>) shears an object in the <e>y</e> direction such that the object's y coordinate is increased by the product of its <e>z</e> coordinate multiplied by <e>number</e>.
<i><kd>zxShear</kd>: <e>number -> transform3</e> 
	<d><k>zxShear2</k>(<e>number</e>) shears an object in the <e>z</e> direction such that the object's z coordinate is increased by the product of its <e>x</e> coordinate multiplied by <e>number</e>.
<i><kd>transform4x4</kd>: <e>number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number -> transform3</e>. The fourth column contains the translation components.
	<d><k>transform4x4</k> converts a matrix of four rows and four columns to four coordinates, <e>x</e>, <e>y</e>, <e>z</e>, and <e>w</e>.
<i><kd>lookAtFrom</kd>: <e>point3 * point3 * vector3 -> transform3</e>
	<d><k>lookAtFrom</k>(<e>from</e>, <e>to</e>, <e>up</e>) creates a transformation when applied to an object centered at the origin, with <e>+Y</e> up and directed toward <e>-Z</e>, moves the object to <e>from</e>, pointing towards <e>to</e>, with its up direction as close to <e>up</e> as possible.
<i><kd>inverse</kd>: <e>transform3 -> transform3</e>
	<d><k>inverse</k>(<e>trans</e>) creates a transformation that is the inverse of <e>trans</e>.
<i><kd>isSingular</kd>: <e>transform3 -> boolean</e>
	<d><k>isSingular</k>(<e>trans</e>) returns true if  <e>trans</e> does not have an inverse transformatin.

</list>
</ref>
<ref>3D Geometry Type: geometry

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>geometry</kd>
	<d>A value of type <k>geometry</k> is a spatially continuous behavior of infinite spatial extent in three dimensions. A geometry value is constructed by importing other geometry formats (such as VRML), applying modeling transformations, material properties, aggregating multiple geometries, positioning sound in 3D, and specifying other attributes.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>emptyGeometry</kd>: <e>geometry</e>
<i><kd>import</kd>(filename.[wrl]): <e>geometry * point3 * point3</e>
	<d>In the <k>import</k> constructor, <k>geometry</k> is the result of importing the specified file. The two points returned are the minimum and maximum extents of the tightest axis-aligned, rectangular bounding volume containing the geometry.
<i><kd>import</kd>(beginLiteral wrl ascii <e>body</e> endLiteral): <e>geometry * point3 * point3</e>
	<d>An alternative <k>import</k> constructor, allows VRML 1.0 geometry to be expressed in line. <e>body</e> is a sequence of ascii characters in VRML 1.0 format.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>infix union</kd>: <e>geometry * geometry -> geometry</e>
	<d><e>g1 union g2</e> aggregates two geometries into their geometric union.
<i><kd>soundSource3</kd>: <e>sound -> geometry</e>
	<d>The <k>soundSource3</k> function allows sounds to be embedded into a geometry. It creates a geometry with the specified sound positioned at the local coordinate system origin. The resultant geometry may be transformed in space, and has no visible presence when rendered. The function <k>renderedSound</k>, described in the Sound section below, takes a <k>geometry</k> and a <k>microphone</k>, and creates a sound by spatializing all of the sounds embedded into that geometry with respect to the microphone.
<i><kd>transformGeometry</kd>: <e>transform3 -> (geometry -> geometry)</e>
	<d><k>transformGeometry</k>(<e>transformation</e>) (<e>geometry</e>) returns a <k>geometry</k> type by applying <e>transformation</e> to <e>geometry</e>.
<i><kd>opacity3</kd>: <e>number </e>* <e>geometry -> geometry</e>
	<d><k>opacity3</k>(<e>value</e>, <e>geo</e>), given a value from 0.0 to 1.0, returns a new geometry identical to <e>geo</e>, but with a certain percentage of opacity, determined by <e>value</e>: <e>percentage opacity = value * 100</e>. This function composes multiplicatively, making <k>opacity3</k>(<e>0</e>.<e>5</e>, <e>opacity3</e>(<e>0</e>.<e>2</e>, <e>myOpaqueGeo</e>)) result in a geometry with opacity of 0.1 (or 90% transparent). The default opacity is 1 (fully opaque).
<i><kd>texture</kd>: <e>image </e>* <e>geometry -> geometry</e>
	<d>The <k>texture</k> function is the means by which texture mapping onto geometry is specified. The coordinates of the image are mapped onto the texture map coordinates associated with the vertices of the primitive geometries comprising the geometry being mapped, resulting in textured geometry. If the primitive geometries have no texture coordinates, texturing is ignored. Note that textures are applied in an outer-overriding fashion. That is, <k>texture</k>(<e>im1</e>, <e>texture</e>(<e>im2</e>, <e>geo</e>)) results in <e>geo</e> textured with <e>im1</e>. The default texture is none.
</list>

<note><ti>Note
<p>The following functions create <e>light</e> geometries, all of which have no visible appearance themselves; but, they do cast light onto other objects they are aggregated with. The <e>point</e> and <e>spot</e> lights are both located at the origin. The <e>directional</e> and <e>spot</e> lights both point along the -Z axis.
</note>

<list BREAKALL>
<data d=ALL r=".5">
<i><kd>ambientLight</kd>: <e>geometry</e>
<i><kd>directionalLight</kd>: <e>geometry</e>
<i><kd>pointLight</kd>: <e>geometry</e>
<i><kd>spotLight</kd>: <e>number * number * number -> geometry</e>
	<d>The <k>spotLight</k> function has arguments <e>fullcone</e>, <e>cutoff</e>, and <e>exponent</e>.
<i><kd>lightColor</kd>: <e>color </e>* <e>geometry -> geometry</e>
	<d><k>lightColor</k>(<e>col</e>, <e>geo</e>) creates a geometry identical to <e>geo</e> where all the lights are <e>col</e> color. By default, the light colors are white.
<i><kd>lightAttenuation</kd>: <e>number * number * number </e>* <e>geometry -> geometry</e>
	<d><k>lightAttenuation</k>(<e>c</e>, <e>l</e>, <e>q</e>, <e>geo</e>) creates a geometry identical to <e>geo</e> where Lambertian light attenuation equation is set to <e>1</e> / (<e>c + ld + qdd</e>) where <e>d</e> is the distance from the light to the object. By default, the attenuation coefficients are (<e>1</e>, <e>0</e>, <e>0</e>).
</list>

<note><ti>Note
<p>The following functions allow for attributing geometry with standard Lambertian shading characteristics. The outermost applied attribute overrides other attributes of the same kind; that is, <k>diffuseColor</k>(<e>red</e>, <e>diffuseColor</e>(<e>blue</e>, <e>geo</e>)) results in a red geometry.
</note>

<list BREAKALL>
<data d=ALL r=".5">
<i><kd>diffuseColor</kd>: <e>color </e>* <e>geometry -> geometry</e>
	<d>The default <k>diffuseColor</k> is white.
<i><kd>ambientColor</kd>: <e>color </e>* <e>geometry -> geometry</e>
	<d>The default <k>ambientColor</k> is white.
<i><kd>specularColor</kd>: <e>color </e>* <e>geometry -> geometry</e>
	<d>The default <k>specularColor</k> is black.
<i><kd>emissiveColor</kd>: <e>color </e>* <e>geometry -> geometry</e>
	<d>The default <k>emmisiveColor</k> is black.
<i><kd>specularExponent</kd>: <e>number </e>* <e>geometry -> geometry</e>
	<d>The default <k>specularExponent</k> is 1.
</list>
</ref>

<ref>Camera Type: camera

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>camera</kd>
	<d>The camera type is used to project geometry into an image via the <k>renderedImage</k> function.  
	<d>
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>defaultCamera</kd> : <e>camera</e>
	<d>The canonical camera, <k>defaultCamera</k>, has its projection point at (0,0,1), looking along the <e>-Z</e> axis with <e>+Y</e> up, with the projection plane in the <e>XY</e> plane at <e>z</e> = 0.
	<d>New cameras may be created by applying transformations to existing cameras in order to position and orient the camera, and also to affect projection properties.  Translation and orientation position and orient the camera, respectively.  Scaling in X or Y stretches the resulting projection accordingly.  Scaling in <e>Z</e> changes the distance between the projection point and the projection plane.  For instance, a <e>Z</e> scale of less than one yields a wide-angle camera, while a <e>Z</e> scale of &infinity; will yield a parallel projecting camera. (In practice, scaling in <e>Z</e> by a very large number is sufficient.)
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>transformCamera</kd>: <e>transform3 -> (camera -> camera)</e>
	<d><k>transformCamera</k>(<e>transformation</e>) (<e>camera</e>) returns a <k>camera</k> type by applying <e>transformation</e> to <e>camera</e>.

</list>
</ref>
<ref>Sound Type: sound

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>sound</kd>
	<d>A <k>sound</k> value is constructed by importing primitive sounds, mixing, rendering of geometry with embedded sounds, and by the application of audio attributes, such as gain. 
	<d>Note that sound is always considered to be single channel. Stereo is supported by constructing two separate sounds.
	<d>Certain audio effects can be achieved by using the general time transformation mechanism. For example, both phase shift and rate control can be achieved by time transformations.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>silence</kd>
<i><kd>import</kd>(pathname.[wav | au | aiff]): <e>sound * sound * number</e>
	<d>Importing a .wav, .au, or .aiff file constructs a pair of sounds, one for the left and right channels of the sound. If the imported file is monophonic, the two returned sounds are identical. When a sound is finished, it terminates. Sounds can be looped by using the <k>repeat</k> facility. The third returned value, a number, is the length in seconds of the longer of the two returned channels.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>infix mix</kd>: <e>sound * sound -> sound</e>
	<d>The expression <e>s1</e> <k>mix</k> s<e>2</e> combines two sounds, <e>s1</e> and <e>s2</e>, into a single sound, with each component sound contributing equally.
<i><kd>renderedSound</kd>: <e>geometry * microphone -> sound</e>
	<d><k>renderedSound</k>(<e>geo</e>, <e>mic</e>) produces an audio rendering of the sounds embedded within geo (by using <k>soundSource3</k>), with respect to <e>mic</e>.
<i><kd>gain</kd>: <e>number </e>* <e>sound -> sound</e>
	<d><k>gain</k>(<e>value</e>, <e>sound</e>) multiplicatively adjusts the gain of a sound. Thus, <e>gain</e>(<e>0</e>.<e>3</e>, <e>gain</e>(<e>5</e>.<e>0</e>, <e>origSound</e>)) results in a sound 1.5 times as loud as the original sound.

</list>
</ref>
<ref>Microphone Type: microphone

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>microphone</kd>
	<d>The <k>microphone</k> type represents an audio perceiver in 3D. ActiveVRML 1.0 supports a simple microphone that may be spatially transformed by using modeling transformations. Future versions will add other attributes to the microphone.
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>defaultMicrophone</kd>: <e>microphone</e>
	<d>The canonical camera, <k>defaultMicrophone</k>, lies at the origin, looking along the <e>-Z</e> axis with <e>+Y</e> up.
	<d>
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>transformMicrophone</kd>: <e>transform3 -> (microphone -> microphone)</e>
	<d><k>transformMicrophone</k>(<e>transformation</e>) (<e>mic</e>) returns an <k>microphone</k> type by applying <e>transformation</e> to <e>mic</e>.

</list>
</ref>
<ref>Color Type: color

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><k>color</k>
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>red</kd>: <e>color</e>
<i><kd>green</kd>: <e>color</e>
<i><kd>blue</kd>: <e>color</e>
<i><kd>cyan</kd>: <e>color</e>
<i><kd>magenta</kd>: <e>color</e>
<i><kd>yellow</kd>: <e>color</e>
<i><kd>white</kd>: <e>color</e>
<i><kd>black</kd>: <e>color</e>
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>colorRgb</kd>: <e>number * number * number -> color</e>
	<d><k>colorRgb</k>(<e>red</e>, <e>green</e>, <e>blue</e>) constructs a <k>color</k> type using the color values, <e>red</e>, <e>green</e>, and <e>blue</e>.
<i><kd>colorHsl</kd>: <e>number * number * number -> color</e>
	<d><k>colorHsl</k>(<e>hue</e>, <e>saturation</e>, <e>lightness</e>) constructs a <kd>color</kd> type using the values, <e>hue</e>, <e>saturation</e>, and <e>lightness</e>.
<i><kd>redComponent</kd>: <e>color -> number</e>
	<d><k>redComponent</k>(<e>color</e>) returns the red color value of <e>color</e>.
<i><kd>greenComponent</kd>: <e>color -> number</e>
	<d><k>greenComponent</k>(<e>color</e>) returns the green color value of <e>color</e>.
<i><kd>blueComponent</kd>: <e>color -> number</e>
	<d><k>blueComponent</k>(<e>color</e>) returns the blue color value of <e>color</e>.
<i><kd>hueComponent</kd>: <e>color -> number</e>
	<d><k>hueComponent</k>(<e>color</e>) returns the hue value of <e>color</e>.
<i><kd>saturationComponent</kd>: <e>color -> number</e>
	<d><k>saturationComponent</k>(<e>color</e>) returns the saturation value of <e>color</e>.
<i><kd>lightnessComponent</kd>: <e>color -> number</e>
	<d><k>lightnessComponent</k>(<e>color</e>) returns the lightness value of <e>color</e>.

</list>
</ref>
<ref>Character Type: char

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>char</kd>
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>'</kd>c<k>'</k>
	<d>In the <k>'</k>c<k>'</k> constructor, <e>c</e> is an ASCII character or one of the following escape forms:
<list>
<data d=ALL r="1">
<i H>Escape Code
<d H>Result
<i>\n
	<d>Newline
<i>\t
	<d>Tab
<i>\'
	<d>Apostrophe
<i>\"
	<d>Quote
<i>\\
	<d>Backslash
<i>\integer
	<d>The ASCII character with this value
</list>
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>ord</kd>: <e>char -> number</e>
	<d><k>ord</k>(<e>c</e>) returns the ASCII code for character <e>c</e>.
<i><kd>chr</kd>: <e>number -> char</e>
	<d><k>chr</k>(<e>n</e>) returns the ASCII character corresponding to <e>n</e>.

</list>
</ref>
<ref>String Type: string

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>string</kd>
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>"</kd>s<e>tring-literal</e><k>"</k>
	<d>In the <k>"</k>s<e>tring-literal</e><k>"</k> constructor, <e>string-literal</e> is a sequence of characters or escape characters.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd id=combine_strings>infix</kd> &: <e>string * string -> string</e>
	<d>The expression <e>string1</e> & <e>string2</e> concatenates the two strings and returns the result.
<i><kd>implode</kd>: <e>char list -> string</e>
	<d><k>implode</k>(<e>char list</e>) returns a <k>string</k> built from <e>char list</e>.
<i><kd>explode</kd>: <e>string -> char list</e>
	<d><k>explode</k>(<e>string</e>) returns a <e S>char list</e> built from <e>string</e>.
<i><kd>numberToString</kd>: <e>number * number -> string</e>
	<d><k>numberToString</k>(<e>num</e>, <e>precision</e>) function formats <e>num</e> to a <k>string</k> with <e>precision</e> digits after the decimal point. If <e>precision</e> is zero, then the decimal point is elided. It is illegal for <e>precision</e> to be negative.

</list>
</ref>
<ref>Font Family Type: fontFamily

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><k>fontFamily</k>
</list>
<element><ti>Constructors
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>serifProportional</kd>: <e>fontFamily</e>
<i><kd>sansSerifProportional</kd>: <e>fontFamily</e>
<i><kd>monospaced</kd>: <e>fontFamily</e>

</list>
</ref>
<ref>Text Type: text

<element><ti>Type
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>text</kd>
	<d>ActiveVRML supports the construction of simply formatted text, which can then be rendered into an image. ActiveVRML 1.0 supports simple scaling, coloring, emboldening, italicizing, and choosing from a fixed set of typefaces.
</list>
<element><ti>Functions
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>simpleText</kd>: <e>string -> text</e>
	<d>The text created by <k>simpleText</k> has a default color (black), family (serif proportional), and is neither bold nor italic. It has a nominal scale of 1 point. 
<i><kd>textColor</kd>: <e>color </e>* <e>text -> text</e>
	<d><k>textColor</k> creates an attributor such that you can assign the color of the text.
<i><kd>textFamily</kd>: <e>fontFamily </e>* <e>text -> text</e>
	<d><e>textFamily</e> selects the text font.
	<d>This could use some explanation.
<i><kd>bold</kd>: <e>text -> text</e>
	<d><k>bold</k>(<e>text</e>) returns a new <k>text</k> type with emboldened text.
<i><kd>italic</kd>: <e>text -> text</e>
	<d><k>italic</k>(<e>text</e>) returns a new <k>text</k> type with italicized text.
<i><kd>renderedImage</kd>: <e>text -> image * point2</e>
	<d>The <k>renderedImage</k> function takes <k>text</k> and returns an <k>image</k>, with the text centered around (0,0) in the image.  The returned <k>point2</k> is the coordinate of the upper-right hand corner of the the nontransparent region of the resultant image.  The resultant image may subsequently be scaled by applying image transformations.
	<d>The resultant image is transparent in all places other than where the text is actually rendered.
	<d>There are explicitly no alignment operators (align left, right, center, etc.), as these can be achieved by transformation of the resultant image.
</list></ref>

<h1 id=integration_differentiation_and_interpolation><ti>Integration, Differentiation, and Interpolation

<p>Derivatives, integrals, and linear interpolation apply to the following types:
<list>
<data d=ALL r="1">
<i H>Type
<d H>Derivative
<i>number
	<d>number
<i>point2
	<d>vector2
<i>vector2
	<d>vector2
<i>point3
	<d>vector3
<i>vector3
	<d>vector3
</list>
<ex>
derivative: T -> DT
integral: DT -> DT
</ex>


<p>Note that the derivative of a point is a vector, but the integral of a vector is a vector.

<h1 id=single_user_interactivity><ti>Single User Interactivity

<p>Interaction with a user is one way in which a behavior value can change over time. For ActiveVRML 1.0 models, a very simple user input model for a single user is provided. It provides behaviors that represent the user's mouse and keyboard, and facilities for specifying reactions to picking (clicking on) geometry and images.

<h2><ti>User Input

<p>The keyboard and mouse of the user are modeled through a number of additional, pervasive library functions and values in ActiveVRML:
<list BREAKALL>
<data d=ALL r=".5">
<i><kd>leftButtonState</kd>: <e>boolean</e>
	<d>Tracks the state of the left button of the mouse.
<i><kd>leftButtonDown</kd>: <e>unit event</e>
	<d>Occurs each time the user presses the left mouse button.
<i><kd>leftButtonUp</kd>: <e>unit event</e>
	<d>Occurs each time the user releases the left mouse button.
<i><kd>rightButtonState</kd>: <e>boolean</e>
<i><kd>rightButtonDown</kd>: <e>unit event</e>
<i><kd>rightButtonUp</kd>: <e>unit event</e>
	<d>Analogous to the corresponding left button behaviors.
<i><kd>keyState</kd>: <e>character -> boolean</e>
	<d>For <e>keyDown</e>(<e>c</e>), the value is true if key <e>c</e> is presently depressed.
<i><kd>keyDown</kd>: <e>character event</e>
	<d>Occurs when a key is pressed. It produces the pressed character in the event data.
<i><kd>keyUp</kd>: <e>character event</e>
	<d>Occurs when a key is released. It produces the released character in the event data.
<i><kd>mousePosition</kd>: <e>point2</e>
	<d>Tracks the current position of the mouse in world image coordinates.
</list>

<h1 id=picking_images_and_geometry><ti>Picking Images and Geometry

<p>ActiveVRML 1.0 provides a simple model of picking geometry and images within a model. Picking is based upon a continuously probing input device, the user's mouse. The following probe functions take images (for 2D) or geometry (for 3D) and return events that occur when any ray, cast from the assumed eye point of the viewer, "touches" the specified image or geometry.

<p>Occlusion is taken into account. That is, probing rays do not pass through one nontransparent image and into another image, or through one nontransparent geometry into another.


<p>The ActiveVRML functions for picking are:

<ex>pickable: image * (string list) -> image * (point2 * vector2) event
pickable: geometry * (string list) -> geometry * (point3 * vector3) event
</ex>

<p>As an example of how these functions are used, consider:

<ex>origGeo = ...;
pickableGeo, pickEv = pickable(origGeo, ["my geo"]);
newGeo = pickableGeo until pickEv => function (pt,vec) . emptyGeometry;
</ex>

<p>(The discussions here are focused on geometry, but the identical properties hold for image picking.)

<p>When the user's probe device (typically his mouse) is over pickableGeo, pickEv will fire causing the event transition, making the geometry invisible (by transitioning to the empty geometry).  Somewhat more formally, in,

<ex>geo', ev = pickable(geo, path)
</ex>

<p>geo' behaves identically to geo, however, when the probe device is over it, the event ev is fired.  The event data that ev is invoked with is the static point of intersection between the probe and the geometry (in the local coordinates of geo), and a vector-valued behavior that tracks the probe as it moves relative to the pick point (also in local coordinates).

<p>The resultant geometry and event are completely insulated from any subsequent modeling transformations applied to the geometry.  Thus, the geometry can be arbitrarily transformed (and multiply referred to), but the event will still fire when any instance, in any coordinate frame, is picked.

<p>The path argument to pickable is a string list that is intended to allow the author to disambiguate between multiple instances of the same geometry or image in situations where different reactions are desired.  For instance:

<ex>origGeo = ...;
pickableGeo, pickEv = pickable(origGeo, ["my geo"]);
geo1 = transformGeometry(xf1)(pickableGeo);
geo2 = transformGeometry(xf2)(pickableGeo);
reactive1 = geo1 until pickEv => function (pt,vec) . emptyGeometry;
reactive2 = geo2 until pickEv => function (pt,vec) . emptyGeometry;
model = reactive1 union reactive2;
</ex>

<p>In this scenario, if either reactive1 or reactive2 is picked, both change to emptyGeometry, since the same event is being used.  If the author wants each instance to behave independently under picking, multiple invocations of pickable would be used, each with a different path argument:

<ex>origGeo = ...;
geo1, ev1 = pickable(origGeo, ["first"]);
geo2, ev2 = pickable(origGeo, ["second"]);

rg1 = transformGeometry(xf1)(geo1);
rg2 = transformGeometry(xf2)(geo2);

reactive1 = rg1 until ev1 => function (pt,vec) . emptyGeometry;
reactive2 = rg2 until ev2 => function (pt,vec) . emptyGeometry;
model = reactive1 union reactive2;
</ex>

<p>The path argument exists in order to allow different events to be returned from the same base geometry.  Because the return values of all of the functions in ActiveVRML are dependent solely upon the value of the inputs, multiple calls to pickable with the same geometry and the same path will return the same geometry * event pair each time.  Thus, the path argument exists to allow the author to explicitly disambiguate multiple instances, when desired.

<h1 id=pattern_matching><ti>Pattern Matching

<p>This section describes a useful, somewhat more advanced feature of ActiveVRML: the ability to specify declarations using pattern matching. The general syntax for a value declaration is as follows:
<ex>pattern = expression
</ex>


<p>The general syntax for a function declaration is as follows:
<ex>identifier pattern = expression
</ex>


<p>Patterns may be used to destructure values and specify bindings for (potentially) more than one identifier. Patterns are denoted in one of the following forms:
<list BREAKALL>
<data d=ALL r=".5">
<i>()
	<d>Matches the trivial value, (), of the type unit.
<i><e>identifier</e>
	<d>Matches any value and effectively binds the value to the identifier in the right hand side of the declaration. All of the identifiers in a pattern must be distinct.
<i><e>pattern1</e>, <e>pattern2</e>
	<d>Matches a pair value if <e>pattern1</e> and <e>pattern2</e> match the left and right components of the pair. The comma pattern associates right.
<i>(<e>pattern</e>)
	<d>Groups pattern syntax for readability and precedence. The form matches if <e>pattern</e> matches the value.
<i><e>pattern</e>: <e>type</e>
	<d>Matches the value if <e>pattern</e> does, and constrains the pattern to have a particular type.
</list>

<p>The following are a few example declarations:
<list BREAKALL>
<data d=ALL r=".5">
<i>x = 3
	<d>This declares an identifier <e>x</e> as a variable with a value of 3. 
<i>(x, y) = (4, 17)
	<d>This pattern matches since the pattern (<e>x</e>, <e>y</e>) and value (<e>4</e>, <e>17</e>) are both pairs. Effectively, <e>x</e> is bound to <e>4</e>, and <e>y</e> is bound to <e>17</e>.
<i>(x, y) = p
	<d>This declaration matches <e>x</e> to the first component of <e>p</e> (which must be a pair) and <e>y</e> to the second component of <e>p</e>.
<i>(x, y) = 3
	<d>This declaration will cause an error to be reported since 3 is not a pair.
<i>f() = 5
	<d>This declares a constant function. The application expression <e>f</e>() will always produce a value of 5.
<i>g(x) = x + 1
	<d>This declares a function <e>g</e> that takes an argument <e>x</e>.
<i>h(x, y) = x + y
	<d>This declares a function <e>h</e> that takes a single argument that must be a pair. The function may be applied either as <e>h</e>(<e>3</e>, <e>4</e>) or as <e>h</e>(<e>p</e>) where <e>p</e> is a pair of numbers.
<i>k(x, y, z) = x + y / z
	<d>This declares a function k that takes a single argument that is a pair, the second component of the pair being also a pair. Because comma patterns associate right, the argument takes the following form:
<ex>(int, (int, int))
</ex>

	<d>An application of <e>k</e> could look like <e>k</e>(<e>1</e>, <e>2</e>, <e>3</e>), <e>k</e>(<e>1</e>, (<e>2</e>, <e>3</e>)), <e>k</e>(<e>1</e>, <e>p</e>) where <e>p</e> is a pair, or <e>k</e>(<e>t</e>) where <e>t</e> is a triple of type <e>int*int*int</e>. The application <e>k</e>((<e>1</e>,<e>2</e>),<e>3</e>) will report an error.
</list>

<p>Pattern matching can also be used to specify the formals for a function expression. The following is an anonymous addition function:
<ex>function (x, y). x + y
</ex>


<p>And, this function returns the first element of a pair:
<ex>function (x, y). x
</ex>



<h1 id=world_wide_web_browsing><ti>ActiveVRML Models and World Wide Web Browsing

<p>This section describes the conventions that must be followed to connect an ActiveVRML model to a World Wide Web (web) browser for single-user interactive animations.

<p>ActiveVRML 1.0 models should contain the following comment as their first source line:
<ex>// ActiveVRML 1.0 ASCII
</ex>


<p>An ActiveVRML model consists of a list of top-level declarations.

<p>An external entry point will be a declaration with type <e>geometry</e> or <e>image*sound*sound</e>. These are the only behaviors that may be indexed from a uniform resource locator (URL). The former will cause the browser to enable a 3D navigational user interface to allow the user to navigate the geometry, and have the embedded sounds rendered (played). The latter form allows the creator of the model to use their own camera, and to directly specify the sounds to play to the left and right speakers.

<h2><ti>Embedding and Hyperlinking To ActiveVRML

<p>To specify a URL from an HTML document to an ActiveVRML model, use the following syntax:
<ex><a href="http://www.microsoft.com/model.av#mainEntry">
</ex>


<p>This will create an active link to the model <e>myModel</e> in the file <e>model</e>.<e>av</e> on the server <e>www</e>.<e>microsoft</e>.<e>com</e>. The entry point for the model, <e>mainEntry</e>, must be type <e>geometry</e> or <e>image*sound*sound</e>. The former is for geometries that will use the default camera from the view (including embedded sound). The latter is for images with stereo sound.

<p>When the user clicks the URL, an ActiveVRML 1.0 capable viewer will begin executing the ActiveVRML (at local time 0).

<p>In order to display an ActiveVRML model on an HTML page, it's necessary to use the OBJECT and PARAM tags. 

<ex>
&lt;OBJECT
    CLASSID="uuid:{389C2960-3640-11CF-9294-00AA00B8A733}"
    ID="AVView"
    WIDTH=300 HEIGHT=300&gt;
    &lt;PARAM NAME="DataPath" VALUE="earth.avr"&gt;
    &lt;PARAM NAME="Expression" VALUE="model"&gt;
&lt;/OBJECT&gt;
</ex>

<h3><ti>The OBJECT Tag

<p>The OBJECT tag has the following attributes:CLASSID, ID, WIDTH, and HEIGHT.

<p>The CLASSID attribute specifies the GUID that's assigned to the OLE control which displays ActiveVRML models. This 128-bit value is: 389C2960-3640-11CF-9294-00AA00B8A733.

<p>The ID attribute is a string used to identify the control if you need to set the control's properties programmatically. For example, the tutorial specifies an identifier of "AVView". Using this identifier and VB Scripting, it's possible to assign a new model
'on the fly' by setting the control's Frozen, Expression, and DataPath properties:
<ex>
AVView.Frozen = True
AVView.Expression = "second_model"
AVView.DataPath = "\avrml\avr\rotate.avr"
AVView.Frozen = False
</ex>

<p>The Frozen property disables the control temporarily so that both the Expression and DataPath properties can be set. (If Frozen were not set, the control would attempt to set reset the Expression property immediately using the
current DataPath.)

<p>The WIDTH and HEIGHT attributes specify the dimensions of the rectangle used by the control to display the model.

<h3><ti>The PARAM Tag

<p>The PARAM tag has the following attributes: NAME and VALUE. As the name implies, the PARAM tags specify parameters that are
used by the OLE control.

<P>
In the previous example and the first use of the PARAM tag, the corresponding NAME attribute specifies that a data path is being specified by the VALUE attribute.
<P>
In the previous example and the second use of the PARAM tag, the corresponding NAME attribute specifies that an string expression is being specified by the VALUE attribute. 

<h2><ti>Hyperlinking from ActiveVRML

<p>The hyperlinking interfaces in ActiveVRML are very basic:
<ex>hyperlink3: string * geometry -> geometry
hyperlink2: string * image -> image
</ex>


<p>These act as attributers for geometries and images. For example:
<ex>im2 = hyperlink2("http://www.microsoft.com")(im1)
</ex>


<p>The variable <e>im2</e> is now an image that when selected will be noticed by the browser, causing a jump to the specified URL. Note that the URL can be any valid web content type, not just ActiveVRML.


<h1 id=viewer_conventions_and_information><ti>Viewer Conventions and Information

<p>The ActiveVRML viewer window will obey a number of conventions that define its interaction with the model being displayed:


<p>The origin of displayed images will be at the center of the viewer window.

<p>When the window is resized, its coordinate range changes.  Thus, generally, more or less of the model comes into view, rather than the model being stretched or squeezed.  The model only reacts to changes in the size of the window if it is making use of the <k>viewerUpperRight</k> behavior described below.

<p> 

<p>The following information is available to the model in ActiveVRML:
<list BREAKALL>
<data d=ALL r=".5">
<i>viewerResolution: <e>number</e>
	<d>The resolution of the view in pixels per meter. In general, this number will be an approximation, as, among other things, monitor size varies.
<i>viewerUpperRight: <e>point2</e>
	<d>The coordinate of the upper-right corner of the viewer window. This is useful for models which size or position objects explicitly with respect to the window the model is being viewed in.
</list>

<h1 id=grammar_and_lexical_conventions><ti>ActiveVRML Grammar and Lexical Conventions

<p>The following information describes ActiveVRML grammatical formations and lexical conventions.

<h2><ti>Identifiers

<p>An ActiveVRML identifier is an alphanumeric string beginning with a letter. Identifiers are case sensitive. No length limit is imposed.

<h2><ti>Type identifiers

<p>A type identifier is an apostrophe (') followed by an identifier. In typeset documents, including this one, Greek letters are often used instead of ASCII for type identifiers to improve readability.

<h2><ti>Comments

<p>Comments are of the form
<ex>/* This is a comment. */
// This is a comment.
</ex>


<p>where the first form encloses any characters up to the first */ pattern and the latter form ignores everything until the end of line. Nested comments are handled correctly.

<h2><ti>White Space

<p>Spaces, tabs, carriage-returns, line-feeds, and comments are considered white space and are ignored other than as token separators.

<h2><ti>ActiveVRML Keywords

<p>Following are the keywords of ActiveVRML. These words are reserved and may not be used as identifiers:

<table>
<row><c>and
<row><c>else
<row><c>event
<row><c>function
<row><c>if
<row><c>import
<row><c>in
<row><c>let
<row><c>list
<row><c>mix
<row><c>not
<row><c>o
<row><c>or
<row><c>over
<row><c>then
<row><c>union
<row><c>until
</table>


<h2><ti>ActiveVRML Precedence Table
<list>
<i H>Operator
<d H>Associativity
<i>->
	<d>Right
<i>* (product type)
	<d>Left
<i>list event
	<d>Non Associative
<i>, (comma)
	<d>Right
<i>.(dot in function) else in 
	<d>Non Associative
<i>until
	<d>Right
<i>| (or event)
	<d>Left
<i>=> (event handler)
	<d>Left
<i>o union over mix 
	<d>Left
<i>:: (list cons)
	<d>Right
<i>or
	<d>Left
<i>and
	<d>Left
<i>not
	<d>Non Associative
<i>= < <= > >= <>
	<d>Left
<i>+ - (binary) &
	<d>Left
<i>* /
	<d>Left
<i>^ 
	<d>Right
<i>+ - (unary)
	<d>Non Associative
<i>: (type qualification)
	<d>Non Associative
</list>

<h2><ti>ActiveVRML Syntax
<ex>program:
declarations 
| epsilon

declarations:
declaration 
| declaration ;
| declaration ; declarations

declaration:
pattern = commaexpression
| identifier pattern = commaexpression
pattern:
 ()
| identifier
| pattern , pattern
| (pattern)
| pattern: typeexp

expressionlist:
nonemptyexpressionlist
| epsilon
nonemptyexpressionlist:
expression , nonemptyexpressionlist
| expression

commaexpression:
expression , commaexpression
| expression
expression:
if expression then expression else expression
| let declarations in expression
| function pattern . expression
| expression binaryoperator expression
| unaryoperator expression
| applyterm

binaryoperator:
 + | - | * | / | ^ | = | > | >= | < | <= |:: | & | and | or | until | | | union | over | mix | o 

unaryoperator:
 + | - | not

applyterm:
applyterm term 
| term
term:
 numberliteral
 | characterliteral
 | stringliteral
| identifier
| ()
| (commaexpression )
| [ expressionlist]
| term: typeexp

typeexp:
typeidentifier
| identifier
| typeexp * typeexp 
| typeexp -> typeexp
| typeexp identifier
| (typeexp)

epsilon:
/* empty */</ex>
</chp>

