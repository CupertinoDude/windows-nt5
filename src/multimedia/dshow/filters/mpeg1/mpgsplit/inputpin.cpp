// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.

/*

    File:  inputpin.cpp

    Description:

        Definitions for CMpeg1Splitter::CInputPin

    This class defines the input pin for the MPEG-I stream splitter.

    It handles

        Connection of the input pin including allocator negotiation

        Receive() of data from its connected pin which is sends
        to the parser
*/

#include <streams.h>
#include "driver.h"
#include <seqhdr.h>
#include <native.h>

#pragma warning(disable:4355)

/*  Constructor and Destructor */
CMpeg1Splitter::CInputPin::CInputPin(CMpeg1Splitter *pSplitter,
                                     HRESULT *phr) :
    CBaseInputPin(NAME("CMpeg1Splitter::CInputPin"),
                  &pSplitter->m_Filter,
                  &pSplitter->m_csFilter,
                  phr,
                  L"Input"),
    m_pSplitter(pSplitter),
    m_pPosition(NULL),
    m_llSeekPosition(0),
    m_bPulling(FALSE),
    m_puller(this)
{
}

CMpeg1Splitter::CInputPin::~CInputPin()
{
    ASSERT(m_pPosition == NULL);
}

/*  Helper to pass stuff to the parser

    If in the process of handling the data we do a seek within the
    allocator we repeat sending the data to the parser.  If we didn't
    do this we wouldn't work properly because if the output pin we're
    connected to is at end of stream in this situation we won't get
    called again
*/
inline HRESULT CMpeg1Splitter::CInputPin::SendDataToParser(
    BOOL bEOS
)
{
    CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;

    for (;;) {

        /*  We validate any newly valid data, call the parser and
            advance the pointer by as much as the parser ate
        */
        LONG lLengthToProcess = pAllocator->LengthValid();

        LONG lProcessed = m_pSplitter->m_pParse->ParseBytes(
                               pAllocator->GetCurrentOffset(),
                               pAllocator->GetPosition(),
                               lLengthToProcess,
                               bEOS ? CBasicParse::Flags_EOS : 0);

        DbgLog((LOG_TRACE, 3, TEXT("Processed %d bytes out of %d"),
                lProcessed, pAllocator->LengthValid()));

        pAllocator->Advance(lProcessed);

        if (m_State == State_Seeking) {
            /*  Force completion of seek */
            if (bEOS) {
                m_pSplitter->m_pParse->EOS();
            }

            /*  Check if a seek was requested */
            if (m_bSeekRequested) {
                //  This fires for some reason after time format
                //  changes due to the implicit seek
                //  generated by the format change
                //  ASSERT(m_bComplete);
                ASSERT(m_bPulling || (m_pPosition != NULL));

                /*  Note that we ate a seek but didn't request the
                    reader to seek
                */
                m_bSeekRequested = FALSE;

                CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;

                /*  Check to see if the allocator can do it */
                pAllocator->Seek(m_llSeekPosition);
            }

            if (m_bComplete) {
                /*  If we've completed a seek then Run() */
                SetState(State_Run);
                m_pSplitter->m_pParse->Run();

                /*  Send any data already in the allocator

                    If we don't do this here then the next call we
                    get might be EndOfStream and we wouldn't use
                    the data we already have
                */
            } else {
                return S_OK;
            }
        } else {  // State_Running
            /*  Flush out the rest */
            m_pSplitter->SendOutput();

            /*  We don't want any more data if we've completed the play */
            if (m_bComplete || bEOS) {
                /*  We must have finished a play */
                EndOfStreamInternal();

                /*  Return S_FALSE if there was no seek - in this case
                **  WE generate the EndOfStream() call (what if none of
                **  our output pins are connected)?
                */
                return S_FALSE;
            } else {
                return S_OK;
            }

            /*  Parsing errors are reported to the filter graph - but then
                we may be completely stuck if we get one?
            */
        }
    }
}


/* IMemInputPin virtual methods */

/*  Gets called by the output pin when another sample is ready */
STDMETHODIMP CMpeg1Splitter::CInputPin::Receive(IMediaSample *pSample)
{
    // m_csReceive is held for the receive-thread operations such as Receive
    // You must hold m_csFilter already if you want both.
    CAutoLock lck(&m_pSplitter->m_csReceive);

    // This function does not check for media type changes because
    // it is extremely unlikely that the upstream filter will try to change
    // the media type by attaching a media type to a media sample.  If
    // the upstream filter tries to change the media type, the parser code
    // will reject the samples with the new media type.
    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    BOOL bDiscontinuity = pSample->IsDiscontinuity() == S_OK;

    /*  Find out the position this sample corresponds to */
    CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;

    if (bDiscontinuity) {
        // Make sure the parser knows
        m_pSplitter->m_pParse->Replay();

        // we can seek if we have either IAsyncReader or IMediaPosition
        if (m_bPulling || (m_pPosition != NULL)) {

            // if we are receiving data from a new segment, then
            // IPin::NewSegment will have told us the start time
            // (handled in CBasePin).
            //
            // if we are pulling data, then we maintain m_tStart and m_tStop
            // ourselves to be the selection we are fetching.

            // We must have the rounded start time from the puller
            // so do it anyway
            pAllocator->SetStart((LONGLONG)m_tStart / UNITS);


            //  Don't overlap with next seek request

            {
                CAutoLock lck(&m_pSplitter->m_csPosition);

                //  Always go to seeking state for a time-based seek
                SetState(State_Seeking);
                m_pSplitter->m_pParse->SetSeekState();

                //  May not require seek phase
                if (m_bComplete) {
                    SetState(State_Run);
                }
            }


        } else {
            /*  If the source is not seekable then the start position
                is meaningless but the allocator wants to be told something
            */
            pAllocator->SetStart(0);
        }
    }

    /*  First give the sample back to the allocator - this
        will AddRef the sample and update the length valid
    */
    PBYTE pbData;
    EXECUTE_ASSERT(SUCCEEDED(pSample->GetPointer(&pbData)));
    LONG lData = pSample->GetActualDataLength();

    /*  Avoid bugs in allocator */
    if (lData == 0) {
        DbgLog((LOG_TRACE, 0, TEXT("Unexpected End Of File")));
        EndOfStream();
        return S_FALSE;
    }

    /*  AddRef() it so we hold on to it (Advance() in the allocator balances
        this)
    */
    pSample->AddRef();

    hr = pAllocator->Receive(pbData, lData);
    if (FAILED(hr)) {

        pSample->Release();
        NotifyError(hr);

        /*  The whole allocator is now 'bad' */
        return hr;
    }

    /*  Process the new data */
    return SendDataToParser(FALSE);
}

/*  Where we're told which allocator we are using */
STDMETHODIMP CMpeg1Splitter::CInputPin::NotifyAllocator(IMemAllocator *pAllocator)
{
    // The MPEG1 Splitter's input pin is designed to only work with its' own allocator.
    if (pAllocator != m_pAllocator) {
        return E_FAIL;
    }
    return S_OK;
}

/*  Use our own allocator if possible */
STDMETHODIMP CMpeg1Splitter::CInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    CAutoLock lck(m_pLock);

    HRESULT hr = S_OK;

    /*  Create our own allocator if it isn't already created */
    if (m_pAllocator == NULL) {
        m_pAllocator =
            new CStreamAllocator(NAME("CMpeg1Splitter::CInputPin::m_pAllocator"),
                                 NULL,     // No owner
                                 &hr,
                                 MAX_MPEG_PACKET_SIZE + 4);
        if (m_pAllocator == NULL) {
            hr = E_OUTOFMEMORY;
        } else {
            if (FAILED(hr)) {
                delete static_cast<CStreamAllocator *>(m_pAllocator);
                m_pAllocator = NULL;
            } else {
                m_pAllocator->AddRef();
            }
        }
    }

    *ppAllocator = m_pAllocator;

    /*  We return a reference counted pointer */
    if (m_pAllocator != NULL) {
        m_pAllocator->AddRef();
    }
    return hr;
}

/*  Start Flushing samples
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::BeginFlush()
{
    CAutoLock lck(m_pLock);

    if (m_pSplitter->m_Filter.m_State == State_Stopped) {
        return S_OK;
    }
    CBaseInputPin::BeginFlush();

    // can't flush the allocator here - need to sync with receive
    // thread, so do it in EndFlush

    /*  call the downstream pins  */
    return m_pSplitter->BeginFlush();
}

/*  End flushing samples - after this we won't send any more
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::EndFlush()
{
    CAutoLock lck(m_pLock);
    if (!IsFlushing()) {
        return S_OK;
    }

    //  Flush the allocator - need to do this after the receive
    // thread has been deactivated.
    CStreamAllocator *pAlloc = (CStreamAllocator *)m_pAllocator;
    pAlloc->ResetPosition();

    if (m_pSplitter->m_Filter.m_State != State_Stopped) {
        m_pSplitter->EndFlush();
    }
    return CBaseInputPin::EndFlush();
}

#if 0
HRESULT CMpeg1Splitter::CInputPin::SetStop(REFTIME llTime)
{
    ASSERT(m_bPulling || (m_pPosition != NULL));

    /*  We have to make the reader flush so reset its start! */
    // m_tStart is not our last SetStart value, but the last
    // NewSegment call. Thus if the app does put_Current, put_Stop
    // the put_Stop may reset the start position on the reader to
    // the start position before the put_Current.
    //
    // Safest fix according to Robin is just to not do this. The cost
    // is that if someone does (just) a put_Stop when the reader had
    // already reached the old stop position, the reader will not continue
    // to play beyond that old stop position

    // we know the start time from the last NewSegment call
    DbgLog((LOG_TRACE, 2, TEXT("CInputPin::SetStop - put_CurrentPosition(%s)"),
               (LPCTSTR)CDisp(m_tStart)));

    HRESULT hr = m_pPosition->put_CurrentPosition(m_tStart);

    return S_OK;
}
#endif


/*  Say if Receive can block
    It can't for us so we return S_FALSE
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::ReceiveCanBlock()
{
    return S_FALSE;
}

void CMpeg1Splitter::CInputPin::EndOfStreamInternal()
{
    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::CInputPin::EndOfStreamInternal()")));
    CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;
    pAllocator->Advance(pAllocator->TotalLengthValid());
    m_pSplitter->EndOfStream();
}

/*  End of data - either called by our input pin or by us if we
    detect it ourselves
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::EndOfStream()
{
    // hold m_csReceive on receive-thread operations to sync with Stop

    CAutoLock lck(&m_pSplitter->m_csReceive);
    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }
    /*  Send any dregs to the parser
        SendDataToParser will call EndOfStreamInternal
    */
    SendDataToParser(TRUE);

    return S_OK;
}


/* CBasePin methods */

HRESULT CMpeg1Splitter::CInputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    pMediaType->majortype            = MEDIATYPE_Stream;
    ASSERT(pMediaType->bFixedSizeSamples);
    pMediaType->bTemporalCompression = TRUE;
    ASSERT(pMediaType->lSampleSize == 1);

    switch (iPosition) {
    case 0:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1System;
        break;

    case 1:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1VideoCD;
        break;

    case 2:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1Video;
        break;

    case 3:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1Audio;
        break;

    default:
        return VFW_S_NO_MORE_ITEMS;
    }
    return S_OK;
}


/*  Connection establishment */
HRESULT CMpeg1Splitter::CInputPin::CheckMediaType(const CMediaType *pmt)
{
    for (int i = 0; ; i++) {
        CMediaType mt;
        HRESULT hr = GetMediaType(i, &mt);
        if (hr == VFW_S_NO_MORE_ITEMS) {
            break;
        }
        if (*pmt->Type() == *mt.Type() &&
            *pmt->Subtype() == *mt.Subtype()) {
            if (*pmt->FormatType() == GUID_NULL) {
                return S_OK;
            }
            if ((pmt->subtype == MEDIASUBTYPE_MPEG1System ||
                 pmt->subtype == MEDIASUBTYPE_MPEG1VideoCD) &&
                pmt->formattype == FORMAT_MPEGStreams ||
                pmt->subtype == MEDIASUBTYPE_MPEG1Audio &&
                pmt->formattype == FORMAT_WaveFormatEx ||
                pmt->subtype == MEDIASUBTYPE_MPEG1Video &&
                pmt->formattype == FORMAT_VideoInfo) {
                return S_OK;
            }
        }
    }
    return S_FALSE;
}

/*  Called when connect is broken or we fail to connect */
HRESULT CMpeg1Splitter::CInputPin::BreakConnect()
{
    DbgLog((LOG_TRACE, 2, TEXT("CInputPin::BreakConnect()")));

    if (m_bPulling) {
        m_puller.Disconnect();
        m_bPulling = FALSE;
    }

    /*  Disconnect and remove all the output pins */
    m_pSplitter->RemoveOutputPins();
    if (m_pPosition != NULL) {
        m_pPosition->Release();
        m_pPosition = NULL;
    }

    /*  Free the parser */
    if (m_pSplitter->m_pParse != NULL) {
        delete m_pSplitter->m_pParse;
        m_pSplitter->m_pParse = NULL;
    }
    return CBaseInputPin::BreakConnect();
}

/*  Override active to tell parser we're going to get new data */
HRESULT CMpeg1Splitter::CInputPin::Active()
{
    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::CInputPin::Active()")));
    HRESULT hr = m_pSplitter->m_pParse->Replay();
    if (FAILED(hr)) {
        return hr;
    }

    if (m_bPulling) {

        // since we control exactly when and where we get data from,
        // we should always explicitly set the start and stop position
        // ourselves here
        m_puller.Seek(m_tStart, m_tStop);

        // if we are pulling data from IAsyncReader, start our thread working
        hr = m_puller.Active();
        if (FAILED(hr)) {
            return hr;
        }
    }

    return CBaseInputPin::Active();
}

/*  Override Inactive to synchronize with Receive() */
HRESULT CMpeg1Splitter::CInputPin::Inactive()
{
    if (!IsConnected()) {
        return S_OK;
    }

    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::CInputPin::Inactive()")));

    // if we are pulling data from IAsyncReader, stop our thread
    if (m_bPulling) {
        HRESULT hr = m_puller.Inactive();
        if (FAILED(hr)) {
            return hr;
        }
    }

    /*  Call the base class - future Receives will now fail */
    return CBaseInputPin::Inactive();
}

/*  Override CompleteConnect so we can check out the real file data
    before accepting the connection
*/
HRESULT CMpeg1Splitter::CInputPin::CompleteConnect(IPin *pPin)
{
    DbgLog((LOG_TRACE, 3, TEXT("CMpeg1Splitter::CInputPin::CompleteConnect")));

#define READ_SIZE 32768
#define BUFFER_SIZE \
        (((MAX_MPEG_PACKET_SIZE + READ_SIZE - 1) / READ_SIZE) * READ_SIZE)

    int ReadSize = READ_SIZE;
    int BufferSize = BUFFER_SIZE;

    /*  Set up the parser */
    if (m_mt.subtype == MEDIASUBTYPE_MPEG1System) {
        m_pSplitter->m_pParse = new CMpeg1SystemParse;
        if (m_pSplitter->m_pParse == NULL) {
            return E_OUTOFMEMORY;
        }
    } else {
        if (m_mt.subtype == MEDIASUBTYPE_MPEG1VideoCD) {
            m_pSplitter->m_pParse = new CVideoCDParse;
            if (m_pSplitter->m_pParse == NULL) {
                return E_OUTOFMEMORY;
            }
        } else {
            if (m_mt.subtype == MEDIASUBTYPE_MPEG1Video) {
                m_pSplitter->m_pParse = new CNativeVideoParse;
            } else {
                if (m_mt.subtype == MEDIASUBTYPE_MPEG1Audio) {
                    m_pSplitter->m_pParse = new CNativeAudioParse;

                    //  Allow for large (64K) ID3 headers when scanning
                    ReadSize = 16 * 1024;
                    BufferSize = 128 * 1024;
                } else {
                    return E_FAIL;
                }
            }
        }
    }


    // simple file reader class for use by GetStreamsAndDuration.
    // we can build one of these on IStream or IAsyncReader
    CReader* pReader = NULL;

    //
    // look for IAsyncReader on the output pin and if found set up for
    // pulling data instead of using IMemInputPin.
    //
    // make an allocator first
    IMemAllocator* pAlloc;
    HRESULT hr = GetAllocator(&pAlloc);
    if (FAILED(hr)) {
        return hr;
    }
    pAlloc->Release();  // Our pin still has a ref count

    // Pull synchrously to avoid reading too much beyond the stop time
    // or seek position
    hr = m_puller.Connect(pPin, pAlloc, TRUE);
    if (S_OK == hr) {
        m_bPulling = TRUE;

        CReaderFromAsync* pR = new CReaderFromAsync;
        if (NULL == pR) {
            m_puller.Disconnect();
            return E_OUTOFMEMORY;
        }
        IAsyncReader* pSource = m_puller.GetReader();

        //  HACKHACK - do a huge read to download the whole of an FTP
        //  file
        ASSERT(pSource != NULL);
        BYTE bData[1];
        LONGLONG llTotal, llAvailable;
        HRESULT hr = pSource->Length(&llTotal, &llAvailable);
        if (FAILED(hr)) {
            pSource->Release();
            return hr;
        }
        if (llTotal == 0) {
            HRESULT hrRead = pSource->SyncRead(0x7FFFFFFFFFF, 1, bData);
            ASSERT(S_OK != hrRead);

            //  Reconnect to set up correct duration
            pSource->Release();
            m_puller.Disconnect();
            hr = m_puller.Connect(pPin, pAlloc, TRUE);
            if (FAILED(hr)) {
                return hr;
            }
            pSource = m_puller.GetReader();
            pSource->Length(&llTotal, &llAvailable);
            if (llTotal == 0) {
                pSource->Release();
                return FAILED(hrRead) ? hrRead : VFW_E_TYPE_NOT_ACCEPTED;
            }
            ASSERT(llTotal >= llAvailable);
        }

        hr = pR->Init(
                pSource,
                BufferSize,
                ReadSize,
                TRUE);
        if (FAILED(hr)) {
            delete pR;
            return hr;
        }
        // if it succeeded, it addrefed the interface

        pReader = pR;
   } else {


        /*  See if output pin supports IStream */
        IStream *pStream;
        hr = pPin->QueryInterface(IID_IStream, (void **)&pStream);

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("Outpin pin doesn't support IStream")));
        } else {

            /*  See if the output pin supports IMediaPosition */
            pPin->QueryInterface(IID_IMediaPosition, (void **)&m_pPosition);

            /*  Read the stream to get the stream data */
            CReaderFromStream* pR = new CReaderFromStream;
            if (pR) {
                hr = pR->Init(
                        pStream,
                        BufferSize,
                        ReadSize,
                        m_pPosition != NULL);
            } else {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr)) {
                pStream->Release();
                delete pR;
                return hr;
            }
            // if it succeeded it addrefed the stream.
            pReader = pR;
        }
    }

    hr = GetStreamsAndDuration(pReader);

    // releases any addrefed interfaces
    delete pReader;

    return hr;
}

/*
     Do all the basic work to create information from the MPEG data:

     1.  Read the start of the data (or from the current data if
         the stream is not seekable) and pass the data to the parser
         for it to extract format data and a start time for each
         stream

     2.  If the stream is seekable find the end (time)

     3.  For each stream found an output pins


*/
HRESULT CMpeg1Splitter::CInputPin::GetStreamsAndDuration(CReader *pReader)
{
    /*  Basically just process the file until we've got the
        data we need we use a circular buffer object for this (do
        we really need this or can we work to a fixed size?)
    */

    /*  No pins yet */
    ASSERT(m_pSplitter->m_OutputPins.GetCount() == 0);

    /*  Initialize */
    m_bSeekRequested = FALSE;

    /*  Initialize the parser */
    CBasicParse *pParse = m_pSplitter->m_pParse;
    pParse->SetNotify(this);

    LONGLONG llSize, llAvail;
    if (pReader != NULL) {
        llSize = pReader->GetSize(&llAvail);
    }
    pParse->Init(pReader == NULL ? 0 : llSize,
                 pReader == NULL ? FALSE : pReader->IsSeekable(),
                 &m_mt);

    if (pReader != NULL) {
        /*  m_bComplete is set by the completion callback from the parser
        */
        SetState(State_Initializing);
        LONGLONG llPos = 0;

        /*  Find the streams by searching from the start */
        HRESULT hr;
        while (!m_bComplete) {

            hr = pReader->ReadMore();
            if (FAILED(hr)) {
                return hr;
            }

            PBYTE    pbData;
            LONG     lLength;
            pbData = pReader->GetCurrent(lLength, llPos);

            DWORD dwFlags = llSize == llAvail ? 0 : CBasicParse::Flags_SlowMedium;
            if (S_FALSE == hr) {
                dwFlags |= CBasicParse::Flags_EOS;
            }

            LONG lProcessed = pParse->ParseBytes(llPos,
                                                  pbData,
                                                  lLength,
                                                  dwFlags);
            ASSERT(lProcessed <= lLength);
            if (hr == S_FALSE) {
                pParse->EOS();
                break;
            }
            pReader->Advance(lProcessed);
        }

        /*  If we got no streams fail */
        if (pParse->NumberOfStreams() == 0) {
            /*  Not an MPEG file */
            return E_INVALIDARG;
        }


        /*  See if we should find the length */
        if (pParse->IsSeekable() && llSize == llAvail) {

            /*  Set our own state */
            SetState(State_FindEnd);
            pParse->FindEnd();
            if (m_bSeekRequested) {
                m_bSeekRequested = FALSE;
                hr = pReader->Seek(m_llSeekPosition);
                if (FAILED(hr)) {
                    return hr;
                }
            }

            /*  Some parsing doesn't require this extra pass
                (Audio and short video files) in which case it
                will have called complete() inside FindEnd().
            */
            if (!m_bComplete) {

                for (;;) {
                    hr = pReader->ReadMore();
                    if (FAILED(hr)) {
                        return hr;
                    }

                    PBYTE    pbData;
                    LONGLONG llPos;
                    LONG     lLength;
                    pbData = pReader->GetCurrent(lLength, llPos);

                    LONG lProcessed = pParse->ParseBytes(llPos,
                                                         pbData,
                                                         lLength,
                                                         S_FALSE == hr ? CBasicParse::Flags_EOS : 0);
                    ASSERT(lProcessed <= lLength);
                    if (hr == S_FALSE) {
                        pParse->EOS();
                        break;
                    }
                    pReader->Advance(lProcessed);
                }
            }
            REFERENCE_TIME tDuration;
            HRESULT hr = pParse->GetDuration(&tDuration);
            if (FAILED(hr)) {
                return hr;
            }

            DbgLog((LOG_TRACE, 2, TEXT("Duration is %s"),
                   (LPCTSTR)CDisp(tDuration)));
        }
    } else {
        /*  If we got no streams in the media type fail */
        if (pParse->NumberOfStreams() == 0) {
            /*  Not an MPEG file */
            return E_INVALIDARG;
        }
    }

    /*  Now make a pin for each stream
    */

    for (int i = 0; i < pParse->NumberOfStreams(); i++) {

        CBasicStream *pStream;
        pStream = pParse->GetStream(i);

        HRESULT hr = S_OK;
        /*  Create an output pin for this stream */
        COutputPin *pPin = new COutputPin(m_pSplitter,
                                          pStream->m_uStreamId,
                                          pStream,
                                          &hr);
        if (pPin == NULL) {
            return E_OUTOFMEMORY;
        }
        if (FAILED(hr)) {
            delete pPin;
            return hr;
        }

        /* Release() is called when the pin is removed from the list */
        pPin->AddRef();
        POSITION pos = m_pSplitter->m_OutputPins.AddTail(pPin);
        if (pos == NULL) {
            delete pPin;
            return E_OUTOFMEMORY;
        }
    }

    /*  Fix up the allocator for this file */
    ALLOCATOR_PROPERTIES propRequest, propActual;

    /* Make sure we've got an allocator then set our preferred size */
    IMemAllocator *pAlloc;
    EXECUTE_ASSERT(SUCCEEDED(GetAllocator(&pAlloc)));
    pAlloc->Release();
    LONG lBufferSize = m_pSplitter->m_pParse->GetBufferSize();

    propRequest.cbPrefix = 0;
    propRequest.cbAlign = 1;
    propRequest.cBuffers = 4;
    propRequest.cbBuffer = lBufferSize/4;
    EXECUTE_ASSERT(SUCCEEDED(
        m_pAllocator->SetProperties(
            &propRequest,
            &propActual)));

    /*  Put ourselves into 'running' state */
    SetState(State_Run);
    pParse->Run();
    return S_OK;
}

/*  Get available and total byte counts from upstream */
HRESULT CMpeg1Splitter::CInputPin::GetAvailable(
    LONGLONG * pllTotal,
    LONGLONG * pllAvailable )
{
    if (!m_bPulling) {
        return E_FAIL;
    } else {
        IAsyncReader *pReader = m_puller.GetReader();
        HRESULT hr = pReader->Length(pllTotal, pllAvailable);
        pReader->Release();
        return hr;
    }

}

/*  Set up for seeking */
HRESULT CMpeg1Splitter::CInputPin::SetSeek(
             LONGLONG llStart,
             REFERENCE_TIME *prtStart,
             const GUID *pTimeFormat)
{
    BOOL bDoSeek = FALSE;
    REFERENCE_TIME tSeekPosition;
    {
        CAutoLock lck2(&m_pSplitter->m_csPosition);

        /*  Latch the seek time

            This will be used next time we get a discontinuity in the
            input data
        */

        /*  Ask the parser where to seek to */
        m_pSplitter->m_pParse->Seek(llStart, prtStart, pTimeFormat);

        /*  Check if this generated a seek request */
        if (m_bSeekRequested) {
            ASSERT(m_bPulling || (m_pPosition != NULL));
            m_bSeekRequested = FALSE;

            /*  Position is in seconds */
            tSeekPosition = COARefTime((REFTIME)m_llSeekPosition);
            DbgLog((LOG_TRACE, 3, TEXT("Requesting reader to seek to %s"),
                   (LPCTSTR)CDisp(tSeekPosition)));

            bDoSeek = TRUE;
        }
    }
    if (bDoSeek) {
        return DoSeek(COARefTime(tSeekPosition));
    } else {
        return S_OK;
    }
}
/*  Seek the upstream pin */
HRESULT CMpeg1Splitter::CInputPin::DoSeek(REFERENCE_TIME tSeekPosition)
{
    HRESULT hr = S_OK;
    if (m_bPulling) {
        // tell our worker thread the new segment.
        ALLOCATOR_PROPERTIES Actual;
        hr = m_pAllocator->GetProperties(&Actual);
        m_tStart = m_puller.AlignDown(tSeekPosition / UNITS, Actual.cbAlign) * UNITS;
        hr = m_puller.Seek(m_tStart, m_tStop);
    } else {
        // m_tStart will be set by the NewSegment call from the
        // upstream filter when it starts pushing this data
        hr = m_pPosition->put_CurrentPosition(COARefTime(tSeekPosition));
    }

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("Seek failed code 0x%8.8X"), hr));
    }
    return hr;
}

#pragma warning(disable:4514)

