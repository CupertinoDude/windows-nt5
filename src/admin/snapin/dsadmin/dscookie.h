//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSCookie.h
//
//  Contents:  DS Cookie functions
//
//  History:   02-Oct-96 WayneSc    Created
//
//--------------------------------------------------------------------------


#ifndef __DSCOOKIE_H__
#define __DSCOOKIE_H__

#include "dscache.h"
#include "uinode.h"

// Forward prototypes
class CContextMenuVerbs;




/////////////////////////////////////////////////////////////////////////////
// CDSCookieInfoBase : extra inof for special classes we know about

class CDSCookieInfoBase
{
public:
  enum cookieClass { base, group, connection };
  CDSCookieInfoBase()
  {
    m_class = base;
  }
  virtual ~CDSCookieInfoBase()
  {
  }
  cookieClass GetClass() { return m_class;}
  virtual LPCWSTR GetFriendlyClassName() { return L"";}
protected:
  cookieClass m_class;
};

/////////////////////////////////////////////////////////////////////////////
// CDSCookieInfoGroup : extra info for groups

class CDSCookieInfoGroup : public CDSCookieInfoBase
{
public:
  CDSCookieInfoGroup() 
  { 
    m_class = group;
    m_GroupType = 0;
  }

  virtual LPCWSTR GetFriendlyClassName() 
  { 
    return GetGroupTypeStringHelper(m_GroupType);
  }
  INT m_GroupType;
};


/////////////////////////////////////////////////////////////////////////////
// CDSCookieInfoConnection : extra info for nTDSConnection objects

class CDSCookieInfoConnection : public CDSCookieInfoBase
{
public:
  CDSCookieInfoConnection()
  {
    m_class = connection;
    m_nOptions = 0;
    m_fFRSConnection = FALSE;
  }
  CString m_strFRSComputerReference; // not always present
  int m_nOptions;
  BOOL m_fFRSConnection; 
};


/////////////////////////////////////////////////////////////////////////////
// CDSCookie

// CODEWORK these flags come from ntdsa.h

/* Object Class independent bits */
// NOTE: These flags MAY have different behaviour in different NCs.
// For example, the FLAG_CONFIG_foo flags only have meaning inside the
// configuration NC.  the FLAG_DOMAIN_foo flags have meaning only outside the
// configuration NC.  
#define FLAG_DISALLOW_DELETE           0x80000000
#define FLAG_CONFIG_ALLOW_RENAME       0x40000000 
#define FLAG_CONFIG_ALLOW_MOVE         0x20000000 
#define FLAG_CONFIG_ALLOW_LIMITED_MOVE 0x10000000 
#define FLAG_DOMAIN_DISALLOW_RENAME    0x08000000
#define FLAG_DOMAIN_DISALLOW_MOVE      0x04000000

// Bit flags for options attribute on NTDS-Connection objects.
#define NTDSCONN_OPT_IS_GENERATED       ( 1 << 0 )  /* object generated by DS, not admin */

/* Object Class specific bits, by object class */

/* CrossReference objects */
#define FLAG_CR_NTDS_NC       0x00000001 // NC is in NTDS (not VC or foreign)
#define FLAG_CR_NTDS_DOMAIN   0x00000002 // NC is a domain (not non-domain NC)

// end of ntdsa.h

class CDSCookie : public CNodeData
{
public:
    CDSCookie();
    virtual ~CDSCookie();

//operators
public:


  // values retrieved from the cache item (per class values)
  int GetImage(BOOL bOpen); // base and DS
  GUID* GetGUID();  // base and DS

  LPCWSTR GetClass();
  LPCWSTR GetLocalizedClassName();

  // Value management functions
  void SetName(LPCWSTR lpszName) { m_strName = lpszName;}
  LPCWSTR GetName() { return m_strName; }
  
  void SetPath(LPCWSTR lpszPath) { m_strPath = lpszPath;}
  LPCWSTR GetPath(void) { return m_strPath;}
  
  void SetSystemFlags(int iSystemFlags) { m_iSystemFlags=iSystemFlags;}
  int GetSystemFlags(void) { return m_iSystemFlags; }

  void SetDesc(LPCWSTR lpszDesc) { m_strDesc = lpszDesc;}
  LPCWSTR GetDesc() { return m_strDesc; }
  
  void SetCacheItem(CDSClassCacheItemBase* pCacheItem) 
  { 
    ASSERT(pCacheItem != NULL);
    m_pCacheItem = pCacheItem;
  }


  void SetChildList(WCHAR **ppList);
  WCHAR ** GetChildList(void) { return m_ppChildList; }
  
  void SetChildCount(int cChildCount) { m_cChildCount=cChildCount;}
  int GetChildCount(void) { return m_cChildCount; }

  LPCWSTR GetChildListEntry(int iChildIndex) 
  { 
    ASSERT(iChildIndex >= 0 && iChildIndex < GetChildCount());
    return m_ppChildList[iChildIndex];
  }


  BOOL IsDisabled() {	return m_bDisabled; }
  void SetDisabled() { m_bDisabled=TRUE; }
  void ReSetDisabled() { m_bDisabled=FALSE; }

  BOOL IsNonExpiringPwd() { return m_bNonExpiringPassword; }
  void SetNonExpiringPwd() { m_bNonExpiringPassword = TRUE; }
  void ReSetNonExpiringPwd() { m_bNonExpiringPassword = FALSE; }

  BOOL IsContainerClass()
  { 
    if (m_pCacheItem == NULL)
    {
      ASSERT(FALSE); // should never happen
      return TRUE;
    }
    // ask the class cache item about it
    return m_pCacheItem->IsContainer();
  }


  CDSCookieInfoBase* GetExtraInfo() { return m_pExtraInfo;}
  void SetExtraInfo(CDSCookieInfoBase* pExtraInfo)
  {
    ASSERT(pExtraInfo != NULL);
    if (m_pExtraInfo != NULL)
      delete m_pExtraInfo;
    m_pExtraInfo = pExtraInfo;
  }


  
  CStringList& GetParentClassSpecificStrings(void)
  { return m_strlistParentClassSpecificStrings; }

  SYSTEMTIME* GetModifiedTime() { return m_pModifiedTime; }
  void SetModifiedTime(SYSTEMTIME* pModifiedTime)
  {
    if (m_pModifiedTime == NULL)
    {
      m_pModifiedTime = (SYSTEMTIME*)malloc(sizeof(SYSTEMTIME));
    }

    if (m_pModifiedTime != NULL)
    {
      memcpy(m_pModifiedTime, pModifiedTime, sizeof(SYSTEMTIME));
    }
  }

  

//attributes
  
private:
  CString     m_strName;
  CString     m_strPath;
  int         m_iSystemFlags; // systemFlags of the node
  CString     m_strDesc;
  WCHAR     **m_ppChildList; // list of allowable child classes
  int         m_cChildCount; // count of items in above list
  
  BOOL        m_bDisabled;      // only valid if class is sec. princ.
  BOOL        m_bNonExpiringPassword; // only valid if class is sec. princ.

  // We enumerate additional attributes depending on the class of the parent.
  CStringList     m_strlistParentClassSpecificStrings;
  SYSTEMTIME*    m_pModifiedTime;
  

  
  CDSClassCacheItemBase* m_pCacheItem;
  CDSCookieInfoBase* m_pExtraInfo;
};


/////////////////////////////////////////////////////////////////////////////
// CDSUINode : UI node corresponding to a DS object (result of an ADSI query)

class CDSUINode : public CUINode
{
public:
  CDSUINode(CUINode* pParentNode);

  // override of pure virtual functions
  virtual void SetName(LPCWSTR lpszName) { GetCookie()->SetName(lpszName);}
  virtual LPCWSTR GetName() { return GetCookie()->GetName();}

  virtual void SetDesc(LPCWSTR lpszDesc) { GetCookie()->SetDesc(lpszDesc);}
  virtual LPCWSTR GetDesc() { return GetCookie()->GetDesc();}

  int GetImage(BOOL bOpen) { return GetCookie()->GetImage(bOpen);}
  virtual GUID* GetGUID() { return GetCookie()->GetGUID();}

  virtual LPCWSTR GetDisplayString(int nCol, CDSColumnSet* pColumnSet);

  CDSCookie* GetCookie() 
  {
    // assume that the cast succeeds
    CDSCookie* pCookie = dynamic_cast<CDSCookie*>(m_pNodeData);
    ASSERT(pCookie != NULL);
    return pCookie;
  }
  void SetCookie(CDSCookie* pCookie) 
  {
    ASSERT(m_pNodeData == NULL);
    m_pNodeData = pCookie;
  }

// end port

  virtual CDSColumnSet* GetColumnSet(CDSComponentData* pComponentData);

  //
  // These set the state of the standard context menu items
  //
  virtual BOOL IsDeleteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRenameAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRefreshAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL ArePropertiesAllowed(CDSComponentData* pComponentData, BOOL* pbHide);

  virtual BOOL IsCutAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCopyAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsPasteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);

  virtual CContextMenuVerbs* GetContextMenuVerbsObject(CDSComponentData* pComponentData);

  virtual BOOL HasPropertyPages(LPDATAOBJECT pDataObject);
};

// REVIEW_MARCOC_PORT: this is just to get going, cannot assume this ever
inline CDSCookie* GetDSCookieFromUINode(CUINode* pUINode)
{
  ASSERT(pUINode != NULL);
  CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
  ASSERT(pDSUINode != NULL);
  return pDSUINode->GetCookie();
}




/////////////////////////////////////////////////////////////////////////////
// CDSThreadQueryInfo

typedef enum DSQueryType { unk, rootFolder, dsFolder, queryFolder };

class CDSThreadQueryInfo : public CThreadQueryInfo
{
public:

  CDSThreadQueryInfo()
  {
    m_bOneLevel = TRUE;
    m_QueryType = unk;
  }

  void SetQueryDSQueryParameters(DSQueryType QueryType, 
                                 LPCWSTR lpszPath, 
                                 LPCWSTR lpszClass,
                                 LPCWSTR lpszQueryString, 
                                 UINT nMaxItemCount,
                                 BOOL bOneLevel,
                                 LPCWSTR lpszColumnSetID)
  {
    ASSERT(m_QueryType == unk);
    ASSERT(QueryType != unk);
    m_QueryType = QueryType;
    SetMaxItemCount(nMaxItemCount);
    m_szPath = lpszPath;
    m_szClass = lpszClass;
    m_szQueryString = lpszQueryString;
    m_bOneLevel = bOneLevel;
    m_szColumnSetID = lpszColumnSetID;
  }

  BOOL IsOneLevel() { return m_bOneLevel;}
  DSQueryType GetType() { return m_QueryType;}
  LPCWSTR GetPath() { return m_szPath;}
  LPCWSTR GetClass() { return m_szClass;}
  LPCWSTR GetQueryString() { return m_szQueryString;}
  LPCWSTR GetColumnSetID() { return m_szColumnSetID;}

private:
  BOOL    m_bOneLevel;
  DSQueryType    m_QueryType;
  CString m_szPath;
  CString m_szClass;
  CString m_szQueryString;
  CString m_szColumnSetID;
};

/////////////////////////////////////////////////////////////////////////////
// CThreadQueryResult

class CThreadQueryResult
{
public:
  CThreadQueryResult()
  {
    m_hr = S_OK;
    m_bOwnMemory = TRUE;
  }
  ~CThreadQueryResult()
  {
    if (m_bOwnMemory)
    {
      while (!m_nodeList.IsEmpty())
        delete m_nodeList.RemoveHead();
    }
  }
  CUINodeList m_nodeList;
  HRESULT m_hr;
  BOOL m_bOwnMemory;
};



#endif //__DSCOOKIE_H__
