#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "MultiSel.h"
#include <windows.h>
#include "TReg.hpp"
#include "ResStr.h"

HRESULT GetHelpFileFullPath( BSTR *bstrHelp )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString                   strPath, strName;
   TRegKey                   key;
   TCHAR                     szModule[2*_MAX_PATH];
   DWORD                     dwReturn = 0;
   LPOLESTR					 lpHelpFile;

	  //mmc requires we use CoTaskMemAlloc to allocate memory returned from 
      //this function
   lpHelpFile = (LPOLESTR) CoTaskMemAlloc( 2 * MAX_PATH * sizeof(WCHAR) );
   if ( !lpHelpFile )
   {
       return E_OUTOFMEMORY;
   }

   dwReturn = key.Open(GET_STRING(IDS_DOMAIN_ADMIN_REGKEY),HKEY_LOCAL_MACHINE);
   if ( ! dwReturn )
   {
      dwReturn = key.ValueGetStr(L"Directory",szModule,DIM(szModule));
      if (! dwReturn )
      {
         strPath = szModule;
         strPath += L"\\";
         strName.LoadString(IDS_HELPFILE);
         strPath += strName;
      }
   }
   wcscpy(lpHelpFile, strPath);
   *bstrHelp = lpHelpFile;

   return HRESULT_FROM_WIN32(dwReturn);
}

/////////////////////////////////////////////////////////////////////////////
// CDomMigratorComponentData
static const GUID CDomMigratorGUID_NODETYPE = 
{ 0xe1975d72, 0x3f8e, 0x11d3, { 0x99, 0xee, 0x0, 0xc0, 0x4f, 0x39, 0xbd, 0x92 } };

HRESULT CDomMigrator::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CDomMigrator, CDomMigratorComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_32));
	if (hBitmap32 == NULL)
		return S_OK;

//	if (spImageList->ImageListSetStrip((long*)hBitmap16, 
//		(long*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	if (spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, 
		(LONG_PTR*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	DeleteObject(hBitmap16);
	DeleteObject(hBitmap32);

	// setting root node handle to main window
	// so that the root node may disable the main
	// window when a wizard is active

	HWND hwndMainWindow = 0;
	m_spConsole->GetMainWindow(&hwndMainWindow);

	if (m_pNode)
	{
		((CRootNode*)m_pNode)->SetMainWindow(hwndMainWindow);
	}

	return S_OK;
}


STDMETHODIMP 
   CDomMigratorComponent::AddMenuItems(
      LPDATAOBJECT           pDataObject,
      LPCONTEXTMENUCALLBACK  piCallback,
      long                 * pInsertionAllowed
   )
{
   ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::AddMenuItems\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(pDataObject != NULL);
   
   if (pDataObject == NULL)
   {
      ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
   }
   else
   {
      CSnapInItem          * pItem;
      DATA_OBJECT_TYPES      type;

      hr = m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

      if (SUCCEEDED(hr))
      {
         hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
      }
      else
      {  // is it multiselection data
         SMMCDataObjects *pMsDataObjs = CMultiSelectItemDataObject::ExtractMSDataObjects(pDataObject);

         if ((pMsDataObjs) && ( pMsDataObjs->count ))
         {
            LPDATAOBJECT   pMsData;
            pMsData = pMsDataObjs->lpDataObject[0];
            FORMATETC format={(CLIPFORMAT)CMultiSelectItemDataObject::s_cfMsObjTypes,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
            hr = pMsData->QueryGetData(&format);
            if ( hr == S_OK ) 
            {
               hr = ((CMultiSelectItemDataObject *)pMsData)->AddMenuItems(piCallback, pInsertionAllowed, type);
            }
         }
      }
   }
   return hr;
}


STDMETHODIMP CDomMigratorComponent::Command(long lCommandID,
  LPDATAOBJECT pDataObject)
{
	ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::Command\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
	else
	{
		CSnapInItem          * pItem;
		DATA_OBJECT_TYPES      type;

		hr = m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
		
		if (SUCCEEDED(hr))
      {
         hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)this, type);
      }
      else
      {  // is it multiselection data
         SMMCDataObjects *pMsDataObjs = CMultiSelectItemDataObject::ExtractMSDataObjects(pDataObject);

         if ((pMsDataObjs) && ( pMsDataObjs->count ))
         {
            LPDATAOBJECT   pMsData;
            pMsData = pMsDataObjs->lpDataObject[0];
            FORMATETC format={(CLIPFORMAT)CMultiSelectItemDataObject::s_cfMsObjTypes,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
            HRESULT hr = pMsData->QueryGetData(&format);
            if ( hr == S_OK ) 
            {
               hr = ((CMultiSelectItemDataObject *)pMsData)->Command(lCommandID, (CSnapInObjectRootBase*)this, type);
            }
         }
      }

	}
	return hr;
}

CDomMigrator::CDomMigrator()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   m_pNode = new CRootNode;
	_ASSERTE(m_pNode != NULL);
	m_pComponentData = this;
   m_lpszSnapinHelpFile.LoadString(IDS_HELPFILE);
}

CDomMigrator::~CDomMigrator()
{
	delete m_pNode;
	m_pNode = NULL;
}

   /*
   On the Help menu, there should be 1 Help Topics option that displays a Contents list with both our Help and the MMC Help.
*/
STDMETHODIMP CDomMigrator::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  if (m_lpszSnapinHelpFile.IsEmpty() )
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

  return GetHelpFileFullPath(lpCompiledHelpFile);
}

STDMETHODIMP CDomMigrator::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
   if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  return GetHelpFileFullPath(lpCompiledHelpFile);
}
