#ifndef __FILEPARSER_HPP__
#define __FILEPARSER_HPP__
/*---------------------------------------------------------------------------
  File: FileParser.hpp

  Comments: Classes to parse text files generated by the Domain Admin dispatcher and agent.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 15:16:31

 ---------------------------------------------------------------------------
*/

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "ServList.hpp"




#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)


class TFileParser
{
protected:
   FILE                    * m_pFile;
   WCHAR                     m_filename[MAX_PATH];
   BOOL                      m_bValidData;        
public:
   TFileParser()
   {
      m_filename[0] = 0;
      m_pFile = NULL;
      m_bValidData = FALSE;
   }
   ~TFileParser()
   {
      if ( m_pFile )
         fclose(m_pFile);
   }

   BOOL Open(WCHAR const * filename)
   {
      safecopy(m_filename,filename);
      
      if ( *m_filename )
      {
         m_pFile = _wfopen(m_filename,L"rb");
      }
      else
      {
         m_pFile = 0;
      }
   
      return ( m_pFile != 0 );
   }

   BOOL IsOpen() { return ( m_pFile != 0 ); }
   void Close() { if ( m_pFile ) { fclose(m_pFile); m_pFile = NULL; } }
   BOOL IsEof() { return m_pFile ? feof(m_pFile) : TRUE; }
   BOOL Restart() 
   { 
      BOOL                   bRc = FALSE;
      if ( m_pFile ) 
      { 
         bRc = ( fseek(m_pFile,0,SEEK_SET) == 0 );
      }
      return bRc;
   }
   virtual BOOL ScanEntry() = 0;
};

class TErrorLogParser:public TFileParser
{
   int                       m_Severity;
   int                       m_SourceLine;         // 
   WCHAR                     m_Timestamp[100];     // the timestamp of the entry
   WCHAR                     m_Message[1000];      // the message text part of the entry
   WCHAR                     m_strBuf[1000];       // a line from the log file
public:                                         
   virtual BOOL ScanEntry() 
   { 
      MCSASSERT(m_pFile);
      m_bValidData = FALSE;
      if ( m_pFile && fgetws(m_strBuf,1000,m_pFile) )
      {
         m_bValidData = ScanFileEntry(m_strBuf,m_Timestamp,&m_Severity,&m_SourceLine,m_Message);
            
      }
      return m_bValidData;
   }
   
   int GetSeverity() { MCSASSERT(m_bValidData); return m_Severity; }
   int GetSourceLine() { MCSASSERT(m_bValidData); return m_SourceLine; }
   WCHAR const * GetTimestamp() { MCSASSERT(m_bValidData); return m_Timestamp; }
   WCHAR const * GetMessage() { MCSASSERT(m_bValidData); return m_Message; }
protected:
   BOOL 
   ScanFileEntry(
      WCHAR                * string,      // in - line from TError log file
      WCHAR                * timestamp,   // out- timestamp from this line
      int                  * pSeverity,   // out- severity level of this message
      int                  * pSourceLine, // out- the source line for this message
      WCHAR                * msgtext      // out- the textual part of the message
   );

};

class TAcctReplStatusFileParser: public TFileParser
{
   WCHAR                    m_sourceAccount[LEN_Account];
   WCHAR                    m_targetAccount[LEN_Account];
   DWORD                    m_sourceRid;
   DWORD                    m_targetRid;
   DWORD                    m_accountType;
   DWORD                    m_status;
public:
   virtual BOOL ScanEntry()
   {
      m_bValidData = FALSE;
      MCSASSERT(m_pFile);
      if ( m_pFile && fwscanf(m_pFile,L"%[^,],%[^,],%lx,%lx,%lx,%lx\r\n",
                           m_sourceAccount,
                           m_targetAccount,
                           &m_accountType,
                           &m_status,
                           &m_sourceRid,
                           &m_targetRid)   == 6 )
      {
         m_bValidData = TRUE;
      }
      return m_bValidData;
   }
   WCHAR const * GetSource() { MCSASSERT(m_bValidData); return m_sourceAccount; }
   WCHAR const * GetTarget() { MCSASSERT(m_bValidData); return m_targetAccount; }
   DWORD     GetSourceRid() { MCSASSERT(m_bValidData); return m_sourceRid;}
   DWORD     GetTargetRid() { MCSASSERT(m_bValidData); return m_targetRid;}
   DWORD        GetStatus() { MCSASSERT(m_bValidData); return m_status; }
   DWORD     GetAccountType() { MCSASSERT(m_bValidData); return m_accountType;}
   
};

class TAccountStatFileParser: public TFileParser
{
   WCHAR                     m_account[LEN_Account];
   DWORD                     m_owners;
   DWORD                     m_groups;
   DWORD                     m_daces;
   DWORD                     m_saces;
public:
   virtual BOOL ScanEntry()
   {
      m_bValidData = FALSE;
      MCSASSERT(m_pFile);
      if ( m_pFile && fwscanf(m_pFile,L"%[^,],%ld,%ld,%ld,%ld\r\n",m_account,&m_owners,&m_groups,&m_daces,&m_saces) == 5 )
      {
         m_bValidData = TRUE;
      }
      return m_bValidData;
   }

   WCHAR const * GetAccount() { MCSASSERT(m_bValidData); return m_account; }
   DWORD GetOwners() { MCSASSERT(m_bValidData); return m_owners;}
   DWORD GetGroups() { MCSASSERT(m_bValidData); return m_groups; }
   DWORD GetDACEs() { MCSASSERT(m_bValidData); return m_daces; }
   DWORD GetSACEs() { MCSASSERT(m_bValidData); return m_saces; }
};


void ParseInputFile(WCHAR const * gLogFile);

void 
   ReadResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename,
      WCHAR          const * dbName
   );


#endif //__FILEPARSER_HPP__