#ifndef __GLOBALS_H__
#define __GLOBALS_H__
/*---------------------------------------------------------------------------
  File: ...

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/04/99 17:13:56

 ---------------------------------------------------------------------------
*/


#include "ServList.hpp"
#include "Monitor.h"
#include "TSync.hpp"

class GlobalData
{
   long                      m_LinesRead;          // number of lines of the dispatch log that have been processed
   WCHAR                     m_LogFile[MAX_PATH];  // full path of dispatch log
   WCHAR                     m_ReadableLogFile[MAX_PATH]; // full path of human-readable log file
   WCHAR                     m_ResultDir[MAX_PATH];// full path of results directory
   WCHAR                     m_ResultShare[MAX_PATH]; // sharename for results share
   WCHAR                     m_DatabasePath[MAX_PATH]; // full path of Access database to write resulting stats to
   WCHAR                     m_CacheFile[MAX_PATH]; // filename of FST cache file generated by dispatcher
   int                       m_IntervalSeconds;    // number of seconds for monitoring threads to wait between passes
   BOOL                      m_Done;               // monitoring threads should check this to see if they should stop
   BOOL                      m_ImportStats;        // indicates whether the monitor should write stats to a database
   BOOL                      m_bFirstPassDone;     // indicates whether we have made a first pass through the log file yet
   HWND                      m_ListWnd;            // handle to the server list window
   HWND                      m_SummaryWnd;         // handle to the summary window
   HWND                      m_DetailWnd;          // handle to the single-server detail window
   ComputerStats             m_ComputerStats;       // stats on number of computers in progress
   DetailStats               m_DetailStats;        // stats on total objects processed (by completed agents)
   TServerList               m_ServerList;         // list containing the  servers where the agent is being dispatched
   TCriticalSection          m_cs;           
   BOOL                      m_LogDone;            // indicates whether the dispatcher has finished writing to the log file
public:
   GlobalData() 
   {
      Initialize();
   }
   void Initialize()
   {
      m_cs.Enter();
      m_LinesRead = 0;
      m_LogFile[0] = 0;
      m_ReadableLogFile[0] = 0;
      m_ResultDir[0] = 0;
      m_ResultShare[0] = 0;
      m_DatabasePath[0] = 0;
      m_CacheFile[0] = 0;
      m_IntervalSeconds = 5;
      m_Done = FALSE;
      m_ImportStats = FALSE;
      m_bFirstPassDone = FALSE;
      m_ListWnd = NULL;
      m_SummaryWnd = NULL;
      m_DetailWnd = NULL;
      memset(&m_ComputerStats,0,sizeof m_ComputerStats);
      memset(&m_DetailStats,0,sizeof m_DetailStats);
      m_ServerList.Clear();
      m_LogDone = FALSE;
      m_cs.Leave();
   }

   void GetLinesRead(long * lines) { m_cs.Enter(); (*lines) = m_LinesRead; m_cs.Leave(); }
   void SetLinesRead(long lines) { m_cs.Enter(); m_LinesRead = lines; m_cs.Leave(); }

   void GetLogPath(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_LogFile); m_cs.Leave(); }
   void SetLogPath(WCHAR const * path) { m_cs.Enter(); safecopy(m_LogFile,path); m_cs.Leave(); }

   void GetReadableLogFile(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_ReadableLogFile); m_cs.Leave(); }
   void SetReadableLogFile(WCHAR const * path) { m_cs.Enter(); safecopy(m_ReadableLogFile,path); m_cs.Leave(); }
   
   void GetResultDir(WCHAR * dir) { m_cs.Enter(); UStrCpy(dir,m_ResultDir); m_cs.Leave() ; }
   void SetResultDir(WCHAR const * dir) { m_cs.Enter(); safecopy(m_ResultDir,dir); m_cs.Leave(); }

   void GetResultShare(WCHAR * share) { m_cs.Enter(); UStrCpy(share,m_ResultShare); m_cs.Leave() ; }
   void SetResultShare(WCHAR const * share) { m_cs.Enter(); safecopy(m_ResultShare,share); m_cs.Leave(); }

   void GetWaitInterval(long * interval) { m_cs.Enter(); (*interval) = m_IntervalSeconds; m_cs.Leave(); }
   void SetWaitInterval(long interval) { m_cs.Enter(); m_IntervalSeconds = interval; m_cs.Leave(); }

   void GetDone(BOOL * bDone) { m_cs.Enter(); (*bDone) = m_Done; m_cs.Leave(); }
   void SetDone(BOOL bDone) { m_cs.Enter(); m_Done = bDone; m_cs.Leave(); }

   void GetLogDone(BOOL * bDone) { m_cs.Enter(); (*bDone) = m_LogDone; m_cs.Leave(); }
   void SetLogDone(BOOL bDone) { m_cs.Enter(); m_LogDone = bDone; m_cs.Leave(); }

   void GetListWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_ListWnd; m_cs.Leave(); }
   void SetListWindow(HWND hWnd) { m_cs.Enter(); m_ListWnd = hWnd; m_cs.Leave(); }

   void GetSummaryWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_SummaryWnd; m_cs.Leave(); }
   void SetSummaryWindow(HWND hWnd) { m_cs.Enter(); m_SummaryWnd = hWnd; m_cs.Leave(); }

   void GetDetailWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_DetailWnd; m_cs.Leave(); }
   void SetDetailWindow(HWND hWnd) { m_cs.Enter(); m_DetailWnd = hWnd; m_cs.Leave(); }

   void GetComputerStats(ComputerStats * pStats) { m_cs.Enter(); memcpy(pStats,&m_ComputerStats, sizeof m_ComputerStats); m_cs.Leave(); }
   void SetComputerStats(ComputerStats const * pStats) { m_cs.Enter(); memcpy(&m_ComputerStats,pStats,sizeof m_ComputerStats); m_cs.Leave(); }

   void GetDetailStats(DetailStats * pStats) { m_cs.Enter(); memcpy(pStats,&m_DetailStats,sizeof m_DetailStats); m_cs.Leave(); }
   
   void GetImportStats(BOOL * pVal) { m_cs.Enter(); (*pVal) = m_ImportStats; m_cs.Leave(); }
   void SetImportStats(BOOL v) { m_cs.Enter(); m_ImportStats = v; m_cs.Leave(); }

   void GetDatabaseName(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_DatabasePath); m_cs.Leave();  }
   void SetDatabaseName(WCHAR const * path) { m_cs.Enter(); safecopy(m_DatabasePath,path); m_cs.Leave(); }

   void GetFirstPassDone(BOOL * pVal) { m_cs.Enter(); (*pVal) = m_bFirstPassDone; m_cs.Leave(); }
   void SetFirstPassDone(BOOL val) { m_cs.Enter(); m_bFirstPassDone = val; m_cs.Leave(); }

   void GetCacheFile(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_CacheFile); m_cs.Leave(); }
   void SetCacheFile(WCHAR const * path) { m_cs.Enter(); UStrCpy(m_CacheFile,path); m_cs.Leave(); }

   TServerList * GetUnsafeServerList(){ return &m_ServerList;}

   void Lock() { m_cs.Enter(); }

   void Unlock() { m_cs.Leave(); }

   void AddDetailStats(DetailStats * stats)
   {
      m_cs.Enter();
      m_DetailStats.directoriesChanged += stats->directoriesChanged;
      m_DetailStats.directoriesExamined += stats->directoriesExamined;
      m_DetailStats.directoriesUnchanged += stats->directoriesUnchanged;

      m_DetailStats.filesChanged += stats->filesChanged;
      m_DetailStats.filesExamined += stats->filesExamined;
      m_DetailStats.filesUnchanged += stats->filesUnchanged;

      m_DetailStats.sharesChanged += stats->sharesChanged;
      m_DetailStats.sharesExamined += stats->sharesExamined;
      m_DetailStats.sharesUnchanged += stats->sharesUnchanged;

      m_DetailStats.membersChanged += stats->membersChanged;
      m_DetailStats.membersExamined += stats->membersExamined;
      m_DetailStats.membersUnchanged += stats->membersUnchanged;

      m_DetailStats.rightsChanged += stats->rightsChanged;
      m_DetailStats.rightsExamined += stats->rightsExamined;
      m_DetailStats.rightsUnchanged += stats->rightsUnchanged;

      m_cs.Leave();
   }

};

extern GlobalData       gData;

void helpWrapper(HWND hwndDlg, int t);


#endif //__GLOBALS_H__