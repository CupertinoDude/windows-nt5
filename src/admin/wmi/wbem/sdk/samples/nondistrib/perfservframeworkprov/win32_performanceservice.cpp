// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Win32_PerformanceService.CPP -- WMI provider class implementation
//
// Generated by Microsoft WMI Code Generation Engine
//
// TO DO: See individual function headers
//
// Description: 
//
//=================================================================

#include <fwcommon.h>  // This must be the first include.
#include <provider.h>

#include "Win32_PerformanceService.h"

// TO DO:	REPLACE "NameSpace" with the appropriate namespace for your
// 		provider instance.   For instance:  "root\\default or "root\\cimv2"
// 		This code will compile, but it WILL NOT APPEAR in the correct 
//	 	namespace until this is changed.
//===================================================================
CWin32_PerformanceService MyWin32_PerformanceServiceSet (PROVIDER_NAME_WIN32_PERFORMANCESERVICE, "root\\cimv2") ;

// Property names
//===============

const char* pFirstCounter = "FirstCounter" ;
const char* pLastCounter = "LastCounter" ;
const char* pLibrary = "Library" ;
const char* pName = "Name";


/*****************************************************************************
 *
 *  FUNCTION    :	CWin32_PerformanceService::CWin32_PerformanceService
 *
 *  DESCRIPTION :	Constructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    :	Calls the Provider constructor.
 *
 *****************************************************************************/
CWin32_PerformanceService::CWin32_PerformanceService (const CHString& strName, LPCSTR pszNameSpace ) :
	Provider(strName, pszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :	CWin32_PerformanceService::~CWin32_PerformanceService
 *
 *  DESCRIPTION :	Destructor
 *
 *  INPUTS      :	none
 *
 *  RETURNS     :	nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CWin32_PerformanceService::~CWin32_PerformanceService ()
{
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::EnumerateInstances
*
*  DESCRIPTION :	Returns all the instances of this class.
*
*  INPUTS      :	none
*
*  RETURNS     :	WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO:	All instances on the machine should be returned here.
*				If there are no instances, return WBEM_S_NO_ERROR.
*				It is not an error to have no instances
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
	CInstance* pInstance;
	HRESULT hRes = WBEM_S_NO_ERROR;
	HKEY hServices;
	long lRes;
    DWORD dwMaxLen;

// TO DO:	The following commented lines contain the 'set' methods for the
//		properties entered for this class.   They are commented because they
//		will NOT compile in their current form.   Each <Property Value> should be
//		replaced with an appropriate value.
//
//		If the expectation is that there is more than one instance on the machine
//		EnumerateInstances should loop through the instances and fill them accordingly.
//
//		Note that you must ALWAYS set ALL the key properties.  See the docs for
//		further details.
///////////////////////////////////////////////////////////////////////////////

    // Open the registry key for services
    // ==================================

    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    "SYSTEM\\CurrentControlSet\\Services",
                    0, KEY_READ, &hServices);
    if(lRes)
        return WBEM_E_FAILED;


    // Determine maximum subkey length
    // ===============================

    lRes = RegQueryInfoKey(hServices, NULL, NULL, NULL, NULL, &dwMaxLen,
                            NULL, NULL, NULL, NULL, NULL, NULL);
    if(lRes)
	{
		RegCloseKey(hServices);
        return WBEM_E_FAILED;
	}


    // Enumerate all the subkeys of the Services key
    // =============================================

    DWORD dwIndex = 0;
    TCHAR* szKeyName = new TCHAR[dwMaxLen+1];
    DWORD dwNameLen = dwMaxLen + 1;

    while(RegEnumKeyEx(hServices, dwIndex++, szKeyName, &dwNameLen, NULL,
                        NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        // Construct our instance (if any) for this service
        // ================================================

		pInstance = CreateNewInstance(pMethodContext);
		if (pInstance)
		{
			if(ConstructInstance(hServices, szKeyName, pInstance))
				hRes = Commit(pInstance);
		}
		else
			hRes = WBEM_E_OUT_OF_MEMORY;

        dwNameLen = dwMaxLen + 1;
    }

	RegCloseKey(hServices);

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::GetObject
*
*  DESCRIPTION :	Find a single instance based on the key properties for the
*					class. 
*
*  INPUTS      :	A pointer to a CInstance object containing the key properties. 
*
*  RETURNS     :	WBEM_S_NO_ERROR if the instance can be found
*			WBEM_E_NOT_FOUND if the instance described by the key properties 
* 				could not be found
*			WBEM_E_FAILED if the instance could be found but another error 
*				occurred. 
*
*  COMMENTS    : 
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::GetObject ( CInstance* pInstance, long lFlags )
{
	// TO DO:	The GetObject function is used to search for an instance of this
	//		class on the machine based on the key properties.   Unlike
	//		EnumerateInstances which finds all instances on the machine, GetObject
	//		uses the key properties to find the matching single instance and 
	//		returns that instance.    
	//
	//		Use the CInstance Get functions (GetCHString, etc) against pInstance to see
	//		the key values the client app requested.
	
	HKEY hServices;
	CHString sName;
	long lRes;
	
	//Get the key value
	//=================

	pInstance->GetCHString(pName, sName);

    // Open the registry key for services
    // ==================================

    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    "SYSTEM\\CurrentControlSet\\Services",
                    0, KEY_READ, &hServices);
    if(lRes)
        return WBEM_E_FAILED;

	//Construct the instance for this service if applicable
	//=====================================================

	if(ConstructInstance(hServices, sName, pInstance))
		return WBEM_S_NO_ERROR;

	RegCloseKey(hServices);

    return WBEM_E_NOT_FOUND;
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::ExecQuery
*
*  DESCRIPTION :	You are passed a method context to use in the creation of 
*			instances that satisfy the query, and a CFrameworkQuery 
*			which describes the query.  Create and populate all 
*			instances which satisfy the query.  CIMOM will post - 
*			filter the query for you, you may return more instances 
*			or more properties than are requested and CIMOM 
*			will filter out any that do not apply.
*
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if not supported for this class
*			WBEM_E_FAILED if the query failed
*			WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, cimom 
*			will call your enumerate function to get all the instances and perform the 
*			filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*			queries, you should remove this entire method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	 return (WBEM_E_NOT_SUPPORTED);
}

/*****************************************************************************
*
*  FUNCTION    : CWin32_PerformanceService::PutInstance
*
*  DESCRIPTION :	PutInstance should be used in provider classes that can write
*			instance information back to the hardware or software.
*			For example: Win32_Environment will allow a PutInstance of a new
*			environment variable, because environment variables are "software"
*			related.   However, a class like Win32_MotherboardDevice will not
*			allow editing of the bus speed.   Since by default PutInstance 
*			returns WBEM_E_NOT_SUPPORTED, this function is placed here as a
*			skeleton, but can be removed if not used.
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if PutInstance is not available
*			WBEM_E_FAILED if there is an error delivering the instance
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, remove this method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::PutInstance ( const CInstance &Instance, long lFlags)
{
	return (WBEM_E_NOT_SUPPORTED);
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::DeleteInstance
*
*  DESCRIPTION :	DeleteInstance, like PutInstance, actually writes information
*			to the software or hardware.   For most hardware devices, 
*			DeleteInstance should not be implemented, but for software
*			configuration, DeleteInstance implementation is plausible.
*			Like PutInstance, DeleteInstance returns WBEM_E_NOT_SUPPORTED from
*			inside Provider::DeleteInstance (defined in Provider.h).  So, if
*			you choose not to implement DeleteInstance, remove this function
*			definition and the declaration from Win32_PerformanceService.h 
*
*  INPUTS      : 
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if DeleteInstance is not available.
*			WBEM_E_FAILED if there is an error deleting the instance.
*			WBEM_E_INVALID_PARAMETER if any of the instance properties 
*				are incorrect.
*			WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances, remove this method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::DeleteInstance ( const CInstance &Instance, long lFlags )
{
	return (WBEM_E_NOT_SUPPORTED);
}

/*****************************************************************************
*
*  FUNCTION    :	CWin32_PerformanceService::ExecMethod
*
*  DESCRIPTION : 	Override this function to provide support for methods.  
*			A method is an entry point for the user of your provider 
*			to request your class perform some function above and 
*			beyond a change of state.  (A change of state should be 
*			handled by PutInstance() )
*
*  INPUTS      :	A pointer to a CInstance containing the instance the method was executed against.
*			A string containing the method name
*			A pointer to the CInstance which contains the IN parameters.
*			A pointer to the CInstance to contain the OUT parameters.
*			A set of specialized method flags
*
*  RETURNS     :	WBEM_E_NOT_SUPPORTED if not implemented for this class
*			WBEM_S_NO_ERROR if method executes successfully
*			WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CWin32_PerformanceService::ExecMethod ( const CInstance& Instance,
						const BSTR bstrMethodName,
						CInstance *pInParams,
						CInstance *pOutParams,
						long lFlags)
{
	return (WBEM_E_NOT_SUPPORTED);
}


//////////////////////////////////////////////////////////////////
BOOL CWin32_PerformanceService::ConstructInstance(HKEY hServices, LPCTSTR szServiceName, 
														CInstance* pInstance)
{
    // Locate the service
    // ==================

    HKEY hService;
    if(RegOpenKeyEx(hServices, szServiceName, 0, KEY_READ, &hService))
        return FALSE;

    // Open its performance data
    // =========================

    HKEY hPerformance;
    if(RegOpenKeyEx(hService, _T("Performance"), 0, KEY_READ, &hPerformance))
    {
        // No performance subkey --- not our service
        // =========================================

        RegCloseKey(hService);
        return FALSE;
    }
   
    RegCloseKey(hService);

    
	// Fill in the key
    // ===============

	pInstance->SetCHString(pName, szServiceName);
	
//			pInstance->SetDWORD(pFirstCounter, <Property Value>);
//			pInstance->SetDWORD(pLastCounter, <Property Value>);
//			pInstance->SetCHString(pLibrary, <Property Value>);


    // Get the library name
    // ====================

    TCHAR szLibraryName[MAX_PATH];
    DWORD dwValLen = MAX_PATH;
    if(RegQueryValueEx(hPerformance, _T("Library"), NULL, NULL, 
                        (LPBYTE)szLibraryName, &dwValLen) == 0)
	{

        // Fill in the property
        // ====================

		pInstance->SetCHString(pLibrary, szLibraryName);
	};


    // Get the FirstCounter index
    // ==========================

    dwValLen = sizeof(DWORD);
	DWORD dwVal;
    if(RegQueryValueEx(hPerformance, _T("First Counter"), NULL, NULL, 
                        (LPBYTE)&dwVal, &dwValLen) == 0)
    {
        // Fill in the property
        // ====================

        pInstance->SetDWORD(pFirstCounter, dwVal);

    }
    
    // Get the LastCounter index
    // ==========================

    dwValLen = sizeof(DWORD);
    if(RegQueryValueEx(hPerformance, _T("Last Counter"), NULL, NULL, 
                        (LPBYTE)&dwVal, &dwValLen) == 0)
    {
        // Fill in the property
        // ====================

        pInstance->SetDWORD(pLastCounter, dwVal);

    }
    
    // Clean up
    // ========

    RegCloseKey(hPerformance);

    return TRUE;
}
        

