/******************************************************************

 Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
   FrameworkProv.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).
  
   Description: 
   Sample provider using the Provider Framework
  
******************************************************************/

#include <fwcommon.h>  // This must be the first include.

#include "FrameworkProv.h"

// See ExecQuery for details of the usage of these #defines
#define BIT_REDNOSE 0x00000001
#define BIT_WEIGHT  0x00000002
#define BIT_ALL_PROPERTIES 0xffffffff

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.   For instance:  "root\\default or "root\\cimv2".
//===================================================================
CReindeer MyReindeerProvSet (PROVIDER_NAME_REINDEERPROV, L"root\\default") ;

// Property names
//===============
const static WCHAR* pName = L"Name" ;
const static WCHAR* pRedNose = L"RedNose" ;
const static WCHAR* pWeight = L"Weight" ;

// This WCHAR * is used to illustrate returning status
// objects.  See DeleteInstance.
//====================================================
const static WCHAR* pErrorClass = L"\\\\.\\root\\default:ReindeerError";

// Sample data
// ===========
Deers ohDeers[Deers::NDeers] =
{
    // Name     Weight  Red Nose    Deleted flag
    {L"Dasher",  200,    false,      false},
    {L"Dancer",  150,    false,      false},
    {L"Prancer", 162,    false,      false},
    {L"Vixen",   125,    false,      false},
    {L"Comet",   212,    false,      false},
    {L"Cupid",   196,    false,      false},
    {L"Donder",  255,    false,      false},
    {L"Blitzen", 145,    false,      false},
    {L"Rudolf",  123,    true,       false}
};

/*****************************************************************************
 *
 *  FUNCTION    :   CReindeer::CReindeer
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CReindeer::CReindeer (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
    Provider(lpwszName, lpwszNameSpace)
{
}

/*****************************************************************************
 *
 *  FUNCTION    :   CReindeer::~CReindeer
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CReindeer::~CReindeer ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_DEEP
*                       WBEM_FLAG_SHALLOW
*                       WBEM_FLAG_RETURN_IMMEDIATELY
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    : TO DO: All instances on the machine should be returned here and
*                       all properties that this class knows how to populate must 
*                       be filled in.  If there are no instances, return 
*                       WBEM_S_NO_ERROR.  It is not an error to have no instances.
*                       If you are implementing a 'method only' provider, you
*                       should remove this method.
*
*****************************************************************************/
HRESULT CReindeer::EnumerateInstances ( MethodContext* pMethodContext, long lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // create an instance for each reindeer
    for (int i = 0; (i < Deers::NDeers) && (SUCCEEDED(hRes)); i++)
    {
        // we don't want to return deleted deer
        if (!ohDeers[i].m_deleted)
        {
            // Note that CreateNewInstance may throw, but will never return NULL.
            CInstance *pInstance = CreateNewInstance(pMethodContext);

            pInstance->SetCHString(pName, CHString(ohDeers[i].m_name));
            if (SUCCEEDED(LoadPropertyValues(pInstance, i, BIT_ALL_PROPERTIES)))
            {
                hRes = pInstance->Commit();
            }

            pInstance->Release();
        }
    }

    return hRes ;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*  COMMENTS    :    If you are implementing a 'method only' provider, you should
*                   remove this method.
*
*****************************************************************************/
HRESULT CReindeer::GetObject ( CInstance* pInstance, long lFlags )
{
    // TO DO: The GetObject function is used to search for an instance of this
    //        class on the machine based on the key properties.   Unlike
    //        EnumerateInstances which finds all instances on the machine, GetObject
    //        uses the key properties to find the matching single instance and 
    //        returns that instance.
    //
    //        Use the CInstance Get functions (for example, call 
    //        GetCHString(L"Name", sTemp)) against pInstance to see the key values 
    //        the client requested.
    HRESULT hr = WBEM_E_NOT_FOUND;

    // name is the key, we retrieve the name
    CHString name;
    pInstance->GetCHString(pName, name);

    // search the array for a Reindeer with the name we're given
    // (make sure he hasn't been deleted!)
    for (int i = 0; i < Deers::NDeers; i++) 
    {
        if (0 == name.CompareNoCase(CHString(ohDeers[i].m_name)) && !ohDeers[i].m_deleted)
        {
            // we found the one they're look for - fill in the data
            
            hr = LoadPropertyValues(pInstance, i, BIT_ALL_PROPERTIES);
            break;
        }
    }

    return hr ;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CReindeer::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

// While this class is too small to really benefit from query processing, this method is
// being instrumented to show how it could be done.  There are two different ways query processing
// can be used to improve performance.  
// 
// Method 1 - Look at the fields that are being requested, and only return data for those fields.  This
//            can be a very big win for some classes if some properties are very expensive to retrieve.  
//            In our own LogicalDisk class, populating just the DeviceID field is very cheap.  However, 
//            populating the FreeSpace property requires that we spin up the disk.  For floppy, cd, and 
//            network drives, that is very expensive.
//
// Method 2 - Look at the where clause and only return the requested records.  Obviously, this also has 
//            the potential to be a big win.  For example, if the query is of the form 'Select Name, 
//            Size from CIM_Datafile where where drive="a:"', clearly this can be resolved much faster 
//            then doing the default behavior when no ExecQuery routine is specified (enumerating all 
//            directories on all drives and let Winmgmt pick out the matching entries).

//            On the other hand, just because a WHERE clause in included doesn't mean that the query can 
//            be processed any faster.  Consider a query of the form "Select * from CIM_Datafile where 
//            ReadOnly = TRUE".  By the time we have called FindFirstFile and examined the structure, the 
//            most expensive parts of the processing is already done.  How about a query of the form 
//            'Select * from CIM_Datafile where Drive="a:" or ReadOnly = TRUE'?  Again, to satisfy this 
//            query, we're going to have to walk all the instances on all the drives anyway since there 
//            is no way to specify to the Win32 API's that you only want ReadOnly files.  Since Winmgmt 
//            already has a bunch of code to process instances against queries, there's no reason to add 
//            that complexity to our provider UNLESS we are getting a big performance win.  If we send 
//            back a few too many instances, winmgmt will trim them out.

//            For most classes, there are a few (sometimes only 1) properties that it makes sense to 
//            try to optimize on (CIM_Datafile actually does a bunch, but many other classes that process 
//            queries only do 1-2).

//            So, there is a method that can be run against the CFrameworkQuery object where you pass it 
//            the name of a property, and it will tell you all the values they requested.  For example, 
//            if the query is of the form 'Select * from Reindeer where name = "Dasher" or 
//            name = "Dancer" or name = "pickle"', GetValuesForProp(L"Name") would send back an array 
//            that contains {"Dasher", "Dancer", "pickle"}.  Or if the query was of the form 'Select * 
//            from CIM_Datafile where Drive = "a:" AND ReadOnly = TRUE' (note that this query, unlike 
//            the one in the paragraph above, uses AND), then GetValuesForProp(L"Drive") would 
//            return {"a:"}.  Given this array, you can quickly return just the few instances they 
//            requested.  If there are additional clauses on the query that you didn't process, (like 
//            the Drive AND ReadOnly example above), don't worry.  Winmgmt will discard the instances 
//            that don't match.

// In your provider, you can use either, neither, or both of these methods.  In the code below, 
// both methods are illustrated.

   DWORD dwRequiredProperties = 0;
   CHStringArray asNames;
   HRESULT hRes = WBEM_S_NO_ERROR;

   // Part of Method 2
   Query.GetValuesForProp(pName, asNames);

   BOOL bGetAllInstances = asNames.GetSize() == 0;

   // Used by Method 1
   if (Query.IsPropertyRequired(pWeight))
       dwRequiredProperties |= BIT_WEIGHT;

   if (Query.IsPropertyRequired(pRedNose))
       dwRequiredProperties |= BIT_REDNOSE;

    // walk through all the reindeer
   for (int i = 0; (i < Deers::NDeers) && (SUCCEEDED(hRes)); i++)
   {
       // we don't want to return deleted deer
       if (!ohDeers[i].m_deleted)
       {
           // Method 2 - Check to see if the query CAN be processed by 'name', if so,
           // only return those names.
           if (bGetAllInstances || IsInList(asNames, ohDeers[i].m_name))
           {
               // Note that CreateNewInstance may throw, but will never return NULL.
               CInstance *pInstance = CreateNewInstance(pMethodContext);

               // Always set the key property
               pInstance->SetCHString(pName, CHString(ohDeers[i].m_name));

               if (SUCCEEDED(LoadPropertyValues(pInstance, i, dwRequiredProperties)))
               {
                   hRes = pInstance->Commit();
               }

               pInstance->Release();
           }
       }
   }

   return hRes;
}

/*****************************************************************************
*
*  FUNCTION    : CReindeer::LoadPropertyValues
*
*  DESCRIPTION :    This routine was NOT created by the code generator.  It
*                   was hand edited into this file.  Creating this routines 
*                   saves us from having to have these pInstance->Set lines 
*                   in three different routines (EnumerateInstances, 
*                   GetObject, ExecQuery).
*
*  INPUTS      :    - A pointer to a CInstance object to populate
*                   - A DWORD that is the index into ohDeers of the entry to 
*                   populate.  For a more useful class, this might be a pointer
*                   to a structure from which we extract the information.
*                   - A DWORD that is a bitmask indicating which properties 
*                   to populate.
*
*  RETURNS     :    WBEM_S_NO_ERROR if instance is properly populated
*
*  COMMENTS    : 
*
*****************************************************************************/
HRESULT CReindeer::LoadPropertyValues( CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties)
{
   if (dwRequiredProperties & BIT_WEIGHT)
       pInstance->SetDWORD(pWeight,  ohDeers[dwIndex].m_weight);
   
   if (dwRequiredProperties & BIT_REDNOSE)
       pInstance->Setbool(pRedNose,  ohDeers[dwIndex].m_redNose);

   return WBEM_S_NO_ERROR;
}
                   
/*****************************************************************************
*
*  FUNCTION    : CReindeer::PutInstance
*
*  DESCRIPTION :    PutInstance should be used in provider classes that can 
*                   write instance information back to the hardware or 
*                   software.  For example: Win32_Environment will allow a 
*                   PutInstance to create or update an environment variable.  
*                   However, a class like MotherboardDevice will not allow 
*                   editing of the number of slots, since it is difficult for 
*                   a provider to affect that number.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT CReindeer::PutInstance ( const CInstance &Instance, long lFlags)
{
    HRESULT hresult = WBEM_E_INVALID_PARAMETER;

    // we do not create reindeer here.
    if (lFlags & WBEM_FLAG_CREATE_ONLY) 
        hresult = WBEM_E_UNSUPPORTED_PARAMETER;
    else
    {
        // get the key value so we can tell which reindeer we're operating on
        CHString name;
        Instance.GetCHString(pName, name);
        for (int i = 0; i < Deers::NDeers; i++) 
        {
            if (0 == name.CompareNoCase(CHString(ohDeers[i].m_name)) && !ohDeers[i].m_deleted)
            {
                // we found one, we can change the red nose and/or the weight properties
                DWORD weight;
                bool  redNoze;

                if (Instance.GetDWORD(pWeight,  weight))
                    ohDeers[i].m_weight = weight;

                if (Instance.Getbool(pRedNose, redNoze))
                    ohDeers[i].m_redNose = redNoze;

                hresult = WBEM_S_NO_ERROR;
                break;
            }
        }

        if (FAILED(hresult))
        {
            // If they said they wanted to update, but it wasn't there
            if (lFlags & WBEM_FLAG_UPDATE_ONLY)
            {
                hresult = WBEM_E_NOT_FOUND;
            }
        }
    }

    return hresult; 
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.   For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CReindeer::DeleteInstance ( const CInstance &Instance, long lFlags )
{
    HRESULT hresult = WBEM_E_NOT_FOUND;

    // get the key value so we can tell which reindeer we're operating on
    CHString name;
    Instance.GetCHString(pName, name);

    // see if we can find the deer we want,
    // note that we won't delete one that's already been deleted
    for (int i = 0; i < Deers::NDeers; i++) 
    {
        if (0 == name.CompareNoCase(ohDeers[i].m_name)) 
        {
            if (!ohDeers[i].m_deleted)
            {
                // we found it - mark as deleted 
                ohDeers[i].m_deleted = true;
                hresult = WBEM_S_NO_ERROR;
                break;
            }
            else
            {
                // Ok, this is a bit of a stretch, but I want to be able
                // to show how to report errors using an error object.

                // This code is entered if the same reindeer is deleted
                // twice in a row.  If this deletion is done in wbemtest, 
                // a dialog with a 'More Info' button will be displayed.  
                // Clicking this button will show the object we are 
                // populating here.
                CHString sRelPath;

                Instance.GetCHString(L"__RelPath", sRelPath);
                CInstance *pErrorInstance = NULL;

                // First, get a status object
                CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance);

                // Now, populate it
                pErrorInstance->SetWCHARSplat(L"Operation", L"DeleteInstance");
                pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_REINDEERPROV);
                pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_NOT_FOUND);
                pErrorInstance->SetCHString(L"ReindeerName", name);

                pErrorInstance->SetWCHARSplat(L"Description", 
                    L"Attempt to delete reindeer that has already been deleted");

                // Get the actual IWbemClassObject pointer
                IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();

                // Note that no Release() is required for this
                MethodContext *pMethodContext = Instance.GetMethodContext();  

                // Set the status object
                pMethodContext->SetStatusObject(pObj);

                // Cleanup
                pObj->Release();
                pErrorInstance->Release();

                break;
            }
        }
    }

    return hresult;
}

/*****************************************************************************
*
*  FUNCTION    :    CReindeer::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    : TO DO: If you don't intend to support Methods, remove this method.
*
*****************************************************************************/
HRESULT CReindeer::ExecMethod ( const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags
)
{
    // Note that there are two status codes involved here.  The hresult,
    // which is the return code for the function, indicates whether the method
    // was successfully invoked.  Then there is the hStatusCode which is used
    // to indicate whether the function did what it was asked to do.  
    
    // hStatusCode will end up being the uint32 return code, and can be seen in the
    // 'Edit Out Parameters' box in wbemtest after executing this method.

    HRESULT hresult = WBEM_E_PROVIDER_NOT_CAPABLE;
    HRESULT hStatusCode = WBEM_E_NOT_FOUND;

    // Make sure we recognize the method they are requesting
    if (_wcsicmp(bstrMethodName, L"Undelete") == 0)
    {
        // The method we implement here is declared as:

	    //	[Implemented, static, Description(
	    //	"The Undelete method will set the Deleted flag for the specified"
        //    "reindeer back to false.  Returns WBEM_S_NO_ERROR if succeeded, 
        //    WBEM_E_NOT_FOUND if the Reindeer is not in the list, or WBEM_S_FALSE
        //    if the reindeer was not already marked as deleted.")]
        // uint32 Undelete([In] string ReindeerName) ;

        hresult = WBEM_S_NO_ERROR;

        // get the key value so we can tell which reindeer we're operating on
        CHString name;
        pInParams->GetCHString(L"ReindeerName", name);

        // see if we can find the deer we want,
        for (int i = 0; i < Deers::NDeers; i++) 
        {
            if (0 == name.CompareNoCase(ohDeers[i].m_name)) 
            {
                if (!ohDeers[i].m_deleted)
                {
                    // It wasn't deleted.  Set the appropriate code
                    hStatusCode = WBEM_S_FALSE;
                    break;
                }
                else
                {
                    // It was deleted, so undelete it, and set the
                    // error code.
                    ohDeers[i].m_deleted = false;
                    hStatusCode = WBEM_S_NO_ERROR;
                }
            }
        }

        // put the result code back in the structure.
        pOutParams->SetDWORD(L"ReturnValue", hStatusCode);
    } 
    else if (_wcsicmp(bstrMethodName, L"Rename") == 0)
    {
        // The method we implement here is declared as:

        //        [Implemented, Description(
        //        "The Rename method will change the name of the reindeer it is run"
        //        "against.")]
        //    uint32 Rename([In] string NewReindeerName) ;

        hresult = WBEM_S_NO_ERROR;

        // get the key value so we can tell which reindeer we're operating on
        CHString sNewName, sCurName;
        Instance.GetCHString(L"name", sCurName);  // Old name

        if (!pInParams->IsNull(L"NewReindeerName"))
        {
            pInParams->GetCHString(L"NewReindeerName", sNewName); // New name
        }

        // No name was specified or a blank name was specified.
        if (!sNewName.IsEmpty())
        {
            // see if we can find the deer we want,
            for (int i = 0; i < Deers::NDeers; i++) 
            {
                if (0 == sCurName.CompareNoCase(ohDeers[i].m_name)) 
                {
                    if (!ohDeers[i].m_deleted)
                    {
                        ohDeers[i].m_name = sNewName.AllocSysString();
                        hStatusCode = WBEM_S_NO_ERROR;
                        break;
                    }
                }
            }
        }
        else
        {
            hStatusCode = WBEM_E_INVALID_PARAMETER;
        }

        // put the result code back in the structure.
        pOutParams->SetDWORD(L"ReturnValue", hStatusCode);
    }

    // Shows how to use the GetInstancesByQuery method.  The error reporting is a little light,
    // but I didn't want obscure the GetInstancesByQuery function with a whole bunch of other
    // stuff.
    else if (_wcsicmp(bstrMethodName, L"CalcWeight") == 0)
    {
        // The method we implement here is declared as:

        //        [Implemented, static, Description(
        //        "The CalcWeight method will compute the total weight of all "
        //        "the reindeer.  It will return the total weight, or 0xffffffff "
        //        "on error.")]
        //    uint32 CalcWeight() ;

        TRefPointerCollection<CInstance>    ReindeerList;

        // Get a method context pointer off the CInstance
        MethodContext *pMethodContext = Instance.GetMethodContext();

        // Run the query.  While I'm not using a WHERE clause here, I certainly could.  Note 
        // that the ReindeerList is a collection of CInstances.  As such, it can get VERY large
        // depending on the number of instances, and the size of the instances.  If you are
        // going to be hitting a big class, consider the GetInstancesByQueryAsynch function
        // instead.
        if (SUCCEEDED(hresult = CWbemProviderGlue::GetInstancesByQuery(L"SELECT Weight FROM Reindeer",
                                            &ReindeerList,
                                            pMethodContext,
                                            L"root\\default")))
        {
            REFPTRCOLLECTION_POSITION   pos;

            // Initialize the enum
            if ( ReindeerList.BeginEnum( pos ) )
            {

                // Set some vars
                CInstance *pReindeer;
                DWORD dwWeight, dwTotWeight = 0;

                // Walk the enum.  Note the pReindeer must be released when
                // we are done with it.
                while (pReindeer = ReindeerList.GetNext(pos))
                {
                    if (pReindeer->GetDWORD(pWeight, dwWeight))
                    {
                        dwTotWeight += dwWeight;
                    }

                    pReindeer->Release();
                }

                ReindeerList.EndEnum();

                // Set the out parameter, and we're done
                pOutParams->SetDWORD(L"ReturnValue", dwTotWeight);
            }
            else
            {
                pOutParams->SetDWORD(L"ReturnValue", 0xffffffff);
            }
        }
        else
        {
            pOutParams->SetDWORD(L"ReturnValue", 0xffffffff);
        }
    }
    else if (_wcsicmp(bstrMethodName, L"CalcWeightNonRed") == 0)
    {
        //        [Implemented, static, Description(
        //        "The CalcWeightNonRed method will compute the total weight of all "
        //        "the reindeer that don't have a red nose.  It will return the total "
        //        "weight, or 0xffffffff on error.")]
        //    uint32 CalcWeightNonRed() ;

        // This time we're going to use the Asynch version of GetInstancesByQuery.
        // See EnumerationCallback for discussion.

        // Get a method context pointer off the CInstance
        MethodContext *pMethodContext = Instance.GetMethodContext();

        DWORD dwTotWeight = 0;

   	    hresult = CWbemProviderGlue::GetInstancesByQueryAsynch(
                                        L"Select Weight FROM Reindeer WHERE RedNose = FALSE", 
                                        this, 
                                        StaticEnumerationCallback, 
                                        L"Root\\Default", 
                                        pMethodContext, 
                                        &dwTotWeight);

        if (SUCCEEDED(hresult))
        {
            pOutParams->SetDWORD(L"ReturnValue", dwTotWeight);
        }
        else
        {
            pOutParams->SetDWORD(L"ReturnValue", 0xffffffff);
        }
    }

    return hresult;
}

BOOL CReindeer::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************
 *
 *  FUNCTION    : CReindeer::StaticEnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch as a wrapper to EnumerationCallback
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
HRESULT WINAPI CReindeer::StaticEnumerationCallback(
                                                    
    Provider* pThat, 
    CInstance* pInstance, 
    MethodContext* pContext, 
    void* pUserData) 
{
    CReindeer* pThis;
    HRESULT hr;

	pThis = static_cast<CReindeer *>(pThat);

	if (pThis)
		hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    else
        hr = WBEM_E_FAILED;

    return hr;
}

/*****************************************************************************
 *
 *  FUNCTION    : CReindeer::EnumerationCallback
 *
 *  DESCRIPTION : Called from GetAllInstancesAsynch via StaticEnumerationCallback
 *
 *  INPUTS      : (see CWbemProviderGlue::GetAllInstancesAsynch)
 *
 *  OUTPUTS     : 
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : If we wanted to, this routine could create/commit instances.  We
 *                have a pMethodContext, all we'd need to do is 
 *                pInstance = CreateNewInstance(pMethodContext)
 *
 *                However, since in Reindeer this routine is being called from ExecMethod, 
 *                that really doesn't make any sense.  But if we were writing
 *                an association class between User and Group, we could do a query
 *                like "SELECT Domain, Name, SidType from Win32_Group", and 'asynchronously'
 *                call a routine just like this that took the group name, called the Win32 
 *                api's to find out what users were in that group, and create/commit
 *                instances.  If we did do that, then the return value from this function
 *                should be set to the return value of the Commit() call.  That way, if
 *                the client cancels the enumeration, everything will cancel correctly.
 *
 *                The benefit to using these 'Asynch' functions is that instances
 *                would start appearing at the client sooner.  After all, if we called
 *                the GetInstancesByQuery, that function wouldn't return until it had
 *                ALL the groups stored in the TRefPointerCollection.  This could take
 *                a while if many groups are defined.  Further, the TRefPointerCollection
 *                could consume a great deal of memory.
 *
 *****************************************************************************/
HRESULT CReindeer::EnumerationCallback(
                                       
    CInstance *pReindeer, 
    MethodContext *pMethodContext, 
    VOID *pTotWeight
)
{
    DWORD dwWeight;
    LPDWORD pdwTotWeight = (LPDWORD)pTotWeight;

    if (pReindeer->GetDWORD(pWeight, dwWeight))
    {
        *pdwTotWeight += dwWeight;
    }

    return WBEM_S_NO_ERROR;
}
