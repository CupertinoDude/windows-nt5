//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FRQueryEx.h
//
//  Purpose: Extended and non-published query support classes
//
//***************************************************************************

#pragma once

#define SetBit( p, offset ) \
            *((BYTE*)p + ((unsigned int)offset / 8)) |= (1 << ((unsigned int)offset % 8) )

#define IsBitSet( p, offset )   \
            *((BYTE*)p + ((unsigned int)offset / 8)) & (1 << ((unsigned int)offset % 8) )

#define SetAllBits( p, maxBits )    \
            memset( p , 0xff, ((unsigned int)maxBits / 8) + 1 )

#define ZeroAllBits( p, maxBits )   \
            memset( p , 0x00, ((unsigned int)maxBits / 8) + 1 )

class POLARITY CFrameworkQueryEx : public CFrameworkQuery
{
protected:
    CHString m_sQueryEx;

public:
    CFrameworkQueryEx();
    ~CFrameworkQueryEx();

// Note: call VariantInit on the variants before calling this function.

// This method is a quick and dirty implementation.  It is needed to allow for optimization of
// a specific type of query that is generated by cimon during a specific type of assocation queries.
// If the association is between two instances of the same class (like Directory To SubDirectory),
// cimom generates a query of the form WHERE (Antecedent = 'D:\foo' or Dependent = 'D:\foo').  The normal
// GetValuesForProp can't handle this.
//
// First this routine checks the query to see if it is an OR query between
// exactly two expressions.  The expressions must be = operators (ie not >, <=, etc).
// If so, then it checks the property names of the two expressions against the two passed in property names.
// If they both match, it sends back the values in the variants, and returns TRUE;
//
// So, these queries all return FALSE for a call like this (L"x", L"y", vVar1, vVar2):
// "Select * from foo"
// "Select * from foo where x=5",
// "Select * from foo where x=5 and y = 7"
// "Select * from foo where x = 5 or x = 6 or x = 7"
// "Select * from foo where x = 5 or y < 8"
// "Select * from foo where x = 5 or z = 9"

// These will return TRUE for the same call
// "Select * from foo where x = 5 or y = 6
// "Select * from foo where y = 6 or x = 5"
// "Select * from foo where (y = 6 or x = 5)"
    BOOL Is3TokenOR(LPCWSTR wszProp1, LPCWSTR wszProp2, VARIANT &vVar1, VARIANT &vVar2);


/*****************************************************************************
 *
 *  FUNCTION    : IsNTokenAnd
 *
 *  DESCRIPTION : Checks to see if the query is of the form:
 *                propname1 = value1 [and propname2 = value2 [and etc]]]
 *
 *  INPUTS      :
 *
 *  OUTPUTS     : CHStringArray - Outputs the propnames
 *                CHPtrArray    - Outputs array of variant_t*
 *
 *  RETURNS     : TRUE if the query is of the correct form, else FALSE
 *
 *  COMMENTS    :
 *
 *  The only joining operator recognized is AND.  'OR' and 'NOT' will both
 *  cause the function to return FALSE.  Because of the operation of the
 *  parsing class, parenthesis will get simplified out if all joining operators
 *  are AND, so ((propname1 = value1) and propname2 = value2) should also work.
 *
 *  The properties must be doing equality comparisons (=) to their values (ie not
 *  >, < >=, etc).  If they are not, this function returns FALSE.
 *
 *  Lastly, property names cannot repeat, or else this function returns FALSE.
 *
 *  Both the CHStringArray and the CHPtrArray must be empty before calling this
 *  function.  Further, the elements CHPtrArray MUST BE FREED BY THE CALLER.
 *
 *  As a note, the property names returned in sarr will all be uppercase.
 *
 *  Also note, queries of the form propname1 = value1 will return true.
 *
 *****************************************************************************/

    BOOL IsNTokenAnd(CHStringArray &sarr, CHPtrArray &sPtrArr);


    // Like CFrameworkQuery::GetValuesForProp except uses variant_t's.
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<_variant_t>& vectorValues);

    // Like CFrameworkQuery::GetValuesForProp except uses ints
    HRESULT GetValuesForProp(LPCWSTR wszPropName, std::vector<int>& vectorValues);

/*****************************************************************************
 *
 *  FUNCTION    : GetPropertyBitMask
 *
 *  DESCRIPTION : Checks an array of property names, and sets a bitmask to
 *                show which properties are required.
 *
 *  INPUTS      : Array to scan
 *
 *  OUTPUTS     : Array of bits.
 *
 *  RETURNS     :
 *
 *  COMMENTS    : We must populate the elements in the where clause, otherwise
 *                winmgmt will postprocess away all our instances.
 *
 *****************************************************************************/
    void GetPropertyBitMask(const CHPtrArray &Properties, LPVOID pBits);

    virtual HRESULT InitEx(

            const BSTR bstrQueryFormat, 
            const BSTR bstrQuery, 
            long lFlags,
            CHString &sNamespace
    );

    virtual bool IsExtended();
};

