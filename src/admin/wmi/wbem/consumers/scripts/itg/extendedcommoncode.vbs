'---------------------------------------------------------
'
'	File:
'
'			Monitor.VBS
'
'	Description:		
'
'			Script file to extend the standard WMI event query language
'
'	Author:
'
'			Steve Menzies
'
'	Date:
'
'			01/12/00
'
'	Version:
'
'			Draft 1.0
'
'
' E ::= E Or A | A
' A ::= A And L | L
' L ::= L < R | L > R | L >= R | L <= R | L = R | L <> R | R
' R ::= R + T | R - T | T
' T ::= T * F | T / F | F
' F ::= ID | BOOLEAN | NUMBER | REAL | STRING | ( E ) | P ( E ) | NOT E | ID ISA STRING | - E
' P ::= LIKE | LOWER | UPPER 
'
'
'
' E ::= A E_ 
' E_ ::= Or A E_ | e
'
' A ::= L A_
' A_ :: = And L A_ | e

' L ::= R L_
' L_ ::= < R L_ | > R L_ | >= R L_ | <= R L_ | = R L_ | <> R L_ | e

' R ::= T R_
' R_ ::= + T R_ | - T R_ | e

' T ::= F T_
' T_ ::= * F T_ | / F T_ | e

' F ::= ID | BOOLEAN | NUMBER | REAL | STRING | ( E ) | P ( E ) | NOT E | ID ISA STRING | -E

' P ::= LIKE | LOWER | UPPER 
'
'
'
'										Type Info
'
'	Unary Arithmetic Table
'
'
'	Real		- Real
'
'	Integer		- Integer
'
'	Boolean
'
'	String	
'
'	Null

'
'	Binary Arithmetic Table
'
'
'				Real				Integer				Boolean			String		Null
'
'	Real		* / + -	Real		* / + -	Real						
'
'	Integer		* / + -	Real		* / + - Integer
'
'	Boolean
'
'	String																+ String
'
'	Null
'
'	Operator Argument Table
'
'	And			Boolean
'   Or			Boolean
'	Not			Boolean
'	Isa			String
'	Like		String
'	Upper		String
'	Lower		String
'	=			Real,Integer,String,Boolean,Null
'	<>			Real,Integer,String,Boolean,Null
'	<			Real,Integer,String
'	>			Real,Integer,String
'	<=			Real,Integer,String
'	>=			Real,Integer,String
'	+			Real,Integer,String
'	-			Real,Integer
'	*			Real,Integer
'	/			Real,Integer
'	Unary -		Real,Integer
'
'	Operator Result Table
'
'	And			Boolean
'   Or			Boolean
'	Not			Boolean
'	Isa			Boolean
'	Like		Boolean
'	Upper		Boolean
'	Lower		Boolean
'	=			Boolean
'	<>			Boolean
'	<			Boolean
'	>			Boolean
'	<=			Boolean
'	>=			Boolean
'	+			Real,Integer,String
'	-			Real,Integer
'	*			Real,Integer
'	/			Real,Integer
'	Unary -		Real,Integer
'
'
'	Type Table
'
'
'				Real		Integer		Boolean		String		Null
'
'	And									X
'   Or									X
'	Not									X
'	Isa												X
'	Like											X
'	Upper											X
'	Lower											X
'	=			X			X			X			X			X
'	<>			X			X			X			X			X
'	<			X			X						X
'	>			X			X						X
'	<=			X			X						X
'	>=			X			X						X
'	+			X			X						X
'	-			X			X						X
'	*			X			X
'	/			X			X
'	Unary -		X			X
'
'
'---------------------------------------------------------

'---------------------------------------------------------
'
'	Function:
'
'		Globals
'
'	Description:
'
'		Initialize global variables
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Option Explicit

Dim g_WshArguments
Set g_WshArguments = WScript.Arguments 

const wbemCimtypeSint8 = 16
const wbemCimtypeUint8 = 17
const wbemCimtypeSint16 = 2
const wbemCimtypeUint16 = 18
const wbemCimtypeSint32 = 3
const wbemCimtypeUint32 = 19
const wbemCimtypeSint64 = 20
const wbemCimtypeUint64 = 21
const wbemCimtypeReal32 = 4
const wbemCimtypeReal64 = 5
const wbemCimtypeBoolean = 11
const wbemCimtypeString = 8
const wbemCimtypeDatetime = 101
const wbemCimtypeReference = 102
const wbemCimtypeChar16 = 103
const wbemCimtypeObject = 13

Dim g_Debug
g_Debug = 0

const Error_Success = 0
const Error_NoArgs = -1
const Error_InsufficientArgs = -2
const Error_InvalidArgs = -3
const Error_ImpossibleState = -4
const Error_UnexpectedEof = -5
const Error_SyntaxError = -6

const Parser_Success = 0 
const Parser_Syntax_Error = -1
const Parser_Lexical_Error = -2
const Parser_Failed = -3 
const Parser_Buffer_Too_Small = -4

const SQL_1_TOK_EOF           = 0
const SQL_1_TOK_ERROR         = 1
const SQL_1_TOK_IDENT         = 100
const SQL_1_TOK_QSTRING       = 101
const SQL_1_TOK_INT           = 102
const SQL_1_TOK_REAL          = 103
const SQL_1_TOK_CHAR          = 104
const SQL_1_TOK_BOOL          = 105

const SQL_1_TOK_LE            = 106
const SQL_1_TOK_LT            = 107
const SQL_1_TOK_GE            = 108
const SQL_1_TOK_GT            = 109
const SQL_1_TOK_EQ            = 110
const SQL_1_TOK_NE            = 111

const SQL_1_TOK_DOT           = 112
const SQL_1_TOK_OPEN_PAREN    = 113
const SQL_1_TOK_CLOSE_PAREN   = 114
const SQL_1_TOK_ASTERISK      = 115
const SQL_1_TOK_COMMA         = 116
const SQL_1_TOK_PLUS	      = 117
const SQL_1_TOK_MINUS	      = 118
const SQL_1_TOK_DIVIDE	      = 119

const SQL_1_TOK_SELECT        = 120
const SQL_1_TOK_WHERE         = 121
const SQL_1_TOK_FROM          = 122
const SQL_1_TOK_LIKE          = 123
const SQL_1_TOK_OR            = 124
const SQL_1_TOK_AND           = 125
const SQL_1_TOK_NOT           = 126
const SQL_1_TOK_ISA           = 127
const SQL_1_TOK_NULL          = 128
const SQL_1_TOK_WITHIN        = 129

const GLEX_ACCEPT      = 1          ' Add the char to the token
const GLEX_CONSUME     = 2          ' Consume the char without adding to token
const GLEX_PUSHBACK    = 4          ' Place the char back in the source buffer for next token
const GLEX_NOT         = 8          ' A match occurs if the char is NOT the one specified
const GLEX_LINEFEED    = 16         ' Increase the source linecount
const GLEX_RETURN      = 32         ' Return the indicated token to caller
const GLEX_ANY         = 65535		' wchar_t(0xFFFF) Any character
const GLEX_EMPTY       = 65534		' wchar_t(0xFFFE) When subrange is not specified

const ST_STRING			= 26
const ST_IDENT			= 31
const ST_GE				= 37
const ST_LE				= 39
const ST_NE				= 42
const ST_NUMERIC		= 44
const ST_REAL			= 47
const ST_STRING2		= 53
const ST_STRING_ESC		= 58
const ST_STRING2_ESC	= 59

' State    First   Last        New state,  Return tok,      Instructions
' =======================================================================

Dim DFA_Definition
DFA_Definition = Array ( _
65,				90,					ST_IDENT,		0,						GLEX_ACCEPT,					_
97 ,			122,				ST_IDENT,		0,						GLEX_ACCEPT,					_
95,				GLEX_EMPTY ,		ST_IDENT,		0,						GLEX_ACCEPT,					_
128  ,			65533 ,				ST_IDENT,		0,						GLEX_ACCEPT,					_
40,				GLEX_EMPTY ,		0,				SQL_1_TOK_OPEN_PAREN,	GLEX_ACCEPT,					_
41,				GLEX_EMPTY ,		0,				SQL_1_TOK_CLOSE_PAREN,	GLEX_ACCEPT,					_
46,				GLEX_EMPTY ,		0,				SQL_1_TOK_DOT,			GLEX_ACCEPT,					_
42,				GLEX_EMPTY ,		0,				SQL_1_TOK_ASTERISK,		GLEX_ACCEPT,					_
47,				GLEX_EMPTY ,		0,				SQL_1_TOK_DIVIDE,		GLEX_ACCEPT,					_
43,				GLEX_EMPTY ,		0,				SQL_1_TOK_PLUS,			GLEX_ACCEPT,					_
45,				GLEX_EMPTY ,		0,				SQL_1_TOK_MINUS,		GLEX_ACCEPT,					_
61,				GLEX_EMPTY ,		0,				SQL_1_TOK_EQ,			GLEX_ACCEPT,					_
62,				GLEX_EMPTY ,		ST_GE,			0,						GLEX_ACCEPT,					_
60,				GLEX_EMPTY ,		ST_LE,			0,						GLEX_ACCEPT,					_
48,				57,					ST_NUMERIC,		0,						GLEX_ACCEPT,					_
34,				GLEX_EMPTY ,		ST_STRING,		0,						GLEX_CONSUME,					_
39,				GLEX_EMPTY ,		ST_STRING2,		0,						GLEX_CONSUME,					_
33,				GLEX_EMPTY ,		ST_NE,			0,						GLEX_ACCEPT,					_
45,				GLEX_EMPTY ,		ST_NUMERIC,		0,						GLEX_ACCEPT,					_
32,				GLEX_EMPTY ,		0,				0,						GLEX_CONSUME,					_
9,				GLEX_EMPTY ,		0,				0,						GLEX_CONSUME,					_
10,				GLEX_EMPTY ,		0,				0,						GLEX_CONSUME Or GLEX_LINEFEED,	_
13 ,			GLEX_EMPTY ,		0,				0,						GLEX_CONSUME,					_
0,				GLEX_EMPTY ,		0,				SQL_1_TOK_EOF,			GLEX_CONSUME Or GLEX_RETURN,	_
44,				GLEX_EMPTY ,		0,				SQL_1_TOK_COMMA,		GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		0,				SQL_1_TOK_ERROR,		GLEX_ACCEPT Or GLEX_RETURN,		_
10,				GLEX_EMPTY ,		0,				SQL_1_TOK_ERROR,		GLEX_ACCEPT Or GLEX_LINEFEED,	_
13,				GLEX_EMPTY ,		0,				SQL_1_TOK_ERROR,		GLEX_ACCEPT Or GLEX_LINEFEED,	_
34,				GLEX_EMPTY ,		0,				SQL_1_TOK_QSTRING,		GLEX_CONSUME,					_
92,				GLEX_EMPTY ,		ST_STRING_ESC,  0,						GLEX_CONSUME,					_
GLEX_ANY ,		GLEX_EMPTY ,		ST_STRING,		0,						GLEX_ACCEPT,					_
97,				122,				ST_IDENT,		0,						GLEX_ACCEPT,					_
65,				90,					ST_IDENT,		0,						GLEX_ACCEPT,					_
95,				GLEX_EMPTY ,		ST_IDENT,		0,						GLEX_ACCEPT,					_
48,				57,					ST_IDENT,		0,						GLEX_ACCEPT,					_
128,			65533 ,				ST_IDENT,		0,						GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		0,				SQL_1_TOK_IDENT,		GLEX_PUSHBACK Or GLEX_RETURN,	_
61,				GLEX_EMPTY ,		0,				SQL_1_TOK_GE,			GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		0,				SQL_1_TOK_GT,			GLEX_PUSHBACK Or GLEX_RETURN,	_
61,				GLEX_EMPTY ,		0,				SQL_1_TOK_LE,			GLEX_ACCEPT,					_
62,				GLEX_EMPTY ,		0,				SQL_1_TOK_NE,			GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		0,				SQL_1_TOK_LT,			GLEX_PUSHBACK Or GLEX_RETURN,	_
60,				GLEX_EMPTY ,		0,				SQL_1_TOK_NE,			GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		0,				SQL_1_TOK_ERROR,		GLEX_ACCEPT Or GLEX_RETURN,		_
48,				57,					ST_NUMERIC,		0,						GLEX_ACCEPT,					_
46,				GLEX_EMPTY ,		ST_REAL,		0,						GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		0,				SQL_1_TOK_INT,			GLEX_PUSHBACK Or GLEX_RETURN,	_
48,				57,					ST_REAL,		0,						GLEX_ACCEPT,					_
69,				GLEX_EMPTY ,		ST_REAL,		0,						GLEX_ACCEPT,					_
101,			GLEX_EMPTY ,		ST_REAL,		0,						GLEX_ACCEPT,					_
43,				GLEX_EMPTY ,		ST_REAL,		0,						GLEX_ACCEPT,					_
45,				GLEX_EMPTY ,		ST_REAL,		0,						GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		0,				SQL_1_TOK_REAL,			GLEX_PUSHBACK Or GLEX_RETURN,	_
10,				GLEX_EMPTY ,		0,				SQL_1_TOK_ERROR,		GLEX_ACCEPT Or GLEX_LINEFEED,	_
13,				GLEX_EMPTY ,		0,				SQL_1_TOK_ERROR,		GLEX_ACCEPT Or GLEX_LINEFEED,	_
39,				GLEX_EMPTY ,		0,				SQL_1_TOK_QSTRING,		GLEX_CONSUME,					_
92,				GLEX_EMPTY ,		ST_STRING2_ESC, 0,						GLEX_CONSUME,					_		
GLEX_ANY ,		GLEX_EMPTY ,		ST_STRING2,		0,						GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		ST_STRING,		0,						GLEX_ACCEPT,					_
GLEX_ANY ,		GLEX_EMPTY ,		ST_STRING2,		0,						GLEX_ACCEPT						_
)

const TREE_NODE_SELECT			= 0
const TREE_NODE_WHERE			= 1
const TREE_NODE_FROM			= 2
const TREE_NODE_WITHIN			= 3

const TREE_NODE_LIKE			= 4
const TREE_NODE_LOWER			= 5
const TREE_NODE_UPPER			= 6
const TREE_NODE_ISA				= 7

const TREE_NODE_OR				= 8
const TREE_NODE_AND				= 9
const TREE_NODE_NOT				= 10

const TREE_NODE_UNARYMINUS		= 11
const TREE_NODE_PLUS			= 12
const TREE_NODE_MINUS			= 13
const TREE_NODE_DIVIDE			= 14
const TREE_NODE_MULTIPLY		= 15

const TREE_NODE_LESSEQUAL		= 16
const TREE_NODE_LESS            = 17
const TREE_NODE_GREATEREQUAL	= 18
const TREE_NODE_GREATER         = 19
const TREE_NODE_EQUAL           = 20
const TREE_NODE_NOTEQUAL        = 21

const TREE_NODE_NULL			= 22
const TREE_NODE_STRING			= 23
const TREE_NODE_REAL			= 24
const TREE_NODE_INTEGER			= 25
const TREE_NODE_BOOLEAN			= 26
const TREE_NODE_EMPTY			= 27
const TREE_NODE_IDENTIFIER		= 28
const TREE_NODE_UNDEFINED		= 29

const TYPE_FACTOR = 100

Dim TREE_NODE_NULL_NULL
Dim TREE_NODE_NULL_STRING
Dim TREE_NODE_NULL_REAL
Dim TREE_NODE_NULL_INTEGER
Dim TREE_NODE_NULL_BOOLEAN
Dim TREE_NODE_NULL_EMPTY
Dim TREE_NODE_NULL_IDENTIFIER
Dim TREE_NODE_NULL_UNDEFINED

Dim TREE_NODE_STRING_NULL
Dim TREE_NODE_STRING_STRING
Dim TREE_NODE_STRING_REAL
Dim TREE_NODE_STRING_INTEGER
Dim TREE_NODE_STRING_BOOLEAN
Dim TREE_NODE_STRING_EMPTY
Dim TREE_NODE_STRING_IDENTIFIER
Dim TREE_NODE_STRING_UNDEFINED

Dim TREE_NODE_REAL_NULL
Dim TREE_NODE_REAL_STRING
Dim TREE_NODE_REAL_REAL
Dim TREE_NODE_REAL_INTEGER
Dim TREE_NODE_REAL_BOOLEAN
Dim TREE_NODE_REAL_EMPTY
Dim TREE_NODE_REAL_IDENTIFIER
Dim TREE_NODE_REAL_UNDEFINED

Dim TREE_NODE_INTEGER_NULL
Dim TREE_NODE_INTEGER_STRING
Dim TREE_NODE_INTEGER_REAL
Dim TREE_NODE_INTEGER_INTEGER
Dim TREE_NODE_INTEGER_BOOLEAN
Dim TREE_NODE_INTEGER_EMPTY
Dim TREE_NODE_INTEGER_IDENTIFIER
Dim TREE_NODE_INTEGER_UNDEFINED

Dim TREE_NODE_BOOLEAN_NULL
Dim TREE_NODE_BOOLEAN_STRING
Dim TREE_NODE_BOOLEAN_REAL
Dim TREE_NODE_BOOLEAN_INTEGER
Dim TREE_NODE_BOOLEAN_BOOLEAN
Dim TREE_NODE_BOOLEAN_EMPTY
Dim TREE_NODE_BOOLEAN_IDENTIFIER
Dim TREE_NODE_BOOLEAN_UNDEFINED

Dim TREE_NODE_EMPTY_NULL
Dim TREE_NODE_EMPTY_STRING
Dim TREE_NODE_EMPTY_REAL
Dim TREE_NODE_EMPTY_INTEGER
Dim TREE_NODE_EMPTY_BOOLEAN
Dim TREE_NODE_EMPTY_EMPTY
Dim TREE_NODE_EMPTY_IDENTIFIER
Dim TREE_NODE_EMPTY_UNDEFINED

Dim TREE_NODE_IDENTIFIER_NULL
Dim TREE_NODE_IDENTIFIER_STRING
Dim TREE_NODE_IDENTIFIER_REAL
Dim TREE_NODE_IDENTIFIER_INTEGER
Dim TREE_NODE_IDENTIFIER_BOOLEAN
Dim TREE_NODE_IDENTIFIER_EMPTY
Dim TREE_NODE_IDENTIFIER_IDENTIFIER
Dim TREE_NODE_IDENTIFIER_UNDEFINED

Dim TREE_NODE_UNDEFINED_NULL
Dim TREE_NODE_UNDEFINED_STRING
Dim TREE_NODE_UNDEFINED_REAL
Dim TREE_NODE_UNDEFINED_INTEGER
Dim TREE_NODE_UNDEFINED_BOOLEAN
Dim TREE_NODE_UNDEFINED_EMPTY
Dim TREE_NODE_UNDEFINED_IDENTIFIER
Dim TREE_NODE_UNDEFINED_UNDEFINED


' Offsets into array, used as structure offset

const STRUCT_NODE_TYPE				= 0
const STRUCT_INTERNAL_NODE_VALUE	= 1
const STRUCT_INTERNAL_EVAL_TYPE		= 2
const STRUCT_LEFT_NODE_VALUE		= 3
const STRUCT_RIGHT_NODE_VALUE		= 4

Dim Binary_Function_Definition
Binary_Function_Definition = Array ( _
TREE_NODE_OR,			TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_OR,			TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_OR,			TREE_NODE_BOOLEAN,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_OR,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_AND,			TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_AND,			TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_AND,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_AND,			TREE_NODE_BOOLEAN,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LIKE,			TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LIKE,			TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LIKE,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LIKE,			TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LOWER,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LOWER,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LOWER,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LOWER,		TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_UPPER,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_UPPER,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_UPPER,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_UPPER,		TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_ISA,			TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_ISA,			TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_ISA,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_ISA,			TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_NULL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_BOOLEAN,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_NULL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_NULL,			TREE_NODE_NULL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_UNDEFINED,	TREE_NODE_NULL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_BOOLEAN,		TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_NULL,			TREE_NODE_UNDEFINED,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_NULL,			TREE_NODE_NULL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_PLUS,			TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_STRING,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		_
TREE_NODE_PLUS,			TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_PLUS,			TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_REAL,			_
TREE_NODE_PLUS,			TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_MINUS,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_MINUS,		TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_STRING,		_
TREE_NODE_MINUS,		TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_MINUS,		TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_STRING,		_
TREE_NODE_MINUS,		TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_MINUS,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		_
TREE_NODE_MINUS,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_MINUS,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_REAL,			_
TREE_NODE_MINUS,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_DIVIDE,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_DIVIDE,		TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_STRING,		_
TREE_NODE_DIVIDE,		TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_DIVIDE,		TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_STRING,		_
TREE_NODE_DIVIDE,		TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_DIVIDE,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		_
TREE_NODE_DIVIDE,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_DIVIDE,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_REAL,			_
TREE_NODE_DIVIDE,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_MULTIPLY,		TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_MULTIPLY,		TREE_NODE_UNDEFINED,	TREE_NODE_REAL,			TREE_NODE_STRING,		_
TREE_NODE_MULTIPLY,		TREE_NODE_REAL,			TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_MULTIPLY,		TREE_NODE_UNDEFINED,	TREE_NODE_INTEGER,		TREE_NODE_STRING,		_
TREE_NODE_MULTIPLY,		TREE_NODE_INTEGER,		TREE_NODE_UNDEFINED,	TREE_NODE_STRING,		_
TREE_NODE_MULTIPLY,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		_
TREE_NODE_MULTIPLY,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_MULTIPLY,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_REAL,			_
TREE_NODE_MULTIPLY,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_EMPTY,		TREE_NODE_EMPTY,		TREE_NODE_EMPTY,		TREE_NODE_EMPTY			_
)

Dim Unary_Function_Definition
Unary_Function_Definition = Array ( _
TREE_NODE_NOT,			TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOT,			TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	_
TREE_NODE_UNARYMINUS,	TREE_NODE_UNDEFINED,	TREE_NODE_UNDEFINED,	_
TREE_NODE_UNARYMINUS,	TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		_
TREE_NODE_UNARYMINUS,	TREE_NODE_REAL,			TREE_NODE_REAL,			_
TREE_NODE_EMPTY,		TREE_NODE_EMPTY,		TREE_NODE_EMPTY			_
)

Dim Post_Binary_Function_Definition
Post_Binary_Function_Definition = Array ( _
TREE_NODE_OR,			TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_AND,			TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LIKE,			TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LOWER,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_UPPER,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_ISA,			TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESSEQUAL,	TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_LESS,			TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATEREQUAL,	TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_GREATER,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_STRING,		TREE_NODE_STRING,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_INTEGER,		TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_REAL,			TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_REAL,			TREE_NODE_INTEGER,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_INTEGER,		TREE_NODE_REAL,			TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		TREE_NODE_BOOLEAN,		_
TREE_NODE_EQUAL,		TREE_NODE_NULL,		TREE_NODE_NULL,				TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_STRING,	TREE_NODE_STRING,			TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_INTEGER,	TREE_NODE_INTEGER,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_REAL,		TREE_NODE_REAL,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_REAL,		TREE_NODE_INTEGER,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_INTEGER,	TREE_NODE_REAL,		TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_BOOLEAN,	TREE_NODE_BOOLEAN,	TREE_NODE_BOOLEAN,		_
TREE_NODE_NOTEQUAL,		TREE_NODE_NULL,		TREE_NODE_NULL,		TREE_NODE_BOOLEAN,		_
TREE_NODE_PLUS,			TREE_NODE_STRING,	TREE_NODE_STRING,	TREE_NODE_STRING,		_
TREE_NODE_PLUS,			TREE_NODE_INTEGER,	TREE_NODE_INTEGER,	TREE_NODE_INTEGER,		_
TREE_NODE_PLUS,			TREE_NODE_REAL,		TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_PLUS,			TREE_NODE_REAL,		TREE_NODE_INTEGER,	TREE_NODE_REAL,			_
TREE_NODE_PLUS,			TREE_NODE_INTEGER,	TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_MINUS,		TREE_NODE_INTEGER,	TREE_NODE_INTEGER,	TREE_NODE_INTEGER,		_
TREE_NODE_MINUS,		TREE_NODE_REAL,		TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_MINUS,		TREE_NODE_REAL,		TREE_NODE_INTEGER,	TREE_NODE_REAL,			_
TREE_NODE_MINUS,		TREE_NODE_INTEGER,	TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_DIVIDE,		TREE_NODE_INTEGER,	TREE_NODE_INTEGER,	TREE_NODE_INTEGER,		_
TREE_NODE_DIVIDE,		TREE_NODE_REAL,		TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_DIVIDE,		TREE_NODE_REAL,		TREE_NODE_INTEGER,	TREE_NODE_REAL,			_
TREE_NODE_DIVIDE,		TREE_NODE_INTEGER,	TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_MULTIPLY,		TREE_NODE_INTEGER,	TREE_NODE_INTEGER,	TREE_NODE_INTEGER,		_
TREE_NODE_MULTIPLY,		TREE_NODE_REAL,		TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_MULTIPLY,		TREE_NODE_REAL,		TREE_NODE_INTEGER,	TREE_NODE_REAL,			_
TREE_NODE_MULTIPLY,		TREE_NODE_INTEGER,	TREE_NODE_REAL,		TREE_NODE_REAL,			_
TREE_NODE_EMPTY,		TREE_NODE_EMPTY,	TREE_NODE_EMPTY,	TREE_NODE_EMPTY			_
)

Dim Post_Unary_Function_Definition
Post_Unary_Function_Definition = Array ( _
TREE_NODE_NOT,			TREE_NODE_BOOLEAN,	TREE_NODE_BOOLEAN,	_
TREE_NODE_UNARYMINUS,	TREE_NODE_INTEGER,	TREE_NODE_INTEGER,	_
TREE_NODE_UNARYMINUS,	TREE_NODE_REAL,		TREE_NODE_REAL,		_
TREE_NODE_EMPTY,		TREE_NODE_EMPTY,	TREE_NODE_EMPTY		_
)

Function Initialize_Globals ()

	TREE_NODE_NULL_NULL				= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_NULL_STRING			= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_NULL_REAL				= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_NULL_INTEGER			= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_NULL_BOOLEAN			= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_NULL_EMPTY			= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_NULL_IDENTIFIER		= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_NULL_UNDEFINED		= ( TREE_NODE_NULL * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	TREE_NODE_STRING_NULL			= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_STRING_STRING			= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_STRING_REAL			= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_STRING_INTEGER		= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_STRING_BOOLEAN		= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_STRING_EMPTY			= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_STRING_IDENTIFIER		= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_STRING_UNDEFINED		= ( TREE_NODE_STRING * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	TREE_NODE_REAL_NULL				= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_REAL_STRING			= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_REAL_REAL				= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_REAL_INTEGER			= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_REAL_BOOLEAN			= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_REAL_EMPTY			= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_REAL_IDENTIFIER		= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_REAL_UNDEFINED		= ( TREE_NODE_REAL * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	TREE_NODE_INTEGER_NULL			= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_INTEGER_STRING		= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_INTEGER_REAL			= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_INTEGER_INTEGER		= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_INTEGER_BOOLEAN		= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_INTEGER_EMPTY			= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_INTEGER_IDENTIFIER	= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_INTEGER_UNDEFINED		= ( TREE_NODE_INTEGER * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	TREE_NODE_BOOLEAN_NULL			= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_BOOLEAN_STRING		= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_BOOLEAN_REAL			= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_BOOLEAN_INTEGER		= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_BOOLEAN_BOOLEAN		= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_BOOLEAN_EMPTY			= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_BOOLEAN_IDENTIFIER	= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_BOOLEAN_UNDEFINED		= ( TREE_NODE_BOOLEAN * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	TREE_NODE_EMPTY_NULL			= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_EMPTY_STRING			= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_EMPTY_REAL			= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_EMPTY_INTEGER			= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_EMPTY_BOOLEAN			= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_EMPTY_EMPTY			= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_EMPTY_IDENTIFIER		= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_EMPTY_UNDEFINED		= ( TREE_NODE_EMPTY * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	TREE_NODE_IDENTIFIER_NULL		= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_IDENTIFIER_STRING		= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_IDENTIFIER_REAL		= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_IDENTIFIER_INTEGER	= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_IDENTIFIER_BOOLEAN	= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_IDENTIFIER_EMPTY		= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_IDENTIFIER_IDENTIFIER	= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_IDENTIFIER_UNDEFINED	= ( TREE_NODE_IDENTIFIER * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	TREE_NODE_UNDEFINED_NULL		= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_NULL
	TREE_NODE_UNDEFINED_STRING		= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_STRING
	TREE_NODE_UNDEFINED_REAL		= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_REAL
	TREE_NODE_UNDEFINED_INTEGER		= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_INTEGER
	TREE_NODE_UNDEFINED_BOOLEAN		= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_BOOLEAN
	TREE_NODE_UNDEFINED_EMPTY		= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_EMPTY
	TREE_NODE_UNDEFINED_IDENTIFIER	= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_IDENTIFIER
	TREE_NODE_UNDEFINED_UNDEFINED	= ( TREE_NODE_UNDEFINED * TYPE_FACTOR ) + TREE_NODE_UNDEFINED

	Initialize_Globals = True

End Function

Function ParseCommandLine ( a_ArgumentArray , a_ArgumentArrayCount , ByRef a_Test , ByRef a_Create , ByRef a_Server , ByRef a_Namespace , ByRef a_Query , ByRef a_Script , ByRef a_FilterName , ByRef a_ConsumerName ) 

	ParseCommandLine = Error_Success

	a_Test = False
	a_Create = False

	If a_ArgumentArrayCount <> 0 Then

		Dim t_ArgumentIndex 
		t_ArgumentIndex = 0 
		
		While t_ArgumentIndex < a_ArgumentArrayCount

			Dim t_Argument
			t_Argument = a_ArgumentArray ( t_ArgumentIndex ) 

			If t_Argument = "-T" Then

				a_Test = True

				t_ArgumentIndex = t_ArgumentIndex + 1

				If t_ArgumentIndex = a_ArgumentArrayCount - 1 Then

					a_Query = a_ArgumentArray ( t_ArgumentIndex ) 

				Else

					ParseCommandLine = Error_InsufficientArgs

				End If

				Exit Function 

			Else

				If t_Argument = "-D" Then

					t_ArgumentIndex = t_ArgumentIndex + 1

					a_Create = FALSE

					If t_Argument = "-S" Then

						t_ArgumentIndex = t_ArgumentIndex + 1
						a_Server = a_ArgumentArray ( t_ArgumentIndex ) 
		
					Else 
						If t_Argument = "-N" Then

							t_ArgumentIndex = t_ArgumentIndex + 1
							a_Namespace = a_ArgumentArray ( t_ArgumentIndex ) 

						Else

							If t_ArgumentIndex = a_ArgumentArrayCount - 1 - 1 Then

								a_FilterName = a_ArgumentArray ( t_ArgumentIndex ) 
								a_ConsumerName = a_ArgumentArray ( t_ArgumentIndex + 1 ) 

							Else

								ParseCommandLine = Error_InsufficientArgs

							End If

							Exit Function
						End If

					End If

					t_ArgumentIndex = t_ArgumentIndex + 1 

				Else 
					If t_Argument = "-C" Then

						t_ArgumentIndex = t_ArgumentIndex + 1

						a_Create = TRUE

						If t_Argument = "-S" Then

							t_ArgumentIndex = t_ArgumentIndex + 1
							a_Server = a_ArgumentArray ( t_ArgumentIndex ) 
			
						Else 
							If t_Argument = "-N" Then

								t_ArgumentIndex = t_ArgumentIndex + 1
								a_Namespace = a_ArgumentArray ( t_ArgumentIndex ) 

							Else

								If t_ArgumentIndex = a_ArgumentArrayCount - 1 - 3 Then
		
									a_Query = a_ArgumentArray ( t_ArgumentIndex ) 
									a_Script = a_ArgumentArray ( t_ArgumentIndex + 1 ) 
									a_FilterName = a_ArgumentArray ( t_ArgumentIndex + 2 ) 
									a_ConsumerName = a_ArgumentArray ( t_ArgumentIndex + 3 ) 

								Else

									ParseCommandLine = Error_InsufficientArgs
				
								End If
		
								Exit Function
							End If

						End If
		
						t_ArgumentIndex = t_ArgumentIndex + 1 
					Else

						ParseCommandLine = Error_InvalidArgs

						Exit Function

					End If

				End If

			End If

		Wend
	
	Else
		ParseCommandLine = Error_NoArgs

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		CreateFilter
'
'	Description:
'
'		
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function CreateFilter ( a_Filter , a_Query , a_Name ) 

	a_Filter.QueryLanguage = "WQL"
	a_Filter.Query = a_Query 
	a_Filter.Name = a_Name 

	a_Filter.Put_

	CreateFilter = Err.Number

End Function


'---------------------------------------------------------
'
'	Function:
'
'		CreateConsumer
'
'	Description:
'
'		
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function CreateConsumer ( a_Consumer , a_Script , a_Name ) 

	a_Consumer.Name = a_Name 

	If 0 Then 

		a_Consumer.CommandLineTemplate = a_Script
		a_Consumer.DesktopName = "WinSta0\default"
	Else

		a_Consumer.ScriptFilename = a_Script
		a_Consumer.ScriptingEngine = "VBScript"
	End If

	a_Consumer.Put_

	CreateConsumer = Err.Number

End Function

'---------------------------------------------------------
'
'	Function:
'
'		CreateBinding
'
'	Description:
'
'		
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function CreateBinding ( a_Binding , a_Filter , a_Consumer ) 


	a_Binding.Filter = a_Filter.Path_.RelPath
	a_Binding.Consumer = a_Consumer.Path_.RelPath

	a_Binding.Put_

	CreateBinding = Err.Number

End Function

'---------------------------------------------------------
'
'	Function:
'
'		DeleteFilter
'
'	Description:
'
'		
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function DeleteFilter ( a_Filter , a_Name ) 

	On Error Resume Next

	a_Filter.Name = a_Name 

	a_Filter.Delete_

	DeleteFilter = Err.Number

End Function


'---------------------------------------------------------
'
'	Function:
'
'		DeleteConsumer
'
'	Description:
'
'		
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function DeleteConsumer ( a_Consumer , a_Name ) 

	On Error Resume Next

	a_Consumer.Name = a_Name 
	a_Consumer.Delete_

	DeleteConsumer = Err.Number

End Function

'---------------------------------------------------------
'
'	Function:
'
'		DeleteBinding
'
'	Description:
'
'		
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function DeleteBinding ( a_Binding , a_Filter , a_Consumer ) 

	On Error Resume Next

	a_Binding.Filter = a_Filter.Path_.RelPath
	a_Binding.Consumer = a_Consumer.Path_.RelPath

	a_Binding.Delete_

	DeleteBinding = Err.Number

End Function

'---------------------------------------------------------
'
'	Function:
'
'		CreateFilterBindingAndConsumer
'
'	Description:
'
'		Parse command line arguments, to extract server, namespace, query definition and consumer to execute
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function CreateFilterBindingAndConsumer ( a_Server , a_Namespace , a_Query , a_Script , a_FilterName , a_ConsumerName ) 

	Dim t_Locator
	Dim t_Service
	Dim t_Filter
	Dim t_Binding
	Dim t_Consumer 
	
	Set t_Locator = CreateObject("WbemScripting.SWbemLocator")
	if Err.Number <> 0 Then

		WScript.Echo "CreateObject" , Err.Description		

		CreateFilterBindingAndConsumer = Err.Number
		Exit Function
	End If

	Set t_Server = t_Locator.ConnectServer ( a_server, a_Namespace )
	if Err.Number <> 0 Then

		WScript.Echo "ConnectServer" , Err.Description		
	
		CreateFilterBindingAndConsumer = Err.Number
		Exit Function
	End If

	Set t_Filter = t_Server.Get ( "__EventFilter" ).SpawnInstance_
	If Err.Number <> 0 Then

		WScript.Echo "Get __EventFilter" , Err.Description		
		
		CreateFilterBindingAndConsumer = Err.Number
		Exit Function

	End If

	Set t_Binding = t_Server.Get ( "__FilterToConsumerBinding" ).SpawnInstance_
	If Err.Number <> 0 Then

		WScript.Echo "Get __FilterToConsumerBinding" , Err.Description		
		
		CreateFilterBindingAndConsumer = Err.Number
		Exit Function

	End If

	If 0 Then
		Set t_Consumer = t_Server.Get ( "CommandLineEventConsumer" ).SpawnInstance_
	Else
		Set t_Consumer = t_Server.Get ( "ActiveScriptEventConsumer" ).SpawnInstance_
	End If
	If Err.Number <> 0 Then

		WScript.Echo "Get CommandLineConsumer" , Err.Description		
		
		CreateFilterBindingAndConsumer = Err.Number
		Exit Function

	End If

	Dim t_Status

	t_Status = CreateFilter ( t_Filter , a_Query , a_FilterName ) 
	If Err.Number <> 0 Then

		WScript.Echo "CreateFilter" , Err.Description		

		CreateFilterBindingAndConsumer = Err.Number
		Exit Function
		
	End If

	t_Status = CreateConsumer ( t_Consumer , a_Script , a_ConsumerName ) 
	If Err.Number <> 0 Then

		WScript.Echo "CreateConsumer" , Err.Description		

		t_Status = t_Filter.Delete_

		CreateFilterBindingAndConsumer = Err.Number
		Exit Function
		
	End If

	t_Status = CreateBinding ( t_Binding , t_Filter , t_Consumer ) 
	If Err.Number <> 0 Then

		WScript.Echo "CreateBinding" , Err.Description		

		t_Status = t_Filter.Delete_ 
		t_Status = t_Consumer.Delete_ 

		CreateFilterBindingAndConsumer = Err.Number
		Exit Function
		
	End If
	
End Function

'---------------------------------------------------------
'
'	Function:
'
'		DeleteFilterBindingAndConsumer
'
'	Description:
'
'		Parse command line arguments, to extract server, namespace, query definition and consumer to execute
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function DeleteFilterBindingAndConsumer ( a_Server , a_Namespace , a_FilterName , a_ConsumerName ) 

	Dim t_Locator
	Dim t_Service
	Dim t_Filter
	Dim t_Binding
	Dim t_Consumer 
	
	Set t_Locator = CreateObject("WbemScripting.SWbemLocator")
	if Err.Number <> 0 Then

		WScript.Echo "CreateObject" , Err.Description		

		DeleteFilterBindingAndConsumer = Err.Number
		Exit Function
	End If

	Set t_Server = t_Locator.ConnectServer ( a_server, a_Namespace )
	if Err.Number <> 0 Then

		WScript.Echo "ConnectServer" , Err.Description		
	
		DeleteFilterBindingAndConsumer = Err.Number
		Exit Function
	End If

	Set t_Filter = t_Server.Get ( "__EventFilter" ).SpawnInstance_
	If Err.Number <> 0 Then

		WScript.Echo "Get __EventFilter" , Err.Description		
		
		DeleteFilterBindingAndConsumer = Err.Number
		Exit Function

	End If

	Set t_Binding = t_Server.Get ( "__FilterToConsumerBinding" ).SpawnInstance_
	If Err.Number <> 0 Then

		WScript.Echo "Get __FilterToConsumerBinding" , Err.Description		
		
		DeleteFilterBindingAndConsumer = Err.Number
		Exit Function

	End If

	If 0 Then

		Set t_Consumer = t_Server.Get ( "CommandLineEventConsumer" ).SpawnInstance_
	Else

		Set t_Consumer = t_Server.Get ( "ActiveScriptEventConsumer" ).SpawnInstance_
	End If

	If Err.Number <> 0 Then

		WScript.Echo "Get CommandLineConsumer" , Err.Description		
		
		DeleteFilterBindingAndConsumer = Err.Number
		Exit Function

	End If

	Dim t_Status

	On Error Resume Next

	t_Status = DeleteFilter ( t_Filter , a_FilterName ) 
	If t_Status <> 0 Then

		WScript.Echo "DeleteFilter" , t_Status , Err.Description		

		DeleteFilterBindingAndConsumer = t_Status
		
	End If

	t_Status = DeleteConsumer ( t_Consumer , a_ConsumerName ) 
	If t_Status <> 0 Then

		WScript.Echo "DeleteConsumer" , t_Status , Err.Description		

		DeleteFilterBindingAndConsumer = t_Status
		
	End If

	t_Status = DeleteBinding ( t_Binding , t_Filter , t_Consumer ) 
	If t_Status <> 0 Then

		WScript.Echo "DeleteBinding" , t_Status , Err.Description		

		DeleteFilterBindingAndConsumer = t_Status
		
	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		InsertLeft
'
'	Description:
'
'		
'
'	Input Arguments:
'
'		None
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function Get_Node_Type ( ByRef Node , ByRef Node_Type )

	Node_Type = Node ( STRUCT_NODE_TYPE )
	
	Get_Node_Type = TRUE

End Function

Function Get_Node_Eval_Type ( ByRef Node , ByRef Node_Type )

	Node_Type = Node ( STRUCT_INTERNAL_EVAL_TYPE )
	
	Get_Node_Eval_Type = TRUE 

End Function

Function Get_Node_Eval_Value ( ByRef Node , ByRef Node_Value )

	Node_Value = Node ( STRUCT_INTERNAL_NODE_VALUE )
	
	Get_Node_Eval_Value = TRUE

End Function

Function Get_Left_Node ( ByRef Node , ByRef Left_Node )

	Left_Node = Node ( STRUCT_LEFT_NODE_VALUE )
	
	Get_Left_Node = TRUE

End Function

Function Get_Right_Node ( ByRef Node , ByRef Right_Node )

	Right_Node = Node ( STRUCT_RIGHT_NODE_VALUE )

	Get_Right_Node = TRUE
	
End Function

Function Set_Node_Type ( ByRef Node , a_VariantType ) 

	Node ( STRUCT_NODE_TYPE ) = a_VariantType

	Set_Node_Type = TRUE

End Function

Function Set_Node_Eval_Type ( ByRef Node , a_VariantType ) 

	Node ( STRUCT_INTERNAL_EVAL_TYPE ) = a_VariantType

	Set_Node_Eval_Type = TRUE

End Function

Function Set_Node_Eval_Value ( ByRef Node , a_Variant ) 

	Node ( STRUCT_INTERNAL_NODE_VALUE ) = a_Variant

	Set_Node_Eval_Value = TRUE

End Function

Function Set_Left_Node ( ByRef Node , a_Variant ) 

	Node ( STRUCT_LEFT_NODE_VALUE ) = a_Variant

	Set_Left_Node = TRUE

End Function

Function Set_Right_Node ( ByRef Node , a_Variant ) 

	Node ( STRUCT_RIGHT_NODE_VALUE ) = a_Variant

	Set_Right_Node = TRUE

End Function

Function Output_Node ( ByRef Node )

	Select Case Node ( STRUCT_NODE_TYPE )

		Case TREE_NODE_LIKE

			WScript.Echo "Like"

		Case TREE_NODE_UPPER

			WScript.Echo "Upper"

		Case TREE_NODE_LOWER

			WScript.Echo "Lower"

		Case TREE_NODE_EQUAL

			WScript.Echo "="

		Case TREE_NODE_NOTEQUAL

			WScript.Echo "<>"

		Case TREE_NODE_LESS

			WScript.Echo "<"

		Case TREE_NODE_LESSEQUAL

			WScript.Echo "<="

		Case TREE_NODE_GREATER

			WScript.Echo ">"

		Case TREE_NODE_GREATEREQUAL

			WScript.Echo ">="

		Case TREE_NODE_NOT

			WScript.Echo "Not"

		Case TREE_NODE_UNARYMINUS

			WScript.Echo "-"

		Case TREE_NODE_OR

			WScript.Echo "Or"

		Case TREE_NODE_AND

			WScript.Echo "And"

		Case TREE_NODE_ISA

			WScript.Echo "IsA"

		Case TREE_NODE_PLUS

			WScript.Echo "Plus"

		Case TREE_NODE_MINUS

			WScript.Echo "Minus"

		Case TREE_NODE_DIVIDE

			WScript.Echo "Divide"

		Case TREE_NODE_MULTIPLY

			WScript.Echo "Multiply"

		Case TREE_NODE_NULL

			WScript.Echo "Null"

		Case TREE_NODE_STRING

			WScript.Echo "String"

		Case TREE_NODE_REAL

			WScript.Echo "Real"

		Case TREE_NODE_INTEGER

			WScript.Echo "Integer"

		Case TREE_NODE_BOOLEAN

			WScript.Echo "Boolean"

		Case TREE_NODE_IDENTIFIER

			WScript.Echo "Identifier"

		Case TREE_NODE_EMPTY

			WScript.Echo "Empty"

		Case Else

			WScript.Echo "Unknown"

	End Select

End Function

Function Concatenate_Identifier ( ByRef Node , ByRef a_String )

	Dim Identifier_Array 
	Identifier_Array = Node ( STRUCT_INTERNAL_NODE_VALUE )

	Dim Array_Size
	Array_Size = UBound ( Identifier_Array ) - LBound ( Identifier_Array ) + 1 

	Dim Index
	Index = 0 
	While Index < Array_Size		

		a_String = a_String + CStr ( Identifier_Array ( Index ) )

		If Index < Array_Size - 1 Then

			a_String = a_String + "."

		End If

		Index = Index + 1

	WEnd

	Concatenate_Identifier = True

End Function

Function Resolve_Identifier ( ByRef Node , a_EventObject )

	Dim Identifier_Array 
	Identifier_Array = Node ( STRUCT_INTERNAL_NODE_VALUE )

	Dim Array_Size
	Array_Size = UBound ( Identifier_Array ) - LBound ( Identifier_Array ) + 1 

	Dim t_Object
	Set t_Object = a_EventObject

	Dim Index
	Index = 0 
	While Index < Array_Size 

		Dim t_Property
		Dim t_PropertyValue

		Set t_Property = t_Object.Properties_ ( CStr ( Identifier_Array ( Index ) ) )

		If t_Property.CIMType = wbemCimtypeObject Then

			If Index = Array_Size - 1 Then
	
				Status = Set_Node_Eval_Value ( Node , t_Property.Value.GetObjectText_ ) 

			Else
	
				Set t_Object = t_Property.Value 

			End If

		Else

			If Index = Array_Size - 1 Then
	
				Dim Status
				Status = Set_Node_Eval_Value ( Node , t_Property.Value ) 

				Select Case t_Property.CIMType 

					Case wbemCimtypeSint8

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_INTEGER ) 

					Case wbemCimtypeUint8

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_INTEGER ) 

					Case wbemCimtypeChar16

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_INTEGER ) 

					Case wbemCimtypeSint16

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_INTEGER ) 

					Case wbemCimtypeUint16

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_INTEGER ) 

					Case wbemCimtypeSint32

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_INTEGER ) 

					Case wbemCimtypeUint32

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_INTEGER ) 

					Case wbemCimtypeReal32

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_REAL ) 

					Case wbemCimtypeReal64

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_REAL ) 

					Case wbemCimtypeBoolean

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_BOOLEAN ) 

					Case wbemCimtypeSint64

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_STRING ) 

					Case wbemCimtypeUint64

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_STRING ) 

					Case wbemCimtypeString

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_STRING ) 

					Case wbemCimtypeDatetime

							Status = Set_Node_Eval_Type ( Node , TREE_NODE_STRING ) 

					Case Else

						Resolve_Identifier = False 

				End Select

			Else

				Resolve_Identifier = False 

				Exit Function

			End If

		End If

		Index = Index + 1

	WEnd

	Resolve_Identifier = True

End Function

Function Concatenate_Node ( ByRef Node , ByRef a_String )

	Select Case Node ( STRUCT_NODE_TYPE )

		Case TREE_NODE_LIKE

			a_String = a_String + " Like "

		Case TREE_NODE_OR

			a_String = a_String + " Or "

		Case TREE_NODE_AND

			a_String = a_String + " And "

		Case TREE_NODE_ISA

			a_String = a_String + " IsA "

		Case TREE_NODE_UPPER

			a_String = a_String + " Upper "

		Case TREE_NODE_LOWER

			a_String = a_String + " Lower "

		Case TREE_NODE_EQUAL

			a_String = a_String +  " = "

		Case TREE_NODE_NOTEQUAL

			a_String = a_String +  " <> "

		Case TREE_NODE_LESS

			a_String = a_String +  " < "

		Case TREE_NODE_LESSEQUAL

			a_String = a_String + " <= "

		Case TREE_NODE_GREATER

			a_String = a_String + " > "

		Case TREE_NODE_GREATEREQUAL

			a_String = a_String +  " >= "

		Case TREE_NODE_NOT

			a_String = a_String + " Not "

		Case TREE_NODE_UNARYMINUS

			a_String = a_String + " - "

		Case TREE_NODE_PLUS

			a_String = a_String + " + "

		Case TREE_NODE_MINUS

			a_String = a_String + " - "

		Case TREE_NODE_DIVIDE

			a_String = a_String + " / "

		Case TREE_NODE_MULTIPLY

			a_String = a_String + " * "

		Case TREE_NODE_NULL

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_STRING

			a_String = a_String + """" + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) ) + """"

		Case TREE_NODE_REAL

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_INTEGER

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_BOOLEAN

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_IDENTIFIER

			Dim Status
			Status = Concatenate_Identifier ( Node , a_String )

		Case TREE_NODE_EMPTY

			a_String = a_String + "Empty"

		Case Else

			a_String = a_String + "Unknown"

	End Select

	Concatenate_Node = TRUE 

End Function

Function Concatenate_Eval_Node ( ByRef Node , ByRef a_String )

	Select Case Node ( STRUCT_NODE_TYPE )

		Case TREE_NODE_LIKE

			a_String = a_String + " Like "

		Case TREE_NODE_OR

			a_String = a_String + " Or "

		Case TREE_NODE_AND

			a_String = a_String + " And "

		Case TREE_NODE_ISA

			a_String = a_String + " IsA "

		Case TREE_NODE_UPPER

			a_String = a_String + " Upper "

		Case TREE_NODE_LOWER

			a_String = a_String + " Lower "

		Case TREE_NODE_EQUAL

			a_String = a_String +  " = "

		Case TREE_NODE_NOTEQUAL

			a_String = a_String +  " <> "

		Case TREE_NODE_LESS

			a_String = a_String +  " < "

		Case TREE_NODE_LESSEQUAL

			a_String = a_String + " <= "

		Case TREE_NODE_GREATER

			a_String = a_String + " > "

		Case TREE_NODE_GREATEREQUAL

			a_String = a_String +  " >= "

		Case TREE_NODE_NOT

			a_String = a_String + " Not "

		Case TREE_NODE_UNARYMINUS

			a_String = a_String + " - "

		Case TREE_NODE_PLUS

			a_String = a_String + " + "

		Case TREE_NODE_MINUS

			a_String = a_String + " - "

		Case TREE_NODE_DIVIDE

			a_String = a_String + " / "

		Case TREE_NODE_MULTIPLY

			a_String = a_String + " * "

		Case TREE_NODE_NULL

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_STRING

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_REAL

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_INTEGER

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_BOOLEAN

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_IDENTIFIER

			a_String = a_String + CStr ( Node ( STRUCT_INTERNAL_NODE_VALUE ) )

		Case TREE_NODE_EMPTY

			a_String = a_String + "Empty"

		Case Else

			a_String = a_String + "Unknown"

	End Select

	Concatenate_Eval_Node = TRUE 

End Function

Function Output_NodeType ( ByRef NodeType )

	Select Case NodeType

		Case TREE_NODE_LIKE

			WScript.Echo "Like"

		Case TREE_NODE_OR

			WScript.Echo "Or"

		Case TREE_NODE_AND

			WScript.Echo "And"

		Case TREE_NODE_ISA

			WScript.Echo "IsA"

		Case TREE_NODE_UPPER

			WScript.Echo "Upper"

		Case TREE_NODE_LOWER

			WScript.Echo "Lower"

		Case TREE_NODE_EQUAL

			WScript.Echo "="

		Case TREE_NODE_NOTEQUAL

			WScript.Echo "<>"

		Case TREE_NODE_LESS

			WScript.Echo "<"

		Case TREE_NODE_LESSEQUAL

			WScript.Echo "<="

		Case TREE_NODE_GREATER

			WScript.Echo ">"

		Case TREE_NODE_GREATEREQUAL

			WScript.Echo ">="

		Case TREE_NODE_NOT

			WScript.Echo "Not"

		Case TREE_NODE_UNARYMINUS

			WScript.Echo "-"

		Case TREE_NODE_PLUS

			WScript.Echo "Plus"

		Case TREE_NODE_MINUS

			WScript.Echo "Minus"

		Case TREE_NODE_DIVIDE

			WScript.Echo "Divide"

		Case TREE_NODE_MULTIPLY

			WScript.Echo "Multiply"

		Case TREE_NODE_NULL

			WScript.Echo "Null"

		Case TREE_NODE_STRING

			WScript.Echo "String"

		Case TREE_NODE_REAL

			WScript.Echo "Real"

		Case TREE_NODE_INTEGER

			WScript.Echo "Integer"

		Case TREE_NODE_BOOLEAN

			WScript.Echo "Boolean"

		Case TREE_NODE_IDENTIFIER

			WScript.Echo "Identifier"
		
		Case TREE_NODE_EMPTY

			WScript.Echo "Empty"

		Case Else

			WScript.Echo "Unknown"

	End Select

End Function

Function Is_Simple_Type ( ByRef NodeType )

	Select Case NodeType

		Case TREE_NODE_NULL

			Is_Simple_Type = true

		Case TREE_NODE_STRING

			Is_Simple_Type = true

		Case TREE_NODE_REAL

			Is_Simple_Type = true

		Case TREE_NODE_INTEGER

			Is_Simple_Type = true

		Case TREE_NODE_BOOLEAN

			Is_Simple_Type = true

		Case Else

			Is_Simple_Type = false

	End Select
	
End Function

Function Is_Unary_Node ( ByRef Node )

	Select Case Node ( STRUCT_NODE_TYPE )

		Case TREE_NODE_NOT

			Is_Unary_Node = true

		Case TREE_NODE_UNARYMINUS

			Is_Unary_Node = true

		Case TREE_NODE_UPPER

			Is_Unary_Node = true

		Case TREE_NODE_LOWER

			Is_Unary_Node = true

		Case Else

			Is_Unary_Node = false

	End Select

End Function

Function Is_Binary_Node ( ByRef Node )

	Select Case Node ( STRUCT_NODE_TYPE )

		Case TREE_NODE_LIKE

			Is_Binary_Node = true

		Case TREE_NODE_OR

			Is_Binary_Node = true

		Case TREE_NODE_AND

			Is_Binary_Node = true

		Case TREE_NODE_ISA

			Is_Binary_Node = true

		Case TREE_NODE_PLUS

			Is_Binary_Node = true

		Case TREE_NODE_MINUS

			Is_Binary_Node = true

		Case TREE_NODE_DIVIDE

			Is_Binary_Node = true

		Case TREE_NODE_MULTIPLY

			Is_Binary_Node = true

		Case TREE_NODE_EQUAL

			Is_Binary_Node = true

		Case TREE_NODE_NOTEQUAL

			Is_Binary_Node = true
		
		Case TREE_NODE_GREATER

			Is_Binary_Node = true

		Case TREE_NODE_GREATEREQUAL

			Is_Binary_Node = true

		Case TREE_NODE_LESS

			Is_Binary_Node = true

		Case TREE_NODE_LESSEQUAL

			Is_Binary_Node = true

		Case Else

			Is_Binary_Node = false

	End Select

End Function

Function Is_Relational ( ByRef Node )

	Select Case Node ( STRUCT_NODE_TYPE )

		Case TREE_NODE_LIKE

			Is_Relational = true

		Case TREE_NODE_ISA

			Is_Relational = true

		Case TREE_NODE_EQUAL

			Is_Relational = true

		Case TREE_NODE_NOTEQUAL

			Is_Relational = true
		
		Case TREE_NODE_GREATER

			Is_Relational = true

		Case TREE_NODE_GREATEREQUAL

			Is_Relational = true

		Case TREE_NODE_LESS

			Is_Relational = true

		Case TREE_NODE_LESSEQUAL

			Is_Relational = true

		Case Else

			Is_Relational = false

	End Select

End Function

Function Is_Non_Conformant_Node ( ByRef Node )

	Select Case Node ( STRUCT_NODE_TYPE )

		Case TREE_NODE_PLUS

			Is_Non_Conformant_Node = true

		Case TREE_NODE_MINUS

			Is_Non_Conformant_Node = true

		Case TREE_NODE_DIVIDE

			Is_Non_Conformant_Node = true

		Case TREE_NODE_MULTIPLY

			Is_Non_Conformant_Node = true

		Case TREE_NODE_UNARYMINUS

			Is_Non_Conformant_Node = true

		Case Else

			Is_Non_Conformant_Node = false

	End Select

End Function

Function Validate_Unary_Node ( Function_Node , Arg1_Node , ByRef ResultType )

	Validate_Unary_Node = FALSE
	
	Dim Index 
	Index = 0 

	While True

		Dim ElementIndex 
		ElementIndex = Index * 3

		Dim Function_Value
		Dim Arg1_Value
		Dim Arg2_Value
		Dim Result_Value

		Function_Value = Unary_Function_Definition ( ElementIndex )
		Arg1_Value = Unary_Function_Definition ( ElementIndex + 1 )
		Result_Value = Unary_Function_Definition ( ElementIndex + 2 )

		If Function_Value = TREE_NODE_EMPTY Then

			Exit Function

		End If

		Dim Status
		Dim Function_Input
		Dim Arg1_Input
		Dim Arg2_Input

		Status = Get_Node_Type ( Function_Node , Function_Input )
		Status = Get_Node_Eval_Type ( Arg1 , Arg1_Input ) 

		Dim Equivalence
		Equivalence = ( Function_Value = Function_Input ) 
		Equivalence = Equivalence And ( Arg1_Value = Arg1_Input ) 

		If Equivalence Then

			ResultType = Result_Value

			Validate_Unary_Node = True

			Exit Function

		End If

		Index = Index + 1 

	WEnd 

End Function

Function Validate_Binary_Node ( Function_Node , Arg1_Node , Arg2_Node , ByRef ResultType )

	Validate_Binary_Node = FALSE
	
	Dim Index 
	Index = 0 

	While True

		Dim ElementIndex 
		ElementIndex = Index * 4

		Dim Function_Value
		Dim Arg1_Value
		Dim Arg2_Value
		Dim Result_Value

		Function_Value = Binary_Function_Definition ( ElementIndex )
		Arg1_Value = Binary_Function_Definition ( ElementIndex + 1 )
		Arg2_Value = Binary_Function_Definition ( ElementIndex + 2 )
		Result_Value = Binary_Function_Definition ( ElementIndex + 3 )

		If Function_Value = TREE_NODE_EMPTY Then

			Exit Function

		End If

		Dim Status
		Dim Function_Input
		Dim Arg1_Input
		Dim Arg2_Input

		Status = Get_Node_Type ( Function_Node , Function_Input )
		Status = Get_Node_Eval_Type ( Arg1_Node , Arg1_Input ) 
		Status = Get_Node_Eval_Type ( Arg2_Node , Arg2_Input ) 

		Dim Equivalence
		Equivalence = ( Function_Value = Function_Input ) 
		Equivalence = Equivalence And ( Arg1_Value = Arg1_Input ) 
		Equivalence = Equivalence And ( Arg2_Value = Arg2_Input ) 

		If Equivalence Then

			ResultType = Result_Value

			Validate_Binary_Node = True

			Exit Function

		End If

		Index = Index + 1 

	WEnd 

End Function

Function Create_Binary_Node_Template ( ByRef Node )

	Dim Empty_Node
	Dim Undefined_Node
	Dim Status

	Status = Create_Empty ( Empty_Node )
	Status = Create_Undefined ( Undefined_Node )

	Node = Array ( TREE_NODE_UNDEFINED , Undefined_Node , TREE_NODE_UNDEFINED , Empty_Node , Empty_Node )

	Create_Binary_Node_Template = TRUE 

End Function

Function Create_Unary_Node_Template ( ByRef Node )

	Dim Empty_Node
	Dim Undefined_Node

	Dim Status

	Status = Create_Empty ( Empty_Node )
	Status = Create_Undefined ( Undefined_Node )

	Node = Array ( TREE_NODE_UNDEFINED , Undefined_Node , TREE_NODE_UNDEFINED , Empty_Node )

	Create_Unary_Node_Template = TRUE 

End Function

Function Create_Like ( ByRef Like_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Like_Node ) 

	Status = Set_Node_Type ( Like_Node , TREE_NODE_LIKE )

	Create_Like = TRUE

End Function

Function Create_Lower ( ByRef Lower_Node ) 

	Dim Status
	Status = Create_Unary_Node_Template ( Lower_Node ) 

	Status = Set_Node_Type ( Lower_Node , TREE_NODE_LOWER )

	Create_Lower = TRUE

End Function

Function Create_Upper ( ByRef Upper_Node ) 

	Dim Status
	Status = Create_Unary_Node_Template ( Upper_Node ) 

	Status = Set_Node_Type ( Upper_Node , TREE_NODE_UPPER )

	Create_Upper = TRUE

End Function

Function Create_And ( ByRef And_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( And_Node ) 

	Status = Set_Node_Type ( And_Node , TREE_NODE_AND )

	Create_And = TRUE

End Function

Function Create_Or ( ByRef Or_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Or_Node ) 

	Status = Set_Node_Type ( Or_Node , TREE_NODE_OR )

	Create_OR = TRUE

End Function

Function Create_Less ( ByRef Less_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Less_Node ) 

	Status = Set_Node_Type ( Less_Node , TREE_NODE_LESS )

	Create_Less = TRUE

End Function

Function Create_Greater ( ByRef Greater_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Greater_Node ) 

	Status = Set_Node_Type ( Greater_Node , TREE_NODE_GREATER )

	Create_Greater = TRUE

End Function

Function Create_Equal ( ByRef Equal_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Equal_Node ) 

	Status = Set_Node_Type ( Equal_Node , TREE_NODE_EQUAL )

	Create_Equal = TRUE

End Function

Function Create_NotEqual ( ByRef NotEqual_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( NotEqual_Node ) 

	Status = Set_Node_Type ( NotEqual , TREE_NODE_NOTEQUAL )

	Create_NotEqual = TRUE

End Function

Function Create_LessEqual ( ByRef LessEqual_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( LessEqual_Node ) 

	Status = Set_Node_Type ( LessEqual_Node , TREE_NODE_LESSEQUAL )

	Create_LessEqual = TRUE

End Function

Function Create_GreaterEqual ( ByRef GreaterEqual_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( GreaterEqual_Node ) 

	Status = Set_Node_Type ( GreaterEqual_Node , TREE_NODE_GREATEREQUAL )

	Create_GreaterEqual = TRUE

End Function

Function Create_IsA ( ByRef Isa_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Isa_Node ) 

	Status = Set_Node_Type ( Isa_Node , TREE_NODE_ISA )

	Create_IsA = TRUE

End Function

Function Create_Plus ( ByRef Plus_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Plus_Node ) 

	Status = Set_Node_Type ( Plus_Node , TREE_NODE_PLUS )

	Create_Plus = TRUE

End Function

Function Create_Minus ( ByRef Minus_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Minus_Node ) 

	Status = Set_Node_Type ( Minus_Node , TREE_NODE_MINUS )

	Create_Minus = TRUE

End Function

Function Create_Multiply ( ByRef Multiply_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Multiply_Node ) 

	Status = Set_Node_Type ( Multiply_Node , TREE_NODE_MULTIPLY )

	Create_Multiply = TRUE

End Function

Function Create_Divide ( ByRef Divide_Node ) 

	Dim Status
	Status = Create_Binary_Node_Template ( Divide_Node ) 

	Status = Set_Node_Type ( Divide_Node , TREE_NODE_DIVIDE )

	Create_Divide = TRUE

End Function

Function Create_Not ( ByRef Not_Node ) 

 	Dim Status
	Status = Create_Unary_Node_Template ( Not_Node ) 

	Status = Set_Node_Type ( Not_Node , TREE_NODE_NOT )

	Create_Not = TRUE

End Function

Function Create_UnaryMinus ( ByRef UnaryMinus_Node ) 

 	Dim Status
	Status = Create_Unary_Node_Template ( UnaryMinus_Node ) 

	Status = Set_Node_Type ( UnaryMinus_Node , TREE_NODE_UNARY_MINUS )

	Create_UnaryMinus = TRUE

End Function

Function Create_Identifier ( ByRef Identifier_Node , a_Identifier ) 

	Dim Identifier_Value 
	Identifier_Value = Array ( a_Identifier ) 

	Identifier_Node = Array ( TREE_NODE_IDENTIFIER , Identifier_Value , TREE_NODE_UNDEFINED )

	Create_Identifier = TRUE

End Function

Function Insert_Identifier ( ByRef Identifier_Node , a_Identifier ) 

	Dim Identifier_Array 
	Identifier_Array = Identifier_Node ( STRUCT_INTERNAL_NODE_VALUE )

	Dim Array_Size
	Array_Size = UBound ( Identifier_Array ) - LBound ( Identifier_Array ) + 1 

	Redim Preserve Identifier_Array ( Array_Size )
	Identifier_Array ( Array_Size ) = a_Identifier

	Identifier_Node ( STRUCT_INTERNAL_NODE_VALUE ) = Identifier_Array 

	Insert_Identifier = TRUE

End Function

Function Create_String ( ByRef String_Node , a_String ) 

	String_Node = Array ( TREE_NODE_STRING , a_String , TREE_NODE_STRING )

	Create_String = TRUE

End Function

Function Create_Integer ( ByRef Integer_Node , a_Integer ) 

	Integer_Node = Array ( TREE_NODE_INTEGER , CInt ( a_Integer ) , TREE_NODE_INTEGER )

	Create_Integer = TRUE

End Function

Function Create_Boolean ( ByRef Boolean_Node , a_Boolean ) 

	Boolean_Node = Array ( TREE_NODE_BOOLEAN , CBool ( a_Boolean ) , TREE_NODE_BOOLEAN )

	Create_Boolean = TRUE

End Function

Function Create_Real ( ByRef Real_Node , a_Real ) 

	Real_Node = Array ( TREE_NODE_REAL , CDbl ( a_Real ) , TREE_NODE_REAL )

	Create_Real = TRUE

End Function

Function Create_Null ( ByRef Null_Node ) 

	Null_Node = Array ( TREE_NODE_NULL , "<null>" , TREE_NODE_NULL )

	Create_Null = TRUE

End Function

Function Create_Empty ( ByRef Empty_Node ) 

	Empty_Node = Array ( TREE_NODE_EMPTY , "<empty>" , TREE_NODE_EMPTY )

	Create_Empty = TRUE

End Function

Function Create_Undefined ( ByRef Undefined_Node ) 

	Undefined_Node = Array ( TREE_NODE_UNDEFINED, "<undefined>" , TREE_NODE_UNDEFINED )

	Create_Undefined = TRUE

End Function

Function Evaluate_Expression_UnaryMinus ( ByRef a_Root , ByRef Node , ByRef a_EventObject ) 

	Evaluate_Expression_UnaryMinus = True

	Dim Node_Value
	Dim Node_Type 
	Status = Get_Node_Eval_Type ( Node , Node_Type ) 
	Status = Get_Node_Eval_Value ( Node , Node_Value ) 

	Dim Created_Node

	Select Case Node_Type

		Case TREE_NODE_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_INTEGER ) 

			Status = Set_Node_Eval_Value ( a_Root , -1 * Node_Value ) 

		Case TREE_NODE_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_REAL ) 

			Status = Set_Node_Eval_Value ( a_Root , 1.0 * Node_Value ) 

		Case Else

			Evaluate_Expression_UnaryMinus = False

	End Select

End Function

Function Evaluate_Expression_Not ( ByRef a_Root , ByRef Node , ByRef a_EventObject ) 

	Evaluate_Expression_Not = True

	Dim Node_Value
	Dim Node_Type 
	Status = Get_Node_Eval_Type ( Node , Node_Type ) 
	Status = Get_Node_Eval_Value ( Node , Node_Value ) 

	Dim Created_Node

	Select Case Node_Type

		Case TREE_NODE_BOOLEAN

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , Not ( Node_Value ) ) 

		Case Else

			Evaluate_Expression_Not = False

	End Select

End Function

Function Evaluate_Expression_Upper ( ByRef a_Root , ByRef Node , ByRef a_EventObject ) 

	Evaluate_Expression_Upper = True

	Dim Node_Value
	Dim Node_Type 
	Status = Get_Node_Eval_Type ( Node , Node_Type ) 
	Status = Get_Node_Eval_Value ( Node , Node_Value ) 

	Dim Created_Node

	Select Case Node_Type

		Case TREE_NODE_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_STRING ) 

			Dim UpperString
			UpperString = Node_Value.toUpperCase 
			Status = Set_Node_Eval_Value ( a_Root , UpperString ) 

		Case Else

			Evaluate_Expression_Upper = False

	End Select

End Function

Function Evaluate_Expression_Lower ( ByRef a_Root , ByRef Node , ByRef a_EventObject ) 

	Evaluate_Expression_Lower = True

	Dim Node_Value
	Dim Node_Type 
	Status = Get_Node_Eval_Type ( Node , Node_Type ) 
	Status = Get_Node_Eval_Value ( Node , Node_Value ) 

	Dim Created_Node

	Select Case Node_Type

		Case TREE_NODE_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_STRING ) 

			Dim LowerString
			LowerString = Node_Value.toLowerCase 

			Status = Set_Node_Eval_Value ( a_Root , LowerString ) 

		Case Else

			Evaluate_Expression_Lower = False

	End Select

End Function

Function Evaluate_Expression_Or ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Or = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_BOOLEAN_BOOLEAN

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value Or RightNode_Value ) 

		Case Else

			Evaluate_Expression_Or = False

	End Select

End Function

Function Evaluate_Expression_And ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_And = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_BOOLEAN_BOOLEAN

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value And RightNode_Value ) 

		Case Else

			Evaluate_Expression_And = False

	End Select

End Function

Function Evaluate_Expression_Minus ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Minus = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_INTEGER ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value - RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_REAL ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value - RightNode_Value ) 

		Case Else

			Evaluate_Expression_Minus = False

	End Select

End Function

Function Evaluate_Expression_Plus ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Plus = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_STRING_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_String ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value + RightNode_Value ) 

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_INTEGER ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value + RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_REAL ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value + RightNode_Value ) 

		Case Else

			Evaluate_Expression_Plus = False

	End Select

End Function

Function Evaluate_Expression_Multiply ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Multiply = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_INTEGER ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value * RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_REAL ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value * RightNode_Value ) 

		Case Else

			Evaluate_Expression_Multiply = False

	End Select

End Function

Function Evaluate_Expression_Divide ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Divide = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_INTEGER_INTEGER

			If RightNode_Value <> 0.0 Then

				Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_INTEGER ) 

				Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value / RightNode_Value ) 

			Else

				Evaluate_Expression_Divide = False

			End If

		Case TREE_NODE_REAL_REAL

			If RightNode_Value <> 0.0 Then

				Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_REAL ) 

				Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value / RightNode_Value ) 

			Else

				Evaluate_Expression_Divide = False

			End If

		Case Else

			Evaluate_Expression_Divide = False

	End Select

End Function

Function Evaluate_Expression_Like ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Like = True

End Function

Function Evaluate_Expression_Isa ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Isa = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_UNDEFINED_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , True ) 

		Case Else

			Evaluate_Expression_Isa = False

	End Select

End Function

Function Evaluate_Expression_Equal ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Equal = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_STRING_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value = RightNode_Value ) 

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value = RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value = RightNode_Value ) 

		Case TREE_NODE_NULL_NULL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value = RightNode_Value ) 

		Case Else

			Evaluate_Expression_Equal = False

	End Select

End Function

Function Evaluate_Expression_NotEqual ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_NotEqual = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_STRING_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value <> RightNode_Value ) 

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value <> RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value <> RightNode_Value ) 

		Case TREE_NODE_NULL_NULL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value <> RightNode_Value ) 

		Case Else

			Evaluate_Expression_NotEqual = False

	End Select

End Function

Function Evaluate_Expression_Less ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Less = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_STRING_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value < RightNode_Value ) 

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value < RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value < RightNode_Value ) 

		Case Else

			Evaluate_Expression_Less = False

	End Select

End Function

Function Evaluate_Expression_Greater ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_Greater = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_STRING_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value > RightNode_Value ) 

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value > RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value > RightNode_Value ) 

		Case Else

			Evaluate_Expression_Greater = False

	End Select

End Function

Function Evaluate_Expression_LessEqual ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_LessEqual = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_STRING_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value <= RightNode_Value ) 

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value <= RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value <= RightNode_Value ) 

		Case Else

			Evaluate_Expression_LessEqual = False

	End Select

End Function

Function Evaluate_Expression_GreaterEqual ( ByRef a_Root , ByRef LeftNode , ByRef RightNode , ByRef a_EventObject ) 

	Evaluate_Expression_GreaterEqual = True

	Dim LeftNode_Value
	Dim LeftNode_Type 
	Dim RightNode_Value
	Dim RightNode_Type 

	Status = Get_Node_Eval_Type ( LeftNode , LeftNode_Type ) 
	Status = Get_Node_Eval_Value ( LeftNode , LeftNode_Value ) 
	Status = Get_Node_Eval_Type ( RightNode , RightNode_Type ) 
	Status = Get_Node_Eval_Value ( RightNode , RightNode_Value ) 

	Dim Node_Types
	Node_Types = ( LeftNode_Type * TYPE_FACTOR ) + RightNode_Type

	Dim Created_Node

	Select Case Node_Types

		Case TREE_NODE_STRING_STRING

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value >= RightNode_Value ) 

		Case TREE_NODE_INTEGER_INTEGER

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value >= RightNode_Value ) 

		Case TREE_NODE_REAL_REAL

			Status = Set_Node_Eval_Type ( a_Root , TREE_NODE_BOOLEAN ) 

			Status = Set_Node_Eval_Value ( a_Root , LeftNode_Value >= RightNode_Value ) 

		Case Else

			Evaluate_Expression_GreaterEqual = False

	End Select

End Function

Function Traverse_Tree ( ByRef a_Root , ByRef a_String )

	Dim Status

	If Is_Unary_Node ( a_Root ) Then

		Status = Concatenate_Node ( a_Root , a_String ) 

		Dim Node 

		Status = Get_Left_Node ( a_Root , Node )

		Status = Traverse_Tree ( Node , a_String ) 

	Else 

		If Is_Binary_Node ( a_Root ) Then

			Dim LeftNode 
			Dim RightNode 

			Status = Get_Left_Node ( a_Root , LeftNode )
			Status = Get_Right_Node ( a_Root , RightNode )

			a_String = a_String + "( "

			Status = Traverse_Tree ( LeftNode , a_String ) 

			Status = Concatenate_Node ( a_Root , a_String ) 		

			Status = Traverse_Tree ( RightNode , a_String ) 

			a_String = a_String + " )"

		Else

			Status = Concatenate_Node ( a_Root , a_String )

		End If	

	End If

End Function

Function Traverse_Eval_Tree ( ByRef a_Root , ByRef a_String )

	Dim Status

	If Is_Unary_Node ( a_Root ) Then

		Status = Concatenate_Eval_Node ( a_Root , a_String ) 

		Dim Node 

		Status = Get_Left_Node ( a_Root , Node )

		Status = Traverse_Eval_Tree ( Node , a_String ) 

	Else 

		If Is_Binary_Node ( a_Root ) Then

			Dim LeftNode 
			Dim RightNode 

			Status = Get_Left_Node ( a_Root , LeftNode )
			Status = Get_Right_Node ( a_Root , RightNode )

			a_String = a_String + "( "

			Status = Traverse_Eval_Tree ( LeftNode , a_String ) 

			Status = Concatenate_Eval_Node ( a_Root , a_String ) 		

			Status = Traverse_Eval_Tree ( RightNode , a_String ) 

			a_String = a_String + " )"

		Else

			Status = Concatenate_Eval_Node ( a_Root , a_String )

		End If	

	End If

End Function


Function Type_Internal_Evaluate_Tree ( ByRef a_Root , ByRef a_FailureRoot )

	Type_Internal_Evaluate_Tree = True

	Dim Status

	If Is_Unary_Node ( a_Root ) Then

		Dim Node 

		Status = Get_Left_Node ( a_Root , Node )

		Status = Type_Internal_Evaluate_Tree ( Node , a_FailureRoot ) 

		If Status = True Then

			Dim ResultType

			Status = Validate_Unary_Node ( a_Root , Node , ResultType )

			If Status = True Then

				Status = Set_Node_Eval_Type ( a_Root , ResultType )

			Else

				Type_Internal_Evaluate_Tree = False

				a_FailureRoot = a_Root

				Exit Function

			End If		

		End If

	Else 

		If Is_Binary_Node ( a_Root ) Then

			Dim LeftNode 
			Dim RightNode 

			Status = Get_Left_Node ( a_Root , LeftNode )
			Status = Get_Right_Node ( a_Root , RightNode )

			Status = Type_Internal_Evaluate_Tree ( LeftNode , a_FailureRoot ) 

			If Status = True Then

				Status = Type_Internal_Evaluate_Tree ( RightNode , a_FailureRoot ) 

				If Status = True Then

					Status = Validate_Binary_Node ( a_Root , LeftNode , RightNode , ResultType )

					If Status = True Then

						Status = Set_Node_Eval_Type ( a_Root , ResultType )

					Else

						a_FailureRoot = a_Root

						Type_Internal_Evaluate_Tree = False

						Exit Function

					End If		

				Else

					Exit Function

				End If

			Else
			
				Exit Function 

			End If

		Else

		End If	

	End If

End Function

Function Type_Evaluate_Tree ( ByRef a_Root )

	Dim t_FailureTree 

	Type_Evaluate_Tree = Type_Internal_Evaluate_Tree ( a_Root , t_FailureTree )

	If Type_Evaluate_Tree = False Then

		If Is_Unary_Node ( t_FailureTree ) Then

			Dim t_LeftNode
			Dim t_LeftNodeType
			Dim Status

			Status = Get_Left_Node ( t_Failure_Tree , t_LeftNode ) 
			Status = Get_Node_Eval_Type ( t_LeftNode , t_LeftNodeType ) 

			Output_Node ( t_FailureExpression )
			Output_Node ( t_LeftNode )
			Output_NodeType ( t_LeftNodeType )

		Else

			If Is_Binary_Node ( t_FailureTree ) Then

				Dim t_RightNode
				Dim t_RightNodeType

				Status = Get_Left_Node ( t_FailureTree , t_LeftNode ) 
				Status = Get_Right_Node ( t_FailureTree , t_RightNode ) 
				Status = Get_Node_Eval_Type ( t_LeftNode , t_LeftNodeType ) 
				Status = Get_Node_Eval_Type ( t_RightNode , t_RightNodeType ) 

				Output_Node ( t_FailureTree )
				Output_Node ( t_LeftNode )
				Output_NodeType ( t_LeftNodeType )
				Output_Node ( t_RightNode )
				Output_NodeType ( t_RightNodeType )
			
			Else

			End If 

		End If

		Dim t_FailureExpression
		Status = Traverse_Tree ( t_FailureTree ,t_FailureExpression )

		WScript.Echo t_FailureExpression 

	End If

End Function

Function Generate_Conformant_Expression ( ByRef a_Parent , ByRef a_Root , ByRef a_Contains_Non_Conformant )

	Generate_Conformant_Expression = True

	Dim Status
	Dim ParentType

	Status = Get_Node_Type ( a_Parent , ParentType ) 

	Status = Is_Non_Conformant_Node ( a_Root )

	If Status Then
	
		a_Contains_Non_Conformant = True

	Else

		Dim t_Is_Relational
		t_Is_Relational = Is_Relational ( a_Root )

		If Is_Unary_Node ( a_Root ) Then

			Dim Node 

			Status = Get_Left_Node ( a_Root , Node )

			Generate_Conformant_Expression = Generate_Conformant_Expression ( a_Root , Node , a_Contains_Non_Conformant ) 

			Status = Set_Left_Node ( a_Root , Node ) 

		Else 

			If Is_Binary_Node ( a_Root ) Then

				Dim LeftNode 
				Dim RightNode 

				Status = Get_Left_Node ( a_Root , LeftNode )

				Generate_Conformant_Expression = Generate_Conformant_Expression ( a_Root , LeftNode , a_Contains_Non_Conformant ) 

				Status = Set_Left_Node ( a_Root , LeftNode ) 

				If a_Contains_Non_Conformant = True And t_Is_Relational = True Then

					Dim Boolean_Node

					If ParentType = TREE_NODE_AND Then
	
						Status = Create_Boolean ( Boolean_Node , True )

					Else

						Status = Create_Boolean ( Boolean_Node , False )

					End If

					a_Root = Boolean_Node

					a_Contains_Non_Conformant = False 

				Else

					Status = Get_Right_Node ( a_Root , RightNode )

					Generate_Conformant_Expression = Generate_Conformant_Expression ( a_Root , RightNode , a_Contains_Non_Conformant ) 

					Status = Set_Right_Node ( a_Root , RightNode ) 

					If a_Contains_Non_Conformant = True And t_Is_Relational = True Then

						If ParentType = TREE_NODE_AND Then
		
							Status = Create_Boolean ( Boolean_Node , True )

						Else

							Status = Create_Boolean ( Boolean_Node , False )

						End If

						a_Root = Boolean_Node

					End If

					a_Contains_Non_Conformant = False 

				End If

			Else

			End If	

		End If

	End If

	If Is_Unary_Node ( a_Root ) Then

		Dim Node_Type

		Status = Get_Node_Type ( a_Root , Node_Type ) 

		If Node_Type = TREE_NODE_NOT Then

			Status = Get_Left_Node ( a_Root , Node )
			Status = Get_Node_Type ( Node , Node_Type ) 

			If Node_Type = TREE_NODE_BOOLEAN Then

				Dim Node_Value
				Status = Get_Node_Eval_Value ( Node , Node_Value ) 
	
				If Node_Value = False Then

					Status = Create_Boolean ( Boolean_Node , True )

				Else

					Status = Create_Boolean ( Boolean_Node , False )

				End If

				a_Root = Boolean_Node

			End If

		Else

		End If

	Else

		If Is_Binary_Node ( a_Root ) Then

			Status = Get_Node_Type ( a_Root , Node_Type ) 

			If Node_Type = TREE_NODE_AND Then

				Dim LeftNode_Type
				Dim RightNode_Type

				Status = Get_Left_Node ( a_Root , LeftNode )
				Status = Get_Node_Type ( LeftNode , LeftNode_Type ) 
				Status = Get_Right_Node ( a_Root , RightNode )
				Status = Get_Node_Type ( RightNode , RightNode_Type ) 

				If LeftNode_Type = TREE_NODE_BOOLEAN Then

					Status = Get_Node_Eval_Value ( LeftNode , Node_Value ) 
		
					If Node_Value = False Then

						Status = Create_Boolean ( Boolean_Node , False )

						a_Root = Boolean_Node

					Else

						a_Root = RightNode

					End If


				Else

					If RightNode_Type = TREE_NODE_BOOLEAN Then

						Status = Get_Node_Eval_Value ( RightNode , Node_Value ) 
			
						If Node_Value = False Then

							Status = Create_Boolean ( Boolean_Node , False )
							a_Root = Boolean_Node

						Else

							a_Root = LeftNode

						End If


					End If

				End If

			Else

				If Node_Type = TREE_NODE_OR Then

					Status = Get_Left_Node ( a_Root , LeftNode )
					Status = Get_Node_Type ( LeftNode , LeftNode_Type ) 

					Status = Get_Right_Node ( a_Root , RightNode )
					Status = Get_Node_Type ( RightNode , RightNode_Type ) 

					If LeftNode_Type = TREE_NODE_BOOLEAN Then

						Status = Get_Node_Eval_Value ( LeftNode , Node_Value ) 
			
						If Node_Value = True Then

							Status = Create_Boolean ( Boolean_Node , True )

							a_Root = Boolean_Node

						Else

							a_Root = RightNode

						End If


					Else


						If RightNode_Type = TREE_NODE_BOOLEAN Then

							Status = Get_Node_Eval_Value ( RightNode , Node_Value ) 
				
							If Node_Value = True Then

								Status = Create_Boolean ( Boolean_Node , True )

								a_Root = Boolean_Node

							Else

								a_Root = LeftNode

							End If

						End If

					End If

				End If

			End If

		End If

	End If

End Function

Function Bind_Identifier_Values ( ByRef a_Root , a_EventObject )

	Bind_Identifier_Values = True 

	Dim Status

	If Is_Unary_Node ( a_Root ) Then

		Dim Node 

		Status = Get_Left_Node ( a_Root , Node )

		Bind_Identifier_Values = Bind_Identifier_Values ( Node , a_EventObject ) 

		Status = Set_Left_Node ( a_Root , Node )

	Else 

		If Is_Binary_Node ( a_Root ) Then

			Dim LeftNode 
			Dim RightNode 

			Status = Get_Left_Node ( a_Root , LeftNode )
			Status = Get_Right_Node ( a_Root , RightNode )

			Bind_Identifier_Values = Bind_Identifier_Values ( LeftNode , a_EventObject ) 

			Status = Set_Left_Node ( a_Root , LeftNode )

			If Bind_Identifier_Values = True Then

				Bind_Identifier_Values = Bind_Identifier_Values ( RightNode , a_EventObject ) 

				Status = Set_Right_Node ( a_Root , RightNode )

			End If

		Else

			Dim a_Root_Type

			Status = Get_Node_Type ( a_Root , a_Root_Type ) 

			If a_Root_Type = TREE_NODE_IDENTIFIER Then

				Bind_Identifier_Values = Resolve_Identifier ( a_Root , a_EventObject )

			End If
			
		End If	

	End If

End Function

Function Evaluate_Expression ( ByRef a_Root , a_EventObject )

	Evaluate_Expression = True 

	Dim Status

	If Is_Unary_Node ( a_Root ) Then

		Dim Node 

		Status = Get_Left_Node ( a_Root , Node )

		Evaluate_Expression = Evaluate_Expression ( Node , a_EventObject ) 

		Status = Set_Left_Node ( a_Root , Node )

		Dim Node_Type
		Status = Get_Node_Type ( a_Root , Node_Type ) 

		Select Case Node_Type 

			Case TREE_NODE_UNARYMINUS

				Evaluate_Expression = Evaluate_Expression_UnaryMinus ( a_Root , Node , a_EventObject ) 

			Case TREE_NODE_NOT

				Evaluate_Expression = Evaluate_Expression_Not ( a_Root , Node , a_EventObject ) 

			Case Else

		End Select

	Else 

		If Is_Binary_Node ( a_Root ) Then

			Dim LeftNode 
			Dim RightNode 

			Status = Get_Left_Node ( a_Root , LeftNode )
			Status = Get_Right_Node ( a_Root , RightNode )

			Evaluate_Expression = Evaluate_Expression ( LeftNode , a_EventObject ) 

			Status = Set_Left_Node ( a_Root , LeftNode )

			If Evaluate_Expression = True Then

				Evaluate_Expression = Evaluate_Expression ( RightNode , a_EventObject ) 

				Status = Set_Right_Node ( a_Root , RightNode )

				Status = Get_Node_Type ( a_Root , Node_Type ) 

				Select Case Node_Type 

					Case TREE_NODE_OR

						Evaluate_Expression = Evaluate_Expression_Or ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_AND

						Evaluate_Expression = Evaluate_Expression_And ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_MINUS

						Evaluate_Expression = Evaluate_Expression_Minus ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_PLUS

						Evaluate_Expression = Evaluate_Expression_Plus ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_MULTIPLY

						Evaluate_Expression = Evaluate_Expression_Multiply ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_DIVIDE

						Evaluate_Expression = Evaluate_Expression_Divide ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_LIKE

						Evaluate_Expression = Evaluate_Expression_Like ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_UPPER

						Evaluate_Expression = Evaluate_Expression_Upper ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_LOWER

						Evaluate_Expression = Evaluate_Expression_Lower ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_ISA

						Evaluate_Expression = Evaluate_Expression_Isa ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_EQUAL

						Evaluate_Expression = Evaluate_Expression_Equal ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_NOTEQUAL

						Evaluate_Expression = Evaluate_Expression_NotEqual ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_LESS

						Evaluate_Expression = Evaluate_Expression_Less ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_GREATER

						Evaluate_Expression = Evaluate_Expression_Greater ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_LESSEQUAL

						Evaluate_Expression = Evaluate_Expression_LessEqual ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case TREE_NODE_GREATEREQUAL

						Evaluate_Expression = Evaluate_Expression_GreaterEqual ( a_Root , LeftNode , RightNode , a_EventObject ) 

					Case Else


				End Select

			End If

		Else

		End If	

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		LexicalAnalyser_Next
'
'	Description:
	'
'		Lexical analyse input stream
'
'	Input Arguments:
'
'		a_Dfa - finite machine
'		a_Stream - string to parse
'		a_Pos - position in stream
'
'	Output Arguments:
'
'		a_Token - tokenised string parsed
'		a_NextPosition - position in stream to scan next
'		a_TokenText - string parsed
'
'	Return Value:
'	
'		Status
'---------------------------------------------------------


Function LexicalAnalyser_NextToken ( a_Dfa , a_Stream , a_Position , ByRef a_Token , ByRef a_NextPosition , ByRef a_TokenText )

	LexicalAnalyser_NextToken = Error_Success 

	Dim State
    State = 0

    Dim Read 
	Read = TRUE

	Dim EndOfFile
	EndOfFile = FALSE 

    Dim Current

	Dim CurrentLine
	CurrentLine = 0

	a_Token = 0
	a_TokenText = ""
	a_NextPosition = a_Position 

' Generic DFA driver based on the table specified
' in the constructor.

	Dim DFA_Definition_Size
	DFA_Definition_Size = UBound ( DFA_Definition ) - LBound ( DFA_Definition ) + 1

    While True

		Dim Dfa_ElementIndex 
		Dfa_ElementIndex = State * 5

		Dim First 
		Dim Last
		Dim GotoState
		Dim ReturnToken
		Dim Instruction

		First = a_Dfa ( Dfa_ElementIndex ) 
		Last = a_Dfa ( Dfa_ElementIndex + 1 ) 
		GotoState = a_Dfa ( Dfa_ElementIndex + 2 ) 
		ReturnToken = a_Dfa ( Dfa_ElementIndex + 3 )
		Instruction = a_Dfa ( Dfa_ElementIndex + 4 ) 

		If g_Debug And 8 Then
			WScript.Echo a_NextPosition , State , First , Last , GotoState , ReturnToken , Instruction
		End If

        If Read Then

			If EndOfFile Then

				LexicalAnalyser_NextToken = Error_UnexpectedEof
				
				Exit Function

			End If

            If a_NextPosition > Len ( a_Stream )  Then

				Current = 0

				EndOfFile = TRUE 

			Else

				Current = Asc ( Mid ( a_Stream , a_NextPosition , 1 ) )

			End If

		End If

        Read = FALSE

        Dim Match 
		Match = FALSE

        If First = GLEX_ANY Then

            Match = TRUE
		
        Else 
			If Last = GLEX_EMPTY Then

				If Current = First Then

					Match = TRUE

	            Else 
					If ( Instruction And GLEX_NOT ) And ( Not ( Current = First ) ) Then
                
						Match = TRUE

					End If
				End If
			Else

				If ( Instruction And GLEX_NOT ) And ( Not ( ( Current >= First ) And ( Current <= Last ) ) ) Then

					Match = TRUE

				Else 

					If ( Current >= First ) And ( Current <= Last ) Then

						Match = TRUE

					End If
				End If
			End If
        End If

        If Match Then

            If Instruction And GLEX_ACCEPT Then

' Expand the current buffer, if required.

                a_TokenText = a_TokenText + ChrW ( Current ) 

                Read = TRUE

            End If

            If Instruction And GLEX_CONSUME Then

               Read = TRUE

			End If

            If Instruction And GLEX_PUSHBACK Then

                Read = TRUE

                a_NextPosition = a_NextPosition - 1

            End If

            If Instruction And GLEX_LINEFEED Then

                CurrentLine = CurrentLine + 1

			End If

			a_NextPosition = a_NextPosition + 1

            If ReturnToken Or ( Instruction And GLEX_RETURN ) Then

                a_Token = ReturnToken

				Exit Function

			End If

            State = GotoState

        Else

' If here, there was no match.

	            State = State + 1 
		End If

	Wend 

    LexicalAnalyser_NextToken = Error_ImpossibleState 

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_NextToken
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_NextToken ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText )

	Dim Status 

	Status = LexicalAnalyser_NextToken ( DFA_Definition , a_Stream , a_Position , a_CurrentToken , a_NextPosition , a_CurrentTokenText )

    If Status <> Error_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Lex Error"
		End If 

		Parser_NextToken = Parser_Lexical_Error

		Exit Function

	End If

	If a_CurrentToken = SQL_1_TOK_ERROR Then

		If g_Debug And 1 Then
			WScript.Echo "Token Error"
		End If

		Parser_NextToken = Parser_Lexical_Error

		Exit Function

	End If

    If a_CurrentToken = SQL_1_TOK_EOF Then

		If g_Debug And 4 Then
			WScript.Echo "End Of File"
		End If

        a_CurrentTokenText = "<end of file>"

	End If

' Keyword check.

    If a_CurrentToken = SQL_1_TOK_IDENT Then

   		Select Case LCase ( a_CurrentTokenText )

			   Case "select"    
								a_CurrentToken = SQL_1_TOK_SELECT
			   Case "from"		
								a_CurrentToken = SQL_1_TOK_FROM
			   Case "where"		
								a_CurrentToken = SQL_1_TOK_WHERE
			   Case "within"
								a_CurrentToken = SQL_1_TOK_WITHIN
			   Case "like"		
								a_CurrentToken = SQL_1_TOK_LIKE
			   Case "or"		
								a_CurrentToken = SQL_1_TOK_OR
			   Case "and"		
								a_CurrentToken = SQL_1_TOK_AND
			   Case "not"		
								a_CurrentToken = SQL_1_TOK_NOT
			   Case "isa"		
								a_CurrentToken = SQL_1_TOK_ISA
			   Case "null"		
								a_CurrentToken = SQL_1_TOK_NULL
			   Case "true"		
								a_CurrentToken = SQL_1_TOK_TRUE
								a_CurrentTokenText = "65535"
			   Case "false"		
								a_CurrentToken = SQL_1_TOK_FALSE 
								a_CurrentTokenText = "0"
			   Case Else

		End Select

	End If

	If g_Debug And 1 Then
		WScript.Echo a_CurrentToken , a_CurrentTokenText 
	End If

    Parser_NextToken = Parser_Success

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_NextToken
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Property_Name ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText )

	Parser_Property_Name = Parser_Success

    If a_CurrentToken = SQL_1_TOK_ASTERISK Then

	Else

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_PropList2
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_PropList2 ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText )

	Parser_PropList2 = Parser_Syntax_Error 

	Dim t_Position 
	t_Position = a_Position

    If a_CurrentToken = SQL_1_TOK_COMMA Then

		Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

		t_Position = a_NextPosition 

		If Status = Parser_Success Then

			If g_Debug And 4 Then
				WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
			End If

			Parser_PropList2 = Parser_PropList ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

			t_Position = a_NextPosition

		Else

			If g_Debug And 1 Then
				WScript.Echo "Parse Error" , Status
			End If

			Parser_PropList2 = Status 

			Exit Function

		End If
	Else

		Parser_PropList2 = Parser_Success

		Exit Function

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_PropList
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_PropList ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText )

	Parser_PropList = Parser_Syntax_Error 

	Dim t_Position 
	t_Position = a_Position

    If ( a_CurrentToken <> SQL_1_TOK_ASTERISK ) And ( a_CurrentToken <> SQL_1_TOK_IDENT ) Then

        Parser_PropList = Parser_Syntax_Error 

		Exit Function

	End If

	Dim Status
	Status = Parser_Property_Name ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

    If Status <> Parser_Success Then

        Parser_PropList = Status 

		Exit Function

	End If

	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

	    Parser_PropList = Parser_PropList2 ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

		t_Position = a_NextPosition

	Else

		If g_Debug And 1 Then
			WScript.Echo "Parse Error" , Status
		End If

		Parser_PropList = Status 

		Exit Function

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Class_Name
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Class_Name ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText )

	Parser_Class_Name = Parser_Syntax_Error

	Dim t_Position 
	t_Position = a_Position

	Dim Status

	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

		If a_CurrentToken = SQL_1_TOK_IDENT Then

			Parser_Class_Name = Parser_Success

		Else

			If g_Debug And 1 Then
				WScript.Echo "Parse Error" , Status
			End If

			Parser_Class_Name = Parser_Syntax_Error

			Exit Function

		End If

	Else

		If g_Debug And 1 Then
			WScript.Echo "Parse Error" , Status
		End If

		Parser_Class_Name = Parser_Syntax_Error

		Exit Function

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Within
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Within ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText )

	Parser_Within = Parser_Syntax_Error

	Dim t_Position 
	t_Position = a_Position

	Dim Status

	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

		If a_CurrentToken <> SQL_1_TOK_WITHIN Then

			If g_Debug And 1 Then
				WScript.Echo "Parse Error" , Status
			End If

			Parser_Within = Parser_Syntax_Error

			Exit Function

		End If

	End If

	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

		If ( a_CurrentToken = SQL_1_TOK_INT ) Or ( a_CurrentToken = SQL_1_TOK_REAL ) Then

			Parser_Within = Parser_Success

		Else

			If g_Debug And 1 Then
				WScript.Echo "Within Type Parse Error" , Status
			End If

			Parser_Within = Parser_Syntax_Error

			Exit Function

		End If

	Else

		If g_Debug And 1 Then
			WScript.Echo "Parse Error" , Status
		End If

		Parser_Within = Parser_Syntax_Error

		Exit Function

	End If

End Function

Function Parser_IdentifierList ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree , ByRef a_Identifier )

	Parser_IdentifierList = Parser_Success

	If g_Debug And 2 Then
		WScript.Echo "Parser_IdentifierList"
	End If

	Dim t_PushPosition 
	t_PushPosition = a_Position 

	Dim t_Position
	t_Position = a_Position

	Dim Status
	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If a_CurrentToken = SQL_1_TOK_ISA Then

			Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

			t_Position = a_NextPosition 

			If Status = Parser_Success Then

				If a_CurrentToken <> SQL_1_TOK_QSTRING Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Factor Parse Error" , Status
					End If

					Parser_IdentifierList = Parser_Syntax_Error

					Exit Function

				Else

					Dim Isa_Node
					Status = Create_Isa ( Isa_Node ) 

					Dim RightString_Node
					Status = Create_String ( RightString_Node , a_CurrentTokenText )

					Status = Set_Left_Node ( Isa_Node , a_Identifier ) 
					Status = Set_Right_Node ( Isa_Node , RightString_Node ) 

					a_ParseTree = Isa_Node 

				End If

			Else

				If g_Debug And 1 Then
					WScript.Echo "Parser_Factor Parse Error" , Status
				End If

				Parser_IdentifierList = Status

				Exit Function

			End If
		Else

			If a_CurrentToken = SQL_1_TOK_DOT Then

				Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

				t_Position = a_NextPosition 

				If Status = Parser_Success Then

					Status = Insert_Identifier ( a_Identifier , a_CurrentTokenText ) 

					Status = Parser_IdentifierList ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree , a_Identifier )

					t_Position = a_NextPosition 

				Else

					If g_Debug And 1 Then
						WScript.Echo "Parser_Factor Parse Error" , Status
					End If

					Parser_IdentifierList = Status

					Exit Function

				End If				
			Else

				a_ParseTree = a_Identifier

				a_NextPosition = t_PushPosition 

			End If
		
		End If

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Factor
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Factor ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Factor"
	End If

	Parser_Factor = Parser_Success

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

    If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

   		Select Case a_CurrentToken

			Case SQL_1_TOK_IDENT

				Select Case LCase ( a_CurrentTokenText )

					Case "like"

						Dim Like_Node
						Status = Create_Like ( Like_Node ) 

						Status = Set_Left_Node ( Like_Node , a_ParseTree ) 

						a_ParseTree = Like_Node 

						Dim t_RightNode 

						Status = Parser_Expression ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

						t_Position = a_NextPosition 

						If Status <> Parser_Success Then

							If g_Debug And 1 Then
								WScript.Echo "Parser_Factor Parse Error" , Status
							End If

							Parser_Factor = Parser_Syntax_Error

							Exit Function

						Else

							Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

							Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

							t_Position = a_NextPosition 

								If Status = Parser_Success Then

								If a_CurrentToken <> SQL_1_TOK_CLOSE_PAREN Then

									If g_Debug And 1 Then
										WScript.Echo "Parser_Factor Parse Error" , Status
									End If

									Parser_Factor = Parser_Syntax_Error

									Exit Function

								End If

							End If

						End If
					
					Case "lower"

						Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

						t_Position = a_NextPosition 

						If Status = Parser_Success Then

							If a_CurrentToken <> SQL_1_TOK_OPEN_PAREN Then

								If g_Debug And 1 Then
									WScript.Echo "Parser_Factor Parse Error" , Status
								End If

								Parser_Factor = Parser_Syntax_Error

								Exit Function

							Else

								Dim Lower_Node
								Status = Create_Lower ( Lower_Node ) 

								Status = Set_Left_Node ( Lower_Node , a_ParseTree ) 

								a_ParseTree = Lower_Node 

								Status = Parser_Expression ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

								t_Position = a_NextPosition 

								If Status <> Parser_Success Then

									If g_Debug And 1 Then
										WScript.Echo "Parser_Factor Parse Error" , Status
									End If

									Parser_Factor = Parser_Syntax_Error

									Exit Function

								Else

									Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

									Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

									t_Position = a_NextPosition 

									If Status = Parser_Success Then

										If a_CurrentToken <> SQL_1_TOK_CLOSE_PAREN Then

											If g_Debug And 1 Then
												WScript.Echo "Parser_Factor Parse Error" , Status
											End If

											Parser_Factor = Parser_Syntax_Error

											Exit Function

										End If

									End If

								End If

							End If

						Else

							If g_Debug And 1 Then
								WScript.Echo "Parser_Factor Parse Error" , Status
							End If

							Parser_Factor = Parser_Syntax_Error

							Exit Function

						End If

					Case "upper"

						Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

						t_Position = a_NextPosition 

						If Status = Parser_Success Then

							If a_CurrentToken <> SQL_1_TOK_OPEN_PAREN Then

								If g_Debug And 1 Then
									WScript.Echo "Parser_Factor Parse Error" , Status
								End If

								Parser_Factor = Parser_Syntax_Error

								Exit Function

							Else

								Dim Upper_Node
								Status = Create_Upper ( Upper_Node ) 

								Status = Set_Left_Node ( Upper_Node , a_ParseTree ) 

								a_ParseTree = Upper_Node 

								Status = Parser_Expression ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

								t_Position = a_NextPosition 

								If Status <> Parser_Success Then

									If g_Debug And 1 Then
										WScript.Echo "Parser_Factor Parse Error" , Status
									End If

									Parser_Factor = Parser_Syntax_Error

									Exit Function

								Else

									Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

									Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

									t_Position = a_NextPosition 

									If Status = Parser_Success Then

										If a_CurrentToken <> SQL_1_TOK_CLOSE_PAREN Then

											If g_Debug And 1 Then
												WScript.Echo "Parser_Factor Parse Error" , Status
											End If

											Parser_Factor = Parser_Syntax_Error

											Exit Function

										End If

									End If

								End If

							End If

						Else

							If g_Debug And 1 Then
								WScript.Echo "Parser_Factor Parse Error" , Status
							End If

							Parser_Factor = Parser_Syntax_Error

							Exit Function

						End If

					Case Else 

						Dim t_Identifier

						Status = Create_Identifier ( t_Identifier , a_CurrentTokenText ) 

						Status = Parser_IdentifierList ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree , t_Identifier )

						t_Position = a_NextPosition 

						If Status = Parser_Success Then


						Else

							If g_Debug And 1 Then
								WScript.Echo "Parser_Factor Parse Error" , Status
							End If

							Parser_Factor = Parser_Syntax_Error

							Exit Function

						End If

				End Select

				Parser_Factor = Parser_Success

			Case SQL_1_TOK_QSTRING

				Status = Create_String ( a_ParseTree , a_CurrentTokenText ) 

				Parser_Factor = Parser_Success

			Case SQL_1_TOK_INT

				Status = Create_Integer ( a_ParseTree , a_CurrentTokenText ) 

				Parser_Factor = Parser_Success

			Case SQL_1_TOK_REAL

				Status = Create_Real ( a_ParseTree , a_CurrentTokenText ) 

				Parser_Factor = Parser_Success

			Case SQL_1_TOK_CHAR

				Parser_Factor = Parser_Success

			Case SQL_1_TOK_BOOL

				Status = Create_Boolean ( a_ParseTree , a_CurrentTokenText ) 

				Parser_Factor = Parser_Success

			Case SQL_1_TOK_OPEN_PAREN

				Status = Parser_Expression ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

				t_Position = a_NextPosition 
	
				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Factor Parse Error" , Status
					End If

					Parser_Factor = Status

					Exit Function

				Else

					Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

					t_Position = a_NextPosition 

					If Status = Parser_Success Then

						If a_CurrentToken <> SQL_1_TOK_CLOSE_PAREN Then

							If g_Debug And 1 Then
								WScript.Echo "Parser_Factor Parse Error" , Status
							End If

							Parser_Factor = Parser_Syntax_Error

							Exit Function

						End If

					End If

				End If

			Case SQL_1_TOK_NOT

				Dim Not_Node
				Status = Create_Not ( Not_Node ) 

				a_ParseTree = Not_Node 

				Dim t_Node 

				Status = Parser_Expression ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_Node )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Factor Parse Error" , Status
					End If

					Parser_Factor = Status

					Exit Function

				Else

					Status = Set_Left_Node ( Not_Node , t_Node ) 

				End If

			Case SQL_1_TOK_MINUS

				Dim UnaryMinus_Node
				Status = Create_UnaryMinus ( UnaryMinus_Node ) 

				a_ParseTree = UnaryMinus_Node 

				Status = Parser_Expression ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_Node )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Factor Parse Error" , Status
					End If

					Parser_Factor = Status

					Exit Function

				Else

					Status = Set_Left_Node ( UnaryMinus_Node , t_Node ) 

				End If

			Case Else

		End Select

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Term_
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Term_ ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 4 Then
		WScript.Echo "Parser_Term_"
	end If

	Parser_Term_ = Parser_Syntax_Error

	Dim t_PushPosition 
	t_PushPosition = a_Position

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

    If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

   		Select Case a_CurrentToken

			Case SQL_1_TOK_ASTERISK

				Dim Multiply_Node
				Status = Create_Multiply ( Multiply_Node ) 

				Status = Set_Left_Node ( Multiply_Node , a_ParseTree ) 

				a_ParseTree = Multiply_Node 

				Dim t_RightNode 

				Status = Parser_Factor ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Term Parse Error" , Status
					End If

					Parser_Term_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Term_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Term_ Parse Error" , Status
						End If

						Parser_Term_ = Status

						Exit Function

					Else

						Parser_Term_ = Parser_Success
				
					End If
					
				End If

			Case SQL_1_TOK_DIVIDE

				Dim Divide_Node
				Status = Create_Divide ( Divide_Node ) 

				Status = Set_Left_Node ( Divide_Node , a_ParseTree ) 

				a_ParseTree = Divide_Node 

				Status = Parser_Factor ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Term Parse Error" , Status
					End If

					Parser_Term_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Term_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Term_ Parse Error" , Status
						End If

						Parser_Term_ = Status

						Exit Function

					Else

						Parser_Term_ = Parser_Success
				
					End If
					
				End If
					
			Case Else

				a_NextPosition = t_PushPosition 

				Parser_Term_ = Parser_Success

		End Select

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Term
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Term ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Term"
	End If

	Dim t_Position 
	t_Position = a_Position

	Dim Status

	Status = Parser_Factor ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Parser_Term Parse Error" , Status
		End If

		Parser_Term = Status

		Exit Function

	Else

		Status = Parser_Term_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

		t_Position = a_NextPosition 

		If Status <> Parser_Success Then

			If g_Debug And 1 Then
				WScript.Echo "Parser_Term Parse Error" , Status
			End If

			Parser_Term = Status

			Exit Function
			
		End If
		
	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Relation_
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Relation_ ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Relation_"
	End If

	Parser_Relation_ = Parser_Syntax_Error

	Dim t_PushPosition 
	t_PushPosition = a_Position

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

    If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

   		Select Case a_CurrentToken

			Case SQL_1_TOK_PLUS

				Dim Plus_Node
				Status = Create_Plus ( Plus_Node ) 

				Status = Set_Left_Node ( Plus_Node , a_ParseTree ) 

				a_ParseTree = Plus_Node 

				Dim t_RightNode 

				Status = Parser_Term ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Relation Parse Error" , Status
					End If

					Parser_Relation_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Relation_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Relation_ Parse Error" , Status
						End If

						Parser_Relation_ = Status

						Exit Function

					Else

						Parser_Relation_ = Parser_Success
				
					End If
					
				End If

			Case SQL_1_TOK_MINUS

				Dim Minus_Node
				Status = Create_Minus ( Minus_Node ) 

				Status = Set_Left_Node ( Minus_Node , a_ParseTree ) 

				a_ParseTree = Minus_Node 

				Status = Parser_Term ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Relation Parse Error" , Status
					End If

					Parser_Relation_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Relation_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Relation_ Parse Error" , Status
						End If

						Parser_Relation_ = Status

						Exit Function

					Else

						Parser_Relation_ = Parser_Success
				
					End If
					
				End If
					
			Case Else

				a_NextPosition = t_PushPosition 

				Parser_Relation_ = Parser_Success

		End Select

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Relation
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Relation ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Relation"
	End If

	Dim t_Position 
	t_Position = a_Position

	Dim Status

	Status = Parser_Term ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Parser_Relation Parse Error" , Status
		End If

		Parser_Relation = Status

		Exit Function

	Else

		Status = Parser_Relation_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

		t_Position = a_NextPosition 

		If Status <> Parser_Success Then

			If g_Debug And 1 Then
				WScript.Echo "Parser_Relation Parse Error" , Status
			End If

			Parser_Relation = Status

			Exit Function
			
		End If
		
	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Logical_
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Logical_ ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Logical_"
	End If

	Parser_Logical_ = Parser_Syntax_Error

	Dim t_PushPosition 
	t_PushPosition = a_Position

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

    If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

   		Select Case a_CurrentToken

			Case SQL_1_TOK_LE

				Dim LessEqual_Node
				Status = Create_LessEqual ( LessEqual_Node ) 

				Status = Set_Left_Node ( LessEqual_Node , a_ParseTree ) 

				a_ParseTree = LessEqual_Node 

				Dim t_RightNode 

				Status = Parser_Relation ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Logical Parse Error" , Status
					End If

					Parser_Logical_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Logical_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Logical_ Parse Error" , Status
						End If

						Parser_Logical_ = Status

						Exit Function

					Else

						Parser_Logical_ = Parser_Success
				
					End If
					
				End If

			Case SQL_1_TOK_LT

				Dim Less_Node
				Status = Create_Less ( Less_Node ) 

				Status = Set_Left_Node ( Less_Node , a_ParseTree ) 

				a_ParseTree = Less_Node 

				Status = Parser_Relation ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Logical Parse Error" , Status
					End If

					Parser_Logical_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Logical_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Logical_ Parse Error" , Status
						End If

						Parser_Logical_ = Status

						Exit Function

					Else

						Parser_Logical_ = Parser_Success
				
					End If
					
				End If

			Case SQL_1_TOK_GE

				Dim GreaterEqual_Node
				Status = Create_GreaterEqual ( GreaterEqual_Node ) 

				Status = Set_Left_Node ( GreaterEqual_Node , a_ParseTree ) 

				a_ParseTree = GreaterEqual_Node 

				Status = Parser_Relation ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Logical Parse Error" , Status
					End If

					Parser_Logical_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Logical_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Logical_ Parse Error" , Status
						End If

						Parser_Logical_ = Status

						Exit Function

					Else

						Parser_Logical_ = Parser_Success
				
					End If
					
				End If

			Case SQL_1_TOK_GT

				Dim Greater_Node
				Status = Create_Greater ( Greater_Node ) 

				Status = Set_Left_Node ( Greater_Node , a_ParseTree ) 

				a_ParseTree = Greater_Node 

				Status = Parser_Relation ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Logical Parse Error" , Status
					End If

					Parser_Logical_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Logical_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Logical_ Parse Error" , Status
						End If

						Parser_Logical_ = Status

						Exit Function

					Else

						Parser_Logical_ = Parser_Success
				
					End If
					
				End If

			Case SQL_1_TOK_EQ

				Dim Equal_Node
				Status = Create_Equal ( Equal_Node ) 

				Status = Set_Left_Node ( Equal_Node , a_ParseTree ) 

				a_ParseTree = Equal_Node 

				Status = Parser_Relation ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Logical Parse Error" , Status
					End If

					Parser_Logical_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Logical_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Logical_ Parse Error" , Status
						End If

						Parser_Logical_ = Status

						Exit Function

					Else

						Parser_Logical_ = Parser_Success
				
					End If
					
				End If

			Case SQL_1_TOK_NE

				Dim NotEqual_Node

				Status = Create_NotEqual ( NotEqual_Node ) 

				Status = Set_Left_Node ( NotEqual_Node , a_ParseTree ) 

				a_ParseTree = NotEqual_Node 

				Status = Parser_Relation ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Logical Parse Error" , Status
					End If

					Parser_Logical_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Logical_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Logical_ Parse Error" , Status
						End If

						Parser_Logical_ = Status

						Exit Function

					Else

						Parser_Logical_ = Parser_Success
				
					End If
					
				End If

			Case Else

				a_NextPosition = t_PushPosition 

				Parser_Logical_ = Parser_Success

		End Select

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Logical
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Logical ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Logical"
	End If

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_Relation ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Parser_Logical Parse Error" , Status
		End If

		Parser_Logical = Status

		Exit Function

	Else

		Status = Parser_Logical_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

		t_Position = a_NextPosition 

		If Status <> Parser_Success Then

			If g_Debug And 1 Then
				WScript.Echo "Parser_Logical Parse Error" , Status
			End If

			Parser_Logical = Status

			Exit Function
			
		End If
		
	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_And_
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_And_ ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_And_"
	End If

	Parser_And_ = Parser_Syntax_Error

	Dim t_PushPosition 
	t_PushPosition = a_Position

	Dim t_Position 
	t_Position = a_Position

	Dim Status

	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

    If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

   		Select Case a_CurrentToken

			Case SQL_1_TOK_AND

				Dim And_Node
				Status = Create_And ( And_Node ) 

				Status = Set_Left_Node ( And_Node , a_ParseTree ) 

				a_ParseTree = And_Node 

				Dim t_RightNode 

				Status = Parser_Logical ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Factor Parse Error" , Status
					End If

					Parser_And_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_And_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Factor Parse Error" , Status
						End If

						Parser_And_ = Status

						Exit Function

					Else

						Parser_And_ = Parser_Success
				
					End If
					
				End If
					
			Case Else

				a_NextPosition = t_PushPosition 

				Parser_And_ = Parser_Success

		End Select

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_And
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_And ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_And"
	End If

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_Logical ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Parser_And Parse Error" , Status
		End If

		Parser_And = Status

		Exit Function

	Else

		Status = Parser_And_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

		t_Position = a_NextPosition 

		If Status <> Parser_Success Then

			If g_Debug And 1 Then
				WScript.Echo "Parser_And Parse Error" , Status
			End If

			Parser_And = Status

			Exit Function
			
		End If
		
	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Expression_
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Expression_ ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Expression_"
	End If

	Parser_Expression_ = Parser_Syntax_Error

	Dim t_PushPosition 
	t_PushPosition = a_Position

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

    If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

   		Select Case a_CurrentToken

			Case SQL_1_TOK_OR

				Dim Or_Node
				Status = Create_Or ( Or_Node ) 

				Status = Set_Left_Node ( Or_Node , a_ParseTree ) 

				a_ParseTree = Or_Node 

				Dim t_RightNode 

				Status = Parser_And ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , t_RightNode )

				t_Position = a_NextPosition 

				If Status <> Parser_Success Then

					If g_Debug And 1 Then
						WScript.Echo "Parser_Factor Parse Error" , Status
					End If

					Parser_Expression_ = Status

					Exit Function

				Else

					Status = Set_Right_Node ( a_ParseTree , t_RightNode ) 

					Status = Parser_Expression_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

					t_Position = a_NextPosition 

					If Status <> Parser_Success Then

						If g_Debug And 1 Then
							WScript.Echo "Parser_Factor Parse Error" , Status
						End If

						Parser_Expression_ = Status

						Exit Function

					Else

						Parser_Expression_ = Parser_Success
				
					End If
					
				End If
					
			Case Else

				a_NextPosition = t_PushPosition 

				Parser_Expression_ = Parser_Success

		End Select

	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Expression
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Expression ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	If g_Debug And 2 Then
		WScript.Echo "Parser_Expression"
	End If

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_And ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Parser_Expression Parse Error" , Status
		End If

		Parser_Expression = Status

		Exit Function

	Else

		Status = Parser_Expression_ ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

		t_Position = a_NextPosition 

		If Status <> Parser_Success Then

			If g_Debug And 1 Then
				WScript.Echo "Parser_Expression Parse Error" , Status
			End If

			Parser_Expression = Status

			Exit Function
			
		End If
		
	End If

End Function

'---------------------------------------------------------
'
'	Function:
'
'		Parser_Where
'
'	Description:
'
'		Parse query language extensions
	'
'	Input Arguments:
'
'		a_Dfa 
'		a_Stream  
'		a_Position
'
'	Output Arguments:
'
'		ByRef a_NextPosition 
'		ByRef a_CurrentToken 
'		ByRef a_CurrentTokenText 
'
'	Return Value:
'	
'		Status 
'---------------------------------------------------------

Function Parser_Where ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_CurrentToken , ByRef a_CurrentTokenText , ByRef a_ParseTree )

	Parser_Where = Parser_Syntax_Error

	Dim t_Position 
	t_Position = a_Position

	Dim Status
	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , a_CurrentToken , a_CurrentTokenText
		End If

		If a_CurrentToken = SQL_1_TOK_EOF Then

			Parser_Where = Parser_Syntax_Success

		Else

			If a_CurrentToken = SQL_1_TOK_WHERE Then

				Status = Parser_Expression ( a_Dfa , a_Stream , t_Position , a_NextPosition , a_CurrentToken , a_CurrentTokenText , a_ParseTree )

				t_Position = a_NextPosition 

				If Status = Parser_Success Then

					If a_CurrentToken <> SQL_1_TOK_EOF Then

						Parser_Where = Parser_Syntax_Error

						Exit Function

					End If
					
				Else

					If g_Debug And 1 Then
						WScript.Echo "Parser_Expression Parse Error" , Status
					End If

					Parser_Where = Status

					Exit Function
					
				End If

			Else

				If g_Debug And 1 Then
					WScript.Echo "Parse Error" , Status
				End If

				Parser_Where = Parser_Syntax_Error

				Exit Function

			End If
		End If

	End If

	Parser_Where = Parser_Success

End Function

'---------------------------------------------------------
'
'	Function:
'
'		ParseQuery
'
'	Description:
'
'		Parse query language extensions
'
'	Input Arguments:
	'
'		a_Query	- Query string to parse
'
'	Output Arguments:
'
'		None
'
'	Return Value:
'	
'		None
'---------------------------------------------------------

Function Parser_Select ( a_Dfa , a_Stream , a_Position , ByRef a_NextPosition , ByRef a_ParseTree , ByRef a_WhereExpressionPosition )

	Parser_Select = Parser_Syntax_Error 

	Dim t_CurrentToken 
	Dim t_CurrentTokenText 

	Dim t_Position 
	t_Position = a_Position

	Dim Status

	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , t_CurrentToken , t_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo Status , a_NextPosition , t_CurrentToken , t_CurrentTokenText
		End If

		If t_CurrentToken <> SQL_1_TOK_SELECT Then

			Parser_Select = Parser_Syntax_Error

			Exit Function

		End If

	Else

		If g_Debug And 1 Then
			WScript.Echo "Parse Error" , Status
		End If

		Parser_Select = Parser_Syntax_Error

		Exit Function

	End If

	Status = Parser_NextToken ( a_Dfa , a_Stream , t_Position , a_NextPosition , t_CurrentToken , t_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status = Parser_Success Then

		If g_Debug And 4 Then
			WScript.Echo "proplist" , Status , a_NextPosition , t_CurrentToken , t_CurrentTokenText
		End If

		Status = Parser_PropList ( a_Dfa , a_Stream , t_Position , a_NextPosition , t_CurrentToken , t_CurrentTokenText )

		t_Position = a_NextPosition 

		If Status <> Parser_Success Then

			If g_Debug And 1 Then
				WScript.Echo "PropList Parse Error" , Status
			End If

			Parser_Select = Status

			Exit Function
			
		End If
	Else

		Parser_Select = Status

		If g_Debug And 1 Then
			WScript.Echo "Parse Error" , Status
		End If

		Exit Function

	End If

    If t_CurrentToken <> SQL_1_TOK_FROM Then

		Parser_Select = Parser_Syntax_Error

		Exit Function

	End If

	Status = Parser_Class_Name ( a_Dfa , a_Stream , t_Position , a_NextPosition , t_CurrentToken , t_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Parse Error" , Status
		End If

		Parser_Select = Status

		Exit Function
		
	End If

	Status = Parser_Within ( a_Dfa , a_Stream , t_Position , a_NextPosition , t_CurrentToken , t_CurrentTokenText )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Within Parse Error" , Status
		End If

		Parser_Select = Status

		Exit Function
		
	End If

	a_WhereExpressionPosition = t_Position

	Status = Parser_Where ( a_Dfa , a_Stream , t_Position , a_NextPosition , t_CurrentToken , t_CurrentTokenText , a_ParseTree )

	t_Position = a_NextPosition 

	If Status <> Parser_Success Then

		If g_Debug And 1 Then
			WScript.Echo "Where Parse Error" , Status
		End If

		Parser_Select = Status

		Exit Function
		
	End If

	Parser_Select = Parser_Success

End Function
