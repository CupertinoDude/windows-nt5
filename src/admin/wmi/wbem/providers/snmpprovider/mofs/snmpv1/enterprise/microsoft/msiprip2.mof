// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	MOF Generated for module "MSIPRIP2-MIB" by smi2smir version 1.00.456.0000
qualifier textual_convention:ToInstance ToSubClass;
qualifier object_identifier:ToInstance ToSubClass;
qualifier encoding:ToInstance ToSubClass;
qualifier object_syntax:ToInstance ToSubClass;
qualifier status:ToInstance ToSubClass;
qualifier fixed_length:ToInstance ToSubClass;
qualifier variable_length:ToInstance ToSubClass;
qualifier variable_value:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier enumeration:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier description:ToInstance ToSubClass;
qualifier display_hint:ToInstance ToSubClass;
qualifier defval:ToInstance ToSubClass;
qualifier units:ToInstance ToSubClass;
qualifier reference:ToInstance ToSubClass;
qualifier virtual_key:ToInstance ToSubClass;
qualifier rowstatus:ToInstance ToSubClass;
qualifier module_name:ToInstance ToSubClass;
qualifier module_imports:ToInstance ToSubClass;
qualifier group_objectid:ToInstance ToSubClass;

[abstract]
class SnmpMacro
{
};

[abstract]
class SnmpObjectType:SnmpMacro
{
};

class SnmpNotifyStatus:__ExtendedStatus
{
[write] sint32 SnmpStatusCode;
[write] string Description;
};

[description("Table of IP addresses bound to interfaces\nEntry for an IP address for an interface"), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifAddressTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.7.1.1"), read, description("Index corresponding to the Interface with which this entry \n\t\t is associated."), status("mandatory"), key, key_order(1)] sint32 ifAEIfIndex = 0;
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.2.7.1.2"), read, description("Ip address bound to the associated interface."), status("mandatory"), key, key_order(2)] string ifAEAddress = "0.0.0.0";
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.2.7.1.3"), read, description("Address Mask associated with the IP address contained in the \n         corresponding ifAEAddress field."), status("mandatory"), key, key_order(3)] string ifAEMask = "0.0.0.0";
};
[description("Table of RIP statistics for interfaces\nRIP interface statistics entry. \n         Each entry contains counts of send/receive failures, requests/resposes\n         sent/received, bad packets/entries reveived and triggered updates sent"), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifStatsTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.6"), read, description("Number of RIP REQUEST packets received on this interface."), status("mandatory")] uint32 ifSERequestReceiveds = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.10"), read, description("Number of RIP RESPONSE routes ignored due to errors in the entry."), status("mandatory")] uint32 ifSEBadResponseEntriesReceiveds = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.8"), read, description("Number of RIP RESPONSE packets received on this interface."), status("mandatory")] uint32 ifSEResponseReceiveds = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.11"), read, description("Count of triggered updates sent. "), status("mandatory")] uint32 ifSETriggeredUpdateSends = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.3"), read, description("Number of times a failure occurred while attempting to send a \n         packet on this interface."), status("mandatory")] uint32 ifSESendFailures = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.5"), read, description("Number of RIP REQUEST packets sent on this interface."), status("mandatory")] uint32 ifSERequestSends = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.7"), read, description("Number of RIP RESPONSE packets sent on this interface."), status("mandatory")] uint32 ifSEResponseSends = 0;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.1"), read, description("Index for the RIP interface Statistics table"), status("mandatory"), key, key_order(1)] sint32 ifSEIndex = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("enabled(1),bound(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.2"), read, description("Current state of RIP on this interface."), status("mandatory")] string ifSEState = "enabled";
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.4"), read, description("Number of times a failure occurred while attempting to receive\n         a packet on this interface."), status("mandatory")] uint32 ifSEReceiveFailures = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.1.1.9"), read, description("Number of RIP RESPONSE packets discarded due to errors in the header."), status("mandatory")] uint32 ifSEBadResponsePacketReceiveds = 0;
};
[description("Table of the peers routers to which update messages need \n         to be unicast\nEntry for a peer router for an interface"), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifUnicastPeersTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.3.1.1"), read, write, description("Interface index corresponding to the interface with which this \n\t\t peer router is associated."), status("mandatory"), key, key_order(1)] sint32 ifUPIfIndex = 0;
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.2.3.1.2"), read, write, description("IP Address of a peer router."), status("mandatory"), key, key_order(2)] string ifUPAddress = "0.0.0.0";
	[textual_convention("EnumeratedINTEGER"), enumeration("create(1),delete(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.3.1.3"), read, write, description("create : Creates an entry in the unicast peer table\n\t\t delete\t: Deletes an entry in the unicast peer table\n\t\t"), status("mandatory")] string ifUPTag = "create";
};
[description("Table of the route filters used to filter the set of routes \n         annouced over an interface.\nEntry for a route filter for an interface."), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifAnnounceRouteFilterTable : SnmpObjectType
{
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.2.5.1.3"), read, write, description("Higher address in the range routes covered by this filter."), status("mandatory"), key, key_order(3)] string ifAnnounceRFHiAddress = "0.0.0.0";
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.2.5.1.2"), read, write, description("Lowest address in the range of routes covered by this filter."), status("mandatory"), key, key_order(2)] string ifAnnounceRFLoAddress = "0.0.0.0";
	[textual_convention("EnumeratedINTEGER"), enumeration("create(1),delete(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.5.1.4"), read, write, description("create : Creates an entry in the Announce Route Filter table\n\t\t delete\t: Deletes an entry in the Announce Route Filter table\n\t\t"), status("mandatory")] string ifAnnounceRFTag = "create";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.5.1.1"), read, write, description("Interface index corresponding to the interface to which this route\n         filter entry corresponds"), status("mandatory"), key, key_order(1)] sint32 ifAnnounceRFIfIndex = 0;
};
[description("RIP Interface configuration table.  List of subnets that require\n         separate configuration in RIP.\nRIP configuration entry for an interface. A single routing domain in a\n         single subnet."), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifConfigTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.18"), read, write, description("Number of entries in the Accept Filter Table corresponding to\n         this interface entry."), status("mandatory"), defval("0")] sint32 ifCEAcceptFilterCount = 0;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..16"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.12"), read, write, description("The value to be used as the Authentication key whenever the \n         corresponding instance of ifCEAuthenticationType has a value \n         other than noAuthentication.   A modification of the \n         corresponding instance of ifCEAuthentiationType does not modify \n         the ifCEAuthenticationKey value.  If a string shorter than 16 \n         octects is supplied, it will be left-justified and padded to 16 \n         octects, on the right with nulls (0x00).\n\n         Reading this object always results in an OCTET STRING of length\n         zero; authentication may not be bypasssed by reading the MIB\n         object"), status("mandatory"), defval("")] string ifCEAuthenticationKey = "";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.13"), read, write, description("Value inserted into the Routing Domain field of all RIP packets\n         sent on this interface."), status("mandatory"), defval("0")] sint32 ifCERouteTag = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("disable(1),include(2),exclude(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.16"), read, write, description("Determines the annouce behaviour of the RIP router.  \n\n         If set to include\n         the entries in the Announce Filter Table corresponding to this \n         interface specify the routes to be included.  All other routes \n         are excluded. \n\n\t\t If set to exclude\n         the entries in the Announce Filter Table corresponding to this \n         interface specify the routes to be excluded."), status("mandatory"), defval("1")] string ifCEAnnounceFilterMode = "disable";
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.10"), read, description("Interval between route table annoucements."), status("mandatory"), defval("30")] uint32 ifCEFullUpdateInterval = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("noAuthentication(1),simplePassword(2),md5(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.11"), read, write, description("Type of authentication to be used on this interface."), status("mandatory"), defval("1")] string ifCEAuthenticationType = "noAuthentication";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.19"), read, write, description("Number of entries in the Announce Filter Table corresponding to\n         this interface entry."), status("mandatory"), defval("0")] sint32 ifCEAnnounceFilterCount = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("disable(1),rip1(2),rip1Compat(3),rip2(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.5"), read, write, description("Specifies the type of RIP messages that will be accepted by this router\n         \tdisable\t\t: No RIP messages wil be accepted\n         \trip1\t\t: Only RIP-1 messages will be accepted\n         \trip1Compat\t: Both RIP-1 and RIP-2 messages will be accepted\n         \trip2\t\t: Only RIP-2 messages will be accepted"), status("mandatory"), defval("3")] string ifCEAcceptMode = "disable";
	[textual_convention("EnumeratedINTEGER"), enumeration("periodic(1),demand(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.4"), read, write, description("Mode for sending update messages.  If set to periodic, then messages \n         are sent based on the value of ifCEFullUpdateInterval.  Otherwise \n         update messages are sent only on demand."), status("mandatory"), defval("1")] string ifCEUpdateMode = "periodic";
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.9"), read, write, description("Interval after which a route marked for deletion is removed."), status("mandatory"), defval("120")] uint32 ifCERouteRemovalInterval = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("disable(1),rip1(2),rip1Compat(3),rip2(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.6"), read, write, description("Specifies the type of RIP messages that will be sent by this router.\n         \tdisable\t\t: No RIP messages wil be sent\n         \trip1\t\t: Only RIP-1 messages will be sent in compliance with \n         \t\t\t\t  RFC 1058.\n         \trip1Compat\t: RIP-2 messages will be broadcast using RFC 1058\n         \t\t\t\t  subsumption rules.\n         \trip2\t\t: RIP-2 messages will be multicast"), status("mandatory"), defval("3")] string ifCEAnnounceMode = "disable";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.7"), read, write, description("Options for control of RIP operation.  These options can be used in\n    \t combination.\n    \t\n\t\t\tOption\t\t\t\t\t\t\t\tvalue\n\t\t--------------------------------------------------\n\t\t1.\tACCEPT_HOST_ROUTES           \t\t0x00000001\n\t\t2.\tANNOUNCE_HOST_ROUTES         \t\t0x00000002\n\t\t3.\tACCEPT_DEFAULT_ROUTES        \t\t0x00000004\n\t\t4.\tANNOUNCE_DEFAULT_ROUTES      \t\t0x00000008\n\t\t5.\tSPLIT_HORIZON                \t\t0x00000010\n\t\t6.\tPOISON_REVERSE               \t\t0x00000020\n\t\t7.\tGRACEFUL_SHUTDOWN            \t\t0x00000040\n\t\t8.\tTRIGGERED_UPDATES            \t\t0x00000080\n\t\t9.\tOVERWRITE_STATIC_ROUTES      \t\t0x00000100 "), status("mandatory"), defval("240")] sint32 ifCEProtocolFlags = 0;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.8"), read, write, description("Interval after which route is marked for deletion."), status("mandatory"), defval("180")] uint32 ifCERouteExpirationInterval = 0;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.1"), read, description("Index for RIP interface config. table."), status("mandatory"), key, key_order(1)] sint32 ifCEIndex = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("disable(1),peerAlso(2),peerOnly(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.14"), read, write, description("Determines the unicast behavior when route update messages are sent.\n        \n         If set to peerAlso, updates are sent to those peers in the \n         RIP unicast peer table corresponding to this interace as well as \n         being sent via broadcast/multicast.  \n\n         If set to peerOnly, updates are sent only those peers listed in\n         in the RIP Unicast peer table corresponding to this interface."), status("mandatory"), defval("1")] string ifCEUnicastPeerMode = "disable";
	[textual_convention("EnumeratedINTEGER"), enumeration("enabled(1),bound(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.2"), read, description("Current state of RIP on this interface."), status("mandatory")] string ifCEState = "enabled";
	[textual_convention("EnumeratedINTEGER"), enumeration("disable(1),include(2),exclude(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.15"), read, write, description("Determines the accept behaviour of the RIP router.  \n\n         If set to include\n         the entries in the Accept Filter Table corresponding to this interface \n         specify the routes to be included.  All other routes are excluded. \n\n         If set to exclude\n         the entries in the Accept Filter Table corresponding to this interface\n         specify the routes to be excluded."), status("mandatory"), defval("1")] string ifCEAcceptFilterMode = "disable";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..16"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.3"), read, write, description("Metric for the network connected to this interface."), status("mandatory"), defval("1")] sint32 ifCEMetric = 0;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.2.1.17"), read, write, description("Number of entries in the Unicast Peer Table corresponding to\n         this interface entry."), status("mandatory"), defval("0")] sint32 ifCEUnicastPeerCount = 0;
};
[description("Table of the route filters used to filter the set of routes \n         accepted over an interface.\nEntry for a route filter for an interface"), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifAcceptRouteFilterTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("create(1),delete(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.4.1.4"), read, write, description("create : Creates an entry in the Accept Route Filter table\n\t\t delete\t: Deletes an entry in the Accept Route Filter table\n\t\t"), status("mandatory"), key, key_order(4)] string ifAcceptRFTag = "create";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.4.1.1"), read, write, description("Interface index corresponding to the interface to which this route\n         filter entry corresponds"), status("mandatory"), key, key_order(1)] sint32 ifAcceptRFIfIndex = 0;
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.2.4.1.3"), read, write, description("Higher address in the range routes covered by this filter."), status("mandatory"), key, key_order(3)] string ifAcceptRFHiAddress = "0.0.0.0";
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.2.4.1.2"), read, write, description("Lowest address in the range of routes covered by this filter."), status("mandatory"), key, key_order(2)] string ifAcceptRFLoAddress = "0.0.0.0";
};
[description("Table containing binding information for each interface.\nBinding information entry for an interface"), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifBindingTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.6.1.1"), read, description("Index corresponding to an interface entry in the binding table"), status("mandatory"), key, key_order(1)] sint32 ifBindingIndex = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("enabled(1),bound(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.2.6.1.2"), read, description("State of the interface binding"), status("mandatory")] string ifBindingState = "enabled";
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.2.6.1.3"), read, description("Number of IP address bound to this interface.  This is also the \n         number of entries in the Interface Address Table corresponding\n         to this interface."), status("mandatory")] uint32 ifBindingCounts = 0;
};
[description(""), module_name("MSIPRIP2-MIB"), singleton, group_objectid("1.3.6.1.4.1.311.1.11.1"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_global : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("disable(1),include(2),exclude(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.1.7"), read, write, description("Controls the use of update messages from the list of peers in the peer \n         filter table.  \n\n         If set to include \n         routes will be only be accepted if they are from the routers in the \n         peer array.  \n\n         If set to exclude\n         routes will be rejected that come from the routers whose addresses are \n         in the peer array, and all other routers will be accepted."), status("mandatory")] string globalPeerFilterMode = "disable";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.1.4"), read, write, description("Maximum size to use for queueing incoming packets."), status("mandatory")] sint32 globalMaxRecQueueSize = 0;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.1.8"), read, description("Number of entries in the peer filter table"), status("mandatory")] sint32 globalPeerFilterCount = 0;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.1.5"), read, write, description("Maximum size to use for queueing outgoing packets."), status("mandatory")] sint32 globalMaxSendQueueSize = 0;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.4.1.311.1.11.1.6"), read, write, description("Minimum lag time before sending a triggered update.  Used to \n         consolidate updates to the route table and reduce number of \n         updates sent."), status("mandatory")] uint32 globalMinTriggeredUpdateInterval = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.1.1"), read, description("Number of changes RIP has made to the system routing tables."), status("mandatory")] uint32 globalSystemRouteChanges = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.1.2"), read, description("Number of request messages for which responses have been sent."), status("mandatory")] uint32 globalTotalResponseSends = 0;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),error(2),warning(3),information(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.1.3"), read, write, description("Information logged can be None, Error only, Error + Warning, \n         Error + Warn + Logging.  This variable controls the amount\n         of information logged"), status("mandatory")] string globalLoggingLevel = "none";
};
[description("Table of peer routers communicating with this router via RIP\nPeer router entry. Contains the IP address of peer router"), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.1"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_globalPeerFilterTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("create(1),delete(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.1.9.1.2"), read, write, description("create : Creates an entry in the Global Peer Filter table\n\t\t delete\t: Deletes an entry in the Global Peer Filter table\n\t\t"), status("mandatory")] string globalPFTag = "create";
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.1.9.1.1"), read, write, description("IP Address of peer router"), status("mandatory"), key, key_order(1)] string globalPFAddr = "0.0.0.0";
};
[description("Table of peer router statistics\nEntry corresponding to a peer router."), module_name("MSIPRIP2-MIB"), group_objectid("1.3.6.1.4.1.311.1.11.3"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_MSIPRIP2_MIB_ifPeerStatsTable : SnmpObjectType
{
	[textual_convention("IpAddress"), encoding("IpAddress"), object_syntax("IpAddress"), object_identifier("1.3.6.1.4.1.311.1.11.3.1.1.1"), read, description("IP Address that the peer is using as its source address."), status("mandatory"), key, key_order(1)] string ifPSAddress = "0.0.0.0";
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..255"), object_identifier("1.3.6.1.4.1.311.1.11.3.1.1.4"), read, description("The update version of the last RIP RESPONSE received from this peer."), status("mandatory")] sint32 ifPSLastPeerUpdateVersion = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.3.1.1.5"), read, description("The number of RIP RESPONSE packets which were received from this peer\n         and subsequently discarded."), status("mandatory")] uint32 ifPSPeerBadResponsePackets = 0;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.4.1.311.1.11.3.1.1.6"), read, description("The number of routes in RIP RESPONSE packets which were received\n         from this peer and subsequently discarded."), status("mandatory")] uint32 ifPSPeerBadResponseEntries = 0;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.4.1.311.1.11.3.1.1.3"), read, description("The tick-count in milliseconds at the time of the last RIP RESPONSE\n         received from this peer."), status("mandatory")] uint32 ifPSLastPeerUpdateTickCount = 0;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.4.1.311.1.11.3.1.1.2"), read, description("The route-tag of the last route in the last RIP RESPONSE received\n         from this peer."), status("mandatory")] sint32 ifPSLastPeerRouteTag = 0;
};

