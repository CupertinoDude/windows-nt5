// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	MOF Generated for module "SNMP-REPEATER-MIB" by smi2smir version 1.10.635.0000
qualifier write:ToInstance ToSubClass;
qualifier read:ToInstance ToSubClass;
qualifier provider:ToInstance ToSubClass;
qualifier singleton:ToInstance ToSubClass;
qualifier dynamic:ToInstance ToSubClass;
qualifier textual_convention:ToInstance ToSubClass;
qualifier object_identifier:ToInstance ToSubClass;
qualifier encoding:ToInstance ToSubClass;
qualifier object_syntax:ToInstance ToSubClass;
qualifier status:ToInstance ToSubClass;
qualifier fixed_length:ToInstance ToSubClass;
qualifier variable_length:ToInstance ToSubClass;
qualifier variable_value:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier key_order:ToInstance ToSubClass;
qualifier enumeration:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier description:ToInstance ToSubClass;
qualifier display_hint:ToInstance ToSubClass;
qualifier defval:ToInstance ToSubClass;
qualifier units:ToInstance ToSubClass;
qualifier reference:ToInstance ToSubClass;
qualifier virtual_key:ToInstance ToSubClass;
qualifier rowstatus:ToInstance ToSubClass;
qualifier module_name:ToInstance ToSubClass;
qualifier module_imports:ToInstance ToSubClass;
qualifier group_objectid:ToInstance ToSubClass;

[abstract]
class SnmpMacro
{
};

[abstract]
class SnmpObjectType:SnmpMacro
{
};

class SnmpNotifyStatus:__ExtendedStatus
{
[write] sint32 SnmpStatusCode;
[write] string Description;
};

[description("Table of descriptive and status information about\n               the ports.\nAn entry in the table, containing information\n               about a single port."), module_name("SNMP-REPEATER-MIB"), group_objectid("1.3.6.1.2.1.22.1.3"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_SNMP_REPEATER_MIB_rptrPortTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("enabled(1),disabled(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.22.1.3.1.1.3"), read, write, description("Setting this object to disabled(2) disables the\n               port.  A disabled port neither transmits nor\n               receives.  Once disabled, a port must be\n               explicitly enabled to restore operation.  A port\n               which is disabled when power is lost or when a\n               reset is exerted shall remain disabled when normal\n               operation resumes.\n\n               The admin status takes precedence over auto-\n               partition and functionally operates between the\n               auto-partition mechanism and the AUI/PMA.\n\n               Setting this object to enabled(1) enables the port\n               and exerts a BEGIN on the port's auto-partition\n               state machine.\n\n               (In effect, when a port is disabled, the value of\n               rptrPortAutoPartitionState for that port is frozen\n               until the port is next enabled.  When the port\n\n\n\n\n\n               becomes enabled, the rptrPortAutoPartitionState\n               becomes notAutoPartitioned(1), regardless of its\n               pre-disabling state.)"), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortAdminState and 19.2.6.3, acPortAdminControl."), status("mandatory")] string rptrPortAdminStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.1.3.1.1.2"), read, description("This object identifies the port within the group\n               for which this entry contains information.  This\n               value can never be greater than\n               rptrGroupPortCapacity for the associated group."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortID."), status("mandatory"), key, key_order(2)] sint32 rptrPortIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("notAutoPartitioned(1),autoPartitioned(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.22.1.3.1.1.4"), read, description("The autoPartitionState flag indicates whether the\n               port is currently partitioned by the repeater's\n               auto-partition protection.\n\n               The conditions that cause port partitioning are\n               specified in partition state machine in Section 9\n               [IEEE 802.3 Std].  They are not differentiated\n               here."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aAutoPartitionState."), status("mandatory")] string rptrPortAutoPartitionState;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.1.3.1.1.1"), read, description("This object identifies the group containing the\n               port for which this entry contains information."), status("mandatory"), key, key_order(1)] sint32 rptrPortGroupIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("operational(1),notOperational(2),notPresent(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.22.1.3.1.1.5"), read, description("This object indicates the port's operational\n               status.  The notPresent(3) status indicates the\n               port is physically removed (note this may or may\n               not be possible depending on the type of port.)\n               The operational(1) status indicates that the port\n               is enabled (see rptrPortAdminStatus) and working,\n               even though it might be auto-partitioned (see\n               rptrPortAutoPartitionState).\n\n               If this object has the value operational(1) and\n\n\n\n\n\n               rptrPortAdminStatus is set to disabled(2), it is\n               expected that this object's value will soon change\n               to notOperational(2)."), status("mandatory")] string rptrPortOperStatus;
};
[description("Table of descriptive and status information about\n               the groups of ports.\nAn entry in the table, containing information\n               about a single group of ports."), module_name("SNMP-REPEATER-MIB"), group_objectid("1.3.6.1.2.1.22.1.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_SNMP_REPEATER_MIB_rptrGroupTable : SnmpObjectType
{
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.22.1.2.1.1.5"), read, description("An object that contains the value of sysUpTime at\n               the time that the value of the rptrGroupOperStatus\n               object for this group last changed.\n\n               A value of zero indicates that the group's\n               operational status has not changed since the agent\n               last restarted."), status("mandatory")] uint32 rptrGroupLastOperStatusChange;
	[textual_convention("EnumeratedINTEGER"), enumeration("other(1),operational(2),malfunctioning(3),notPresent(4),underTest(5),resetInProgress(6)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.22.1.2.1.1.4"), read, description("An object that indicates the operational status\n               of the group.\n\n               A status of notPresent(4) indicates that the group\n               is temporarily or permanently physically and/or\n               logically not a part of the repeater.  It is an\n               implementation-specific matter as to whether the\n               agent effectively removes notPresent entries from\n               the table.\n\n               A status of operational(2) indicates that the\n               group is functioning, and a status of\n               malfunctioning(3) indicates that the group is\n               malfunctioning in some way."), status("mandatory")] string rptrGroupOperStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.1.2.1.1.6"), read, description("The rptrGroupPortCapacity is the number of ports\n               that can be contained within the group.  Valid\n               range is 1-1024.  Within each group, the ports are\n               uniquely numbered in the range from 1 to\n               rptrGroupPortCapacity.\n\n               Note:  In practice, this will generally be the\n\n\n\n\n\n               number of ports on a module, card, or board, and\n               the port numbers will correspond to numbers marked\n               on the physical embodiment."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.5.2,\n               aGroupPortCapacity."), status("mandatory")] sint32 rptrGroupPortCapacity;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..255"), object_identifier("1.3.6.1.2.1.22.1.2.1.1.2"), read, description("A textual description of the group.  This value\n               should include the full name and version\n               identification of the group's hardware type and\n               indicate how the group is differentiated from\n               other types of groups in the repeater.  Plug-in\n               Module, Rev A' or 'Barney Rubble 10BASE-T 4-port\n               SIMM socket Version 2.1' are examples of valid\n               group descriptions.\n\n               It is mandatory that this only contain printable\n               ASCII characters."), status("mandatory")] string rptrGroupDescr;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.1.2.1.1.1"), read, description("This object identifies the group within the\n               repeater for which this entry contains\n               information.  This value is never greater than\n               rptrGroupCapacity."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.5.2,\n               aGroupID."), status("mandatory"), key, key_order(1)] sint32 rptrGroupIndex;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.22.1.2.1.1.3"), read, description("The vendor's authoritative identification of the\n               group.  This value may be allocated within the SMI\n               enterprises subtree (1.3.6.1.4.1) and provides a\n               straight-forward and unambiguous means for\n               determining what kind of group is being managed.\n\n               For example, this object could take the value\n               1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones,\n               Inc.' was assigned the subtree 1.3.6.1.4.1.4242,\n               and had assigned the identifier\n               1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone\n               6-Port FOIRL Plug-in Module.'"), status("mandatory")] string rptrGroupObjectID;
};
[description(""), module_name("SNMP-REPEATER-MIB"), singleton, group_objectid("1.3.6.1.2.1.22.1.1"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_SNMP_REPEATER_MIB_rptrRptrInfo : SnmpObjectType
{
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..255"), object_identifier("1.3.6.1.2.1.22.1.1.3"), read, description("The health text object is a text string that\n               provides information relevant to the operational\n               state of the repeater.  Agents may use this string\n               to provide detailed information on current\n               failures, including how they were detected, and/or\n               instructions for problem resolution.  The contents\n               are agent-specific."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aRepeaterHealthText."), status("mandatory")] string rptrHealthText;
	[textual_convention("EnumeratedINTEGER"), enumeration("other(1),ok(2),rptrFailure(3),groupFailure(4),portFailure(5),generalFailure(6)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.22.1.1.2"), read, description("The rptrOperStatus object indicates the\n               operational state of the repeater.  The\n               rptrHealthText object may be consulted for more\n               specific information about the state of the\n               repeater's health.\n\n               In the case of multiple kinds of failures (e.g.,\n               repeater failure and port failure), the value of\n               this attribute shall reflect the highest priority\n               failure in the following order, listed highest\n               priority first:\n\n                   rptrFailure(3)\n                   groupFailure(4)\n                   portFailure(5)\n                   generalFailure(6)."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aRepeaterHealthState."), status("mandatory")] string rptrOperStatus;
	[textual_convention("Gauge"), encoding("Gauge"), object_syntax("Gauge"), object_identifier("1.3.6.1.2.1.22.1.1.6"), read, description("This object returns the total number of ports in\n               the repeater whose current state meets all three\n               of the following criteria:  rptrPortOperStatus\n               does not have the value notPresent(3),\n               rptrPortAdminStatus is enabled(1), and\n               rptrPortAutoPartitionState is autoPartitioned(2)."), status("mandatory")] uint32 rptrTotalPartitionedPorts;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.1.1.1"), read, description("The rptrGroupCapacity is the number of groups\n               that can be contained within the repeater.  Within\n               each managed repeater, the groups are uniquely\n               numbered in the range from 1 to rptrGroupCapacity.\n\n               Some groups may not be present in the repeater, in\n               which case the actual number of groups present\n               will be less than rptrGroupCapacity.  The number\n               of groups present will never be greater than\n               rptrGroupCapacity.\n\n               Note:  In practice, this will generally be the\n               number of field-replaceable units (i.e., modules,\n               cards, or boards) that can fit in the physical\n               repeater enclosure, and the group numbers will\n               correspond to numbers marked on the physical\n               enclosure."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aRepeaterGroupCapacity."), status("mandatory")] sint32 rptrGroupCapacity;
	[textual_convention("EnumeratedINTEGER"), enumeration("noSelfTest(1),selfTest(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.22.1.1.5"), read, write, description("Setting this object to selfTest(2) causes the\n               repeater to perform a agent-specific, non-\n               disruptive self-test that has the following\n               characteristics:  a) The nature of the tests is\n               not specified.  b) The test does not change the\n               state of the repeater or management information\n               about the repeater.  c) The test does not inject\n               packets onto any segment.  d) The test does not\n               prevent the relay of any packets.  e) The test\n               does not interfere with management functions.\n\n               After performing this test, the agent will update\n               the repeater health information (including\n               rptrOperStatus and rptrHealthText) and send a\n               rptrHealth trap.\n\n               Note that this definition allows returning an\n               'okay' result after doing a trivial test.\n\n               Setting this object to noSelfTest(1) has no\n               effect.  The agent will always return the value\n               noSelfTest(1) when this object is read."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.3.3,\n               acExecuteNonDisruptiveSelfTest."), status("mandatory")] string rptrNonDisruptTest;
	[textual_convention("EnumeratedINTEGER"), enumeration("noReset(1),reset(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.22.1.1.4"), read, write, description("Setting this object to reset(2) causes a\n               transition to the START state of Fig 9-2 in\n               section 9 [IEEE 802.3 Std].\n\n               Setting this object to noReset(1) has no effect.\n               The agent will always return the value noReset(1)\n               when this object is read.\n\n               After receiving a request to set this variable to\n               reset(2), the agent is allowed to delay the reset\n               for a short period.  For example, the implementor\n               may choose to delay the reset long enough to allow\n               the SNMP response to be transmitted.  In any\n               event, the SNMP response must be transmitted.\n\n               This action does not reset the management counters\n               defined in this document nor does it affect the\n               portAdminStatus parameters.  Included in this\n               action is the execution of a disruptive Self-Test\n               with the following characteristics:  a) The nature\n               of the tests is not specified.  b) The test resets\n               the repeater but without affecting management\n               information about the repeater.  c) The test does\n               not inject packets onto any segment.  d) Packets\n               received during the test may or may not be\n               transferred.  e) The test does not interfere with\n               management functions.\n\n               After performing this self-test, the agent will\n               update the repeater health information (including\n               rptrOperStatus and rptrHealthText), and send a\n               rptrHealth trap."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.3.3,\n               acResetRepeater."), status("mandatory")] string rptrReset;
};
[description("Table of performance and error statistics for the\n               ports.\nAn entry in the table, containing performance and\n               error statistics for a single port."), module_name("SNMP-REPEATER-MIB"), group_objectid("1.3.6.1.2.1.22.2.3"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_SNMP_REPEATER_MIB_rptrMonitorPortTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.3"), read, description("This object is the number of frames of valid\n               frame length that have been received on this port.\n               This counter is incremented by one for each frame\n               received on this port whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: IEEE 802.3 Std,\n               4.4.2.1) and for which the FCSError and\n               CollisionEvent signals are not asserted.\n\n               This statistic provides one of the parameters\n               necessary for obtaining the packet error rate.\n               The approximate minimum time for rollover of this\n               counter is 80 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n\n\n\n\n\n               aReadableFrames."), status("mandatory")] uint32 rptrMonitorPortReadableFrames;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.4"), read, description("This object is the number of octets contained in\n               valid frames that have been received on this port.\n               This counter is incremented by OctetCount for each\n               frame received on this port which has been\n               determined to be a readable frame (i.e., including\n               FCS octets but excluding framing bits and dribble\n               bits).\n\n               This statistic provides an indicator of the total\n               data transferred.  The approximate minimum time\n               for rollover of this counter is 58 minutes."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aReadableOctets."), status("mandatory")] uint32 rptrMonitorPortReadableOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.12"), read, description("This counter is incremented by one for each\n               CarrierEvent on this port whose ActivityDuration\n               is greater than the MAU Jabber Lockup Protection\n               timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std).\n               Other counters may be incremented as appropriate."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aVeryLongEvents."), status("mandatory")] uint32 rptrMonitorPortVeryLongEvents;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.14"), read, description("This counter is incremented by one for each time\n               the repeater has automatically partitioned this\n               port.  The conditions that cause port partitioning\n               are specified in the partition state machine in\n               Section 9 [IEEE 802.3 Std].  They are not\n               differentiated here."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aAutoPartitions."), status("mandatory")] uint32 rptrMonitorPortAutoPartitions;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.2"), read, description("This object identifies the port within the group\n               for which this entry contains information."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortID."), status("mandatory"), key, key_order(2)] sint32 rptrMonitorPortIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.9"), read, description("This counter is incremented by one for each\n               CarrierEvent on this port that meets one of the\n               following two conditions.  Only one test need be\n               made.  a) The ActivityDuration is greater than\n               ShortEventMaxTime and less than ValidPacketMinTime\n               and the CollisionEvent signal is deasserted.  b)\n               The OctetCount is less than 64, the\n               ActivityDuration is greater than ShortEventMaxTime\n               and the CollisionEvent signal is deasserted.\n               ValidPacketMinTime is greater than or equal to 552\n               bit times and less than 565 bit times.\n\n               An event whose length is greater than 74 bit times\n               but less than 82 bit times shall increment either\n               the shortEvents counter or the runts counter but\n               not both.  A CarrierEvent greater than or equal to\n               552 bit times but less than 565 bit times may or\n               may not be counted as a runt.\n\n\n\n\n\n               ValidPacketMinTime has tolerances included to\n               provide for circuit losses between a conformance\n               test point at the AUI and the measurement point\n               within the state machine.\n\n               Runts usually indicate collision fragments, a\n               normal network event.  In certain situations\n               associated with large diameter networks a\n               percentage of collision fragments may exceed\n               ValidPacketMinTime.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aRunts."), status("mandatory")] uint32 rptrMonitorPortRunts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.6"), read, description("This counter is incremented by one for each frame\n               received on this port with the FCSError and\n               FramingError signals asserted and CollisionEvent\n               signal deasserted and whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: IEEE 802.3 Std,\n               4.4.2.1).  If rptrMonitorPortAlignmentErrors is\n               incremented then the rptrMonitorPortFCSErrors\n               Counter shall not be incremented for the same\n               frame.\n\n               The approximate minimum time for rollover of this\n               counter is 80 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aAlignmentErrors."), status("mandatory")] uint32 rptrMonitorPortAlignmentErrors;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.13"), read, description("This counter is incremented by one for each frame\n               received on this port that meets all of the\n               following conditions:  a) The CollisionEvent\n               signal is not asserted.  b) The ActivityDuration\n               is greater than ValidPacketMinTime.  c) The\n               frequency (data rate) is detectably mismatched\n               from the local transmit frequency.  The exact\n               degree of mismatch is vendor specific and is to be\n               defined by the vendor for conformance testing.\n\n               When this event occurs, other counters whose\n               increment conditions were satisfied may or may not\n               also be incremented, at the implementor's\n               discretion.  Whether or not the repeater was able\n\n\n\n\n\n               to maintain data integrity is beyond the scope of\n               this standard."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aDataRateMismatches."), status("mandatory")] uint32 rptrMonitorPortDataRateMismatches;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.5"), read, description("This counter is incremented by one for each frame\n               received on this port with the FCSError signal\n               asserted and the FramingError and CollisionEvent\n               signals deasserted and whose OctetCount is greater\n               than or equal to minFrameSize and less than or\n               equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3\n               Std).\n\n               The approximate minimum time for rollover of this\n               counter is 80 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aFrameCheckSequenceErrors."), status("mandatory")] uint32 rptrMonitorPortFCSErrors;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.11"), read, description("This counter is incremented by one for each\n               CarrierEvent on this port in which the CollIn(X)\n               variable transitions to the value SQE (Ref:\n               9.6.6.2, IEEE 802.3 Std) while the\n               ActivityDuration is greater than the\n               LateEventThreshold.  Such a CarrierEvent is\n               counted twice, as both a collision and as a\n               lateEvent.\n\n\n\n\n\n\n               The LateEventThreshold is greater than 480 bit\n               times and less than 565 bit times.\n               LateEventThreshold has tolerances included to\n               permit an implementation to build a single\n               threshold to serve as both the LateEventThreshold\n               and ValidPacketMinTime threshold.\n\n               The approximate minimum time for rollover of this\n               counter is 81 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aLateEvents."), status("mandatory")] uint32 rptrMonitorPortLateEvents;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.1"), read, description("This object identifies the group containing the\n               port for which this entry contains information."), status("mandatory"), key, key_order(1)] sint32 rptrMonitorPortGroupIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.10"), read, description("This counter is incremented by one for any\n               CarrierEvent signal on any port for which the\n               CollisionEvent signal on this port is also\n               asserted.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aCollisions."), status("mandatory")] uint32 rptrMonitorPortCollisions;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.15"), read, description("The total number of errors which have occurred on\n               this port.  This counter is the summation of the\n               values of other error counters (for the same\n               port), namely:\n\n                   rptrMonitorPortFCSErrors,\n                   rptrMonitorPortAlignmentErrors,\n                   rptrMonitorPortFrameTooLongs,\n                   rptrMonitorPortShortEvents,\n                   rptrMonitorPortLateEvents,\n                   rptrMonitorPortVeryLongEvents, and\n                   rptrMonitorPortDataRateMismatches.\n\n               This counter is redundant in the sense that it is\n               the summation of information already available\n               through other objects.  However, it is included\n               specifically because the regular retrieval of this\n               object as a means of tracking the health of a port\n               provides a considerable optimization of network\n               management traffic over the otherwise necessary\n\n\n\n\n\n               retrieval of the summed counters."), status("mandatory")] uint32 rptrMonitorPortTotalErrors;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.8"), read, description("This counter is incremented by one for each\n               CarrierEvent on this port with ActivityDuration\n               less than ShortEventMaxTime.  ShortEventMaxTime is\n               greater than 74 bit times and less than 82 bit\n\n\n\n\n\n               times.  ShortEventMaxTime has tolerances included\n               to provide for circuit losses between a\n               conformance test point at the AUI and the\n               measurement point within the state machine.\n\n               Note:  shortEvents may indicate externally\n               generated noise hits which will cause the repeater\n               to transmit Runts to its other ports, or propagate\n               a collision (which may be late) back to the\n               transmitting DTE and damaged frames to the rest of\n               the network.\n\n               Implementors may wish to consider selecting the\n               ShortEventMaxTime towards the lower end of the\n               allowed tolerance range to accommodate bit losses\n               suffered through physical channel devices not\n               budgeted for within this standard.\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aShortEvents."), status("mandatory")] uint32 rptrMonitorPortShortEvents;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.3.1.1.7"), read, description("This counter is incremented by one for each frame\n               received on this port whose OctetCount is greater\n               than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std).\n               If rptrMonitorPortFrameTooLongs is incremented\n               then neither the rptrMonitorPortAlignmentErrors\n               nor the rptrMonitorPortFCSErrors counter shall be\n               incremented for the frame.\n\n               The approximate minimum time for rollover of this\n               counter is 61 days."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aFramesTooLong."), status("mandatory")] uint32 rptrMonitorPortFrameTooLongs;
};
[description(""), module_name("SNMP-REPEATER-MIB"), singleton, group_objectid("1.3.6.1.2.1.22.2.1"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_SNMP_REPEATER_MIB_rptrMonitorRptrInfo : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.1.1"), read, description("This counter is incremented every time the\n               repeater state machine enters the TRANSMIT\n               COLLISION state from any state other than ONE PORT\n               LEFT (Ref: Fig 9-2, IEEE 802.3 Std).\n\n               The approximate minimum time for rollover of this\n               counter is 16 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.3.2,\n               aTransmitCollisions."), status("mandatory")] uint32 rptrMonitorTransmitCollisions;
};
[description("Table of performance and error statistics for the\n\n\n\n\n\n               groups.\nAn entry in the table, containing total\n               performance and error statistics for a single\n               group.  Regular retrieval of the information in\n               this table provides a means of tracking the\n               performance and health of the networked devices\n               attached to this group's ports.\n\n               The counters in this table are redundant in the\n               sense that they are the summations of information\n               already available through other objects.  However,\n               these sums provide a considerable optimization of\n               network management traffic over the otherwise\n               necessary retrieval of the individual counters\n               included in each sum."), module_name("SNMP-REPEATER-MIB"), group_objectid("1.3.6.1.2.1.22.2.2"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_SNMP_REPEATER_MIB_rptrMonitorGroupTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.2.2.1.1.1"), read, description("This object identifies the group within the\n               repeater for which this entry contains\n               information."), status("mandatory"), key, key_order(1)] sint32 rptrMonitorGroupIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.2.1.1.2"), read, description("The total number of frames of valid frame length\n               that have been received on the ports in this group\n               and for which the FCSError and CollisionEvent\n               signals were not asserted.  This counter is the\n               summation of the values of the\n               rptrMonitorPortReadableFrames counters for all of\n               the ports in the group.\n\n               This statistic provides one of the parameters\n               necessary for obtaining the packet error rate.\n               The approximate minimum time for rollover of this\n               counter is 80 hours."), status("mandatory")] uint32 rptrMonitorGroupTotalFrames;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.2.1.1.3"), read, description("The total number of octets contained in the valid\n               frames that have been received on the ports in\n               this group.  This counter is the summation of the\n               values of the rptrMonitorPortReadableOctets\n               counters for all of the ports in the group.\n\n               This statistic provides an indicator of the total\n               data transferred.  The approximate minimum time\n               for rollover of this counter is 58 minutes."), status("mandatory")] uint32 rptrMonitorGroupTotalOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.2.2.1.1.4"), read, description("The total number of errors which have occurred on\n               all of the ports in this group.  This counter is\n               the summation of the values of the\n               rptrMonitorPortTotalErrors counters for all of the\n               ports in the group."), status("mandatory")] uint32 rptrMonitorGroupTotalErrors;
};
[description("Table of address mapping information about the\n               ports.\nAn entry in the table, containing address mapping\n               information about a single port."), module_name("SNMP-REPEATER-MIB"), group_objectid("1.3.6.1.2.1.22.3.3"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_SNMP_REPEATER_MIB_rptrAddrTrackTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.22.3.3.1.1.4"), read, description("This counter is incremented by one for each time\n               that the rptrAddrTrackLastSourceAddress attribute\n               for this port has changed.\n\n\n\n\n\n               This may indicate whether a link is connected to a\n               single DTE or another multi-user segment.\n\n               The approximate minimum time for rollover of this\n               counter is 81 hours."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aSourceAddressChanges."), status("mandatory")] uint32 rptrAddrTrackSourceAddrChanges;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0,6"), object_identifier("1.3.6.1.2.1.22.3.3.1.1.5"), read, description("This object is the SourceAddress of the last\n               readable frame (i.e., counted by\n               rptrMonitorPortReadableFrames) received by this\n               port.  If no frames have been received by this\n               port since the agent began monitoring the port\n               activity, the agent shall return a string of\n               length zero."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aLastSourceAddress."), status("mandatory")] string rptrAddrTrackNewLastSrcAddress;
	[textual_convention("MacAddress"), encoding("OCTETSTRING"), object_syntax("MacAddress"), display_hint("1x:"), object_identifier("1.3.6.1.2.1.22.3.3.1.1.3"), read, description("This object is the SourceAddress of the last\n               readable frame (i.e., counted by\n               rptrMonitorPortReadableFrames) received by this\n               port.\n\n               This object has been deprecated because its value\n               is undefined when no frames have been observed on\n               this port.  The replacement object is\n               rptrAddrTrackNewLastSrcAddress."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aLastSourceAddress."), status("deprecated")] string rptrAddrTrackLastSourceAddress;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.3.3.1.1.2"), read, description("This object identifies the port within the group\n               for which this entry contains information."), reference("Reference IEEE 802.3 Rptr Mgt, 19.2.6.2,\n               aPortID."), status("mandatory"), key, key_order(2)] sint32 rptrAddrTrackPortIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("1..1024"), object_identifier("1.3.6.1.2.1.22.3.3.1.1.1"), read, description("This object identifies the group containing the\n               port for which this entry contains information."), status("mandatory"), key, key_order(1)] sint32 rptrAddrTrackGroupIndex;
};

