// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	MOF Generated for module "RFC1316-MIB" by smi2smir version 1.10.635.0000
qualifier write:ToInstance ToSubClass;
qualifier read:ToInstance ToSubClass;
qualifier provider:ToInstance ToSubClass;
qualifier singleton:ToInstance ToSubClass;
qualifier dynamic:ToInstance ToSubClass;
qualifier textual_convention:ToInstance ToSubClass;
qualifier object_identifier:ToInstance ToSubClass;
qualifier encoding:ToInstance ToSubClass;
qualifier object_syntax:ToInstance ToSubClass;
qualifier status:ToInstance ToSubClass;
qualifier fixed_length:ToInstance ToSubClass;
qualifier variable_length:ToInstance ToSubClass;
qualifier variable_value:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier key_order:ToInstance ToSubClass;
qualifier enumeration:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier description:ToInstance ToSubClass;
qualifier display_hint:ToInstance ToSubClass;
qualifier defval:ToInstance ToSubClass;
qualifier units:ToInstance ToSubClass;
qualifier reference:ToInstance ToSubClass;
qualifier virtual_key:ToInstance ToSubClass;
qualifier rowstatus:ToInstance ToSubClass;
qualifier module_name:ToInstance ToSubClass;
qualifier module_imports:ToInstance ToSubClass;
qualifier group_objectid:ToInstance ToSubClass;

#pragma namespace("\\\\.\\root\\snmp")
class SMIR:__namespace
{
[read] string Name="SMIR";
};

instance of SMIR
{
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[abstract]
class SnmpMacro
{
};

[abstract]
class SnmpObjectType:SnmpMacro
{
};

class SnmpNotifyStatus:__ExtendedStatus
{
[write] sint32 SnmpStatusCode;
[write] string Description;
};

class SnmpNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class SnmpExtendedNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class NotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class ExtendedNotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class SNMP_MODULE:__namespace
{
[read] string Name;
[read] string Module_Oid;
[read] string Module_Identity;
[read] string Organization;
[read] string Contact_Inf;
[read] string Description;
[read] string Revision;
[read] string Last_Updated;
[read] sint32 Snmp_Version;
[read] string Module_Imports;
};

[Association]
class ModuleToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class GroupToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirGroup;
};

[Association]
class ModToNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class ModToExtNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
instance of SNMP_MODULE
{
Name="RFC1316_MIB";
Module_Oid="1.3.6.1.2.1.19";
Module_Identity="rfc1316mibV1ModuleIdentity";
Organization="";
Contact_Inf="";
Description="RFC1316-MIB";
Revision="";
Last_Updated="0000000000Z";
Snmp_Version=1;
Module_Imports="RFC1155-SMI,RFC1213-MIB,RFC-1212";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1316_MIB")
class SNMP_GROUP:__namespace
{
[read] string Name;
[read] string Group_Id;
[read] string Status;
[read] string Description;
[read] string Reference;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1316_MIB")
instance of SNMP_GROUP
{
Name="charV1ObjectGroup";
Group_Id="1.3.6.1.2.1.19";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description(""), module_name("RFC1316-MIB"), singleton, group_objectid("1.3.6.1.2.1.19"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1316_MIB_char : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.19.1"), read, description("The number of entries in charPortTable, regardless\n                    of their current state."), status("mandatory")] sint32 charNumber;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1316_MIB_charSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1316_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1316_MIB_char";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1316_MIB_charSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1316_MIB:SNMP_GROUP.Name=\"charV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1316_MIB_char";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of port session entries.\nStatus and parameter values for a character port\n                    session."), module_name("RFC1316-MIB"), group_objectid("1.3.6.1.2.1.19"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1316_MIB_charSessTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.19.3.1.7"), read, description("This session's subset of charPortInCharacters."), status("mandatory")] uint32 charSessInCharacters;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("InstancePointer"), object_identifier("1.3.6.1.2.1.19.3.1.9"), read, description("A reference to additional local MIB information.\n                    This should be the highest available related MIB,\n                    corresponding to charSessProtocol, such as Telnet.\n                    For example, the value for a TCP connection (in the\n                    absence of a Telnet MIB) is the object identifier of\n                    tcpConnState.  If an agent is not configured to have\n                    such values, the agent returns the object\n                    identifier:\n\n                        nullConnectionId OBJECT IDENTIFIER ::= { 0 0 }\n                    "), status("mandatory")] string charSessConnectionId;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.19.3.1.8"), read, description("This session's subset of charPortOutCharacters."), status("mandatory")] uint32 charSessOutCharacters;
	[textual_convention("EnumeratedINTEGER"), enumeration("ready(1),execute(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.3.1.3"), read, write, description("A control to terminate the session.  In response to\n                    a get-request or get-next-request, the agent always\n                    returns 'ready' as the value.  Setting the value to\n                    'execute' causes termination."), status("mandatory")] string charSessKill;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.19.3.1.2"), read, description("The session index in the context of the port, a\n                    non-zero positive integer.  Session indexes within a\n                    port need not be sequential.  Session indexes may be\n                    reused for different ports.  For example, port 1 and\n                    port 3 may both have a session 2 at the same time.\n                    Session indexes may have any valid integer value,\n                    with any meaning convenient to the agent\n                    implementation."), status("mandatory"), key, key_order(2)] sint32 charSessIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("connecting(1),connected(2),disconnecting(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.3.1.4"), read, description("The current operational state of the session,\n                    disregarding flow control.  'connected' indicates\n                    that character data could flow on the network side\n                    of session.  'connecting' indicates moving from\n                    nonexistent toward 'connected'.  'disconnecting'\n                    indicates moving from 'connected' or 'connecting' to\n                    nonexistent."), status("mandatory")] string charSessState;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("AutonomousType"), object_identifier("1.3.6.1.2.1.19.3.1.5"), read, description("The network protocol over which the session is\n                    running.  Other OBJECT IDENTIFIER values may be\n                    defined elsewhere, in association with specific\n                    protocols.  However, this document assigns those of\n                    known interest as of this writing."), status("mandatory")] string charSessProtocol;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.19.3.1.10"), read, description("The value of sysUpTime in MIB-2 when the session\n                    entered connecting state."), status("mandatory")] uint32 charSessStartTime;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.19.3.1.1"), read, description("The value of charPortIndex for the port to which\n                    this session belongs."), status("mandatory"), key, key_order(1)] sint32 charSessPortIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("unknown(1),network(2),local(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.3.1.6"), read, description("The session's source of establishment."), status("mandatory")] string charSessOperOrigin;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1316_MIB_charSessTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1316_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1316_MIB_charSessTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1316_MIB_charSessTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1316_MIB:SNMP_GROUP.Name=\"charV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1316_MIB_charSessTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of port entries.  The number of entries is\n                    given by the value of charNumber.\nStatus and parameter values for a character port."), module_name("RFC1316-MIB"), group_objectid("1.3.6.1.2.1.19"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1316_MIB_charPortTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.19.2.1.13"), read, description("Total number of characters detected as input from\n                    the port since system re-initialization and while\n                    the port operational state was 'up', 'active', or\n                    'maintenance', including, for example, framing, flow\n                    control (i.e. XON and XOFF), each occurrence of a\n                    BREAK condition, locally-processed input, and input\n                    sent to all sessions."), status("mandatory")] uint32 charPortInCharacters;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),unknown(2),stop(3),go(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.12"), read, description("The current operational state of output flow\n                    control on the port.  'none' indicates not\n                    applicable.  'unknown' indicates this level does not\n                    know.  'stop' indicates flow not allowed.  'go'\n                    indicates flow allowed."), status("mandatory")] string charPortOutFlowState;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.18"), read, description("The value of charSessIndex for the port's first or\n                    only active session.  If the port has no active\n                    session, the agent returns the value zero."), status("mandatory")] sint32 charPortSessionIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.19.2.1.14"), read, description("Total number of characters detected as output to\n                    the port since system re-initialization and while\n                    the port operational state was 'up', 'active', or\n                    'maintenance', including, for example, framing, flow\n                    control (i.e. XON and XOFF), each occurrence of a\n                    BREAK condition, locally-created output, and output\n                    received from all sessions."), status("mandatory")] uint32 charPortOutCharacters;
	[textual_convention("Gauge"), encoding("Gauge"), object_syntax("Gauge"), object_identifier("1.3.6.1.2.1.19.2.1.17"), read, description("The number of open sessions on the port that are in\n                    the connecting, connected, or disconnecting state."), status("mandatory")] uint32 charPortSessionNumber;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..32"), object_identifier("1.3.6.1.2.1.19.2.1.2"), read, write, description("An administratively assigned name for the port,\n                    typically with some local significance."), status("mandatory")] string charPortName;
	[textual_convention("EnumeratedINTEGER"), enumeration("physical(1),virtual(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.3"), read, description("The port's type, 'physical' if the port represents\n                    an external hardware connector, 'virtual' if it does\n                    not."), status("mandatory")] string charPortType;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.16"), read, write, description("The maximum number of concurrent sessions allowed\n                    on the port.  A value of -1 indicates no maximum.\n                    Setting the maximum to less than the current number\n                    of sessions has unspecified results."), status("mandatory")] sint32 charPortSessionMaximum;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.1"), read, description("A unique value for each character port.  Its value\n                    ranges between 1 and the value of charNumber.  By\n                    convention and if possible, hardware port numbers\n                    come first, with a simple, direct mapping.  The\n                    value for each port must remain constant at least\n                    from one re-initialization of the network management\n                    agent to the next."), status("mandatory"), key, key_order(1)] sint32 charPortIndex;
	[textual_convention("EnumeratedINTEGER"), enumeration("ready(1),execute(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.5"), read, write, description("A control to force the port into a clean, initial\n                    state, both hardware and software, disconnecting all\n                    the port's existing sessions.  In response to a\n                    get-request or get-next-request, the agent always\n                    returns 'ready' as the value.  Setting the value to\n                    'execute' causes a reset."), status("mandatory")] string charPortReset;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("AutonomousType"), object_identifier("1.3.6.1.2.1.19.2.1.4"), read, description("A reference to hardware MIB definitions specific to\n                    a physical port's external connector.  For example,\n                    if the connector is RS-232, then the value of this\n                    object refers to a MIB sub-tree defining objects\n                    specific to RS-232.  If an agent is not configured\n                    to have such values, the agent returns the object\n                    identifier:\n\n                        nullHardware OBJECT IDENTIFIER ::= { 0 0 }\n                    "), status("mandatory")] string charPortHardware;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.19.2.1.8"), read, description("The value of sysUpTime at the time the port entered\n                    its current operational state.  If the current state\n                    was entered prior to the last reinitialization of\n                    the local network management subsystem, then this\n                    object contains a zero value."), status("mandatory")] uint32 charPortLastChange;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),xonXoff(2),hardware(3),ctsRts(4),dsrDtr(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.9"), read, write, description("The port's type of input flow control.  'none'\n                    indicates no flow control at this level or below.\n                    'xonXoff' indicates software flow control by\n                    recognizing XON and XOFF characters.  'hardware'\n                    indicates flow control delegated to the lower level,\n                    for example a parallel port.\n\n                    'ctsRts' and 'dsrDtr' are specific to RS-232-like\n                    ports.  Although not architecturally pure, they are\n                    included here for simplicity's sake."), status("mandatory")] string charPortInFlowType;
	[textual_convention("EnumeratedINTEGER"), enumeration("up(1),down(2),maintenance(3),absent(4),active(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.7"), read, description("The port's actual, operational state, independent\n                    of flow control.  'up' indicates able to function\n                    normally.  'down' indicates inability to function\n                    for administrative or operational reasons.\n                    'maintenance' indicates a maintenance mode,\n                    exclusive of normal operation, such as running a\n                    test.  'absent' indicates that port hardware is not\n                    present.  'active' indicates up with a user present\n                    (e.g. logged in)."), status("mandatory")] string charPortOperStatus;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),unknown(2),stop(3),go(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.11"), read, description("The current operational state of input flow control\n                    on the port.  'none' indicates not applicable.\n                    'unknown' indicates this level does not know.\n                    'stop' indicates flow not allowed.  'go' indicates\n                    flow allowed."), status("mandatory")] string charPortInFlowState;
	[textual_convention("EnumeratedINTEGER"), enumeration("dynamic(1),network(2),local(3),none(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.15"), read, write, description("The administratively allowed origin for\n                    establishing session on the port.  'dynamic' allows\n                    'network' or 'local' session establishment. 'none'\n                    disallows session establishment."), status("mandatory")] string charPortAdminOrigin;
	[textual_convention("EnumeratedINTEGER"), enumeration("enabled(1),disabled(2),off(3),maintenance(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.6"), read, write, description("The port's desired state, independent of flow\n                    control.  'enabled' indicates that the port is\n                    allowed to pass characters and form new sessions.\n                    'disabled' indicates that the port is allowed to\n                    pass characters but not form new sessions.  'off'\n                    indicates that the port is not allowed to pass\n                    characters or have any sessions. 'maintenance'\n                    indicates a maintenance mode, exclusive of normal\n                    operation, such as running a test."), status("mandatory")] string charPortAdminStatus;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),xonXoff(2),hardware(3),ctsRts(4),dsrDtr(5)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.19.2.1.10"), read, write, description("The port's type of output flow control.  'none'\n                    indicates no flow control at this level or below.\n                    'xonXoff' indicates software flow control by\n                    recognizing XON and XOFF characters.  'hardware'\n                    indicates flow control delegated to the lower level,\n                    for example a parallel port.\n\n                    'ctsRts' and 'dsrDtr' are specific to RS-232-like\n                    ports.  Although not architecturally pure, they are\n                    included here for simplicy's sake."), status("mandatory")] string charPortOutFlowType;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1316_MIB_charPortTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1316_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1316_MIB_charPortTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1316_MIB_charPortTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1316_MIB:SNMP_GROUP.Name=\"charV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1316_MIB_charPortTable";
};


