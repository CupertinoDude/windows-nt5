// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	MOF Generated for module "RFC1382-MIB" by smi2smir version 1.10.635.0000
qualifier write:ToInstance ToSubClass;
qualifier read:ToInstance ToSubClass;
qualifier provider:ToInstance ToSubClass;
qualifier singleton:ToInstance ToSubClass;
qualifier dynamic:ToInstance ToSubClass;
qualifier textual_convention:ToInstance ToSubClass;
qualifier object_identifier:ToInstance ToSubClass;
qualifier encoding:ToInstance ToSubClass;
qualifier object_syntax:ToInstance ToSubClass;
qualifier status:ToInstance ToSubClass;
qualifier fixed_length:ToInstance ToSubClass;
qualifier variable_length:ToInstance ToSubClass;
qualifier variable_value:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier key_order:ToInstance ToSubClass;
qualifier enumeration:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier description:ToInstance ToSubClass;
qualifier display_hint:ToInstance ToSubClass;
qualifier defval:ToInstance ToSubClass;
qualifier units:ToInstance ToSubClass;
qualifier reference:ToInstance ToSubClass;
qualifier virtual_key:ToInstance ToSubClass;
qualifier rowstatus:ToInstance ToSubClass;
qualifier module_name:ToInstance ToSubClass;
qualifier module_imports:ToInstance ToSubClass;
qualifier group_objectid:ToInstance ToSubClass;

#pragma namespace("\\\\.\\root\\snmp")
class SMIR:__namespace
{
[read] string Name="SMIR";
};

instance of SMIR
{
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[abstract]
class SnmpMacro
{
};

[abstract]
class SnmpObjectType:SnmpMacro
{
};

class SnmpNotifyStatus:__ExtendedStatus
{
[write] sint32 SnmpStatusCode;
[write] string Description;
};

class SnmpNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class SnmpExtendedNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class NotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class ExtendedNotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class SNMP_MODULE:__namespace
{
[read] string Name;
[read] string Module_Oid;
[read] string Module_Identity;
[read] string Organization;
[read] string Contact_Inf;
[read] string Description;
[read] string Revision;
[read] string Last_Updated;
[read] sint32 Snmp_Version;
[read] string Module_Imports;
};

[Association]
class ModuleToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class GroupToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirGroup;
};

[Association]
class ModToNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class ModToExtNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
instance of SNMP_MODULE
{
Name="RFC1382_MIB";
Module_Oid="1.3.6.1.2.1.10.5";
Module_Identity="rfc1382mibV1ModuleIdentity";
Organization="";
Contact_Inf="";
Description="RFC1382-MIB";
Revision="";
Last_Updated="0000000000Z";
Snmp_Version=1;
Module_Imports="RFC1155-SMI,RFC-1212,RFC1213-MIB,RFC-1215,RFC1271-MIB,RFC1381-MIB";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB")
class SNMP_GROUP:__namespace
{
[read] string Name;
[read] string Group_Id;
[read] string Status;
[read] string Description;
[read] string Reference;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB")
instance of SNMP_GROUP
{
Name="x25V1ObjectGroup";
Group_Id="1.3.6.1.2.1.10.5";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description(""), module_name("RFC1382-MIB"), singleton, group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25 : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.7"), read, description("The actual number of entries the agent will\n                          keep in the x25ClearedCircuit Table."), status("mandatory")] sint32 x25ClearedCircuitEntriesGranted;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.6"), read, write, description("The requested number of entries for the\n                          agent to keep in the x25ClearedCircuit\n                          table."), status("mandatory")] sint32 x25ClearedCircuitEntriesRequested;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25SMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25SMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("These objects contain the parameters that\n                          can be varied between X.25 calls.  The\n                          entries in this table are independent of the\n                          PLE.  There exists only one of these tables\n                          for the entire system.  The indexes for the\n                          entries are independent of any PLE or any\n                          circuit.  Other tables reference entries in\n                          this table.  Entries in this table can be\n                          used for default PLE parameters, for\n                          parameters to use to place/answer a call,\n                          for the parameters currently in use for a\n                          circuit, or parameters that were used by a\n                          circuit.\n\n                          The number of references to a given set of\n                          parameters can be found in the\n                          x25CallParmRefCount object sharing the same\n                          instance identifier with the parameters.\n                          The value of this reference count also\n                          affects the access of the objects in this\n                          table.  An object in this table with the\n                          same instance identifier as the instance\n                          identifier of an x25CallParmRefCount must be\n                          consider associated with that reference\n                          count.  An object with an associated\n                          reference count of zero can be written (if\n                          its ACCESS clause allows it).  An object\n                          with an associated reference count greater\n                          than zero can not be written (regardless of\n                          the ACCESS clause).  This ensures that a set\n                          of call parameters being referenced from\n                          another table can not be modified or changed\n                          in a ways inappropriate for continued use by\n                          that table.\nEntries of x25CallParmTable."), module_name("RFC1382-MIB"), group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25CallParmTable : SnmpObjectType
{
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..6"), object_identifier("1.3.6.1.2.1.10.5.9.1.24"), read, write, description("The End-to-End Transit Delay to negotiate.\n                          An octet string of length 2, 4, or 6\n                          contains the facility encoded as specified\n                          in ISO/IEC 8208 section 15.3.2.4.  An octet\n                          string of length 3 containing the three\n                          character DEF for a circuit means use the\n                          PLE default (the entry for the PLE default\n                          can not contain the characters DEF).  A zero\n                          length string indicates no facility\n                          requested."), reference("See ISO 8208 Section 15.3.2.4"), status("mandatory"), defval("")] string x25CallParmEndTrnsDly;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..40"), object_identifier("1.3.6.1.2.1.10.5.9.1.20"), read, write, description("The Calling Extension facility.  This\n                          contains one of the following:\n\n                          A sequence of hex digits with the value to\n                          be put in the facility. These digits will be\n                          converted to binary by the agent and put in\n                          the facility.  These octets do not include\n                          the length octet.\n\n                          A value containing the three character DEF\n                          for a circuit means use the PLE default,\n                          (the entry for the PLE default parameters\n                          may not use the value DEF).\n\n                          A zero length string indicates no facility\n                          requested."), reference("See ISO 8208 Section 15.3.2.1"), status("mandatory"), defval("")] string x25CallParmCallingExt;
	[textual_convention("EnumeratedINTEGER"), enumeration("default(1),notSpecified(2),fastSelect(3),restrictedFastResponse(4),noFastSelect(5),noRestrictedFastResponse(6)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.9.1.10"), read, write, description("Expresses preference for use of fast select\n                          facility.  The value of default for a\n                          circuit is the PLE default.  A value of\n                          default for the PLE means noFastSelect.  A\n                          value of noFastSelect or\n                          noRestrictedFastResponse indicates a circuit\n                          may not use fast select or restricted fast\n                          response."), reference("10733 fastSelect;\n                  Sec ISO 8208 Section 15.2.2.6"), status("mandatory"), defval("5")] string x25CallParmFastSelect;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..108"), object_identifier("1.3.6.1.2.1.10.5.9.1.26"), read, write, description("A string contains the following:\n                          A hex string containing the value for the\n                          protection facility.  This will be converted\n                          from hex to the octets actually in the\n                          packet by the agent.  The agent will supply\n                          the length field and the length octet is not\n                          contained in this string.\n\n                          An string containing the 3 characters DEF\n                          for a circuit means use the PLE default (the\n                          entry for the PLE default parameters may not\n                          use the value DEF).\n\n                          A zero length string mean no facility\n                          requested."), reference("See ISO 8208 Section 15.3.2.5"), status("mandatory"), defval("")] string x25CallParmProtection;
	[textual_convention("EnumeratedINTEGER"), enumeration("default(1),accept(2),refuse(3),neverAccept(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.9.1.8"), read, write, description("An enumeration defining if the PLE will\n                          accept or refuse charges.  A value of\n                          default for a circuit means use the PLE\n                          default value.  A value of neverAccept is\n                          only used for the PLE default and indicates\n                          the PLE will never accept reverse charging.\n                          A value of default for a PLE default means\n                          refuse."), reference("10733 acceptReverseCharging"), status("mandatory"), defval("3")] string x25CallParmAcceptReverseCharging;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4096"), object_identifier("1.3.6.1.2.1.10.5.9.1.4"), read, write, description("The maximum receive packet size in octets\n                          for a circuit.  A size of zero for a circuit\n                          means use the PLE default size.  A size of\n                          zero for the PLE means use a default size of\n                          128."), reference("10733 proposedPacketSize;\n                          See ISO 8208 Section 15.2.2.1.1"), status("mandatory"), defval("128")] sint32 x25CallParmInPacketSize;
	[textual_convention("EnumeratedINTEGER"), enumeration("default(1),noFacility(2),noChargingInfo(3),chargingInfo(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.9.1.17"), read, write, description("The charging Information facility.  A value\n                          of default for a circuit means use the PLE\n                          default.  The value of default for the\n                          default PLE parameters means use noFacility.\n                          The value of noFacility means do not include\n                          a facility."), reference("See ISO 8208 Section 15.2.2.8"), status("mandatory"), defval("2")] string x25CallParmChargingInfo;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..127"), object_identifier("1.3.6.1.2.1.10.5.9.1.6"), read, write, description("The receive window size for a circuit.  A\n                          size of zero for a circuit means use the PLE\n                          default size.  A size of zero for the PLE\n                          default means use 2."), reference("10733 proposedWindowSize;\n                          See ISO 8208 Section 15.2.2.1.2"), status("mandatory"), defval("2")] sint32 x25CallParmInWindowSize;
	[textual_convention("EnumeratedINTEGER"), enumeration("default(1),reverse(2),local(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.9.1.9"), read, write, description("An enumeration defining if the PLE should\n                          propose reverse or local charging.  The\n                          value of default for a circuit means use the\n                          PLE default.  The value of default for the\n                          PLE default means use local."), reference("10733 proposedPacketSize;\n                          See ISO 8208 Section 15.2.2.6"), status("mandatory"), defval("3")] string x25CallParmProposeReverseCharging;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..4"), object_identifier("1.3.6.1.2.1.10.5.9.1.13"), read, write, description("The Closed User Group to specify.  This\n                          consists of two or four octets containing\n                          the characters 0 through 9.  A zero length\n                          string indicates no facility requested.  A\n                          string length of three containing the\n                          characters DEF for a circuit means use the\n                          PLE default, (the PLE default parameter may\n                          not reference an entry of DEF.)"), reference("See ISO 8208 Section 15.2.2.3"), status("mandatory"), defval("")] string x25CallParmCug;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..108"), object_identifier("1.3.6.1.2.1.10.5.9.1.16"), read, write, description("The Network User Identifier facility.  This\n                          is binary value to be included immediately\n                          after the length field.  The PLE will supply\n                          the length octet.  A zero length string\n                          indicates no facility requested.  This value\n                          is ignored for the PLE default parameters\n                          entry."), reference("See ISO 8208 Section 15.2.2.7"), status("mandatory"), defval("")] string x25CallParmNui;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4096"), object_identifier("1.3.6.1.2.1.10.5.9.1.5"), read, write, description("The maximum transmit packet size in octets\n                          for a circuit.  A size of zero for a circuit\n                          means use the PLE default size.  A size of\n                          zero for the PLE default means use a default\n                          size of 128."), reference("10733 proposedPacketSize;\n                          See ISO 8208 Section 15.2.2.1.1"), status("mandatory"), defval("128")] sint32 x25CallParmOutPacketSize;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..108"), object_identifier("1.3.6.1.2.1.10.5.9.1.30"), read, write, description("The called network facilities.  The\n                          facilities are encoded here exactly as\n                          encoded in the call packet.  These\n                          facilities do not include the marker\n                          facility code.\n\n                          A zero length string in the entry for the\n                          parameter to use when establishing a circuit\n                          means use the PLE default.  A zero length\n                          string in the entry for PLE default\n                          parameters indicates no default facilities."), reference("See ISO 8206 Section 15.1, category c"), status("mandatory"), defval("")] string x25CallParmCalledNetworkFacilities;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..127"), object_identifier("1.3.6.1.2.1.10.5.9.1.7"), read, write, description("The transmit window size for a circuit.  A\n                          size of zero for a circuit means use the PLE\n                          default size.  A size of zero for the PLE\n                          default means use 2."), reference("10733 proposedWindowSize;\n                          See ISO 8208 Section 15.2.2.1.2"), status("mandatory"), defval("2")] sint32 x25CallParmOutWindowSize;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..17"), object_identifier("1.3.6.1.2.1.10.5.9.1.22"), read, write, description("The minimum input throughput Class.  A\n                          value of 16 for a circuit means use the PLE\n                          default (the PLE parameters entry may not\n                          use this value).  A value of 17 indicates no\n                          facility requested."), reference("See ISO 8208 Section 15.3.2.3"), status("mandatory"), defval("17")] sint32 x25CallParmInMinThuPutCls;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..3"), object_identifier("1.3.6.1.2.1.10.5.9.1.15"), read, write, description("The Bilateral Closed User Group to specify.\n                          This consists of two octets containing the\n                          characters 0 through 9.  A string length of\n                          three containing the characters DEF for a\n                          circuit means use the PLE default (the PLE\n                          default parameter may not reference an entry\n                          of DEF).  A zero length string indicates no\n                          facility requested."), reference("See ISO 8208 Section 15.2.2.5"), status("mandatory"), defval("")] string x25CallParmBcug;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..108"), object_identifier("1.3.6.1.2.1.10.5.9.1.18"), read, write, description("The RPOA facility.  The octet string\n                          contains n * 4 sequences of the characters\n                          0-9 to specify a facility with n entries.\n                          The octet string containing the 3 characters\n                          DEF for a circuit specifies use of the PLE\n                          default (the entry for the PLE default may\n                          not contain DEF).  A zero length string\n                          indicates no facility requested."), reference("See ISO 8208, section 15.2.2.9"), status("mandatory"), defval("")] string x25CallParmRpoa;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..108"), object_identifier("1.3.6.1.2.1.10.5.9.1.29"), read, write, description("The calling network facilities.  The\n                          facilities are encoded here exactly as\n                          encoded in the call packet.  These\n                          facilities do not include the marker\n                          facility code.\n\n                          A zero length string in the entry for the\n                          parameter to use when establishing a circuit\n                          means use the PLE default.  A zero length\n                          string in the entry for PLE default\n                          parameters indicates no default facilities."), reference("See ISO 8206 Section 15.1, category b"), status("mandatory"), defval("")] string x25CallParmCallingNetworkFacilities;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..4"), object_identifier("1.3.6.1.2.1.10.5.9.1.14"), read, write, description("The Closed User Group with Outgoing Access\n                          to specify.  This consists of two or four\n                          octets containing the characters 0 through\n                          9.  A string length of three containing the\n                          characters DEF for a circuit means use the\n                          PLE default (the PLE default parameters may\n                          not reference an entry of DEF).  A zero\n                          length string indicates no facility\n                          requested."), reference("See ISO 8208 Section 15.2.2.4"), status("mandatory"), defval("")] string x25CallParmCugoa;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.9.1.1"), read, description("A value that distinguishes this entry from\n                          another entry.  Entries in this table are\n                          referenced from other objects which identify\n                          call parameters.\n\n                          It is impossible to know which other objects\n                          in the MIB reference entries in the table by\n                          looking at this table.  Because of this,\n                          changes to parameters must be accomplished\n                          by creating a new entry in this table and\n                          then changing the referencing table to\n                          identify the new entry.\n\n                          Note that an agent will only use the values\n                          in this table when another table is changed\n                          to reference those values.  The number of\n                          other tables that reference an index object\n                          in this table can be found in\n                          x25CallParmRefCount.  The value of the\n                          reference count will affect the writability\n                          of the objects as explained above.\n\n                          Entries in this table which have a reference\n                          count of zero maybe deleted at the convence\n                          of the agent.  Care should be taken by the\n                          agent to give the NMS sufficient time to\n                          create a reference to newly created entries.\n\n                          Should a Management Station not find a free\n                          index with which to create a new entry, it\n                          may feel free to delete entries with a\n                          reference count of zero.  However in doing\n                          so the Management Station much realize it\n                          may impact other Management Stations."), status("mandatory"), key, key_order(1)] sint32 x25CallParmIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..17"), object_identifier("1.3.6.1.2.1.10.5.9.1.23"), read, write, description("The minimum output throughput Class.  A\n                          value of 16 for a circuit means use the PLE\n                          default (the PLE parameters entry may not\n                          use this value).  A value of 17 indicates no\n                          facility requested."), reference("See ISO 8208 Section 15.3.2.3"), status("mandatory"), defval("17")] sint32 x25CallParmOutMinThuPutCls;
	[textual_convention("EnumeratedINTEGER"), enumeration("valid(1),createRequest(2),underCreation(3),invalid(4)"), encoding("INTEGER"), object_syntax("EntryStatus"), object_identifier("1.3.6.1.2.1.10.5.9.1.2"), read, write, description("The status of this call parameter entry.\n                          See RFC 1271 for details of usage."), status("mandatory")] string x25CallParmStatus;
	[textual_convention("EnumeratedINTEGER"), enumeration("tcReserved1(1),tcReserved2(2),tc75(3),tc150(4),tc300(5),tc600(6),tc1200(7),tc2400(8),tc4800(9),tc9600(10),tc19200(11),tc48000(12),tc64000(13),tcReserved14(14),tcReserved15(15),tcReserved0(16),tcNone(17),tcDefault(18)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.9.1.11"), read, write, description("The incoming throughput class to negotiate.\n                          A value of tcDefault for a circuit means use\n                          the PLE default.  A value of tcDefault for\n                          the PLE default means tcNone.  A value of\n                          tcNone means do not negotiate throughtput\n                          class."), reference("See ISO 8208 Section 15.2.2.2, table 18"), status("mandatory"), defval("17")] string x25CallParmInThruPutClasSize;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..128"), object_identifier("1.3.6.1.2.1.10.5.9.1.28"), read, write, description("The call user data as placed in the packet.\n                          A zero length string indicates no call user\n                          data.  If both the circuit call parameters\n                          and the PLE default have call user data\n                          defined, the data from the circuit call\n                          parameters will be used.  If only the PLE\n                          has data defined, the PLE entry will be\n                          used.  If neither the circuit call\n                          parameters or the PLE default entry has a\n                          value, no call user data will be sent."), reference("See ISO 8208 Section 12.2.1.1.6, 12.2.1.2"), status("mandatory"), defval("")] string x25CallParmUserData;
	[textual_convention("EnumeratedINTEGER"), enumeration("default(1),noExpeditedData(2),expeditedData(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.9.1.27"), read, write, description("The Expedited Data facility to negotiate.\n                          A value of default for a circuit means use\n                          the PLE default value.  The entry for the\n                          PLE default parameters may not have the\n                          value default."), reference("See ISO 8208 Section 15.3.2.7"), status("mandatory"), defval("2")] string x25CallParmExptData;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.9.1.3"), read, description("The number of references know by a\n                          management station to exist to this set of\n                          call parameters.  This is the number of\n                          other objects that have returned a value of,\n                          and will return a value of, the index for\n                          this set of call parameters.  Examples of\n                          such objects are the x25AdmnDefCallParamId,\n                          x25OperDataLinkId, or x25AdmnDefCallParamId\n                          objects defined above."), status("mandatory")] sint32 x25CallParmRefCount;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65537"), object_identifier("1.3.6.1.2.1.10.5.9.1.19"), read, write, description("The Transit Delay Selection and Indication\n                          value.  A value of 65536 indicates no\n                          facility requested.  A value of 65537 for a\n                          circuit means use the PLE default (the PLE\n                          default parameters entry may not use the\n                          value 65537).  The value 65535 may only be\n                          used to indicate the value in use by a\n                          circuit."), reference("See ISO 8208, Section 15.2.2.13"), status("mandatory"), defval("65536")] sint32 x25CallParmTrnstDly;
	[textual_convention("EnumeratedINTEGER"), enumeration("tcReserved1(1),tcReserved2(2),tc75(3),tc150(4),tc300(5),tc600(6),tc1200(7),tc2400(8),tc4800(9),tc9600(10),tc19200(11),tc48000(12),tc64000(13),tcReserved14(14),tcReserved15(15),tcReserved0(16),tcNone(17),tcDefault(18)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.9.1.12"), read, write, description("The outgoing throughput class to negotiate.\n                          A value of tcDefault for a circuit means use\n                          the PLE default.  A value of tcDefault for\n                          the PLE default means use tcNone.  A value\n                          of tcNone means do not negotiate throughtput\n                          class."), reference("See ISO 8208 Section 15.2.2.2, table 18"), status("mandatory"), defval("17")] string x25CallParmOutThruPutClasSize;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..6"), object_identifier("1.3.6.1.2.1.10.5.9.1.25"), read, write, description("The priority facility to negotiate.  The\n                          octet string encoded as specified in ISO/IEC\n                          8208 section 15.3.2.5.  A zero length string\n                          indicates no facility requested.  The entry\n                          for the PLE default parameters must be zero\n                          length."), reference("See ISO 8208 Section 15.3.2.5"), status("mandatory"), defval("")] string x25CallParmPriority;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..40"), object_identifier("1.3.6.1.2.1.10.5.9.1.21"), read, write, description("The Called Extension facility.  This\n                          contains one of the following:\n\n                          A sequence of hex digits with the value to\n                          be put in the facility.  These digits will be\n                          converted to binary by the agent and put in\n                          the facility.  These octets do not include\n                          the length octet.\n\n                          A value containing the three character DEF\n                          for a circuit means use the PLE default,\n                          (the entry for the PLE default parameters\n                          may not use the value DEF).\n\n                          A zero length string indicates no facility\n                          requested."), reference("See ISO 8208 Section 15.3.2.2"), status("mandatory"), defval("")] string x25CallParmCalledExt;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25CallParmTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25CallParmTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25CallParmTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25CallParmTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("Statistics information about this X.25\n                          PLE.\nEntries of the x25StatTable."), module_name("RFC1382-MIB"), group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25StatTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.20"), read, description("The number of times the T22 reset timer\n                          expired."), reference("10733 5.9 resetTimeouts"), status("mandatory")] uint32 x25StatResetTimeouts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.13"), read, description("The number of interrupt packets send by the\n                          PLE or over the PVC/VC."), reference("10733 InterruptPacketsSent"), status("mandatory")] uint32 x25StatOutInterrupts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.3"), read, description("The number of incoming calls refused.  This\n                          includes calls refused by the PLE and by\n                          higher layers.  This also includes calls\n                          cleared because of restricted fast select."), status("mandatory")] uint32 x25StatInCallRefusals;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.14"), read, description("The number of data packets sent by this\n                          PLE."), reference("10733 dataPacketSent"), status("mandatory")] uint32 x25StatOutDataPackets;
	[textual_convention("Gauge"), encoding("Gauge"), object_syntax("Gauge"), object_identifier("1.3.6.1.2.1.10.5.3.1.17"), read, description("The number of active two-way Circuits.\n                          This includes call requests sent but not yet\n                          confirmed.  This does not count PVCs."), status("mandatory")] uint32 x25StatTwowayCircuits;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("IfIndexType"), variable_value("1..2147483647"), object_identifier("1.3.6.1.2.1.10.5.3.1.1"), read, description("The ifIndex value for the X.25 interface."), status("mandatory"), key, key_order(1)] sint32 x25StatIndex;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.12"), read, description("The number of call attempts which failed.\n                          This includes calls that were cleared\n                          because of restrictive fast select."), status("mandatory")] uint32 x25StatOutCallFailures;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.11"), read, description("The number of calls attempted."), reference("10733 5.9 callAttempts"), status("mandatory")] uint32 x25StatOutCallAttempts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.9"), read, description("The number of packets received containing a\n                          procedure error cause code.  These include\n                          clear, reset, restart, or diagnostic\n                          packets."), reference("CD 10733 5.9 accusedOfProtocolError"), status("mandatory")] uint32 x25StatInAccusedOfProtocolErrors;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.4"), read, description("The number of clear requests with a cause\n                          code other than DTE initiated."), reference("10733 providerInitiatedDisconnect"), status("mandatory")] uint32 x25StatInProviderInitiatedClears;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.6"), read, description("The number of reset requests received with\n                          cause code other than DTE initiated."), reference("10733 ProviderInitiatedResets"), status("mandatory")] uint32 x25StatInProviderInitiatedResets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.5"), read, description("The number of reset requests received with\n                          cause code DTE initiated."), reference("10733 remotelyInitiatedResets"), status("mandatory")] uint32 x25StatInRemotelyInitiatedResets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.18"), read, description("The number of times the T20 restart timer\n                          expired."), reference("10733 5.9 restartTimeouts"), status("mandatory")] uint32 x25StatRestartTimeouts;
	[textual_convention("Gauge"), encoding("Gauge"), object_syntax("Gauge"), object_identifier("1.3.6.1.2.1.10.5.3.1.16"), read, description("The number of active Incoming Circuits.\n                          This includes call indications received but\n                          not yet acknowledged.  This does not count\n                          PVCs."), status("mandatory")] uint32 x25StatIncomingCircuits;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.22"), read, description("The number of times the T25 data timer\n                          expired."), reference("10733 5.9 dataRetransmissionsTimerExpiries"), status("mandatory")] uint32 x25StatDataRxmtTimeouts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.2"), read, description("The number of incoming calls received."), status("mandatory")] uint32 x25StatInCalls;
	[textual_convention("Gauge"), encoding("Gauge"), object_syntax("Gauge"), object_identifier("1.3.6.1.2.1.10.5.3.1.15"), read, description("The number of active outgoing circuits.\n                          This includes call requests sent but not yet\n                          confirmed.  This does not count PVCs."), status("mandatory")] uint32 x25StatOutgoingCircuits;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.23"), read, description("The number of times the T26 interrupt timer\n                          expired."), reference("10733 5.9 interruptTimerExpires"), status("mandatory")] uint32 x25StatInterruptTimeouts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.25"), read, description("The number of times the R23 clear count was\n                          exceeded."), reference("10733 5.9 clearCountsExceeded"), status("mandatory")] uint32 x25StatClearCountExceededs;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.24"), read, description("The number of times a retry counter was\n                          exhausted."), reference("10733 5.9 retryCountsExceeded"), status("mandatory")] uint32 x25StatRetryCountExceededs;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.7"), read, description("The number of remotely initiated (including\n                          provider initiated) restarts experienced by\n                          the PLE excluding the restart associated\n                          with bringing up the PLE interface.  This\n                          only counts restarts received when the PLE\n                          already has an established connection with\n                          the remove PLE."), reference("10733 5.9 remotelyInitiatedRestarts"), status("mandatory")] uint32 x25StatInRestarts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.19"), read, description("The number of times the T21 call timer\n                          expired."), reference("10733 5.9 callTimeouts"), status("mandatory")] uint32 x25StatCallTimeouts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.10"), read, description("The number of interrupt packets received by\n                          the PLE or over the PVC/VC."), reference("10733 interruptPacketsReceived"), status("mandatory")] uint32 x25StatInInterrupts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.8"), read, description("The number of data packets received."), reference("10733 5.9 dataPacketsReceived."), status("mandatory")] uint32 x25StatInDataPackets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.3.1.21"), read, description("The number of times the T23 clear timer\n                          expired."), reference("10733 5.9 clearTimeouts"), status("mandatory")] uint32 x25StatClearTimeouts;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25StatTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25StatTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25StatTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25StatTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A table of entries about closed circuits.\n                          Entries must be made in this table whenever\n                          circuits are closed and the close request or\n                          close indication packet contains a clearing\n                          cause other than DTE Originated or a\n                          Diagnostic code field other than Higher\n                          Layer Initiated disconnection-normal.  An\n                          agent may optionally make entries for normal\n                          closes (to record closing facilities or\n                          other information).\n\n                          Agents will delete the oldest entry in the\n                          table when adding a new entry would exceed\n                          agent resources.  Agents are required to\n                          keep the last entry put in the table and may\n                          keep more entries.  The object\n                          x25OperClearEntriesGranted returns the\n                          maximum number of entries kept in the\n                          table.\nInformation about a cleared circuit."), module_name("RFC1382-MIB"), group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25ClearedCircuitTable : SnmpObjectType
{
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("X121Address"), variable_length("0..17"), object_identifier("1.3.6.1.2.1.10.5.8.1.11"), read, description("The calling address from the cleared\n                          circuit."), status("mandatory")] string x25ClearedCircuitCallingAddress;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..255"), object_identifier("1.3.6.1.2.1.10.5.8.1.7"), read, description("The Diagnostic Code from the clear request\n                          or clear indication packet that cleared the\n                          circuit."), reference("See ISO 8208 Section 12.2.3.1.2"), status("mandatory")] sint32 x25ClearedCircuitDiagnosticCode;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.8.1.1"), read, description("An index that uniquely distinguishes one\n                          entry in the clearedCircuitTable from\n                          another.  This index will start at\n                          2147483647 and will decrease by one for each\n                          new entry added to the table.  Upon reaching\n                          one, the index will reset to 2147483647.\n                          Because the index starts at 2147483647 and\n                          decreases, a manager may do a getnext on\n                          entry zero and obtain the most recent entry.\n                          When the index has the value of 1, the next\n                          entry will delete all entries in the table\n                          and that entry will be numbered 2147483647."), status("mandatory"), key, key_order(1)] sint32 x25ClearedCircuitIndex;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), variable_length("0..109"), object_identifier("1.3.6.1.2.1.10.5.8.1.12"), read, description("The facilities field from the clear request\n                          or clear indication packet that cleared the\n                          circuit.  A size of zero indicates no\n                          facilities were present."), status("mandatory")] string x25ClearedCircuitClearFacilities;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.10.5.8.1.3"), read, description("The value of sysUpTime when the circuit was\n                          established.  This will be the same value\n                          that was in the x25CircuitEstablishTime for\n                          the circuit."), status("mandatory")] uint32 x25ClearedCircuitTimeEstablished;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.8.1.8"), read, description("The number of PDUs received on the\n                          circuit."), status("mandatory")] uint32 x25ClearedCircuitInPdus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.8.1.5"), read, description("The channel number for the circuit that was\n                          cleared."), status("mandatory")] sint32 x25ClearedCircuitChannel;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.8.1.9"), read, description("The number of PDUs transmitted on the\n                          circuit."), status("mandatory")] uint32 x25ClearedCircuitOutPdus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("IfIndexType"), variable_value("1..2147483647"), object_identifier("1.3.6.1.2.1.10.5.8.1.2"), read, description("The value of ifIndex for the PLE which\n                          cleared the circuit that created the entry."), status("mandatory")] sint32 x25ClearedCircuitPleIndex;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.10.5.8.1.4"), read, description("The value of sysUpTime when the circuit was\n                          cleared.  For locally initiated clears, this\n                          will be the time when the clear confirmation\n                          was received.  For remotely initiated\n                          clears, this will be the time when the clear\n                          indication was received."), status("mandatory")] uint32 x25ClearedCircuitTimeCleared;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("X121Address"), variable_length("0..17"), object_identifier("1.3.6.1.2.1.10.5.8.1.10"), read, description("The called address from the cleared\n                          circuit."), status("mandatory")] string x25ClearedCircuitCalledAddress;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..255"), object_identifier("1.3.6.1.2.1.10.5.8.1.6"), read, description("The Clearing Cause from the clear request\n                          or clear indication packet that cleared the\n                          circuit."), reference("See ISO 8208 Section 12.2.3.1.1"), status("mandatory")] sint32 x25ClearedCircuitClearingCause;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25ClearedCircuitTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25ClearedCircuitTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25ClearedCircuitTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25ClearedCircuitTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("This table contains the administratively\n                          set configuration parameters for an X.25\n                          Packet Level Entity (PLE).\n\n                         Most of the objects in this table have\n                          corresponding objects in the x25OperTable.\n                          This table contains the values as last set\n                          by the administrator.  The x25OperTable\n                          contains the values actually in use by an\n                          X.25 PLE.\n\n                          Changing an administrative value may or may\n                          not change a current operating value.  The\n                          operating value may not change until the\n                          interface is restarted.  Some\n                          implementations may change the values\n                          immediately upon changing the administrative\n                          table.  All implementations are required to\n                          load the values from the administrative\n                          table when initializing a PLE.\nEntries of x25AdmnTable."), module_name("RFC1382-MIB"), group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25AdmnTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.11"), read, write, description("The T26 interrupt timer in milliseconds.  A\n                          value of 2147483647 indicates no interrupt\n                          timer in use."), reference("10733 interruptTime;\n                          See ISO 8208 Section 6.8.1, table 26"), status("mandatory")] sint32 x25AdmnInterruptTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("IfIndexType"), variable_value("1..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.1"), read, description("The ifIndex value for the X.25 Interface."), status("mandatory"), key, key_order(1)] sint32 x25AdmnIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.13"), read, write, description("The T28 registration timer in milliseconds.\n                          A value of 2147483647 indicates no\n                          registration timer in use."), reference("10733 5.8.1 registrationRequestTime (opt)\n                          See ISO 8208    Section 13.1.1.1, table 26"), status("mandatory")] sint32 x25AdmnRegistrationRequestTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.1.1.20"), read, write, description("The R28 Registration retransmission Count.\n                          This value is irrelevant if the\n                          x25AdmnRegistrationRequestTimer indicates no\n                          timer in use."), reference("10733 5.8.1 registrationRequestCount (opt);\n                          See ISO 8208    Section 13.1.1.1, table 27"), status("mandatory")] sint32 x25AdmnRegistrationRequestCount;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.5.1.1.24"), read, write, description("Identifies the version of the X.25 protocol\n                          this interface should support.  Object\n                          identifiers for common versions are defined\n                          below in the x25ProtocolVersion subtree."), reference("10733 5.9 protocolVersionSupported"), status("mandatory")] string x25AdmnProtocolVersionSupported;
	[textual_convention("EnumeratedINTEGER"), enumeration("modulo8(1),modulo128(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.1.1.4"), read, write, description("The modulus of the packet sequence number\n                          space."), reference("10733 extendedPacketSequencing;\n                          See ISO 8208 Section 7.1.1"), status("mandatory")] string x25AdmnPacketSequencing;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4096"), object_identifier("1.3.6.1.2.1.10.5.1.1.3"), read, write, description("The maximum number of circuits this PLE can\n                          support; including PVCs."), reference("10733 5.9 maxActiveCircuits;\n                          See ISO 8208, Section 3.7"), status("mandatory")] sint32 x25AdmnMaxActiveCircuits;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.14"), read, write, description("Minimum time interval between unsuccessful\n                          call attempts in milliseconds."), reference("10733 5.9 minimum RecallTimer"), status("mandatory")] sint32 x25AdmnMinimumRecallTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.6"), read, write, description("The T21 Call timer in milliseconds."), reference("10733 callTime;\n                          See ISO 8208 Section 5.2.1, table 26"), status("mandatory")] sint32 x25AdmnCallTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4096"), object_identifier("1.3.6.1.2.1.10.5.1.1.21"), read, write, description("The number of PVC configured for this PLE.\n                          The PVCs use channel numbers from 1 to this\n                          number."), status("mandatory")] sint32 x25AdmnNumberPVCs;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.8"), read, write, description("The T23 Clear timer in milliseconds."), reference("10733 clearTime;\n                          See ISO 8208 Section 5.5.1, table 26"), status("mandatory")] sint32 x25AdmnClearTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.1.1.17"), read, write, description("The r23 Clear retransmission count."), reference("10733 clearCount;\n                          See ISO 8208 Section 5.5.1, table 27"), status("mandatory")] sint32 x25AdmnClearCount;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.7"), read, write, description("The T22 Reset timer in milliseconds."), reference("10733 resetTime;\n                          See ISO 8208 Section 8.1, table 26"), status("mandatory")] sint32 x25AdmnResetTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.1.1.16"), read, write, description("The r22 Reset retransmission count."), reference("10733 resetCount;\n                          See section ISO 8208 8.1, table 27"), status("mandatory")] sint32 x25AdmnResetCount;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.12"), read, write, description("The T27 Reject retransmission timer in\n                          milliseconds.  A value of 2147483647\n                          indicates no reject timer in use."), reference("10733 5.10.1 dataRejectTime (opt);\n                          See ISO 8208 Section 13.4.1, table 26"), status("mandatory")] sint32 x25AdmnRejectTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.1.1.19"), read, write, description("The R27 reject retransmission count.  This\n                          value is irrelevant if the\n                          x25AdmnRejectTimer indicates no timer in\n                          use."), reference("10733 5.10.1 dataRejectCount (opt)"), status("mandatory")] sint32 x25AdmnRejectCount;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.9"), read, write, description("The T24 window status transmission timer in\n                          milliseconds.  A value of 2147483647\n                          indicates no window timer in use."), reference("10733 5.10.1 windowTime (opt);\n                          See ISO 8208 Section 11.2.2, table 26"), status("mandatory")] sint32 x25AdmnWindowTimer;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("X121Address"), variable_length("0..17"), object_identifier("1.3.6.1.2.1.10.5.1.1.23"), read, write, description("The local address for this PLE subnetwork.\n                          A zero length address maybe returned by PLEs\n                          that only support PVCs."), reference("10733 5.9 localDTEAddress"), status("mandatory")] string x25AdmnLocalAddress;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.5"), read, write, description("The T20 restart timer in milliseconds."), reference("10733 5.9 restartTime\n                          See ISO 8208 Section 4.1, table 26"), status("mandatory")] sint32 x25AdmnRestartTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.1.1.15"), read, write, description("The R20 restart retransmission count."), reference("10733 5.9 restartCount;\n                          See ISO 8208    Section 4.1, table 27"), status("mandatory")] sint32 x25AdmnRestartCount;
	[textual_convention("EnumeratedINTEGER"), enumeration("dte(1),dce(2),dxe(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.1.1.2"), read, write, description("Identifies DCE/DTE mode in which the\n                          interface operates.  A value of dxe\n                          indicates the mode will be determined by XID\n                          negotiation."), reference("10733 5.9 interfaceMode"), status("mandatory")] string x25AdmnInterfaceMode;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.1.1.10"), read, write, description("The T25 data retransmission timer in\n                          milliseconds.  A value of 2147483647\n                          indicates no data retransmission timer in\n                          use."), reference("10733 5.10.1 dataRetransmissionTime (opt);\n                          See ISO 8208 Section 11.2.1, table 26"), status("mandatory")] sint32 x25AdmnDataRxmtTimer;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.5.1.1.22"), read, write, description("This identifies the instance of the\n                          x25CallParmIndex for the entry in the\n                          x25CallParmTable which contains the default\n                          call parameters for this PLE."), status("mandatory")] string x25AdmnDefCallParamId;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.1.1.18"), read, write, description("The R25 Data retransmission count.  This\n                          value is irrelevant if the\n                          x25AdmnDataRxmtTimer indicates no timer in\n                          use."), reference("10733 5.10.1 dataRetransmissionCount (opt)\n                          See ISO 8208 Section 11.2.1, table 27"), status("mandatory")] sint32 x25AdmnDataRxmtCount;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25AdmnTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25AdmnTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25AdmnTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25AdmnTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("The operation parameters in use by the X.25\n                          PLE.\nEntries of x25OperTable."), module_name("RFC1382-MIB"), group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25OperTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.11"), read, description("The T26 Interrupt timer in milliseconds.  A\n                          value of 2147483647 indicates interrupts are\n                          not being used."), reference("10733 interruptTime;\n                          See ISO 8208 Section 6.8.1, table 26"), status("mandatory")] sint32 x25OperInterruptTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("IfIndexType"), variable_value("1..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.1"), read, description("The ifIndex value for the X.25 interface."), status("mandatory"), key, key_order(1)] sint32 x25OperIndex;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.13"), read, description("The T28 registration timer in milliseconds.\n                          A value of 2147483647 indicates no\n                          registration timer in use."), reference("10733 5.8.1 registrationRequestTime (opt);\n                          See ISO 8208    Section 13.1.1.1, table 26"), status("mandatory")] sint32 x25OperRegistrationRequestTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.2.1.20"), read, description("The R28 Registration retransmission Count.\n                          This value is undefined if the\n                          x25OperREgistrationRequestTimer indicates no\n                          timer in use."), reference("10733 5.8.1 registrationRequestCount (opt);\n                          See ISO 8208    Section 13.1.1.1, table 27"), status("mandatory")] sint32 x25OperRegistrationRequestCount;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.5.2.1.25"), read, description("Identifies the version of the X.25 protocol\n                          this interface supports.  Object identifiers\n                          for common versions are defined below in the\n                          x25ProtocolVersion subtree."), reference("10733 5.9 protocolVersionSupported"), status("mandatory")] string x25OperProtocolVersionSupported;
	[textual_convention("EnumeratedINTEGER"), enumeration("modulo8(1),modulo128(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.2.1.4"), read, description("The modulus of the packet sequence number\n                          space."), reference("10733 extendedPacketSequencing;\n                          See ISO 8208    Section 7.1.1"), status("mandatory")] string x25OperPacketSequencing;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4096"), object_identifier("1.3.6.1.2.1.10.5.2.1.3"), read, description("Maximum number of circuits this PLE can\n                          support."), reference("10733 5.9 maxActiveCircuits\n                          See ISO 8208, Section 3.7"), status("mandatory")] sint32 x25OperMaxActiveCircuits;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.14"), read, description("Minimum time interval between unsuccessful\n                          call attempts in milliseconds."), reference("10733 5.9 minimum RecallTimer"), status("mandatory")] sint32 x25OperMinimumRecallTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.6"), read, description("The T21 Call timer in milliseconds."), reference("10733 callTime;\n                          See ISO 8208 Section 5.2.1, table 26"), status("mandatory")] sint32 x25OperCallTimer;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.5.2.1.24"), read, description("This identifies the instance of the index\n                          object in the first table of the most device\n                          specific MIB for the interface used by this\n                          PLE."), status("mandatory")] string x25OperDataLinkId;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4096"), object_identifier("1.3.6.1.2.1.10.5.2.1.21"), read, description("The number of PVC configured for this PLE.\n                          The PVCs use channel numbers from 1 to this\n                          number."), status("mandatory")] sint32 x25OperNumberPVCs;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.8"), read, description("The T23 Clear timer in milliseconds."), reference("10733 clearTime;\n                          See ISO 8208 Section 5.5.1, table 26"), status("mandatory")] sint32 x25OperClearTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.2.1.17"), read, description("The r23 Clear retransmission count."), reference("10733 clearCount;\n                          See ISO 8208 Section 5.5.1, table 27"), status("mandatory")] sint32 x25OperClearCount;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.7"), read, description("The T22 Reset timer in milliseconds."), reference("10733 resetTime;\n                          See ISO 8208    Section 8.1, table 26"), status("mandatory")] sint32 x25OperResetTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.2.1.16"), read, description("The r22 Reset retransmission count."), reference("10733 resetCount;\n                          See section ISO 8208 8.1, table 27"), status("mandatory")] sint32 x25OperResetCount;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.12"), read, description("The T27 Reject retransmission timer in\n                          milliseconds.  A value of 2147483647\n                          indicates no reject timer in use."), reference("10733 5.10.1 dataRejectTime (opt);\n                          See ISO 8208 Section 13.4.1, table 26"), status("mandatory")] sint32 x25OperRejectTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.2.1.19"), read, description("The R27 reject retransmission count.  This\n                          value is undefined if the x25OperRejectTimer\n                          indicates no timer in use."), reference("10733 5.10.1 dataRejectCount (opt)"), status("mandatory")] sint32 x25OperRejectCount;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.9"), read, description("The T24 window status transmission timer\n                          milliseconds.  A value of 2147483647\n                          indicates no window timer in use."), reference("10733 5.10.1 windowTime (opt);\n                          See ISO 8208 Section 11.2.2, table 26"), status("mandatory")] sint32 x25OperWindowTimer;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("X121Address"), variable_length("0..17"), object_identifier("1.3.6.1.2.1.10.5.2.1.23"), read, description("The local address for this PLE subnetwork.\n                          A zero length address maybe returned by PLEs\n                          that only support PVCs."), reference("10733 5.9 localDTEAddress"), status("mandatory")] string x25OperLocalAddress;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.5"), read, description("The T20 restart timer in milliseconds."), reference("10733 5.9 restartTime;\n                          See ISO 8208    Section 4.1, table 26"), status("mandatory")] sint32 x25OperRestartTimer;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.2.1.15"), read, description("The R20 restart retransmission count."), reference("10733 5.9 restartCount\n                          See ISO 8208    Section 4.1, table 27"), status("mandatory")] sint32 x25OperRestartCount;
	[textual_convention("EnumeratedINTEGER"), enumeration("dte(1),dce(2),dxe(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.2.1.2"), read, description("Identifies DCE/DTE mode in which the\n                          interface operates.  A value of dxe\n                          indicates the role will be determined by XID\n                          negotiation at the Link Layer and that\n                          negotiation has not yet taken place."), reference("10733 5.9 interfaceMode"), status("mandatory")] string x25OperInterfaceMode;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("PositiveInteger"), variable_value("0..2147483647"), object_identifier("1.3.6.1.2.1.10.5.2.1.10"), read, description("The T25 Data Retransmission timer in\n                          milliseconds.  A value of 2147483647\n                          indicates no data retransmission timer in\n                          use."), reference("10733 5.10.1 dataRetransmissionTime (opt);\n                          See ISO 8208 Section 11.2.1, table 26"), status("mandatory")] sint32 x25OperDataRxmtTimer;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.5.2.1.22"), read, description("This identifies the instance of the\n                          x25CallParmIndex for the entry in the\n                          x25CallParmTable that contains the default\n                          call parameters for this PLE."), status("mandatory")] string x25OperDefCallParamId;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..65535"), object_identifier("1.3.6.1.2.1.10.5.2.1.18"), read, description("The R25 Data retransmission count.  This\n                          value is undefined if the\n                          x25OperDataRxmtTimer indicates no timer in\n                          use."), reference("10733 5.10.1 dataRetransmissionCount (opt);\n                          See ISO 8208 Section 11.2.1, table 27"), status("mandatory")] sint32 x25OperDataRxmtCount;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25OperTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25OperTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25OperTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25OperTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("These objects contain information about the\n                          channel number configuration in an X.25 PLE.\n                          These values are the configured values.\n                          changes in these values after the interfaces\n                          has started may not be reflected in the\n                          operating PLE.\nEntries of x25ChannelTable."), module_name("RFC1382-MIB"), group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25ChannelTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.4.1.3"), read, write, description("Highest Incoming channel.  A value of zero\n                          indicates no channels in this range."), status("mandatory")] sint32 x25ChannelHIC;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.4.1.2"), read, write, description("Lowest Incoming channel."), status("mandatory")] sint32 x25ChannelLIC;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.4.1.7"), read, write, description("Highest outgoing channel.  A value of zero\n                          indicates no channels in this range."), status("mandatory")] sint32 x25ChannelHOC;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.4.1.6"), read, write, description("Lowest outgoing channel."), status("mandatory")] sint32 x25ChannelLOC;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.4.1.5"), read, write, description("Highest Two-way channel.  A value of zero\n                          indicates no channels in this range."), status("mandatory")] sint32 x25ChannelHTC;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.4.1.4"), read, write, description("Lowest Two-way channel."), status("mandatory")] sint32 x25ChannelLTC;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("IfIndexType"), variable_value("1..2147483647"), object_identifier("1.3.6.1.2.1.10.5.4.1.1"), read, description("The ifIndex value for the X.25 Interface."), status("mandatory"), key, key_order(1)] sint32 x25ChannelIndex;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25ChannelTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25ChannelTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25ChannelTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25ChannelTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("These objects contain general information\n                          about a specific circuit of an X.25 PLE.\nEntries of x25CircuitTable."), module_name("RFC1382-MIB"), group_objectid("1.3.6.1.2.1.10.5"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1382_MIB_x25CircuitTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.10"), read, description("The number of interrupt packets received\n                          for this circuit."), reference("10733 interruptPacketsReceived"), status("mandatory")] uint32 x25CircuitInInterrupts;
	[textual_convention("TimeTicks"), encoding("TimeTicks"), object_syntax("TimeTicks"), object_identifier("1.3.6.1.2.1.10.5.5.1.4"), read, description("The value of sysUpTime when the channel was\n                          associated with this circuit.  For outgoing\n                          SVCs, this is the time the first call packet\n                          was sent.  For incoming SVCs, this is the\n                          time the call indication was received.  For\n                          PVCs this is the time the PVC was able to\n                          pass data to a higher layer entity without\n                          loss of data."), status("mandatory")] uint32 x25CircuitEstablishTime;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("X121Address"), variable_length("0..17"), object_identifier("1.3.6.1.2.1.10.5.5.1.20"), read, write, description("For incoming calls, this is the address in\n                          the call Redirection or Call Deflection\n                          Notification facility if the call was\n                          deflected or redirected, otherwise it will\n                          be called address from the call indication\n                          packet.  For outgoing calls, this is the\n                          address from the call request packet.  This\n                          will be zero length for PVCs."), reference("10733 originallyCalledAddress"), status("mandatory"), defval("")] string x25CircuitOriginallyCalledAddress;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.15"), read, description("The number of times the T22 reset timer\n                          expired for this circuit."), reference("10733 5.11 resetTimeouts"), status("mandatory")] uint32 x25CircuitResetTimeouts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.13"), read, description("The number of interrupt packets sent on\n                          this circuit."), reference("10733 interruptPacketsSent"), status("mandatory")] uint32 x25CircuitOutInterrupts;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..255"), object_identifier("1.3.6.1.2.1.10.5.5.1.21"), read, write, description("A descriptive string associated with this\n                          circuit.  This provides a place for the\n                          agent to supply any descriptive information\n                          it knows about the use or owner of the\n                          circuit.  The agent may return the process\n                          identifier and user name for the process\n                          using the circuit.  Alternative the agent\n                          may return the name of the configuration\n                          entry that caused a bridge to establish the\n                          circuit.  A zero length value indicates the\n                          agent doesn't have any additional\n                          information."), status("mandatory"), defval("")] string x25CircuitDescr;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("IfIndexType"), variable_value("1..2147483647"), object_identifier("1.3.6.1.2.1.10.5.5.1.1"), read, description("The ifIndex value for the X.25 Interface."), status("mandatory"), key, key_order(1)] sint32 x25CircuitIndex;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("X121Address"), variable_length("0..17"), object_identifier("1.3.6.1.2.1.10.5.5.1.18"), read, write, description("For incoming calls, this is the called\n                          address from the call indication packet.\n                          For outgoing calls, this is the called\n                          address from the call confirmation packet.\n                          This will be zero length for PVCs."), reference("10733 calledDTEAddress"), status("mandatory"), defval("")] string x25CircuitCalledDteAddress;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.9"), read, description("The number of Resets received for this\n                          circuit with cause code other than DTE\n                          initiated."), reference("10733 ProviderInitiatedResets"), status("mandatory")] uint32 x25CircuitInProviderInitiatedResets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.8"), read, description("The number of Resets received for this\n                          circuit with cause code of DTE initiated."), reference("10733 remotelyInitiatedResets"), status("mandatory")] uint32 x25CircuitInRemotelyInitiatedResets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.7"), read, description("The number of PDUs received for this\n                          circuit."), reference("10733 5.11 dataPacketsReceived"), status("mandatory")] uint32 x25CircuitInPdus;
	[textual_convention("EnumeratedINTEGER"), enumeration("invalid(1),closed(2),calling(3),open(4),clearing(5),pvc(6),pvcResetting(7),startClear(8),startPvcResetting(9),other(10)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.5.1.3"), read, write, description("This object reports the current status of\n                          the circuit.\n\n                          An existing instance of this object can only\n                          be set to startClear, startPvcResetting, or\n                          invalid.  An instance with the value calling\n                          or open can only be set to startClear and\n                          that action will start clearing the circuit.\n                          An instance with the value PVC can only be\n                          set to startPvcResetting or invalid and that\n                          action resets the PVC or deletes the circuit\n                          respectively.  The values startClear or\n                          startPvcResetting will never be returned by\n                          an agent.  An attempt to set the status of\n                          an existing instance to a value other than\n                          one of these values will result in an error.\n\n                          A non-existing instance can be set to PVC to\n                          create a PVC if the implementation supports\n                          dynamic creation of PVCs.  Some\n                          implementations may only allow creation and\n                          deletion of PVCs if the interface is down.\n                          Since the instance identifier will supply\n                          the PLE index and the channel number,\n                          setting this object alone supplies\n                          sufficient information to create the\n                          instance.  All the DEFVAL clauses for the\n                          other objects of this table are appropriate\n                          for creating a PVC; PLEs creating entries\n                          for placed or accepted calls will use values\n                          appropriate for the call rather than the\n                          value of the DEFVAL clause.  Two managers\n                          trying to create the same PVC can determine\n                          from the return code which manager succeeded\n                          and which failed (the failing manager fails\n                          because it can not set a value of PVC for an\n                          existing object).\n\n                          An entry in the closed or invalid state may\n                          be deleted or reused at the agent's\n                          convence.  If the entry is kept in the\n                          closed state, the values of the parameters\n                          associated with the entry must be correct.\n                          Closed implies the values in the circuit\n                          table are correct.\n\n                          The value of invalid indicates the other\n                          values in the table are invalid.  Many\n                          agents may never return a value of invalid\n                          because they dynamically allocate and free\n                          unused table entries.  An agent for a\n                          statically configured systems can return\n                          invalid to indicate the entry has not yet\n                          been used so the counters contain no\n                          information."), reference("See ISO 8208,\n                                  table 33 for (p<n>) state table"), status("mandatory")] string x25CircuitStatus;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("X121Address"), variable_length("0..17"), object_identifier("1.3.6.1.2.1.10.5.5.1.19"), read, write, description("For incoming calls, this is the calling\n                          address from the call indication packet.\n                          For outgoing calls, this is the calling\n                          address from the call confirmation packet.\n                          This will be zero length for PVCs."), reference("10733 callingDTEAddress"), status("mandatory"), defval("")] string x25CircuitCallingDteAddress;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), variable_value("0..4095"), object_identifier("1.3.6.1.2.1.10.5.5.1.2"), read, description("The channel number for this circuit."), status("mandatory"), key, key_order(2)] sint32 x25CircuitChannel;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.12"), read, description("The number of PDUs sent for this circuit."), reference("10733 5.11 dataPacketsSent"), status("mandatory")] uint32 x25CircuitOutPdus;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.14"), read, description("The number of times the T25 data\n                          retransmission timer expired for this\n                          circuit."), reference("10733 5.11 dataRetransmissionTimerExpiries"), status("mandatory")] uint32 x25CircuitDataRetransmissionTimeouts;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.6"), read, description("The number of octets of user data delivered\n                          to upper layer."), reference("5.11 octetsReceivedCounter"), status("mandatory")] uint32 x25CircuitInOctets;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.16"), read, description("The number of times the T26 Interrupt timer\n                          expired for this circuit."), reference("10733 interruptTimerExpiries"), status("mandatory")] uint32 x25CircuitInterruptTimeouts;
	[textual_convention("EnumeratedINTEGER"), enumeration("incoming(1),outgoing(2),pvc(3)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.2.1.10.5.5.1.5"), read, write, description("The direction of the call that established\n                          this circuit."), reference("10733 direction"), status("mandatory"), defval("3")] string x25CircuitDirection;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.2.1.10.5.5.1.11"), read, description("The number of octets of user data sent for\n                          this circuit."), reference("10733 5.11 octetsSentCounter"), status("mandatory")] uint32 x25CircuitOutOctets;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.2.1.10.5.5.1.17"), read, write, description("This identifies the instance of the\n                          x25CallParmIndex for the entry in the\n                          x25CallParmTable which contains the call\n                          parameters in use with this circuit.  The\n                          entry referenced must contain the values\n                          that are currently in use by the circuit\n                          rather than proposed values.  A value of\n                          NULL indicates the circuit is a PVC or is\n                          using all the default parameters."), status("mandatory"), defval("0.0")] string x25CircuitCallParamId;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25CircuitTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1382_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25CircuitTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1382_MIB_x25CircuitTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1382_MIB:SNMP_GROUP.Name=\"x25V1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1382_MIB_x25CircuitTable";
};


