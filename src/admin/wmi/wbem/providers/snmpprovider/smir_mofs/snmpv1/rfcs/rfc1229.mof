// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//	MOF Generated for module "RFC1229-MIB" by smi2smir version 1.10.635.0000
qualifier write:ToInstance ToSubClass;
qualifier read:ToInstance ToSubClass;
qualifier provider:ToInstance ToSubClass;
qualifier singleton:ToInstance ToSubClass;
qualifier dynamic:ToInstance ToSubClass;
qualifier textual_convention:ToInstance ToSubClass;
qualifier object_identifier:ToInstance ToSubClass;
qualifier encoding:ToInstance ToSubClass;
qualifier object_syntax:ToInstance ToSubClass;
qualifier status:ToInstance ToSubClass;
qualifier fixed_length:ToInstance ToSubClass;
qualifier variable_length:ToInstance ToSubClass;
qualifier variable_value:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier key_order:ToInstance ToSubClass;
qualifier enumeration:ToInstance ToSubClass;
qualifier bits:ToInstance ToSubClass;
qualifier description:ToInstance ToSubClass;
qualifier display_hint:ToInstance ToSubClass;
qualifier defval:ToInstance ToSubClass;
qualifier units:ToInstance ToSubClass;
qualifier reference:ToInstance ToSubClass;
qualifier virtual_key:ToInstance ToSubClass;
qualifier rowstatus:ToInstance ToSubClass;
qualifier module_name:ToInstance ToSubClass;
qualifier module_imports:ToInstance ToSubClass;
qualifier group_objectid:ToInstance ToSubClass;

#pragma namespace("\\\\.\\root\\snmp")
class SMIR:__namespace
{
[read] string Name="SMIR";
};

instance of SMIR
{
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[abstract]
class SnmpMacro
{
};

[abstract]
class SnmpObjectType:SnmpMacro
{
};

class SnmpNotifyStatus:__ExtendedStatus
{
[write] sint32 SnmpStatusCode;
[write] string Description;
};

class SnmpNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class SnmpExtendedNotification:__ExtrinsicEvent
{
[textual_convention("TimeTicks"):ToInstance ToSubClass DisableOverride,encoding("TimeTicks"):ToInstance ToSubClass DisableOverride,object_syntax("TimeTicks"):ToInstance ToSubClass DisableOverride,read,object_identifier("1.3.6.1.2.1.1.3"):ToInstance ToSubClass DisableOverride,description("The time (in hundredths of a second) since the network management portion of the agent was last re-initialized."):ToInstance ToSubClass DisableOverride] uint32 TimeStamp;
[textual_convention("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, encoding("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, object_syntax("OBJECTIDENTIFIER"):ToInstance ToSubClass DisableOverride, read, object_identifier("1.3.6.1.6.3.1.1.4.1"):ToInstance ToSubClass DisableOverride,description("The authoratative identification of this notification."):ToInstance ToSubClass DisableOverride] string Identification;
[read, description("The network address of the entity that created this notification."):ToInstance ToSubClass DisableOverride] string AgentAddress;
[read, description("The network address of the entity that sent this notification. This may be a proxy for the original entity."):ToInstance ToSubClass DisableOverride] string AgentTransportAddress;
[read, description("The transport protocol used by the sending entity."):ToInstance ToSubClass DisableOverride] string AgentTransportProtocol;
[read, description("The security context used to send this notification."):ToInstance ToSubClass DisableOverride] string Community;
};

class NotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class ExtendedNotificationMapper
{
[read, key] string SnmpTrapOID;
[read] string EventClassName;
};

class SNMP_MODULE:__namespace
{
[read] string Name;
[read] string Module_Oid;
[read] string Module_Identity;
[read] string Organization;
[read] string Contact_Inf;
[read] string Description;
[read] string Revision;
[read] string Last_Updated;
[read] sint32 Snmp_Version;
[read] string Module_Imports;
};

[Association]
class ModuleToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class GroupToClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirGroup;
};

[Association]
class ModToNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

[Association]
class ModToExtNotificationClassAssociator
{
[read, key] string AssocName;
[read] object ref SmirClass;
[read] object ref SmirModule;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
instance of SNMP_MODULE
{
Name="RFC1229_MIB";
Module_Oid="1.3.6.1.3.6";
Module_Identity="rfc1229mibV1ModuleIdentity";
Organization="";
Contact_Inf="";
Description="RFC1229-MIB";
Revision="";
Last_Updated="0000000000Z";
Snmp_Version=1;
Module_Imports="RFC1155-SMI,RFC1213-MIB,RFC-1212";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1229_MIB")
class SNMP_GROUP:__namespace
{
[read] string Name;
[read] string Group_Id;
[read] string Status;
[read] string Description;
[read] string Reference;
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR\\RFC1229_MIB")
instance of SNMP_GROUP
{
Name="ifExtensionsV1ObjectGroup";
Group_Id="1.3.6.1.3.6";
Status="current";
Description="";
Reference="";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("This table contains an entry for each\n                          address (broadcast, multicast, or uni-cast)\n                          for which the system will receive packets/\n                          frames on a particular interface.  When an\n                          interface is operating in promiscuous mode,\n                          entries are only required for those addresses\n                          for which the system would receive frames\n                          were it not operating in promiscuous mode.\nA list of objects identifying an address\n                          for which the system will accept packets/\n\n\n\n\n\n                          frames on a particular interface."), module_name("RFC1229-MIB"), group_objectid("1.3.6.1.3.6"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1229_MIB_ifExtnsRcvAddrTable : SnmpObjectType
{
	[textual_convention("EnumeratedINTEGER"), enumeration("other(1),invalid(2),volatile(3),nonVolatile(4)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.3.6.3.1.3"), read, write, description("This object has the value nonVolatile(4)\n                          for those entries in the table which are\n                          valid and will not be deleted by the next\n                          restart of the managed system.  Entries\n                          having the value volatile(3) are valid\n\n\n\n\n\n                          and exist, but have not been saved, so\n                          that will not exist after the next\n                          restart of the managed system.  Entries\n                          having the value other(1) are valid and\n                          exist but are not classified as to whether\n                          they will continue to exist after the next\n                          restart.  Entries having the value invalid(2)\n                          are invalid and do not represent an address\n                          for which an interface accepts frames.\n                              Setting an object instance to one of\n                          the values other(1), volatile(3), or\n                          nonVolatile(4) causes the corresponding\n                          entry to exist or continue to exist, and\n                          to take on the respective status as regards\n                          the next restart of the managed system.\n                              Setting an object instance to the value\n                          invalid(2) causes the corresponding entry\n                          to become invalid or cease to exist.\n                              It is an implementation-specific matter\n                          as to whether the agent removes an\n                          invalidated entry from the table.\n                          Accordingly, management stations must be\n                          prepared to receive tabular information\n                          from agents that corresponds to entries not\n                          currently in use.  Proper interpretation of\n                          such entries requires examination of the\n                          relevant ifExtnsRcvAddrStatus object\n                          instance."), status("mandatory"), defval("3")] string ifExtnsRcvAddrStatus;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.3.6.3.1.1"), read, description("The value of ifIndex, defined in [4,6], of an\n                          interface which recognizes this entry's\n                          address."), status("mandatory"), key, key_order(1)] sint32 ifExtnsRcvAddrIfIndex;
	[textual_convention("PhysAddress"), encoding("OCTETSTRING"), object_syntax("PhysAddress"), display_hint("1x:"), object_identifier("1.3.6.1.3.6.3.1.2"), read, description("An address for which the system will accept\n                          packets/frames on this entry's interface."), status("mandatory"), key, key_order(2)] string ifExtnsRcvAddress;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1229_MIB_ifExtnsRcvAddrTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1229_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1229_MIB_ifExtnsRcvAddrTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1229_MIB_ifExtnsRcvAddrTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1229_MIB:SNMP_GROUP.Name=\"ifExtensionsV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1229_MIB_ifExtnsRcvAddrTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("This table contains one entry per interface.\nAn entry containing objects for invoking\n                           tests on an interface."), module_name("RFC1229-MIB"), group_objectid("1.3.6.1.3.6"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1229_MIB_ifExtnsTestTable : SnmpObjectType
{
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.3.6.2.1.3"), read, description("This object contains the value of the\n                          request-id field in the SNMP PDU [5] which\n                          invoked the current or most recent test on\n                          this interface.  If the request-id is\n                          unknown or undefined, this value contains\n                          the value zero."), status("mandatory")] sint32 ifExtnsTestRequestId;
	[textual_convention("OCTETSTRING"), encoding("OCTETSTRING"), object_syntax("OCTETSTRING"), object_identifier("1.3.6.1.3.6.2.1.2"), read, description("This object contains the name of the SNMP\n                          authentication community [5] which was used\n                          to authenticate the SNMP Message which invoked\n                          the current or most recent test on this\n                          interface.  If the authentication community\n                          is unknown or undefined, this value contains\n                          the zero-length string."), status("mandatory")] string ifExtnsTestCommunity;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.3.6.2.1.6"), read, description("This object contains a code which contains\n                          more specific information on the test result,\n                          for example an error-code after a failed\n                          test.  Error codes and other values this\n                          object may take are specific to the type of\n                          interface and/or test.  However, one subject\n                          identifier:\n\n                          testCodeUnknown  OBJECT IDENTIFIER ::= { 0 0 }\n\n                          for use if no additional result code is\n                          available.\n                              Note that testCodeUnknown is a\n                          syntactically valid object identifier, and\n                          any conformant implementation of ASN.1 and\n                          the BER must be able to generate and\n                          recognize this value."), status("mandatory")] string ifExtnsTestCode;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.3.6.2.1.4"), read, write, description("A control variable used to start and stop\n                          operator-initiated interface tests.\n                              Most OBJECT IDENTIFIER values assigned\n                          to tests are defined elsewhere, in associ-\n                          ation with specific types of interface.\n                          However, this document assigns a value for\n                          a full-duplex loopback test, and defines the\n                          special meanings of the subject identifier:\n\n                            noTest  OBJECT IDENTIFIER ::= { 0 0 }\n\n                          When the value noTest is written to this\n                          object, no action is taken unless a test is\n                          in progress, in which case the test is\n                          aborted.  Writing any other value to this\n                          object is only valid when no test is\n\n\n\n\n\n                          currently in progress, in which case the\n                          indicated test is initiated.\n                              Note that noTest is a syntactically valid\n                          object identifier, and any conformant\n                          implementation of ASN.1 and BER must be able\n                          to generate and recognize this value.\n                              When read, this object always returns\n                          the most recent value that ifExtnsTestType\n                          was set to.  If it has not been set since\n                          the last initialization of the network\n                          management subsystem on the agent, a value\n                          of noTest is returned."), status("mandatory")] string ifExtnsTestType;
	[textual_convention("EnumeratedINTEGER"), enumeration("none(1),success(2),inProgress(3),notSupported(4),unAbleToRun(5),aborted(6),failed(7)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.3.6.2.1.5"), read, description("This object contains the result of the most\n                          recently requested test, or the value\n                          none(1) if no tests have been requested since\n                          the last reset.  Note that this facility\n                          provides no provision for saving the results\n                          of one test when starting another, as could\n                          be required if used by multiple managers\n                          concurrently."), status("mandatory")] string ifExtnsTestResult;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.3.6.2.1.1"), read, description("The value of this object identifies the\n                          interface for which this entry contains\n                          information on interface tests.  The value\n                          of this object for a particular interface\n                          has the same value as the ifIndex object,\n                          defined in [4,6], for the same interface."), status("mandatory"), key, key_order(1)] sint32 ifExtnsTestIfIndex;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1229_MIB_ifExtnsTestTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1229_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1229_MIB_ifExtnsTestTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1229_MIB_ifExtnsTestTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1229_MIB:SNMP_GROUP.Name=\"ifExtensionsV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1229_MIB_ifExtnsTestTable";
};

#pragma namespace("\\\\.\\root\\snmp\\SMIR")
[description("A list of interfaces extension entries.\n                          The number of entries is given by the value\n                          of ifNumber, defined in [4,6].\nAn extension to the interfaces entry,\n                          defined in [4,6], containing additional\n                          objects at the subnetwork layer and below\n                          for a particular interface."), module_name("RFC1229-MIB"), group_objectid("1.3.6.1.3.6"), dynamic, provider("MS_SNMP_INSTANCE_PROVIDER")]
class SNMP_RFC1229_MIB_ifExtnsTable : SnmpObjectType
{
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.3.6.1.1.5"), read, description("The count of frames successfully\n                          transmitted to a subnetwork or link-layer\n                          broadcast addresses.  It does not include\n                          frames sent to a multicast address."), status("mandatory")] uint32 ifExtnsBroadcastsTransmittedOks;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.3.6.1.1.4"), read, description("The count of frames successfully\n                          transmitted to a subnetwork or link-layer\n                          multicast destination address other than a\n                          broadcast address.  For a MAC layer protocol,\n                          this includes both Group and Functional\n                          addresses."), status("mandatory")] uint32 ifExtnsMulticastsTransmittedOks;
	[textual_convention("INTEGER"), encoding("INTEGER"), object_syntax("INTEGER"), object_identifier("1.3.6.1.3.6.1.1.1"), read, description("The value of this object identifies the\n                          interface for which this entry contains\n                          extended management information.  The value\n                          of this object for a particular interface\n                          has the same value as the ifIndex object,\n                          defined in [4,6], for the same interface."), status("mandatory"), key, key_order(1)] sint32 ifExtnsIfIndex;
	[textual_convention("OBJECTIDENTIFIER"), encoding("OBJECTIDENTIFIER"), object_syntax("OBJECTIDENTIFIER"), object_identifier("1.3.6.1.3.6.1.1.2"), read, description("This object identifies the hardware chip\n                          set being used in the interface.  The\n                          assignment of OBJECT IDENTIFIERs to various\n                          types of hardware chip sets is managed\n                          by the IANA.  If the hardware chip set is\n                          unknown, the object identifier\n\n                          unknownChipSet OBJECT IDENTIFIER ::= { 0 0 }\n\n                          is returned.  Note that unknownChipSet is a\n                          syntactically valid object identifier, and\n                          any conformant implementation of ASN.1 and\n                          the BER must be able to generate and\n\n\n\n\n\n                          recognize this value."), status("mandatory")] string ifExtnsChipSet;
	[textual_convention("DisplayString"), encoding("OCTETSTRING"), object_syntax("DisplayString"), variable_length("0..255"), object_identifier("1.3.6.1.3.6.1.1.3"), read, description("An arbitrary octet string that describes\n                          the firmware version of this interface.\n                          It is intended that this should be human\n                          readable.  It must only contain ASCII\n                          printable characters.  Typically this\n                          will be the firmware version of the main\n                          interface software."), status("mandatory")] string ifExtnsRevWare;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.3.6.1.1.7"), read, description("The count of frames successfully received\n                          that are directed to a subnetwork or\n                          link-layer broadcast address.  This does not\n                          include frames received with errors."), status("mandatory")] uint32 ifExtnsBroadcastsReceivedOks;
	[textual_convention("Counter"), encoding("Counter"), object_syntax("Counter"), object_identifier("1.3.6.1.3.6.1.1.6"), read, description("The count of frames successfully received\n                          that are directed to an active subnetwork\n\n\n\n\n\n                          or link-layer multicast address (for a MAC\n                          layer protocol, this includes both Group and\n                          Functional addresses). This does not include\n                          frames directed to a broadcast address, nor\n                          frames received with errors."), status("mandatory")] uint32 ifExtnsMulticastsReceivedOks;
	[textual_convention("EnumeratedINTEGER"), enumeration("true(1),false(2)"), encoding("INTEGER"), object_syntax("EnumeratedINTEGER"), object_identifier("1.3.6.1.3.6.1.1.8"), read, description("This object has a value of false(2) if\n                          this interface only accepts packets/frames\n                          that are addressed to this station. This\n                          object has a value of true(1) when the\n                          station accepts all packets/frames\n                          transmitted on the media.  The value\n                          true(1) is only legal on certain types of\n                          media.  If legal, setting this object to a\n                          value of true(1) may require the interface\n                          to be reset before becoming effective."), status("mandatory")] string ifExtnsPromiscuous;
};
instance of ModuleToClassAssociator
{
AssocName="SNMP_RFC1229_MIB_ifExtnsTableSMIRModuleAssociation";
SmirModule="\\\\.\\root\\snmp\\SMIR:SNMP_MODULE.Name=\"RFC1229_MIB\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1229_MIB_ifExtnsTable";
};

instance of GroupToClassAssociator
{
AssocName="SNMP_RFC1229_MIB_ifExtnsTableSMIRGroupAssociation";
SmirGroup="\\\\.\\root\\snmp\\SMIR\\RFC1229_MIB:SNMP_GROUP.Name=\"ifExtensionsV1ObjectGroup\"";
SmirClass="\\\\.\\root\\snmp\\SMIR:SNMP_RFC1229_MIB_ifExtnsTable";
};


