//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 1
#endif
#endif


#include <iostream.h>
#include <fstream.h>

#include <typeinfo.h>

#include "precomp.h"
#include <snmptempl.h>


#include "smierrsy.hpp"
#include "smierrsm.hpp"

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>

#include "scanner.hpp"
#include "parser.hpp"


#define theScanner  (((SIMCParser *) this)->_theScanner)
#define theParser	((SIMCParser *) this)
#define theModule	(theParser->GetModule())

static SIMCModule * newImportModule = new SIMCModule;
static SIMCOidComponentList * newOidComponentList = new SIMCOidComponentList;
static SIMCBitValueList * newNameList = new SIMCBitValueList;
static SIMCIndexList *newIndexList = new SIMCIndexList;
static SIMCIndexListV2 *newIndexListV2 = new SIMCIndexListV2;
static SIMCVariablesList *newVariablesList = new SIMCVariablesList;
static SIMCObjectsList *newObjectsList = new SIMCObjectsList;
static SIMCRangeList *newRangeList = new SIMCRangeList;
static SIMCNamedNumberList *newNamedNumberList = new SIMCNamedNumberList;
static SIMCSequenceList *newSequenceList = new SIMCSequenceList;
static BOOL firstAssignment = TRUE;

static long HexCharToDecimal(char x)
{
	switch(x)
	{
		case '0':
			return 0;
		case '1':
			return 1;
		case '2':
			return 2;
		case '3':
			return 3;
		case '4':
			return 4;
		case '5':
			return 5;
		case '6':
			return 6;
		case '7':
			return 7;
		case '8':
			return 8;
		case '9':
			return 9;
		case 'a':
		case 'A':
			return 10;
		case 'b':
		case 'B':
			return 11;
		case 'c':
		case 'C':
			return 12;
		case 'd':
		case 'D':
			return 13;
		case 'e':
		case 'E':
			return 14;
		case 'f':
		case 'F':
			return 15;
	}
	return -1;
}

extern YYSTYPE yylval;
#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_yy_name, YY_t_yy_hex_string, YY_t_yy_binary_string, YY_t_yy_module, YY_t_yy_number, YY_t_yy_object_type, YY_t_yy_access, YY_t_yy_accessV2, YY_t_yy_status, YY_t_yy_statusV2, YY_t_yy_index, YY_t_yy_indexV2, YY_t_yy_variables_list, YY_t_yy_objects_list, YY_t_yy_symbol_ref, YY_t_yy_range_or_size_item, YY_t_yy_range_list, YY_t_yy_named_number_list, YY_t_yy_def_val, YY_t_yy_object_identity_status, YY_t_yy_notification_type_status
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&000: %001 &000",  0},
	{ "%044:",  0},
	{ "%001: %005 %044 &021 %045 &006 %046 %047 &027",  0},
	{ "%005: &033",  1},
	{ "%005: &033 %025",  1},
	{ "%005: &049",  1},
	{ "%046: &036 %048 &065",  0},
	{ "%046: &036 &001 &065",  0},
	{ "%046: &036 %049 &065",  0},
	{ "%046: %050",  0},
	{ "%049: %051",  0},
	{ "%049: %050",  0},
	{ "%051: %051 %012",  0},
	{ "%051: %012",  0},
	{ "%012: %048 &032 %002",  4},
	{ "%012: &001 &032 %002",  4},
	{ "%002: &033 &040 %052 &060",  1},
	{ "%002: &033 &040 &001 &060",  1},
	{ "%002: &033",  1},
	{ "%048: %048 &013 %053",  0},
	{ "%048: %053",  0},
	{ "%053: &033",  0},
	{ "%053: &049",  0},
	{ "%053: %011",  0},
	{ "%011: &086",  1},
	{ "%011: &098",  1},
	{ "%011: &077",  1},
	{ "%011: &083",  1},
	{ "%011: &096",  1},
	{ "%011: &104",  1},
	{ "%011: &101",  1},
	{ "%011: &106",  1},
	{ "%011: &112",  1},
	{ "%011: &103",  1},
	{ "%047: %047 %054",  0},
	{ "%047: %050",  0},
	{ "%054: %055",  0},
	{ "%054: %013",  0},
	{ "%054: %056",  0},
	{ "%054: %057",  0},
	{ "%054: %058",  0},
	{ "%054: %059",  0},
	{ "%054: %060",  0},
	{ "%054: %061",  0},
	{ "%054: %062",  0},
	{ "%054: %063",  0},
	{ "%054: %064",  0},
	{ "%054: %065",  0},
	{ "%054: %066",  0},
	{ "%054: %067",  0},
	{ "%054: %068",  0},
	{ "%055: &049 &051 &034 %045 %025",  0},
	{ "%055: &049 &051 &034 %045 &001",  0},
	{ "%025: %022",  15},
	{ "%025: &040 %052 &060",  15},
	{ "%025: &040 &001 &060",  15},
	{ "%052: %069 %052",  0},
	{ "%052: %069",  0},
	{ "%069: %022",  0},
	{ "%069: &049 &046 &042 &063",  0},
	{ "%069: &049 &046 %022 &063",  0},
	{ "%069: &042",  0},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 %025",  6},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 &001",  6},
	{ "%013: &049 &086 &001 %045 %025",  6},
	{ "%026: &087 %027",  15},
	{ "%026: &087 &001",  15},
	{ "%014: &091 &049",  7},
	{ "%014: &091 &001",  7},
	{ "%016: &084 &049",  9},
	{ "%016: &084 &001",  9},
	{ "%007: &081 &045",  1},
	{ "%007: %050",  1},
	{ "%007: &081 &001",  1},
	{ "%008: &085 &045",  1},
	{ "%008: %050",  1},
	{ "%008: &085 &001",  1},
	{ "%018: &092 &040 %070 &060",  11},
	{ "%018: %050",  11},
	{ "%018: &092 &001",  11},
	{ "%070: %071",  0},
	{ "%070: %070 &013 %071",  0},
	{ "%071: %027",  0},
	{ "%071: %022",  0},
	{ "%040: &095 &040 %041 &060",  19},
	{ "%040: %050",  19},
	{ "%040: &095 &001",  19},
	{ "%041: &072",  19},
	{ "%041: &031",  19},
	{ "%041: &042",  19},
	{ "%041: &040 %052 &060",  19},
	{ "%041: &045",  19},
	{ "%041: &043",  19},
	{ "%041: &044",  19},
	{ "%041: &050",  19},
	{ "%041: &049",  19},
	{ "%041: &033 &022 &049",  19},
	{ "%058: &049 &086 %026 %010 %015 %017 %007 %008 %019 %040 %045 %025",  0},
	{ "%015: &090 &049",  8},
	{ "%015: &090 &001",  8},
	{ "%017: &084 &049",  10},
	{ "%017: &084 &001",  10},
	{ "%010: &089 &045",  1},
	{ "%010: %050",  1},
	{ "%019: &092 &040 %072 &060",  12},
	{ "%019: &094 &040 %022 &060",  12},
	{ "%019: %050",  12},
	{ "%019: &092 &001",  12},
	{ "%072: %073",  0},
	{ "%072: %072 &013 %073",  0},
	{ "%073: &093 %022",  0},
	{ "%073: %022",  0},
	{ "%056: &049 &098 %029 %020 %007 %008 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 &001",  0},
	{ "%029: &099 %025",  15},
	{ "%029: &099 &001",  15},
	{ "%020: &100 &040 %074 &060",  13},
	{ "%020: %050",  13},
	{ "%020: &100 &001",  13},
	{ "%074: %075",  0},
	{ "%075: %076",  0},
	{ "%075: %075 &013 %076",  0},
	{ "%076: %022",  0},
	{ "%077: %078",  0},
	{ "%078: %079",  0},
	{ "%078: %078 &013 %079",  0},
	{ "%079: %080",  0},
	{ "%080: &049",  0},
	{ "%080: &033 &022 &049",  0},
	{ "%066: &033 %045 %027",  0},
	{ "%027: %028",  15},
	{ "%027: %030",  15},
	{ "%028: &009",  15},
	{ "%028: &051 &034",  15},
	{ "%028: %003",  15},
	{ "%028: &050",  15},
	{ "%028: %024 %039",  15},
	{ "%028: %004 %027",  15},
	{ "%028: &066 &040 %081 &060",  15},
	{ "%028: &066 &040 &001 &060",  15},
	{ "%024: &038",  15},
	{ "%024: &088",  15},
	{ "%024: %023",  15},
	{ "%039: &040 %082 &060",  18},
	{ "%039: %050",  18},
	{ "%039: &040 &001 &060",  18},
	{ "%082: %083",  0},
	{ "%082: %082 &013 %083",  0},
	{ "%083: &049 &046 %035 &063",  0},
	{ "%035: %034",  15},
	{ "%035: %033",  15},
	{ "%034: &042",  15},
	{ "%034: &043",  15},
	{ "%034: &044",  15},
	{ "%081: %081 &013 %084",  0},
	{ "%081: %084",  0},
	{ "%084: &049 %027",  0},
	{ "%067: &049 %045 %025",  0},
	{ "%068: &049 %027 %045 %031",  0},
	{ "%031: %032",  15},
	{ "%031: %033",  15},
	{ "%032: &072",  15},
	{ "%032: &031",  15},
	{ "%032: &042",  15},
	{ "%032: &043",  15},
	{ "%032: &044",  15},
	{ "%032: &040 %052 &060",  15},
	{ "%032: &040 %085 &060",  15},
	{ "%032: &045",  15},
	{ "%032: &050",  15},
	{ "%085: %086",  0},
	{ "%085: %085 &013 %086",  0},
	{ "%086: &049",  0},
	{ "%033: %022",  15},
	{ "%050:",  0},
	{ "%003: &052 &070",  1},
	{ "%003: &053",  1},
	{ "%004: &067",  1},
	{ "%004: &066 &054",  1},
	{ "%030: %027 %037",  15},
	{ "%030: %027 %038",  15},
	{ "%030: %027 &001",  15},
	{ "%037: &046 %087 %088 &063",  17},
	{ "%037: &046 &001 &063",  17},
	{ "%087: %036",  0},
	{ "%088: &005 %087 %088",  0},
	{ "%088: %050",  0},
	{ "%036: %034",  16},
	{ "%036: %034 &023 %034",  16},
	{ "%038: &046 &069 %037 &063",  17},
	{ "%038: &046 &069 &001 &063",  17},
	{ "%022: &033 &022 &049",  15},
	{ "%022: &049",  15},
	{ "%023: &033 &022 &033",  15},
	{ "%023: &033",  15},
	{ "%045: %006",  0},
	{ "%045: &011",  0},
	{ "%006: &118 &118",  1},
	{ "%006: &118 &119",  1},
	{ "%006: &119",  1},
	{ "%060: &049 &096 %021 %043 &081 &045 %008 %045 %025",  0},
	{ "%043: &084 &049",  21},
	{ "%021: &097 &040 %089 &060",  14},
	{ "%021: %050",  14},
	{ "%021: &097 &001",  14},
	{ "%089: %090",  0},
	{ "%090: %091",  0},
	{ "%090: %090 &013 %091",  0},
	{ "%091: %022",  0},
	{ "%057: &049 &077 &078 &045 &079 &045 &080 &045 &081 &045 %092 %045 %025",  0},
	{ "%092: %093",  0},
	{ "%092: %050",  0},
	{ "%093: %093 %094",  0},
	{ "%093: %094",  0},
	{ "%094: &082 &045 &081 &045",  0},
	{ "%059: &049 &083 %042 %007 %008 %045 %025",  0},
	{ "%042: &084 &049",  20},
	{ "%061: &033 %045 &101 %009 &084 &049 &081 &045 %008 &087 %027",  0},
	{ "%009: &102 &045",  1},
	{ "%009: %050",  1},
	{ "%062: &049 &103 &097 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%063: &049 &104 &105 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%064: &049 &106 &084 &049 &081 &045 %008 %095 %045 %025",  0},
	{ "%095: %096",  0},
	{ "%095: %050",  0},
	{ "%096: %096 %097",  0},
	{ "%096: %097",  0},
	{ "%097: &107 %098 %099 %100",  0},
	{ "%097: &107 %099 %100",  0},
	{ "%098: &033",  0},
	{ "%098: &033 %025",  0},
	{ "%099: &108 &040 %077 &060",  0},
	{ "%099: %050",  0},
	{ "%100: %101",  0},
	{ "%100: %050",  0},
	{ "%101: %101 %102",  0},
	{ "%101: %102",  0},
	{ "%102: &109 &049 &081 &045",  0},
	{ "%102: &051 &049 %103 %104 %105 &081 &045",  0},
	{ "%103: &087 %027",  0},
	{ "%103: %050",  0},
	{ "%104: &110 %027",  0},
	{ "%104: %050",  0},
	{ "%105: &111 &049",  0},
	{ "%105: %050",  0},
	{ "%065: &049 &112 &113 &045 &084 &049 &081 &045 %008 %106 %045 %025",  0},
	{ "%106: %107",  0},
	{ "%106: %050",  0},
	{ "%107: %107 %108",  0},
	{ "%107: %108",  0},
	{ "%108: &114 %109 &115 &040 %077 &060 %110",  0},
	{ "%109: &033 &040 %052 &060",  0},
	{ "%109: &033",  0},
	{ "%110: %111",  0},
	{ "%110: %050",  0},
	{ "%111: %111 %112",  0},
	{ "%111: %112",  0},
	{ "%112: &116 &049 %103 %104 %014 %113 %040 &081 &045",  0},
	{ "%113: &117 &040 %114 &060",  0},
	{ "%113: %050",  0},
	{ "%114: %077",  0},
	{ "%114: %050",  0},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "ABSENT",  257,  0},
	{ "ANY",  258,  0},
	{ "APPLICATION",  259,  0},
	{ "BAR",  260,  0},
	{ "BGIN",  261,  1},
	{ "BIT",  262,  0},
	{ "BITSTRING",  263,  0},
	{ "_BOOLEAN",  264,  1},
	{ "BY",  265,  0},
	{ "CCE",  266,  0},
	{ "CHOICE",  267,  0},
	{ "COMMA",  268,  0},
	{ "COMPONENT",  269,  0},
	{ "COMPONENTS",  270,  0},
	{ "COMPONENTSOF",  271,  0},
	{ "CONTROL",  272,  0},
	{ "DECODER",  273,  0},
	{ "DEFAULT",  274,  0},
	{ "DEFINED",  275,  0},
	{ "DEFINITIONS",  276,  1},
	{ "DOT",  277,  0},
	{ "DOTDOT",  278,  0},
	{ "DOTDOTDOT",  279,  0},
	{ "ENCODER",  280,  0},
	{ "ENCRYPTED",  281,  0},
	{ "END",  282,  1},
	{ "ENUMERATED",  283,  0},
	{ "EXPORTS",  284,  0},
	{ "EXPLICIT",  285,  0},
	{ "FALSE_VAL",  286,  1},
	{ "FROM",  287,  1},
	{ "ID",  288,  1},
	{ "IDENTIFIER",  289,  1},
	{ "IMPLICIT",  290,  0},
	{ "IMPORTS",  291,  1},
	{ "INCLUDES",  292,  0},
	{ "INTEGER",  293,  1},
	{ "LANGLE",  294,  0},
	{ "LBRACE",  295,  1},
	{ "LBRACKET",  296,  0},
	{ "LITNUMBER",  297,  5},
	{ "LIT_HEX_STRING",  298,  2},
	{ "LIT_BINARY_STRING",  299,  3},
	{ "LITSTRING",  300,  1},
	{ "LPAREN",  301,  0},
	{ "MIN",  302,  0},
	{ "MAX",  303,  0},
	{ "NAME",  304,  1},
	{ "NIL",  305,  1},
	{ "OBJECT",  306,  1},
	{ "OCTET",  307,  1},
	{ "OCTETSTRING",  308,  1},
	{ "OF",  309,  1},
	{ "PARAMETERTYPE",  310,  0},
	{ "PREFIXES",  311,  0},
	{ "PRESENT",  312,  0},
	{ "PRINTER",  313,  0},
	{ "PRIVATE",  314,  0},
	{ "RBRACE",  315,  0},
	{ "RBRACKET",  316,  0},
	{ "REAL",  317,  0},
	{ "RPAREN",  318,  0},
	{ "SECTIONS",  319,  0},
	{ "SEMICOLON",  320,  0},
	{ "SEQUENCE",  321,  1},
	{ "SEQUENCEOF",  322,  1},
	{ "SET",  323,  0},
	{ "_SIZE",  324,  1},
	{ "STRING",  325,  1},
	{ "TAGS",  326,  0},
	{ "TRUE_VAL",  327,  1},
	{ "UNIVERSAL",  328,  0},
	{ "WITH",  329,  0},
	{ "PLUSINFINITY",  330,  0},
	{ "MINUSINFINITY",  331,  0},
	{ "MODULEID",  332,  1},
	{ "LASTUPDATE",  333,  1},
	{ "ORGANIZATION",  334,  1},
	{ "CONTACTINFO",  335,  1},
	{ "DESCRIPTION",  336,  1},
	{ "REVISION",  337,  1},
	{ "OBJECTIDENT",  338,  1},
	{ "STATUS",  339,  1},
	{ "REFERENCE",  340,  1},
	{ "OBJECTYPE",  341,  1},
	{ "SYNTAX",  342,  1},
	{ "BITSXX",  343,  1},
	{ "UNITS",  344,  1},
	{ "MAXACCESS",  345,  1},
	{ "ACCESS",  346,  1},
	{ "INDEX",  347,  1},
	{ "IMPLIED",  348,  1},
	{ "AUGMENTS",  349,  1},
	{ "DEFVAL",  350,  1},
	{ "NOTIFY",  351,  1},
	{ "OBJECTS",  352,  1},
	{ "TRAPTYPE",  353,  1},
	{ "ENTERPRISE",  354,  1},
	{ "VARIABLES",  355,  1},
	{ "TEXTCONV",  356,  1},
	{ "DISPLAYHINT",  357,  1},
	{ "OBJECTGROUP",  358,  1},
	{ "NOTIFYGROUP",  359,  1},
	{ "NOTIFICATIONS",  360,  1},
	{ "MODCOMP",  361,  1},
	{ "MODULE",  362,  1},
	{ "MANDATORY",  363,  1},
	{ "GROUP",  364,  1},
	{ "WSYNTAX",  365,  1},
	{ "MINACCESS",  366,  1},
	{ "AGENTCAP",  367,  1},
	{ "PRELEASE",  368,  1},
	{ "SUPPORTS",  369,  1},
	{ "INCLUDING",  370,  1},
	{ "VARIATION",  371,  1},
	{ "CREATION",  372,  1},
	{ "':'",  58,  0},
	{ "'='",  61,  0}

};
#endif
#if YYDEBUG
static char *	YYStatesFile = "states.out";
long yyStates[] = {
0L, 17L, 30L, 69L, 124L, 141L, 154L, 176L, 220L, 233L, 251L, 298L, 320L, 
333L, 424L, 437L, 476L, 498L, 520L, 567L, 590L, 644L, 662L, 685L, 708L, 
721L, 755L, 768L, 781L, 828L, 855L, 882L, 900L, 918L, 992L, 1020L, 1048L, 
1061L, 1144L, 1199L, 1212L, 1225L, 1238L, 1251L, 1264L, 1277L, 1290L, 
1303L, 1316L, 1329L, 1342L, 1355L, 1368L, 1381L, 1394L, 1407L, 1446L, 
1468L, 1512L, 1578L, 1591L, 1655L, 1677L, 1721L, 1739L, 1762L, 1784L, 
1807L, 1829L, 1851L, 1874L, 1958L, 2839L, 2852L, 2865L, 2878L, 2891L, 
2904L, 2917L, 2930L, 2943L, 2956L, 2969L, 2982L, 2995L, 3008L, 3021L, 
3034L, 3052L, 3100L, 3241L, 3264L, 3287L, 3310L, 3394L, 3461L, 3518L, 
3590L, 3662L, 3704L, 3776L, 3845L, 3969L, 3982L, 3995L, 4012L, 4090L, 
4112L, 4125L, 4138L, 4151L, 4222L, 4239L, 4348L, 4361L, 4374L, 4387L, 
4400L, 4413L, 4524L, 4747L, 4828L, 4882L, 4961L, 4978L, 5071L, 5138L, 
5195L, 5267L, 5339L, 5356L, 5430L, 5502L, 5515L, 5559L, 5611L, 5633L, 
5651L, 5754L, 5772L, 5790L, 5808L, 5835L, 5858L, 5876L, 5930L, 6083L, 
6096L, 6140L, 6158L, 6192L, 6256L, 6340L, 6374L, 6406L, 6614L, 6725L, 
6752L, 6779L, 6792L, 6809L, 6871L, 6889L, 6956L, 7013L, 7085L, 7157L, 
7175L, 7244L, 7257L, 7291L, 7363L, 7381L, 7408L, 7425L, 7477L, 7500L, 
7554L, 7603L, 7616L, 7638L, 7682L, 7695L, 7708L, 7721L, 7734L, 7747L, 
7760L, 7804L, 7817L, 7830L, 7843L, 7856L, 7869L, 7882L, 7895L, 7923L, 
7940L, 7953L, 7980L, 8029L, 8056L, 8069L, 8091L, 8135L, 8153L, 8171L, 
8235L, 8248L, 8292L, 8371L, 8389L, 8477L, 8509L, 8522L, 8539L, 8606L, 
8640L, 8764L, 8828L, 8856L, 8884L, 8902L, 8964L, 9031L, 9088L, 9160L, 
9182L, 9195L, 9208L, 9221L, 9265L, 9337L, 9379L, 9392L, 9426L, 9444L, 
9462L, 9534L, 9547L, 9560L, 9604L, 9631L, 9649L, 9701L, 9728L, 9755L, 
9804L, 9826L, 9849L, 9862L, 9884L, 9911L, 9924L, 9968L, 9990L, 10108L, 
10191L, 10219L, 10241L, 10269L, 10296L, 10319L, 10341L, 10364L, 10397L, 
10430L, 10448L, 10475L, 10549L, 10582L, 10600L, 10634L, 10701L, 10719L, 
10737L, 10771L, 10937L, 10970L, 11003L, 11065L, 11132L, 11221L, 11293L, 
11315L, 11337L, 11409L, 11451L, 11469L, 11487L, 11559L, 11581L, 11609L, 
11688L, 11716L, 11744L, 11767L, 11806L, 11834L, 11856L, 11879L, 11902L, 
11925L, 11938L, 11951L, 11978L, 12001L, 12014L, 12027L, 12071L, 12098L, 
12145L, 12163L, 12181L, 12215L, 12329L, 12347L, 12365L, 12526L, 12588L, 
12655L, 12739L, 12811L, 12834L, 12857L, 12929L, 12972L, 13044L, 13067L, 
13119L, 13142L, 13155L, 13178L, 13206L, 13228L, 13256L, 13303L, 13321L, 
13339L, 13448L, 13604L, 13683L, 13782L, 13873L, 13886L, 13899L, 13948L, 
14005L, 14077L, 14149L, 14221L, 14273L, 14296L, 14344L, 14443L, 14456L, 
14500L, 14651L, 14713L, 14807L, 14820L, 14847L, 14916L, 14970L, 15039L, 
15057L, 15114L, 15186L, 15258L, 15330L, 15383L, 15396L, 15423L, 15467L, 
15561L, 15579L, 15606L, 15619L, 15663L, 15787L, 15849L, 15891L, 15904L, 
15917L, 15966L, 16033L, 16060L, 16078L, 16120L, 16147L, 16160L, 16173L, 
16227L, 16250L, 16309L, 16367L, 16466L, 16565L, 16664L, 16691L, 16709L, 
16736L, 16803L, 16889L, 16902L, 16980L, 16993L, 17042L, 17060L, 17087L, 
17211L, 17344L, 17393L, 17435L, 17453L, 17520L, 17547L, 17616L, 17643L, 
17661L, 17689L, 17761L, 17833L, 17860L, 17873L, 17886L, 17935L, 18007L, 
18034L, 18047L, 18064L, 18077L, 18126L, 18193L, 18237L, 18259L, 18287L, 
18309L, 18322L, 18335L, 18348L, 18361L, 18374L, 18396L, 18409L, 18422L, 
18435L, 18462L, 18525L, 18588L, 18615L, 18657L, 18725L, 18753L, 18766L, 
18783L, 18847L, 18874L, 18946L, 19018L, 19045L, 19063L, 19135L, 19163L, 
19181L, 19203L, 19231L, 19299L, 19322L, 19344L, 19366L, 19394L, 19421L, 
19463L, 19556L, 19569L, 19586L, 19645L, 19673L, 19746L, 19819L, 19846L, 
19919L, 19942L, 19965L, 19988L, 20016L, 20058L, 20146L, 20159L, 20176L, 
20218L, 20246L, 20320L, 20338L, 20380L, 20432L, 20445L, 20458L, 20512L, 
20555L, 20598L, 20672L, 20690L, 20759L, 20811L, 20885L, 20898L, 20925L, 
20994L, 21038L, 21090L, 21103L, 21116L, 21143L, 21195L, 21223L
};
const YYMAX_READ = 881;
#endif
static short yydef[] = {

	 264,   -1,   48,  262,   -5,  -13,  -17,    3,  -21,   10, 
	 224,  -25,  -29,  224,  -37,  224,  -67,   87,  -71,    9, 
	 -79,  224,  -83,  260,  259,  -91, -103, -109,  224,  224, 
	-117, -125,  261,  224,  224, -129,  224,  224, -137,  224, 
	 224,  257,  224, -141, -149,   12,  224,  224, -157,  255, 
	 256,  224, -165, -173, -181,   10, -189, -195,   15, -203, 
	 258, -211, -217, -227, -231,  224,  254, -239, -245, -249, 
	-255, -259
};
static short yyex[] = {

	   0,    0,   -1,    1,  282,  224,  288,  224,  304,  224, 
	  -1,    1,  320,  224,   -1,    1,  320,  263,   -1,    1, 
	 339,  224,   -1,    1,  339,  224,   -1,    1,  282,    6, 
	 288,    6,  304,    6,   -1,    1,  266,    7,  268,    7, 
	 282,    7,  288,    7,  304,    7,  315,    7,  336,    7, 
	 344,    7,  345,    7,  346,    7,  365,    7,  366,    7, 
	  58,    7,   61,    7,   -1,    1,  345,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  318,  224, 
	  -1,    1,  344,    4,  345,    4,  346,    4,   -1,    1, 
	 268,   61,  288,   48,  297,   48,  304,   48,  315,   61, 
	  -1,    1,  268,    8,  315,    8,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  318,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  342,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  266,  224,   58,  224,   61,  224, 
	  -1,    1,  266,  224,   58,  224,   61,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  268,    5, 
	 315,    5,   -1,    1,  282,   11,  288,   11,  304,   11, 
	  -1,    1,  336,  224,  365,  224,  366,  224,   -1,    1, 
	 336,  224,  366,  224,   -1,    1,  336,   13,  346,   13, 
	 365,   13,  366,   13,   -1,    1,  336,  224,   -1,    1, 
	 336,   14,  346,   14,  366,   14,   -1,    1,  346,  224, 
	 365,  224,   -1,    1,  346,  224,   -1,    1,  336,  224, 
	 350,  224,   -1,    1,  336,  224,   -1,    1,  315,  224, 
	  -1,    1
};
static short yyact[] = {

	  -1, -443,  304,  288, -278, -277, -312,  304,  295,  288, 
	-275,  277, -274, -278, -408,   -3,  304,  297,  288,  256, 
	-272,  276, -313,  304, -271,  301, -278, -408,   -3,  304, 
	 297,  288, -412,  315, -413,  315, -270, -307, -493,  266, 
	  61,   58, -278, -267, -312,  304,  297,  288, -309, -308, 
	  61,   58,   -5,  261, -409,  318, -410,  318,   -6,  291, 
	-265, -433, -432, -453, -454, -451, -455, -452, -457, -460, 
	-456, -458, -459,  367,  361,  359,  358,  356,  353,  351, 
	 341,  338,  332,  304,  288,  256, -262, -433, -432, -453, 
	-454, -451, -455, -452, -457, -460, -456, -458, -459,  367, 
	 361,  359,  358,  356,  353,  351,  341,  338,  332,  304, 
	 288,  256, -440,  320, -260, -441,  320,  287, -259, -258, 
	-442,  320,  287,  268, -445, -257, -256,  304,  288,  282, 
	-260,  287, -259, -258,  287,  268,   -8,  288, -433, -432, 
	-453, -454, -451, -455, -452, -457, -460, -456, -458, -459, 
	 367,  361,  359,  358,  356,  353,  351,  341,  338,  332, 
	 304,  288, -270, -307, -352, -493,  -10, -345, -349, -241, 
	-248, -489, -245, -490, -249, -250, -242, -344,   -9, -243, 
	-251, -252, -253, -254,  367,  361,  359,  358,  353,  351, 
	 343,  341,  338,  332,  322,  321,  308,  307,  306,  305, 
	 293,  288,  266,  264,   61,   58, -240,  295, -352,  -10, 
	-345, -349, -239, -248, -489, -245, -490, -344,  -12,  356, 
	 343,  322,  321,  308,  307,  306,  305,  293,  288,  264, 
	-238,  368, -237,  339, -236,  360, -235,  352, -234,  339, 
	-233,  333, -232,  352, -230,  277, -324,  325, -270, -307, 
	-320, -493, -229,  301,  266,  256,   61,   58, -227, -323, 
	 309,  295, -352,  -10, -345, -349, -239, -248, -489, -245, 
	-490, -344,  343,  322,  321,  308,  307,  306,  305,  293, 
	 288,  264, -226,  295, -224, -225,  354,  256, -222, -223, 
	 342,  256,  -18,  289, -221, -278, -408,   -3,  304,  297, 
	 288,  256, -219,  357, -351,  289, -320, -229,  301,  256, 
	-217,  300, -216,  304, -215,  295, -214,  295, -297,  304, 
	-213,  336, -212,  300, -302, -211,  295,  256, -210,  339, 
	-311,  288, -207, -339, -338, -337, -208,  324,  299,  298, 
	 297,  256, -333, -278, -206, -332, -331, -330, -327, -312, 
	-326, -334,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -204, -205,  304,  256, -201, -202,  304,  256, 
	-359, -278, -277, -312,  304,  295,  288,  256, -198,  355, 
	-404, -352,  -10, -345, -349, -239, -248, -489, -245, -490, 
	-344,  343,  322,  321,  308,  307,  306,  305,  293,  288, 
	 264,  256, -196, -194,  346,  344, -434,  315, -435,  315, 
	-296,  300, -191,  339, -190,  339, -189,  336, -187, -354, 
	 304,  288, -184,  340, -397, -399,  300,  256, -183,  334, 
	-278, -312,  304,  288, -305,  304, -181,  336, -180, -178, 
	 301,  256, -177,  278, -318,  318, -176,  260, -278, -408, 
	 -26,  304,  297,  288, -346,  315, -172, -347,  315,  268, 
	-171,  301, -341,  315, -170, -343,  315,  268, -361, -339, 
	-338, -337,  299,  298,  297,  256, -356, -169,  295,  256, 
	-371,  300, -168,  345, -402, -403,  304,  256, -166,  339, 
	-414, -278, -277, -312,  304,  295,  288,  256, -165,  304, 
	-164,  304,  -30,  300, -163,  315, -162,  277, -161,  268, 
	-160,  315, -394, -396,  300,  256, -158,  300, -157,  268, 
	-304,  315,  -31,  300, -314,  318, -315,  318, -207, -339, 
	-338, -337,  299,  298,  297,  256, -339, -338, -337,  299, 
	 298,  297, -319,  318, -156, -328,  315,  268, -329,  315, 
	-205,  304, -278, -339, -338, -337, -312,  304,  299,  298, 
	 297,  288, -202,  304, -374, -375,  304,  256, -152,  339, 
	-400, -401,  304,  256, -151,  336, -150,  336, -149,  339, 
	-353,  304, -148,  339, -147,  335, -325,  304, -340,  318, 
	-145,  268, -358,  315, -372, -373,  304,  256,  -39,  300, 
	 -40,  300,  -41,  362, -142,  304, -141,  304, -140,  300, 
	-138,  347,  -46, -136,  363,  288, -134,  336, -133,  336, 
	-132,  336, -130, -131,  349,  347, -391, -129,  295,  256, 
	-128,  350, -126,  342, -125,  369, -123,  295, -122, -121, 
	 364,  306, -136,  363,  -53,  300,  -54,  300,  -55,  300, 
	-120,  295, -366, -119,  295,  256, -352,  -56, -345, -312, 
	-349, -239, -248, -489, -245, -490, -344,  343,  322,  321, 
	 308,  307,  306,  305,  304,  293,  288,  264, -387, -116, 
	 295,  256,  -59,  288,  -60,  304, -111,  304, -108,  337, 
	-278, -312, -105,  348,  304,  288, -102,  277, -101, -393, 
	 315,  268, -385, -100,  -99, -384, -381, -380, -382, -378, 
	-379, -386,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -406, -278, -277, -312,  304,  295,  288,  256, 
	 -97,  295,  -96,  370, -288,  315,  -95,  342,  -94,  336, 
	 -91,  300, -368,  315,  -89, -369,  315,  268, -311, -313, 
	 304,  288,  -88,  277, -389,  315,  -85,  295,  -84,  365, 
	-287,  300,  -83,  336, -377,  304, -383,  315, -282,  315, 
	 -81,  366, -299,  300,  -66,  315, -285,  304,  -79,  336, 
	 -78,  371, -286,  300,  -68,  304, -194,  346,  -76,  372, 
	 -72,  295,  -73,  336, -280,  315, -281,  300,   -1
};
static short yypact[] = {

	   7,   10,   25,   29,   59,   73,   99,  207,  243,  245, 
	 283,  303,  308,  321,  308,  379,  404,   39,  423,  443, 
	 447,  321,  308,  509,  519,   25,  308,  423,  321,  423, 
	 423,  447,  591,  321,  423,  603,  423,  611,  423,  423, 
	 614,  603,  624,  631,  635,    7,  640,  643,  631,  635, 
	 640,  640,  423,  423,  689,  697,  308,  308,  731,  737, 
	 689,  759,  308,  771,  308,  781,  781,  737,  759,  789, 
	 631,  420,  797,  795,  793,  791,  787,  785,  783,  779, 
	 777,  775,  773,  272,  420,  769,  767,  765,  693,    7, 
	 763,    7,    7,  761,  272,  757,   29,  755,   29,  753, 
	 667,  750,    7,  746,  432,  743,   39,  741,   39,   39, 
	 739,  735,    7,  733,  726,  712,  700,   39,  693,  432, 
	 687,  685,  420,   39,  683,  272,   39,  680,  667,  654, 
	 651,  649,  647,  645,    7,  637,  633,  628,    7,  621, 
	 619,  617,   39,  539,  432,   39,  609,  607,  605,  601, 
	 599,  596,   39,  593,  589,  587,  432,  585,    7,  583, 
	 420,  581,  579,  577,  575,  572,  569,  566,  432,  563, 
	 557,  551,  549,  546,  543,  539,  539,  532,  527,  525, 
	 523,  521,  517,  514,   39,  511,  507,  505,  503,  501, 
	 499,  494,  489,  486,  483,  481,    7,  478,  472,  466, 
	 463,  461,  458,  455,  272,  451,  445,  440,  437,  435, 
	 432,  429,  426,  420,  420,  417,  415,  413,  411,  409, 
	 407,   39,  391,   39,  374,  368,  364,  352,  337,  331, 
	 329,  326,  323,  319,  317,  315,  313,  311,  305,  298, 
	 293,  290,  286,  272,  260,    7,  253,  247,  241,  239, 
	 237,  235,  233,  231,  219,  184,   39,  137,  150,  137, 
	 134,  131,  127,  121,  116,  113,   57,   55,   53,   50, 
	  45,   39,   35,   33,   23,   21,   16,   11,    2
};
static short yygo[] = {

	  -2, -437, -436,  257, -350, -244, -446, -310,  -28,  -35, 
	 -37,  -19,   33,   28,   21, -153,  -36, -146,  -38,  -43, 
	-137,  -45, -110, -109, -185,   53,   52,   39,   38,   36, 
	  34,   30,   29,   27, -218, -195, -431, -439, -438,    6, 
	-429,  -70, -193,   76, -167,  -29,  -34,  -44,  -49,  -22, 
	-231, -411, -364, -411, -411, -390, -365, -364, -106, -390, 
	-355, -301, -355, -487, -411, -301, -487, -411, -268, -411, 
	-463,  276,  270,  239,  227,  210,  205,  170,  168,  156, 
	 144,  128,  119,  118,  104,  100,   98,   96,   88,    3, 
	-476,  -11, -289, -300, -294, -293, -376, -284, -407, -292, 
	-306, -298, -415, -405, -360, -336, -444,  245,  224,  196, 
	 191,  158,  138,  134,  114,  112,  102,   92,   91,   89, 
	  45,  -17,  -65,  -63,  -58,  -27,  -23,  -15,  -13, -247, 
	 -57,  255,  254,  243,  222,  204,  125,   94,   83, -474, 
	 -16, -475, -335, -483, -480, -484,  170, -363, -479, -316, 
	-362,  -20,  198,  176,  170,  143, -155, -317, -179, -322, 
	 207, -321, -348, -118,  -75, -127,   70,   48,  -98,  -14, 
	-209, -276, -192,  -90,  -92,  -93, -103, -113, -115, -135, 
	-139, -144, -159, -197, -199, -228, -246, -255, -269,  256, 
	 255,  246,  223,  221,  184,  152,  145,  142,  126,  123, 
	 117,  109,  108,  106,   17, -488, -263, -261, -264,    6, 
	-266, -447, -448, -303, -342, -295, -398, -357, -370, -492, 
	-398, -398, -492, -398, -499, -392, -502, -367, -388, -509, 
	-503, -502, -388, -503, -496, -506, -507, -508, -512, -506, 
	-507, -515, -388, -517, -462, -395,  487,   71,   70,   69, 
	  68,   67,   65,   63,   61,   59,   54,   51,   48,   47, 
	  46,   44,   43,   42,   40,   37,   35,   33,   31,   28, 
	  21,   20,   16,   15,   13,   11,   10,    8,    5,    4, 
	  -7, -464,  -86,  -87, -173, -220, -273,  239,  205,   98, 
	  96,    3, -449, -450,  258, -461, -430, -428, -427, -426, 
	-425, -424, -423, -422, -421, -420, -419, -418, -417, -416, 
	  -4, -117, -466, -465,  100, -104, -468, -467,   88, -154, 
	 -33, -470, -469,  144, -516,  -82, -112, -186, -188,  213, 
	 122,   84,   71,  -24, -472, -471,  160, -473, -203, -200, 
	-478, -477,  169, -481, -482,  171, -174, -486, -485,  155, 
	 -32,  -21,  175, -491, -175,   31, -182,  -25, -495, -494, 
	 156, -107,  -61, -497, -498,   60, -143,  -42, -500, -501, 
	  41,  -48,  -52,  -47,   47, -291, -290,   51,  -51, -504, 
	-505,   50,  -69,  -62,   67,  -77,  -64,   68,  -80, -124, 
	 -50, -510, -511,   49, -114, -283,  -67, -513, -514,   66, 
	 -71,  -74,   -1
};
static short yypgo[] = {

	   0,    0,    0,    2,  121,  313,  307,  139,  344,  157, 
	  90,  302,  371,  383,  386,  394,  400,  398,  394,  392, 
	 306,  388,  380,  380,  373,  371,  369,  369,  305,  304, 
	 303,   34,   34,  169,  300,  364,  298,  359,   50,   50, 
	  50,  170,  301,    7,    7,    7,  188,   90,   70,   70, 
	 161,  161,  157,  351,  159,  159,  141,  141,  141,    5, 
	   4,  348,  143,  143,  143,  143,  143,  143,  143,  143, 
	 143,  309,  308,  151,  151,  151,  341,  162,  162,  162, 
	  91,   91,  139,  139,  139,  139,  139,  139,  139,  337, 
	 337,  322,   49,   49,   49,  140,  140,  297,  297,  297, 
	 317,  317,   48,   48,   48,   48,   35,   35,   46,   46, 
	  44,   44,  299,  168,  168,  168,  168,  168,  168,  168, 
	 168,  168,  168,  165,  165,  165,  313,   47,   47,   47, 
	  24,   24,   24,   11,   11,   11,   45,   45,   42,   42, 
	 121,   40,   40,   40,  310,  310,  310,  310,  106,  106, 
	 296,  296,  295,  295,  295,  295,  295,  295,  295,  295, 
	 295,  295,  295,  295,  295,  295,  295,  293,  293,  293, 
	   2,    2,   38,   38,  280,  280,  205,  205,  205,    6, 
	   6,    0,  171,  205,  210,  208,  208,   36,   36,   36, 
	  36,   36,   36,   36,   36,   36,   36,  206,  206,  106, 
	 286,  311,  311,  315,  315,  320,  320,  333,  333,  335, 
	 130,  130,   91,  339,  339,  156,  156,  338,  338,  142, 
	 142,  346,  346,  145,  245,    4,    5,  354,  354,  188, 
	 357,  357,  361,  362,  362,  366,  367,  367,  373,  376, 
	 378,  378,  383,  386,  388,  389,  390,  390,  395,  396, 
	 396,  400,  401,  401,  395,  389,  376,  366,  361,  356, 
	 328,  319,  286,  210,    6,    0
};
static short yyrlen[] = {

	   0,    0,    0,    1,    2,    1,    3,    2,    2,    1, 
	   1,   11,    1,    2,    2,    1,    4,    9,    4,    7, 
	  12,    2,    7,    4,    4,    2,    3,    4,   10,   13, 
	  13,    1,    2,    2,    7,    4,   13,    1,    2,    1, 
	   4,    2,    9,    1,    2,    2,    1,    3,    1,    3, 
	   4,    4,    3,    1,    3,    4,    2,    2,    2,    2, 
	   2,    1,    1,    1,    3,    3,    1,    1,    1,    1, 
	   1,    4,    3,    1,    1,    1,    4,    3,    1,    3, 
	   1,    1,    4,    4,    2,    1,    1,    2,    1,    3, 
	   1,    1,    2,    1,    4,    2,    2,    5,    5,    8, 
	   1,    2,    2,    1,    4,    4,    1,    2,    2,    2, 
	   2,    2,   12,    3,    1,    1,    1,    1,    1,    3, 
	   1,    1,    1,    2,    1,    4,    1,    2,    1,    4, 
	   2,    1,    2,    2,    1,    2,    2,    2,    2,    2, 
	   2,    5,   11,   11,    1,    4,    4,    1,    3,    3, 
	   5,    5,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   4,    4,    3,    3,    1,    2,    3,    3,    3,    1, 
	   2,    8,    0,    1,    1,    3,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    2,    1,    1, 
	   2,    1,    3,    1,    3,    1,    3,    1,    3,    1, 
	   1,    1,    1,    1,    3,    1,    1,    3,    1,    1, 
	   1,    1,    3,    1,    0,    1,    1,    3,    1,    1, 
	   1,    3,    1,    2,    1,    1,    2,    1,    1,    1, 
	   2,    1,    1,    1,    1,    1,    2,    1,    1,    2, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    2
};
#define YYS0	278
#define YYDELTA	263
#define YYNPACT	279
#define YYNDEF	72

#define YYr263	0
#define YYr264	1
#define YYr265	2
#define YYr18	3
#define YYr65	4
#define YYr82	5
#define YYr130	6
#define YYr138	7
#define YYr157	8
#define YYr188	9
#define YYr195	10
#define YYr218	11
#define YYr230	12
#define YYr240	13
#define YYr242	14
#define YYr253	15
#define YYr259	16
#define YYr258	17
#define YYr252	18
#define YYr251	19
#define YYr246	20
#define YYr244	21
#define YYr239	22
#define YYr238	23
#define YYr232	24
#define YYr231	25
#define YYr229	26
#define YYr228	27
#define YYr223	28
#define YYr222	29
#define YYr221	30
#define YYr220	31
#define YYr219	32
#define YYr217	33
#define YYr216	34
#define YYr215	35
#define YYr210	36
#define YYr209	37
#define YYr205	38
#define YYr204	39
#define YYr203	40
#define YYr202	41
#define YYr201	42
#define YYr200	43
#define YYr199	44
#define YYr198	45
#define YYr196	46
#define YYr194	47
#define YYr193	48
#define YYr192	49
#define YYr191	50
#define YYr190	51
#define YYr189	52
#define YYr185	53
#define YYr184	54
#define YYr183	55
#define YYr182	56
#define YYr181	57
#define YYr180	58
#define YYr179	59
#define YYr176	60
#define YYr173	61
#define YYr170	62
#define YYr169	63
#define YYr168	64
#define YYr167	65
#define YYr166	66
#define YYr165	67
#define YYr164	68
#define YYr163	69
#define YYr162	70
#define YYr159	71
#define YYr158	72
#define YYr154	73
#define YYr153	74
#define YYr152	75
#define YYr149	76
#define YYr146	77
#define YYr145	78
#define YYr144	79
#define YYr142	80
#define YYr141	81
#define YYr140	82
#define YYr139	83
#define YYr137	84
#define YYr136	85
#define YYr135	86
#define YYr134	87
#define YYr133	88
#define YYr129	89
#define YYr128	90
#define YYr123	91
#define YYr119	92
#define YYr118	93
#define YYr117	94
#define YYr116	95
#define YYr115	96
#define YYr114	97
#define YYr113	98
#define YYr112	99
#define YYr111	100
#define YYr110	101
#define YYr107	102
#define YYr106	103
#define YYr105	104
#define YYr104	105
#define YYr103	106
#define YYr102	107
#define YYr101	108
#define YYr100	109
#define YYr99	110
#define YYr98	111
#define YYr97	112
#define YYr96	113
#define YYr95	114
#define YYr94	115
#define YYr93	116
#define YYr92	117
#define YYr91	118
#define YYr90	119
#define YYr89	120
#define YYr88	121
#define YYr87	122
#define YYr86	123
#define YYr85	124
#define YYr84	125
#define YYr83	126
#define YYr79	127
#define YYr78	128
#define YYr77	129
#define YYr76	130
#define YYr75	131
#define YYr74	132
#define YYr73	133
#define YYr72	134
#define YYr71	135
#define YYr70	136
#define YYr69	137
#define YYr68	138
#define YYr67	139
#define YYr66	140
#define YYr64	141
#define YYr63	142
#define YYr62	143
#define YYr61	144
#define YYr60	145
#define YYr59	146
#define YYr58	147
#define YYr55	148
#define YYr54	149
#define YYr52	150
#define YYr51	151
#define YYr50	152
#define YYr49	153
#define YYr48	154
#define YYr47	155
#define YYr46	156
#define YYr45	157
#define YYr44	158
#define YYr43	159
#define YYr42	160
#define YYr41	161
#define YYr40	162
#define YYr39	163
#define YYr38	164
#define YYr37	165
#define YYr36	166
#define YYr23	167
#define YYr22	168
#define YYr21	169
#define YYr17	170
#define YYr16	171
#define YYr15	172
#define YYr14	173
#define YYr13	174
#define YYr12	175
#define YYr8	176
#define YYr7	177
#define YYr6	178
#define YYr5	179
#define YYr4	180
#define YYr2	181
#define YYr1	182
#define YYrACCEPT	YYr263
#define YYrERROR	YYr264
#define YYrLR2	YYr265
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"ModuleDefinition",
	"ImportModuleIdentifier",
	"Octetstring",
	"SequenceOf",
	"MainModuleIdentifier",
	"InsteadOfCCE",
	"DescrPart",
	"ReferPart",
	"DisplayPart",
	"UnitsPart",
	"MacroName",
	"SymbolsFromModule",
	"ObjectTypeV1Definition",
	"AccessPart",
	"MaxAccessPartV2",
	"StatusPart",
	"StatusPartV2",
	"IndexPart",
	"IndexPartV2",
	"VarPart",
	"ObjectsPart",
	"QualifiedName",
	"QualifiedId",
	"QualifiedIdOrIntegerOrBits",
	"ObjectID",
	"SyntaxPart",
	"Type",
	"BuiltinType",
	"EnterprisePart",
	"SubType",
	"Value",
	"BuiltinValue",
	"DefinedValue",
	"NumericValue",
	"NamedNumberValue",
	"SubtypeValueSet",
	"SubtypeRangeSpec",
	"SubtypeSizeSpec",
	"NNlist",
	"DefValPart",
	"DefValValue",
	"ObjectIdentityStatusPart",
	"NotificationTypeStatusPart",
	"$1",
	"AllowedCCE",
	"Imports",
	"AssignmentList",
	"SymbolList",
	"SymbolsImported",
	"empty",
	"SymbolsFromModuleList",
	"ObjectIDComponentList",
	"Symbol",
	"Assignment",
	"ObjectIDefinition",
	"TrapTypeDefinition",
	"ModuleIDefinition",
	"ObjectTypeV2Definition",
	"ObjectDefinition",
	"NotifyDefinition",
	"TextualConventionDefinition",
	"ObjectGroupDefinition",
	"NotifyGroupDefinition",
	"ModComplianceDefinition",
	"AgentCapabilitiesDefinition",
	"Typeassignment",
	"ToleratedOIDAssignment",
	"Valueassignment",
	"ObjectSubID",
	"IndexTypes",
	"IndexType",
	"IndexTypesV2",
	"IndexTypeV2",
	"VarTypeListForTrap",
	"VarTypesForTrap",
	"VarTypeForTrap",
	"VarTypeList",
	"VarTypes",
	"VarType",
	"UncheckedQualifiedName",
	"ElementTypes",
	"NamedNumberList",
	"NamedNumber",
	"NamedType",
	"NameList",
	"Name",
	"SubtypeRangeAlternative",
	"SubtypeRangeAlternativeList",
	"ObjectTypeListForNotification",
	"ObjectTypesForNotification",
	"ObjectTypeForNotification",
	"RevisionPart",
	"Revisions",
	"Revision",
	"MibPart",
	"Mibs",
	"Mib",
	"ModuleIdentifierUnused",
	"MandatoryPart",
	"CompliancePart",
	"Compliances",
	"Compliance",
	"Syntax",
	"WriteSyntax",
	"MinAccessPart",
	"ModulePart",
	"Modules",
	"Module",
	"ModuleReference",
	"VariationPart",
	"Variations",
	"Variation",
	"CreationPart",
	"Creation",
	0
};
short yyrmap[] = {

	 263,  264,  265,   18,   65,   82,  130,  138,  157,  188, 
	 195,  218,  230,  240,  242,  253,  259,  258,  252,  251, 
	 246,  244,  239,  238,  232,  231,  229,  228,  223,  222, 
	 221,  220,  219,  217,  216,  215,  210,  209,  205,  204, 
	 203,  202,  201,  200,  199,  198,  196,  194,  193,  192, 
	 191,  190,  189,  185,  184,  183,  182,  181,  180,  179, 
	 176,  173,  170,  169,  168,  167,  166,  165,  164,  163, 
	 162,  159,  158,  154,  153,  152,  149,  146,  145,  144, 
	 142,  141,  140,  139,  137,  136,  135,  134,  133,  129, 
	 128,  123,  119,  118,  117,  116,  115,  114,  113,  112, 
	 111,  110,  107,  106,  105,  104,  103,  102,  101,  100, 
	  99,   98,   97,   96,   95,   94,   93,   92,   91,   90, 
	  89,   88,   87,   86,   85,   84,   83,   79,   78,   77, 
	  76,   75,   74,   73,   72,   71,   70,   69,   68,   67, 
	  66,   64,   63,   62,   61,   60,   59,   58,   55,   54, 
	  52,   51,   50,   49,   48,   47,   46,   45,   44,   43, 
	  42,   41,   40,   39,   38,   37,   36,   23,   22,   21, 
	  17,   16,   15,   14,   13,   12,    8,    7,    6,    5, 
	   4,    2,    1,    9,   11,   19,   20,   24,   25,   26, 
	  27,   28,   29,   30,   31,   32,   33,   34,   35,   53, 
	  56,   80,   81,  108,  109,  121,  122,  125,  126,  127, 
	 131,  132,  143,  147,  148,  150,  151,  155,  156,  160, 
	 161,  171,  172,  174,  175,  177,  178,  186,  187,  197, 
	 207,  208,  212,  213,  214,  225,  226,  227,  233,  235, 
	 236,  237,  241,  243,  245,  248,  249,  250,  255,  256, 
	 257,  260,  261,  262,  254,  247,  234,  224,  211,  206, 
	 124,  120,   57,   10,    3,    0
};
short yysmap[] = {

	   2,    4,   13,   15,   33,   37,   55,   89,  100,  101, 
	 112,  122,  124,  130,  145,  151,  154,  155,  167,  177, 
	 180,  209,  211,  230,  240,  255,  256,  268,  276,  281, 
	 292,  296,  308,  314,  317,  320,  338,  339,  340,  341, 
	 342,  345,  353,  356,  358,  361,  362,  363,  373,  383, 
	 391,  393,  395,  396,  397,  402,  404,  410,  411,  416, 
	 425,  455,  473,  476,  487,  492,  498,  501,  503,  505, 
	 508,  509,  514,  513,  510,  507,  504,  495,  494,  490, 
	 489,  486,  480,  475,  472,  471,  469,  468,  464,  461, 
	 459,  458,  457,  456,  454,  450,  449,  446,  442,  436, 
	 434,  433,  432,  431,  429,  427,  426,  422,  421,  420, 
	 417,  415,  414,  412,  409,  408,  406,  401,  400,  398, 
	 388,  387,  385,  384,  380,  379,  378,  377,  375,  372, 
	 371,  368,  367,  366,  365,  360,  357,  355,  350,  349, 
	 348,  347,  346,  335,  333,  328,  326,  324,  321,  319, 
	 318,  313,  310,  309,  304,  298,  290,  289,  286,  285, 
	 284,  283,  282,  280,  279,  275,  272,  271,  267,  262, 
	 260,  258,  254,  253,  251,  250,  247,  246,  245,  244, 
	 243,  241,  237,  234,  232,  231,  226,  225,  224,  223, 
	 222,  218,  217,  216,  215,  214,  212,  208,  206,  203, 
	 202,  200,  199,  198,  196,  187,  179,  176,  174,  173, 
	 172,  170,  169,  165,  164,  163,  162,  160,  159,  157, 
	 156,  153,  152,  150,  149,  147,  144,  141,  137,  135, 
	 134,  133,  131,  129,  128,  127,  126,  125,  123,  121, 
	 120,  119,  118,  111,  110,  106,  105,  104,   99,   98, 
	  97,   96,   95,   94,   93,   71,   70,   68,   67,   65, 
	  62,   61,   60,   58,   57,   56,   30,   29,   28,   25, 
	  20,   18,   17,   16,   11,   10,    7,    6,    0,  515, 
	 516,  485,  499,  451,  493,  500,  477,  452,  386,  392, 
	 419,  394,  478,  479,  158,  221,  166,  325,  491,  481, 
	 238,  171,  132,  291,  242,  369,   24,   31,   32,   27, 
	 175,    5,   19,  293,  294,  295,  178,  248,  297,  138, 
	 139,  140,  143,  136,  330,  185,  186,  299,  300,  188, 
	 189,  190,  191,  192,  195,  142,  181,  182,  183,  332, 
	 261,  146,  263,  108,  109,  257,  259,  148,  113,  114, 
	 161,  115,  322,  227,  306,  266,  207,  334,  204,  205, 
	 264,  265,  352,  428,  463,  399,  370,  462,  465,  213, 
	 270,  336,  337,  311,  312,  466,  483,  437,  438,  439, 
	 440,  441,  484,  443,  444,  445,  407,  376,  470,  403, 
	 374,  354,  435,  287,  233,  288,  235,  168,  236,  315, 
	 316,  273,  274,  210,  269,  447,  448,   12,   34,   35, 
	  14,   22,   23,  277,  278,   72,   73,   74,   75,   76, 
	  77,   78,   79,   80,   81,   82,   83,   84,   85,   86, 
	  49,   50,   51,  219,  220,   90,   92,   53,   63,   64, 
	  66,   69,    1,    9,   88,    3,   36,   54,   91,   52, 
	  48,   47,   46,   45,   44,   43,   42,   41,   40,   39, 
	  87,   59,    8,   21,  405,  467,  430,  482,  307,  351, 
	 229,  323,  228,  117,  116,  107,  201,  305,  303,  302, 
	 301,  197,  194,  193,  252,  331,  184,   38,  103,  102, 
	 329,  249,   26,  239,  327,  424,  460,  423,  344,  364, 
	 343,  359,  390,  418,  389,  453,  474,  488,  382,  413, 
	 381,  497,  502,  496,  506,  512,  511
};
int yy_parse::yyntoken = 120;
int yy_parse::yynvar = 115;
int yy_parse::yynstate = 517;
int yy_parse::yynrule = 266;
#endif



// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If YYDEBUG is defined as 1 and yy_parse::yydebug is set to 1,
// yyparse() will print a travelogue of its actions as it reads
// and parses input.
//
// YYSYNC can be defined to cause yyparse() to attempt to always
// hold a lookahead token

const YY_MIN_STATE_NUM = 20;	// not useful to be too small!

#if YYDEBUG
#ifdef YYTRACE
long	* yy_parse::States	= yyStates;
#endif
yyTypedRules * yy_parse::Rules	= yyRules;
yyNamedType * yy_parse::TokenTypes = yyTokenTypes;

#define YY_TRACE(fn) { done = 0; fn(); if (done) YYRETURN(-1); }
#endif

// Constructor for yy_parse: user-provided tables
yy_parse::yy_parse(int sz, short * states, YYSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < YY_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (YYSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		// force reset
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
// Constructor for yy_parse: allocate tables with new
yy_parse::yy_parse(int sz)
{
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new YYSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (YYSTYPE *) 0
#if YYDEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}
}
// Destructor for class yy_parse
//	Free up space
yy_parse::~yy_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if YYDEBUG
	delete typeStack;
#endif
}

#ifdef YACC_WINDOWS

// The initial portion of the yacc parser.
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yyparse() to acutally begin the
// parsing. When complete, win_yyparse() will return a
// value back to our new yyparse() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yyparse().

int
yy_parse::yyparse(yy_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_yydef;		// the following are used for saving
	short *old_yyex;		// the current pointers
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	// the following code will load the required
	// resources for a Windows based parser.

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	// return an error code if any
	// of the resources did not load

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	// the following code will lock the resources
	// into fixed memory locations for the parser
	// (also, save away the old pointer values)

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	// call the official yyparse() function

	wReturnValue = win_yyparse (ps);

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previous pointer values
	//

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	// end yyparse()


// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start

int
yy_parse::win_yyparse(yy_scan* ps)

#else /* YACC_WINDOWS */

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start
int
yy_parse::yyparse(yy_scan* ps)

#endif /* YACC_WINDOWS */

{
	short	* yyp, * yyq;		// table lookup
	int	yyj;
#if YYDEBUG
	int	yyruletype = 0;
#endif

	if ((scan = ps) == (yy_scan *) 0) {	// scanner
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			// start new parse
		yynerrs = 0;
		yyerrflag = 0;
		yyps = stateStack;
		yypv = valueStack;
#if YYDEBUG
		yytp = typeStack;
#endif
		yystate = YYS0;
		yyclearin();
		reset = 0;
	} else			// continue saved parse
		goto yyNext;			// after action

yyStack:
	if (++yyps > &stateStack[size]) {
		scan->yyerror("Parser stack overflow");
		YYABORT;
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	if (yydebug) {
		*++yytp = (short)yyruletype;	/* ... and type */
		YY_TRACE(yyShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	if (yychar < 0) {
		if ((yychar = scan->yylex()) < 0) {
			if (yychar == -2) YYABORT;
			yychar = 0;
		}	/* endif */
		yylval = ::yylval;
#if YYDEBUG
		if (yydebug)
			yyShowRead();	// show new input token
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			yyq = yyp;
			yyi = (short)yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;		/* stack value */
				yyclearin();		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef) 	/* simple state */
#else /* YACC_WINDOWS */
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif /* YACC_WINDOWS */
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
		}
	}

	yyj = yyrlen[yyi];

#if YYDEBUG
	if (yydebug) {
		npop = yyj; rule = yyi;
		YY_TRACE(yyShowReduce)
		yytp -= yyj;
	}
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $ = $1 */
#if YYDEBUG
	if (yydebug)
		yyruletype = yyRules[yyrmap[yyi]].type;
#endif
	switch (yyi) {		/* perform semantic action */
		
case YYr1: {	/* ModuleDefinition :  MainModuleIdentifier */

						SIMCParser *myParser = (SIMCParser *)this;
						myParser ++;
						myParser --;
						SIMCModule *myModule = myParser->GetModule();
						theModule->SetModuleName(yypvt[0].yy_name->name);
						theModule->SetLineNumber(yypvt[0].yy_name->line);
						theModule->SetColumnNumber(yypvt[0].yy_name->column);
						theModule->SetInputFileName(theScanner->GetInputStreamName());
						delete yypvt[0].yy_name;
					
} break;

case YYr2: {	/* ModuleDefinition :  MainModuleIdentifier $1 DEFINITIONS AllowedCCE BGIN Imports AssignmentList END */

						delete yypvt[-5].yy_name;
						delete yypvt[-3].yy_name;
						delete yypvt[0].yy_name;
					
} break;

case YYr4: {	/* MainModuleIdentifier :  ID ObjectID */

					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr5: {	/* MainModuleIdentifier :  NAME */

					theParser->SyntaxError(NAME_INSTEAD_OF_ID);
				
} break;

case YYr6: {	/* Imports :  IMPORTS SymbolList SEMICOLON */

			theParser->SyntaxError(MISSING_MODULE_NAME);
			delete newImportModule;
			newImportModule = new SIMCModule;
			delete yypvt[-2].yy_name;
		
} break;

case YYr7: {	/* Imports :  IMPORTS error SEMICOLON */

			theParser->SyntaxError(IMPORTS_SECTION);
			delete yypvt[-2].yy_name;
		
} break;

case YYr8: {	/* Imports :  IMPORTS SymbolsImported SEMICOLON */

			delete yypvt[-2].yy_name;
		
} break;

case YYr12: {	/* SymbolsFromModuleList :  SymbolsFromModuleList SymbolsFromModule */
			
			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr13: {	/* SymbolsFromModuleList :  SymbolsFromModule */

			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr14: {	/* SymbolsFromModule :  SymbolList FROM ImportModuleIdentifier */

			if(strcmp(yypvt[0].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				theParser->SemanticError(theModule->GetInputFileName(),
							IMPORT_CURRENT,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column,
							yypvt[0].yy_name->name);
				yyval.yy_module = NULL;
			}
			else
			{
				newImportModule->SetModuleName(yypvt[0].yy_name->name);
				newImportModule->SetLineNumber(yypvt[0].yy_name->line);
				newImportModule->SetColumnNumber(yypvt[0].yy_name->column);
				newImportModule->SetSymbolType(SIMCSymbol::MODULE_NAME);
				newImportModule->SetInputFileName(theScanner->GetInputStreamName());
				yyval.yy_module = newImportModule;
			}
			delete yypvt[0].yy_name;
		
} break;

case YYr15: {	/* SymbolsFromModule :  error FROM ImportModuleIdentifier */

			theParser->SyntaxError(LIST_IN_IMPORTS);
			delete yypvt[-1].yy_name;
			delete yypvt[0].yy_name;
			yyval.yy_module = NULL;
		
} break;

case YYr16: {	/* ImportModuleIdentifier :  ID LBRACE ObjectIDComponentList RBRACE */

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr17: {	/* ImportModuleIdentifier :  ID LBRACE error RBRACE */

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
			theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
		
} break;

case YYr18: {	/* ImportModuleIdentifier :  ID */

			yyval.yy_name = yypvt[0].yy_name;
		
} break;

case YYr21: {	/* Symbol :  ID */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr22: {	/* Symbol :  NAME */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr23: {	/* Symbol :  MacroName */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr36: {	/* Assignment :  ObjectIDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr37: {	/* Assignment :  ObjectTypeV1Definition */

				firstAssignment = FALSE;
			
} break;

case YYr38: {	/* Assignment :  TrapTypeDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr39: {	/* Assignment :  ModuleIDefinition */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					case 2:
					{
						if(!firstAssignment)
						{
							theParser->SyntaxError(MODULE_IDENTITY_ONLY_AFTER_IMPORTS);
						}
						else
							firstAssignment = FALSE;
					}
					break;
					default:
					{
						firstAssignment = FALSE;
					}
					break;
				}
			
} break;

case YYr40: {	/* Assignment :  ObjectTypeV2Definition */

				firstAssignment = FALSE;
			
} break;

case YYr41: {	/* Assignment :  ObjectDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr42: {	/* Assignment :  NotifyDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr43: {	/* Assignment :  TextualConventionDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr44: {	/* Assignment :  ObjectGroupDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr45: {	/* Assignment :  NotifyGroupDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr46: {	/* Assignment :  ModComplianceDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr47: {	/* Assignment :  AgentCapabilitiesDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr48: {	/* Assignment :  Typeassignment */

				firstAssignment = FALSE;
			
} break;

case YYr49: {	/* Assignment :  ToleratedOIDAssignment */

				firstAssignment = FALSE;
			
} break;

case YYr50: {	/* Assignment :  Valueassignment */

				firstAssignment = FALSE;
			
} break;

case YYr51: {	/* ObjectIDefinition :  NAME OBJECT IDENTIFIER AllowedCCE ObjectID */

				if(yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-4].yy_name->name);
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-4].yy_name->name,
							new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 	
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
								(*s)->GetReferenceCount()) );
							// delete (*s);
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-4].yy_name->line,
														yypvt[-4].yy_name->column,
														yypvt[-4].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 0) );
					}
				}
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr52: {	/* ObjectIDefinition :  NAME OBJECT IDENTIFIER AllowedCCE error */

				// Add a syntax error statement here
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr54: {	/* ObjectID :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column);
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr55: {	/* ObjectID :  LBRACE error RBRACE */

				yyval.yy_symbol_ref = NULL;
				delete newOidComponentList;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				// Cascade the error, for example to the ObjectIDefinition
				// production
				YYERROR;  

			
} break;

case YYr58: {	/* ObjectSubID :  QualifiedName */

				if(yypvt[0].yy_symbol_ref) 
				{
					newOidComponentList->AddTail(new SIMCOidComponent (
						yypvt[0].yy_symbol_ref->s,yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					NULL, 0, 0));
				}
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr59: {	/* ObjectSubID :  NAME LPAREN LITNUMBER RPAREN */

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[-1].yy_number->number, yypvt[-1].yy_number->isUnsigned,
							yypvt[-1].yy_number->line, yypvt[-1].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[-1].yy_number->line, yypvt[-1].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[-1].yy_number->line, yypvt[-1].yy_number->column,
										yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column );
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_number;
			
} break;

case YYr60: {	/* ObjectSubID :  NAME LPAREN QualifiedName RPAREN */

				if(yypvt[-1].yy_symbol_ref)
					newOidComponentList->AddTail( new SIMCOidComponent(
						yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
						yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr61: {	/* ObjectSubID :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, yypvt[0].yy_number->line, yypvt[0].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[0].yy_number->line, yypvt[0].yy_number->column,
										NULL, 0, 0);
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[0].yy_number;
			
} break;

case YYr62: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE SyntaxPart AccessPart StatusPart DescrPart ReferPart IndexPart DefValPart AllowedCCE ObjectID */
				
			
				switch(theParser->GetSnmpVersion())
				{
					case 2:
					{
						theParser->SyntaxError(V1_OBJECT_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						if(yypvt[-8].yy_symbol_ref)
						{
							SIMCObjectTypeV1 * type = new SIMCObjectTypeV1(
								yypvt[-8].yy_symbol_ref->s, yypvt[-8].yy_symbol_ref->line, yypvt[-8].yy_symbol_ref->column,
								yypvt[-7].yy_access->a, yypvt[-7].yy_access->line, yypvt[-7].yy_access->column,
								yypvt[-6].yy_status->a, yypvt[-6].yy_status->line, yypvt[-6].yy_status->column,
								yypvt[-3].yy_index->indexList, yypvt[-3].yy_index->line, yypvt[-3].yy_index->column, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, (yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, (yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, (yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, (yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, yypvt[-2].yy_def_val->symbol, yypvt[-2].yy_def_val->line, yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
							if(s) // Symbol exists in symbol table
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
										(*s)->GetReferenceCount()) );
									// delete (*s);
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
									// Remove the symbol for the type reference from the module
									// And delete it
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexList;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-10].yy_name; 
				delete yypvt[-9].yy_name; 
				delete yypvt[-8].yy_symbol_ref; 
				delete yypvt[-7].yy_access; 
				delete yypvt[-6].yy_status; 
				delete yypvt[-5].yy_name; 
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_index;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr63: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE SyntaxPart AccessPart StatusPart DescrPart ReferPart IndexPart DefValPart AllowedCCE error */

				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				delete yypvt[-10].yy_name; delete yypvt[-9].yy_name; delete yypvt[-8].yy_symbol_ref; delete yypvt[-7].yy_access;
				delete yypvt[-6].yy_status; if(yypvt[-5].yy_name) delete yypvt[-5].yy_name; if(yypvt[-4].yy_name) delete yypvt[-4].yy_name; delete yypvt[-3].yy_index; delete yypvt[-2].yy_def_val;
				delete newIndexList;
				newIndexList = new SIMCIndexList;

			
} break;

case YYr64: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE error AllowedCCE ObjectID */

				theParser->SyntaxError(ERROR_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				theParser->SyntaxError( SKIPPING_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
			
} break;

case YYr65: {	/* SyntaxPart :  SYNTAX Type */

				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				else
				{	
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				}
			
} break;

case YYr66: {	/* SyntaxPart :  SYNTAX error */

					delete yypvt[-1].yy_name;
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				
} break;

case YYr67: {	/* AccessPart :  ACCESS NAME */

				SIMCObjectTypeV1::AccessType a;
				if ((a=SIMCObjectTypeV1::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_access = NULL;
					YYERROR;
				}
				else
					yyval.yy_access = new SIMCAccessInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr68: {	/* AccessPart :  ACCESS error */

				yyval.yy_access = new SIMCAccessInfo(SIMCObjectTypeV1::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr69: {	/* StatusPart :  STATUS NAME */

				SIMCObjectTypeV1::StatusType a;
				if ((a=SIMCObjectTypeV1::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_status = new SIMCStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr70: {	/* StatusPart :  STATUS error */

					yyval.yy_status = new SIMCStatusInfo(SIMCObjectTypeV1::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr71: {	/* DescrPart :  DESCRIPTION LITSTRING */

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr72: {	/* DescrPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr73: {	/* DescrPart :  DESCRIPTION error */

					theParser->SyntaxError(DESCRIPTION_CLAUSE);
					yyval.yy_name = NULL;
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr74: {	/* ReferPart :  REFERENCE LITSTRING */

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr75: {	/* ReferPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr76: {	/* ReferPart :  REFERENCE error */

				theParser->SyntaxError(REFERENCE_CLAUSE);
				yyval.yy_name = NULL;
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr77: {	/* IndexPart :  INDEX LBRACE IndexTypes RBRACE */

				yyval.yy_index = new SIMCIndexInfo(newIndexList, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexList = new SIMCIndexList;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr78: {	/* IndexPart :  empty */

				yyval.yy_index = new SIMCIndexInfo(newIndexList, 0, 0);
			
} break;

case YYr79: {	/* IndexPart :  INDEX error */

				yyval.yy_index = NULL;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr82: {	/* IndexType :  Type */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr83: {	/* IndexType :  QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr84: {	/* DefValPart :  DEFVAL LBRACE DefValValue RBRACE */

				yyval.yy_def_val = yypvt[-1].yy_def_val;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr85: {	/* DefValPart :  empty */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
			
} break;

case YYr86: {	/* DefValPart :  DEFVAL error */

				delete yypvt[-1].yy_name;
				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
				theParser->SyntaxError(DEFVAL_CLAUSE);
				YYERROR;
			
} break;

case YYr87: {	/* DefValValue :  TRUE_VAL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->trueValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr88: {	/* DefValValue :  FALSE_VAL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->falseValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr89: {	/* DefValValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column) ;
				delete yypvt[0].yy_number;
				delete badName;
			
} break;

case YYr90: {	/* DefValValue :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0,
							new SIMCOidValue(newOidComponentList),
							badName, 
							SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column
							));
				yyval.yy_def_val = new SIMCDefValInfo(NULL, theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) ;
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr91: {	/* DefValValue :  LITSTRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
				delete badName;
			
} break;

case YYr92: {	/* DefValValue :  LIT_HEX_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr93: {	/* DefValValue :  LIT_BINARY_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr94: {	/* DefValValue :  NIL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->nullValueReference,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr95: {	/* DefValValue :  NAME */

				yyval.yy_def_val = new SIMCDefValInfo(NewString(yypvt[0].yy_name->name), NULL, yypvt[0].yy_name->line,
						yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr96: {	/* DefValValue :  ID DOT NAME */

				SIMCSymbol **s;
				if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
				{
					if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
						theModule->AddSymbol(
							new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
											theModule, yypvt[0].yy_name->line,
											yypvt[0].yy_name->column, 0) );
					yyval.yy_def_val = new SIMCDefValInfo( NULL,
						theModule->GetSymbol(yypvt[0].yy_name->name), yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else
				{			
					SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
					if(m) 
					{
						if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
						{
							theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_SYMBOL_ABSENT,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
							yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
						}
						else
					yyval.yy_def_val = new SIMCDefValInfo( NULL, s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
					else // Module is not mentioned in imports
					{
						theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_MODULE_ABSENT,
										yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
										yypvt[-2].yy_name->name);
						yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
				}
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_name;	
			
} break;

case YYr97: {	/* ObjectTypeV2Definition :  NAME OBJECTYPE SyntaxPart UnitsPart MaxAccessPartV2 StatusPartV2 DescrPart ReferPart IndexPartV2 DefValPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(V2_OBJECT_TYPE_DISALLOWED);
					}
					break;

					default:
					{
						if (yypvt[-9].yy_symbol_ref)
						{
							SIMCObjectTypeV2 * type = new SIMCObjectTypeV2(
								yypvt[-9].yy_symbol_ref->s, 
								yypvt[-9].yy_symbol_ref->line, 
								yypvt[-9].yy_symbol_ref->column,
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->name : NULL, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->line:0, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->column:0,
								( SIMCObjectTypeV2::AccessType ) (yypvt[-7].yy_accessV2->a), 
								yypvt[-7].yy_accessV2->line, 
								yypvt[-7].yy_accessV2->column,
								( SIMCObjectTypeV2::StatusType ) (yypvt[-6].yy_statusV2->a) , 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->line : 0, 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->column : 0,
								yypvt[-3].yy_indexV2->indexList, 
								yypvt[-3].yy_indexV2->line, 
								yypvt[-3].yy_indexV2->column,
								yypvt[-3].yy_indexV2->augmentsClause,
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, 
								yypvt[-2].yy_def_val->symbol, 
								yypvt[-2].yy_def_val->line, 
								yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-10].yy_name->line, yypvt[-10].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
							if(s) // Symbol exists in symbol table
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
									// delete (*s);
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
														yypvt[-11].yy_name->name);
									// Remove the symbol for the type reference from the module
									// And delete it
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexListV2;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-11].yy_name; 
				delete yypvt[-10].yy_name; 
				if(yypvt[-9].yy_symbol_ref) delete yypvt[-9].yy_symbol_ref; 
				delete yypvt[-8].yy_name; 
				delete yypvt[-7].yy_accessV2; 
				delete yypvt[-6].yy_statusV2; 
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_indexV2;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr98: {	/* MaxAccessPartV2 :  MAXACCESS NAME */

				SIMCObjectTypeV2::AccessType a;
				if ((a=SIMCObjectTypeV2::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_accessV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_accessV2 = new SIMCAccessInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr99: {	/* MaxAccessPartV2 :  MAXACCESS error */

				yyval.yy_accessV2 = new SIMCAccessInfoV2(SIMCObjectTypeV2::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr100: {	/* StatusPartV2 :  STATUS NAME */

				SIMCObjectTypeV2::StatusType a;
				if ((a=SIMCObjectTypeV2::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_statusV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_statusV2 = new SIMCStatusInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr101: {	/* StatusPartV2 :  STATUS error */

					yyval.yy_statusV2 = new SIMCStatusInfoV2(SIMCObjectTypeV2::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr102: {	/* UnitsPart :  UNITS LITSTRING */

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr103: {	/* UnitsPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr104: {	/* IndexPartV2 :  INDEX LBRACE IndexTypesV2 RBRACE */

				yyval.yy_indexV2 = new SIMCIndexInfoV2(newIndexListV2, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexListV2 = new SIMCIndexListV2;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr105: {	/* IndexPartV2 :  AUGMENTS LBRACE QualifiedName RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[-1].yy_symbol_ref->s);
			
} break;

case YYr106: {	/* IndexPartV2 :  empty */

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, 0, 0);
			
} break;

case YYr107: {	/* IndexPartV2 :  INDEX error */

				yyval.yy_indexV2 = NULL;
				delete newIndexListV2;
				newIndexListV2 = new SIMCIndexListV2;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr110: {	/* IndexTypeV2 :  IMPLIED QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, TRUE));
				}
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr111: {	/* IndexTypeV2 :  QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr112: {	/* TrapTypeDefinition :  NAME TRAPTYPE EnterprisePart VarPart DescrPart ReferPart AllowedCCE NumericValue */

				SIMCTrapTypeType * type = new SIMCTrapTypeType(
					yypvt[-5].yy_symbol_ref->s, yypvt[-5].yy_symbol_ref->line, yypvt[-5].yy_symbol_ref->column,
					yypvt[-4].yy_variables_list, 
					(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
					(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0);

				char *badName1 = theParser->GenerateSymbolName();

				SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
						type, badName1, SIMCSymbol::LOCAL, theModule,
						yypvt[-6].yy_name->line, yypvt[-6].yy_name->column);

				theModule->AddSymbol(typeRef);
				
				SIMCSymbol ** s = theModule->GetSymbol(yypvt[-7].yy_name->name);	
				if(s) // Symbol exists in symbol table
				{
					if(  typeid(**s) == typeid(SIMCUnknown) )
					{
						theModule->ReplaceSymbol( yypvt[-7].yy_name->name,
							new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1),
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
							(*s)->GetReferenceCount()) );
						// delete (*s);
					}
					else
					{
						theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
											yypvt[-7].yy_name->name);
						// Remove the symbol for the type reference from the module
						// And delete it
						theModule->RemoveSymbol(badName1);
						delete type;
						delete typeRef;
						delete newVariablesList;
					}
				}
				else
					theModule->AddSymbol( new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1), 
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column) );

				newVariablesList = new SIMCVariablesList;
				delete badName1; 
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_symbol_ref; 
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name; 
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr113: {	/* TrapTypeDefinition :  NAME TRAPTYPE error AllowedCCE NumericValue */

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr114: {	/* TrapTypeDefinition :  NAME TRAPTYPE error AllowedCCE error */

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr115: {	/* EnterprisePart :  ENTERPRISE ObjectID */

				yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				delete yypvt[-1].yy_name;
			
} break;

case YYr116: {	/* EnterprisePart :  ENTERPRISE error */

				delete yypvt[-1].yy_name;
				theParser->SyntaxError(ENTERPRISE_CLAUSE);
				YYERROR;
			
} break;

case YYr117: {	/* VarPart :  VARIABLES LBRACE VarTypeListForTrap RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr118: {	/* VarPart :  empty */

				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr119: {	/* VarPart :  VARIABLES error */

				yyval.yy_variables_list = newVariablesList;
				theParser->SyntaxError(VARIABLES_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr123: {	/* VarTypeForTrap :  QualifiedName */

					if(yypvt[0].yy_symbol_ref)
					{
						newVariablesList->AddTail(
							new SIMCVariablesItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr128: {	/* UncheckedQualifiedName :  NAME */

					delete yypvt[0].yy_name;
				
} break;

case YYr129: {	/* UncheckedQualifiedName :  ID DOT NAME */

					delete yypvt[-2].yy_name;
					delete yypvt[0].yy_name;
				
} break;

case YYr130: {	/* Typeassignment :  ID AllowedCCE Type */

				if (yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
								new SIMCDefinedTypeReference (
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									(*s)->GetReferenceCount()) 
													);
							// delete (*s);
						}
						else
							theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
											yypvt[-2].yy_name->name);
					}
					else
						theModule->AddSymbol( new SIMCDefinedTypeReference (
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

				}
				delete yypvt[-2].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr133: {	/* BuiltinType :  _BOOLEAN */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->booleanType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr134: {	/* BuiltinType :  OBJECT IDENTIFIER */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->objectIdentifierType,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr135: {	/* BuiltinType :  Octetstring */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->octetStringType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr136: {	/* BuiltinType :  NIL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr137: {	/* BuiltinType :  QualifiedIdOrIntegerOrBits NNlist */

				if( yypvt[0].yy_named_number_list && yypvt[-1].yy_symbol_ref )
				{
					char *badName = theParser->GenerateSymbolName();
					if(yypvt[-1].yy_symbol_ref->s == theParser->integerType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else if (yypvt[-1].yy_symbol_ref->s == theParser->bitsType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_BITS),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}

					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
					delete badName;
					delete yypvt[-1].yy_symbol_ref;
				}
				else  if(yypvt[-1].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[-1].yy_symbol_ref;
				else
					yyval.yy_symbol_ref = NULL;
			
} break;

case YYr138: {	/* BuiltinType :  SequenceOf Type */

				if(yypvt[0].yy_symbol_ref)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceOfType(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column),
								badName,
								SIMCSymbol::LOCAL,
								theModule,
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column) );
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					delete badName;
				}
				else
					yyval.yy_symbol_ref = NULL;
				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr139: {	/* BuiltinType :  SEQUENCE LBRACE ElementTypes RBRACE */

				delete yypvt[-3].yy_name;
				if(newSequenceList)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceType(newSequenceList),
								badName,
								SIMCSymbol::LOCAL,
								theModule) );
					yyval.yy_symbol_ref = new SIMCSymbolReference (
						theModule->GetSymbol(badName), yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
					delete badName;
					newSequenceList = new SIMCSequenceList;
				}
				else
				{
					theParser->SyntaxError(SEQUENCE_DEFINITION);
					newSequenceList = new SIMCSequenceList;
					yyval.yy_symbol_ref = NULL;
				}
			
} break;

case YYr140: {	/* BuiltinType :  SEQUENCE LBRACE error RBRACE */

				theParser->SyntaxError(SEQUENCE_DEFINITION);
				yyval.yy_symbol_ref = NULL;
				delete yypvt[-3].yy_name;
			
} break;

case YYr141: {	/* QualifiedIdOrIntegerOrBits :  INTEGER */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->integerType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr142: {	/* QualifiedIdOrIntegerOrBits :  BITSXX */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->bitsType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr144: {	/* NNlist :  LBRACE NamedNumberList RBRACE */

				yyval.yy_named_number_list = newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
			
} break;

case YYr145: {	/* NNlist :  empty */

				yyval.yy_named_number_list = NULL;
			
} break;

case YYr146: {	/* NNlist :  LBRACE error RBRACE */

				yyval.yy_named_number_list = NULL;
				delete newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
				theParser->SyntaxError(INTEGER_ENUMERATION);
			
} break;

case YYr149: {	/* NamedNumber :  NAME LPAREN NamedNumberValue RPAREN */

				newNamedNumberList->AddTail(new SIMCNamedNumberItem(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
					yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name; 
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr152: {	/* NumericValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, 
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr153: {	/* NumericValue :  LIT_HEX_STRING */

				// attempt to convert it to a signed long
				register char *cp = yypvt[0].yy_hex_string->value;
				if(strlen(cp) > 8)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				}
		
				for (long i = 0; *cp; cp++ ) 
				{
				    i *= 16;
					i += HexCharToDecimal(*cp);
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete badName;
				delete yypvt[0].yy_hex_string;

			
} break;

case YYr154: {	/* NumericValue :  LIT_BINARY_STRING */

				register char *cp = yypvt[0].yy_binary_string->value;
				if(strlen(cp) > 32)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				}
				for (long i = 0; *cp; cp++ ) 
				{
				    i <<= 1;
					i += *cp - '0';
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete badName;
				delete yypvt[0].yy_binary_string;

			
} break;

case YYr157: {	/* NamedType :  NAME Type */

				if(!theModule->GetSymbol(yypvt[-1].yy_name->name) )  
					theModule->AddSymbol( new SIMCUnknown(yypvt[-1].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[-1].yy_name->line,
										yypvt[-1].yy_name->column, 0));

				if (yypvt[0].yy_symbol_ref)
					newSequenceList->AddTail(new SIMCSequenceItem(
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										theModule->GetSymbol(yypvt[-1].yy_name->name),
										yypvt[-1].yy_name->line, yypvt[-1].yy_name->column));
				else
					theParser->SyntaxError(SEQUENCE_DEFINITION);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;

			
} break;

case YYr158: {	/* ToleratedOIDAssignment :  NAME AllowedCCE ObjectID */

		SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
		if(s) // Symbol exists in symbol table
		{
			if(  typeid(**s) == typeid(SIMCUnknown) )
			{
				theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
					new SIMCDefinedValueReference (
						theParser->objectIdentifierType,
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
						yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
						(*s)->GetReferenceCount()) );
				// delete (*s);
			}
			else
			{
				theParser->SemanticError(theModule->GetInputFileName(),
									SYMBOL_REDEFINITION,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
			}
		}
		else
			theModule->AddSymbol( new SIMCDefinedValueReference (
					theParser->objectIdentifierType,
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
					yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

		delete yypvt[-2].yy_name;
		delete yypvt[0].yy_symbol_ref;

	
} break;

case YYr159: {	/* Valueassignment :  NAME Type AllowedCCE Value */

				if(yypvt[0].yy_symbol_ref && yypvt[-2].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-3].yy_name->name);	
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-3].yy_name->name,
								new SIMCDefinedValueReference (
									yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
									(*s)->GetReferenceCount()) );
							// delete (*s);
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
												SYMBOL_REDEFINITION,
												yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
												yypvt[-3].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-3].yy_name->line, yypvt[-3].yy_name->column) );
					}

				}
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
				if(yypvt[-2].yy_symbol_ref)
					delete yypvt[-2].yy_symbol_ref;
				delete yypvt[-3].yy_name;
			
} break;

case YYr162: {	/* BuiltinValue :  TRUE_VAL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->trueValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;

			
} break;

case YYr163: {	/* BuiltinValue :  FALSE_VAL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->falseValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr164: {	/* BuiltinValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (theParser->integerType,
							0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr165: {	/* BuiltinValue :  LIT_HEX_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr166: {	/* BuiltinValue :  LIT_BINARY_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr167: {	/* BuiltinValue :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType, 0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr168: {	/* BuiltinValue :  LBRACE NameList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->bitsType, 0, 0, 
							new SIMCBitsValue(newNameList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newNameList = new SIMCBitValueList;
			
} break;

case YYr169: {	/* BuiltinValue :  LITSTRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType, 0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete badName;
				delete yypvt[0].yy_name;
			
} break;

case YYr170: {	/* BuiltinValue :  NIL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr173: {	/* Name :  NAME */

				newNameList->AddTail(new SIMCBitValue(yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column) );
			
} break;

case YYr176: {	/* Octetstring :  OCTET STRING */

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr179: {	/* SequenceOf :  SEQUENCE OF */

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr180: {	/* SubType :  Type SubtypeRangeSpec */

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						// Create a range sub type
						SIMCRangeType *type = new SIMCRangeType (yypvt[-1].yy_symbol_ref->s, 
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference( theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr181: {	/* SubType :  Type SubtypeSizeSpec */

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						// Create a range sub type
						SIMCSizeType *type = new SIMCSizeType (yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line,
								yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr182: {	/* SubType :  Type error */

					yyval.yy_symbol_ref = NULL;
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr183: {	/* SubtypeRangeSpec :  LPAREN SubtypeRangeAlternative SubtypeRangeAlternativeList RPAREN */

					yyval.yy_range_list = newRangeList;
					newRangeList = new SIMCRangeList;
				
} break;

case YYr184: {	/* SubtypeRangeSpec :  LPAREN error RPAREN */

						delete newRangeList;
						newRangeList = new SIMCRangeList;
						yyval.yy_range_list = NULL;
						theParser->SyntaxError(SUB_TYPE_SPECIFICATION);
						YYERROR;
					
} break;

case YYr185: {	/* SubtypeRangeAlternative :  SubtypeValueSet */

						newRangeList->AddTail(yypvt[0].yy_range_or_size_item);
					
} break;

case YYr188: {	/* SubtypeValueSet :  NumericValue */

				SIMCBuiltInValueReference *bvRef = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue = (SIMCIntegerValue*)bvRef->GetValue();
				yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
				theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr189: {	/* SubtypeValueSet :  NumericValue DOTDOT NumericValue */

				SIMCBuiltInValueReference *bvRef1 = 
					(SIMCBuiltInValueReference *)(*yypvt[-2].yy_symbol_ref->s);
				SIMCIntegerValue *intValue1 = (SIMCIntegerValue*)bvRef1->GetValue();
				SIMCBuiltInValueReference *bvRef3 = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue3 = (SIMCIntegerValue*)bvRef3->GetValue();
				
					yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue1->GetIntegerValue(), intValue1->IsUnsigned(),
							yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column,
							intValue3->GetIntegerValue(), intValue3->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
					theModule->RemoveSymbol((*yypvt[-2].yy_symbol_ref->s)->GetSymbolName());
					theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
					delete yypvt[-2].yy_symbol_ref;
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr190: {	/* SubtypeSizeSpec :  LPAREN _SIZE SubtypeRangeSpec RPAREN */

						yyval.yy_range_list = yypvt[-1].yy_range_list;
						delete yypvt[-2].yy_name;
					
} break;

case YYr191: {	/* SubtypeSizeSpec :  LPAREN _SIZE error RPAREN */

						yyval.yy_range_list = NULL;
						delete yypvt[-2].yy_name;
						theParser->SyntaxError(SIZE_SPECIFICATION);
					
} break;

case YYr192: {	/* QualifiedName :  ID DOT NAME */

			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
										theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else // Module is not mentioned in imports
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr193: {	/* QualifiedName :  NAME */

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				// Reserved Symbol
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					// If Symbol exists in the current module too,
					//		dont use that definition since this is a reserved symbol.
					//		Instead issue a warning.
					// else cool.
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) )  
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name, theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}  
				// Not a reserved symbol, but defined in this module
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				// Not a reserved symbol, not defined in this module so far.
				// Create a new entry, hoping that it will be defined later, or is imported
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr194: {	/* QualifiedId :  ID DOT ID */


			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) )  ) 		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ))
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else // Module is mentioned in imports
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr195: {	/* QualifiedId :  ID */

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				// Reserved Symbol
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					// If Symbol exists in the current module too,
					//		dont use that definition since this is a reserved symbol.
					//		Instead issue a warning.
					// else cool.
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) ) 
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name,  theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				// Not a reserved symbol, but defined in this module
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				// Not a reserved symbol, not defined in this module so far.
				// Create a new entry, hoping that it will be defined later, or is imported
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr196: {	/* AllowedCCE :  InsteadOfCCE */

			theParser->SyntaxError(INSTEAD_OF_CCE, yypvt[0].yy_name->line, yypvt[0].yy_name->column, NULL, yypvt[0].yy_name->name);
			delete yypvt[0].yy_name;
		
} break;

case YYr198: {	/* InsteadOfCCE :  ':' ':' */

			yyval.yy_name = new SIMCNameInfo("::", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr199: {	/* InsteadOfCCE :  ':' '=' */

			yyval.yy_name = new SIMCNameInfo(":=", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr200: {	/* InsteadOfCCE :  '=' */

			yyval.yy_name = new SIMCNameInfo("=", theScanner->yylineno, theScanner->columnNo - 1);
		
} break;

case YYr201: {	/* NotifyDefinition :  NAME NOTIFY ObjectsPart NotificationTypeStatusPart DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						SIMCNotificationTypeType * type = new SIMCNotificationTypeType(
							yypvt[-6].yy_objects_list,
							(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
							(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0,
							yypvt[-5].yy_notification_type_status->a, yypvt[-5].yy_notification_type_status->line, yypvt[-5].yy_notification_type_status->column);

						char *badName1 = theParser->GenerateSymbolName();

						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName1, SIMCSymbol::LOCAL, theModule,
								yypvt[-7].yy_name->line, yypvt[-7].yy_name->column);

						theModule->AddSymbol(typeRef);
						
						// Add an OID value reference
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-8].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-8].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName1), 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
													yypvt[-8].yy_name->name);
								// Remove the symbol for the type reference from the module
								// And delete it
								theModule->RemoveSymbol(badName1);
								delete type;
								delete typeRef;
								delete newObjectsList;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName1), 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column) );


						delete badName1; 
					}
				}
				newObjectsList = new SIMCObjectsList;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-5].yy_notification_type_status; 
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr202: {	/* NotificationTypeStatusPart :  STATUS NAME */

				SIMCNotificationTypeType::StatusType a;
				if ((a=SIMCNotificationTypeType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCNotificationTypeType::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								NOTIFICATION_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_notification_type_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_notification_type_status = new SIMCNotificationTypeStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr203: {	/* ObjectsPart :  OBJECTS LBRACE ObjectTypeListForNotification RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr204: {	/* ObjectsPart :  empty */

				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr205: {	/* ObjectsPart :  OBJECTS error */

				yyval.yy_objects_list = newObjectsList;
				theParser->SyntaxError(OBJECTS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr209: {	/* ObjectTypeForNotification :  QualifiedName */

					if(yypvt[0].yy_symbol_ref)
					{
						newObjectsList->AddTail(
							new SIMCObjectsItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr210: {	/* ModuleIDefinition :  NAME MODULEID LASTUPDATE LITSTRING ORGANIZATION LITSTRING CONTACTINFO LITSTRING DESCRIPTION LITSTRING RevisionPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						theModule->SetModuleIdentityName(yypvt[-12].yy_name->name);
						theModule->SetLastUpdated(yypvt[-9].yy_name->name);
						theModule->SetOrganization(yypvt[-7].yy_name->name);
						theModule->SetContactInfo(yypvt[-5].yy_name->name);
						theModule->SetDescription(yypvt[-3].yy_name->name);

						// Create a value reference in the symbol table,
						// since the symbol can be used as an OID value
					
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
									(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );

					}
					break;
				}
					
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr215: {	/* Revision :  REVISION LITSTRING DESCRIPTION LITSTRING */

				theModule->AddRevisionClause( new SIMCRevisionElement (
									yypvt[-2].yy_name->name, yypvt[0].yy_name->name) );
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr216: {	/* ObjectDefinition :  NAME OBJECTIDENT ObjectIdentityStatusPart DescrPart ReferPart AllowedCCE ObjectID */

				switch( theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						// Form an SIMCObjectIdentity type
						SIMCObjectIdentityType * type = new SIMCObjectIdentityType(
							yypvt[-4].yy_object_identity_status->a, yypvt[-4].yy_object_identity_status->line, yypvt[-4].yy_object_identity_status->column,
							(yypvt[-3].yy_name)? yypvt[-3].yy_name->name : NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line : 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column : 0,
							(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL, (yypvt[-2].yy_name)? yypvt[-2].yy_name->line : 0, (yypvt[-2].yy_name)? yypvt[-2].yy_name->column : 0);

						char *badName = theParser->GenerateSymbolName();
						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName, SIMCSymbol::LOCAL, theModule,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column );
						theModule->AddSymbol(typeRef);
						
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-6].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-6].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
													yypvt[-6].yy_name->name);
								// Remove the symbol for the type reference from the module
								// And delete it
								theModule->RemoveSymbol(badName);
								delete type;
								delete typeRef;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName), 
									yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-6].yy_name->line, yypvt[-6].yy_name->column) );
						}
					}

					delete yypvt[-6].yy_name;
					delete yypvt[-5].yy_name;
					if(yypvt[-4].yy_object_identity_status) delete yypvt[-4].yy_object_identity_status;
					if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
					if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
					if(yypvt[0].yy_symbol_ref) delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr217: {	/* ObjectIdentityStatusPart :  STATUS NAME */

				SIMCObjectIdentityType::StatusType a;
				if ((a=SIMCObjectIdentityType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_IDENTITY_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_object_identity_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_object_identity_status = new SIMCObjectIdentityStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr218: {	/* TextualConventionDefinition :  ID AllowedCCE TEXTCONV DisplayPart STATUS NAME DESCRIPTION LITSTRING ReferPart SYNTAX Type */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(TEXTUAL_CONVENTION_DISALLOWED);
					}
					break;
					default:
					{
						// See if the status clause is valid
						SIMCTextualConvention::SIMCTCStatusType status =
									 SIMCTextualConvention::StringToStatusType(yypvt[-5].yy_name->name);
						if(SIMCTextualConvention::TC_INVALID == status)
							theParser->SemanticError(theModule->GetInputFileName(),
								TC_INVALID_STATUS,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
								yypvt[-5].yy_name->name);
						else
						{	 
							if (yypvt[0].yy_symbol_ref)
							{
								SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
								if(s) // Symbol exists in symbol table
								{
									if(  typeid(**s) == typeid(SIMCUnknown) )
									{
										theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
											new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
												(*s)->GetReferenceCount()) 
																);
										// delete (*s);
									}
									else
										theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
								}
								else
									theModule->AddSymbol( new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							}
						}
					}
					break;
				}
					
				delete yypvt[-10].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr219: {	/* DisplayPart :  DISPLAYHINT LITSTRING */

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr220: {	/* DisplayPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr221: {	/* ObjectGroupDefinition :  NAME OBJECTGROUP OBJECTS LBRACE VarTypeList RBRACE STATUS NAME DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}

				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr222: {	/* NotifyGroupDefinition :  NAME NOTIFYGROUP NOTIFICATIONS LBRACE VarTypeList RBRACE STATUS NAME DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr223: {	/* ModComplianceDefinition :  NAME MODCOMP STATUS NAME DESCRIPTION LITSTRING ReferPart MibPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_COMPLIANCE_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-9].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-9].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
													yypvt[-9].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column) );
					}
				}
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr228: {	/* Mib :  MODULE ModuleIdentifierUnused MandatoryPart CompliancePart */

				delete yypvt[-3].yy_name;
			
} break;

case YYr229: {	/* Mib :  MODULE MandatoryPart CompliancePart */

				delete yypvt[-2].yy_name;
			
} break;

case YYr230: {	/* ModuleIdentifierUnused :  ID */

				if(yypvt[0].yy_name)
					delete (yypvt[0].yy_name);

			
} break;

case YYr231: {	/* ModuleIdentifierUnused :  ID ObjectID */

					if(yypvt[-1].yy_name)
						delete (yypvt[-1].yy_name);
					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr232: {	/* MandatoryPart :  MANDATORY LBRACE VarTypeList RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr238: {	/* Compliance :  GROUP NAME DESCRIPTION LITSTRING */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr239: {	/* Compliance :  OBJECT NAME Syntax WriteSyntax MinAccessPart DESCRIPTION LITSTRING */

				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr240: {	/* Syntax :  SYNTAX Type */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr242: {	/* WriteSyntax :  WSYNTAX Type */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr244: {	/* MinAccessPart :  MINACCESS NAME */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr246: {	/* AgentCapabilitiesDefinition :  NAME AGENTCAP PRELEASE LITSTRING STATUS NAME DESCRIPTION LITSTRING ReferPart ModulePart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(AGENT_CAPABILITIES_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
													yypvt[-11].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );
					}
				}
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr251: {	/* Module :  SUPPORTS ModuleReference INCLUDING LBRACE VarTypeList RBRACE VariationPart */

				delete yypvt[-6].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr252: {	/* ModuleReference :  ID LBRACE ObjectIDComponentList RBRACE */

			delete yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr253: {	/* ModuleReference :  ID */

			delete yypvt[0].yy_name;
		
} break;

case YYr258: {	/* Variation :  VARIATION NAME Syntax WriteSyntax AccessPart CreationPart DefValPart DESCRIPTION LITSTRING */

				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-2].yy_def_val;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr259: {	/* CreationPart :  CREATION LBRACE Creation RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}
yyNext:
	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)		/* busy little loop */
		;
	yystate = ~(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--, yypv--;
#if YYDEBUG
		if (yydebug) yytp--;
#endif
	}
	
yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = (short)yychar;
		scan->yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > stateStack; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif /* YACC_WINDOWS */
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);
			if (YYERRCODE == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > stateStack+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin();
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

}
#if YYDEBUG
/*
 * Return type of token
 */
int
yy_parse::yyGetType(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
yy_parse::yyptok(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

char *
yy_parse::yygetState(int num)
{
	int	size;
	char	*cp;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - States[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
yy_parse::yyExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
yy_parse::yyShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		yysmap[yystate],yystate,yyptok(yychar),yychar,
		yypv - valueStack);
}
// show results of reduction: yyi is rule number
void
yy_parse::yyShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", yyrmap[rule], npop);
}
// show read token
void
yy_parse::yyShowRead()
{
	(void) printf("read %s (%d)\n", yyptok(yychar), yychar);
}
// show Goto
void
yy_parse::yyShowGoto()
{
	(void) printf("goto %d (%d)\n", yysmap[yystate], yystate);
}
// show Shift
void
yy_parse::yyShowShift()
{
	(void) printf("shift %d (%d)\n", yysmap[yystate], yystate);
}
// show error recovery
void
yy_parse::yyShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		yysmap[*(yyps-1)], *(yyps-1), yysmap[yystate], yystate);
}
// show token discards in error processing
void
yy_parse::yyShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		yyptok(yychar), yychar);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */

