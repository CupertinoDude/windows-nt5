//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_PARSER_H
#define SIMC_PARSER_H


/* This file contains the SIMCParse class, which is the parsing engine
 * for parsing MIB files, and it works with the SIMCScanner class, which
 * is the tokenizing engine
 */


/* 
 * The SIMCParser class is derived form the yy_parse class that is
 * generated by the MKS YACC utility, using the information
 * provided in the yacc.y file. This uses the class SIMCScanner as its
 * scanner. SIMCScanner is derived form the class yy_scan that is generated
 * by the MKS LEX utility, using the information provided by the lex.l
 * file.
 * This uses 2 dlls "smierrsy.dll" and "smierrsm.dll" to hold the
 * strings that represent the syntax errors and semantic errors
 * respectively.
 * It uses an SIMCErrorContainer object to put the error messages, it
 * generates.
 * It put the parse information generated for a single parse, info
 * an SIMCModule object.
 * It "knows" about the commonly occuring SMI symbols, like "ip",
 * "transmission" etc., as defined in the "compiler requirements spec".
 */

class SIMCParser : public yy_parse
{
	
	// The size of the buffer used to construct an error message
	static const int MESSAGE_SIZE;

	// The lowest syntax error Id
	static const int SYNTAX_ERROR_BASE;

	// The lowest parser semantic error Id
	static const int SEMANTIC_ERROR_BASE;

	// The text for the various severity levels enumerated by 
	// enum severityLevel
	static const char * const severityLevels[];

	// The place to put the error messages
	SIMCErrorContainer *_errorContainer;	

	// The information collected from the module
	SIMCModule * _module;

	// The flag that is used to decide whether to parse the next module as
	// a V1 or a V2 one. Used by Parse()
	int _snmpVersion;

	// Used to set those pesky references that are initially beleived to be forward
	// references, but actually are references to imported symbols.
	BOOL SetImportSymbols();

	// A count of errors, for each call of Parse()
	long _fatalCount, _warningCount, _informationCount;

	public:

		// The resource-only dll with parser error text string table
		static  HINSTANCE semanticErrorsDll;

		// The resource-only dll with syntax error text string table
		static  HINSTANCE syntaxErrorsDll;

 
		// You always need an error container and a scanner, to parse
		SIMCParser(SIMCErrorContainer * errorContainer, SIMCScanner * scanner);
		
		virtual ~SIMCParser();


 		// The names of the dlls
		static const char * const semanticErrorsDllFile;
		static const char * const syntaxErrorsDllFile;


		// The scanner associated with this parser
		SIMCScanner *_theScanner;

		// ---------------- The symbols known by the parser ---------------------
		SIMCModule	*other,		// Modules common to V1 and V2
					*rfc1155,	// These are V1 only
					*rfc1213, 
					*rfc1212, 
					*rfc1215, 
					*rfc1230, 
					*rfc1902,	// These are V2 only
					*rfc1903,
					*rfc1904,
					*rfc1906;

		SIMCSymbol	**objectIdentifierType,  // These are primitive ASN.1 types 
					**integerType, 
					**octetStringType,
					**nullType, 
					**bitsType, 
					**booleanType;

		SIMCSymbol							// These are V1 OIDs
					**isoV1, 				
					**ccittV1, 
					**jointIsoCcittV1,
					**internetV1, 
					**directoryV1, 
					**mgmtV1, 
					**experimentalV1,
					**privateV1, 
					**enterprisesV1, 
					**mib2V1, 
					**ipV1, 
					**interfacesV1,
					**transmissionV1,
					**zeroDotZeroV2,
					**orgV2,				// These are V2 OIDs
					**dodV2,
					**internetV2,
					**directoryV2,
					**mgmtV2,
					**mib2V2,
					**ipV2,
					**interfacesV2,
					**transmissionV2,
					**experimentalV2,
					**privateV2,
					**enterprisesV2,
					**securityV2,
					**snmpV2V2,
					**snmpDomainsV2,
					**snmpProxysV2,
					**snmpModulesV2,
					**snmpUDPDomainV2,
					**snmpCLNSDomainV2,
					**snmpCONSDomainV2,
					**snmpDDPDomainV2,
					**snmpIPXDomainV2,
					**rfc1157DomainV2,
					**rfc1157ProxyV2;

		SIMCSymbol	**trueValueReference,  // Some values 
					**falseValueReference, 
					**nullValueReference;
		
		// Symbols for the severity levels of the messages
		enum SeverityLevel
		{
			INVALID,
			FATAL,
			WARNING,
			INFORMATION
		};
		
		// Manipulate the SNMP version of this parser. Parsing is done based
		// on this value, as follows
		// 1 - SNMPv2 SMI
		// 2 - SNMPv2 SMI
		// 0 - Union of V1 and V2 SMIs
		int GetSnmpVersion() const
		{
			return _snmpVersion;
		}
		BOOL SetSnmpVersion( int x )
		{
			switch(x)
			{
				case 0:		// '0' means union of v1 and v2 SMIs
				case 1:
				case 2:
					_snmpVersion = x;
					return TRUE;
				default:
					_snmpVersion = 0;
					return FALSE;
			}
		}

		/*
		 * The main parsing function that is called by the user
		 * Return TRUE if the parse is successful. The GetModule() function
		 * may then be called to retrieve the parsed information.
		 * It it returns false, check the error container for error
		 * messages
		 */
		BOOL Parse();

		// A function to generate syntax error messages
		void SyntaxError(int errorType, 
			int lineNo = -1, 
			int columnNo = -1,
			char *lastToken = NULL, char *infoString = NULL);

		// Convert severity level to "readable" form
		const char * const GetSeverityString(int severityLevel)
		{
			return severityLevels[severityLevel];
		}

		// A function to generate semantic error messages
		void SemanticError(const char * const fileName, int errorType,
			int lineNo,
			int columnNo,
			...);

		// Get the parsed information, after a successful call to Parse()
		SIMCModule * GetModule() const;

		void SetErrorContainer(SIMCErrorContainer *errorContainer)
		{
			if(errorContainer)
				_errorContainer = errorContainer;
		}
		SIMCErrorContainer * GetErrorContainer() const
		{
			return _errorContainer;
		}
		void SetScanner( SIMCScanner * scanner)
		{
			_theScanner = scanner;
		}

		/*
		 * Utility functions that are used in Parse(), and also
		 * can be used by the user of this class.
		 *
		 */

		// TRUE, if the symbol specified, is viewed as a symbol
		// "known" to the parser, from the module specified, as per
		// SNMPV1 SMI rules
		static BOOL IsReservedSymbolV1(const char *const name,
						const char * const moduleName);
		// Returns the module in which this "known" symbol is defined, as
		// per the SNMPV1 SMI. Return null if the symbol is "unknown"
		const SIMCModule* IsReservedSymbolV1(const char * const symbolName);
		
		// TRUE, if the symbol specified, is viewed as a symbol
		// "known" to the parser, from the module specified, as per
		// SNMPV2 SMI rules
		static BOOL IsReservedSymbolV2(const char *const name,
						const char * const moduleName);
		// Returns the module in which this "known" symbol is defined, as
		// per the SNMPV2 SMI. Return null if the symbol is "unknown"
		const SIMCModule* IsReservedSymbolV2(const char * const symbolName);

		// Another way of using the above functions
		const SIMCModule* IsReservedSymbol(const char * const symbolName);
		BOOL IsReservedSymbol(const char *const name, const char * const moduleName);
		static BOOL IsReservedSymbol(long snmpVersion, const char *const name,
						const char * const moduleName);
	
		// TRUE, if the module specified, is viewed as a module
		// "known" to the parser, as per SNMPV1 SMI rules
		static BOOL IsReservedModuleV1(const char *const name);
		// TRUE, if the module specified, is viewed as a module
		// "known" to the parser, as per SNMPV2 SMI rules
		static BOOL IsReservedModuleV2(const char *const name);
		// Another way of using the above functions
		static BOOL IsReservedModule(long snmpVersion, const char *const name);
	
		// Used in error-tolerance. Never called by the user
		static const char * GetCorrectModuleNames(const char * const symbolName);

		// Helper functions
		void DoImportModule( SIMCModule *mainModule, SIMCModule *importModule);
		void CreateReservedModules();
		void RemoveExtraneousReservedModule(SIMCModule *module);

		// Generate a unique name of the form "*n" for an anonymnous symbol.
		// n is an integer
		char * GenerateSymbolName()
		{
			static long n = 1;
			char buf[25];
			buf[0] = '*';
			sprintf(buf+1, "%ld", n++);
			return NewString(buf);
		}
		


		long GetFatalCount() const
		{
			return _fatalCount;
		}
		long GetWarningCount() const
		{
			return _warningCount;
		}
		long GetInformationCount() const
		{
			return _informationCount;
		}


};


#endif // SIMC_PARSER_H
