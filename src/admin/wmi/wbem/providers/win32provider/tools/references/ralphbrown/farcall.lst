FAR CALL Interface List		Release 55		Last change 28sep97
Copyright (c) 1989,1990,1991,1992,1993,1994,1995,1996,1997 Ralf Brown

=============================================
>CALL 0000h:0000h - Sample Entry
>InstallCheck:	how to determine CALL address if variable, whether it is
>	  available if address is fixed
>Program: description of the program(s) providing the API
>Note:	any notes related to the API
>SeeAlso: related APIs, and interrupt entries for this API in INTERRUP.*
>
>Call entry point with:
>	input registers
>Return: result registers
>
>Format of data:
>Offset	Size	Description
> 00h	...	...
=============================================

--------D-@00600000--------------------------
CALL 0060h:0000h - Eagle MS-DOS v1.25 IO.SYS - INITIALIZE
InstallCheck:	MS-DOS v1.25 must be installed
Note:	this function should only be called by MSDOS.SYS
SeeAlso: @0060h:0003h,@0060h:0039h
--------D-@00600003--------------------------
CALL 0060h:0003h - Eagle MS-DOS v1.25 IO.SYS - CHECK FOR KEYSTROKE
InstallCheck:	MS-DOS v1.25 must be installed
Note:	does not return extended keystrokes
SeeAlso: @0060h:0000h,@0060h:0006h,@0060h:0027h

(Table F001)
Call Eagle MS-DOS entry point 0003h with:
	nothing
Return: ZF set if no key
	ZF clear if keystroke available
	    AL = keystroke
--------D-@00600006--------------------------
CALL 0060h:0006h - Eagle MS-DOS v1.25 IO.SYS - WAIT FOR KEYSTROKE
InstallCheck:	MS-DOS v1.25 must be installed
Notes:	if an extended keystroke is available, only the low byte is returned,
	  and this function must be called again to get the high byte
	the BIOS keycode 0000h (Ctrl-Break) is returned as 00h+FFh to avoid
	  the ambiguity that might be caused by returning the 00h high byte
SeeAlso: @0060h:0000h,@0060h:0003h,@0060h:0027h

(Table F002)
Call Eagle MS-DOS entry point 0006h with:
	nothing
Return: AL = keystroke
	flags modified
--------D-@00600009--------------------------
CALL 0060h:0009h - Eagle MS-DOS v1.25 IO.SYS - OUTPUT CHARACTER TO SCREEN
InstallCheck:	MS-DOS v1.25 must be installed
Note:	this entry point supports most of the ANSI.SYS control sequences,
	  plus several additional escape sequences
SeeAlso: @0060h:0000h,@0060h:0003h,@0060h:000Ch

(Table F003)
Call Eagle MS-DOS entry point 0009h with:
	AL = character to output
Return: flags modified
--------D-@0060000C--------------------------
CALL 0060h:000Ch - Eagle MS-DOS v1.25 IO.SYS - OUTPUT CHARACTER TO PRINTER
InstallCheck:	MS-DOS v1.25 must be installed
Note:	this entry point is able, if set by configuration (see @0060h:0039h),
	  to strip linefeed characters following carriage returns
SeeAlso: @0060h:0000h,@0060h:0009h

(Table F004)
Call Eagle MS-DOS entry point 000Ch with:
	AL = character to be printed
Return: flags modified
--------D-@0060000F--------------------------
CALL 0060h:000Fh - Eagle MS-DOS v1.25 IO.SYS - INPUT CHAR FROM AUX: DEVICE
InstallCheck:	MS-DOS v1.25 must be installed
Note:	if the configured AUX: device is a parallel port, this call always
	  returns a Ctrl-Z as the "read" character; Ctrl-Z is also returned
	  if the user presses Esc or Ctrl-Break while waiting for a character
	  to arrive on a serial port
SeeAlso: @0060h:0000h

(Table F005)
Call Eagle MS-DOS entry point 000Fh with:
	nothing
Return: AL = received character
--------D-@00600012--------------------------
CALL 0060h:0012h - Eagle MS-DOS v1.25 IO.SYS - OUTPUT CHAR TO AUX: DEVICE
InstallCheck:	MS-DOS v1.25 must be installed
Note:	if the port is busy, this function waits until the port becomes
	  available or the user presses Esc or Ctrl-Break
SeeAlso: @0060h:0000h

(Table F006)
Call Eagle MS-DOS entry point 0012h with:
	AL = character to output
Return: flags modified
--------D-@00600015--------------------------
CALL 0060h:0015h - Eagle MS-DOS v1.25 IO.SYS - READ ABSOLUTE SECTOR(S)
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:0018h,@0060h:001Bh

(Table F007)
Call Eagle MS-DOS entry point 0015h with:
	AL = drive table number
	ES:BX -> buffer
	CX = number of sectors to read
	DX = logical sector number of first sector
	AH = verify flag
Return: CF clear if successful
	CF set on error
	    AL = error code
		0Ch drive table number out of range
Note:	the drive number in AL is *not* the logical DOS drive number, but
	  the number of an internal data table; multiple data tables, each
	  describing a distinct disk format, may be shared by one logical
	  drive
--------D-@00600018--------------------------
CALL 0060h:0018h - Eagle MS-DOS v1.25 IO.SYS - WRITE ABSOLUTE SECTOR(S)
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:0015h,@0060h:001Bh

(Table F008)
Call Eagle MS-DOS entry point 0018h with:
	AL = drive table number
	ES:BX -> data to be written
	CX = number of sectors to write
	DX = logical sector number of first sector
	AH = verify flag
Return: CF clear if successful
	CF set on error
	    AL = error code
		0Ch drive table number out of range
Note:	the drive number in AL is *not* the logical DOS drive number, but
	  the number of an internal data table; multiple data tables, each
	  describing a distinct disk format, may be shared by one logical
	  drive
--------D-@0060001B--------------------------
CALL 0060h:001Bh - Eagle MS-DOS v1.25 IO.SYS - DETERMINE DISK FORMAT
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:0015h,@0060h:002Ah

(Table F009)
Call Eagle MS-DOS entry point 001Bh with:
	AL = DOS drive number
Return: CF clear if successful
	    AL = drive table number
	    AH = ??? flag
		00h ???
		FFh ???
	CF set on error
	    AL = error code
		02h ???
		0Ch unrecognized format
--------D-@0060001E--------------------------
CALL 0060h:001Eh - Eagle MS-DOS v1.25 IO.SYS - SET DAY COUNT
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:0021h,@0060h:0024h

(Table F010)
Call Eagle MS-DOS entry point 001Eh with:
	AX = day count
Return: nothing
--------D-@00600021--------------------------
CALL 0060h:0021h - Eagle MS-DOS v1.25 IO.SYS - SET SYSTEM TIME
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:001Eh,@0060h:0024h

(Table F011)
Call Eagle MS-DOS entry point 0021h with:
	CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths
Return: flags modified
--------D-@00600024--------------------------
CALL 0060h:0024h - Eagle MS-DOS v1.25 IO.SYS - READ SYSTEM TIME
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:001Eh,@0060h:0021h

(Table F012)
Call Eagle MS-DOS entry point 0024h with:
	nothing
Return: AX = day count
	CH = hours
	CL = minutes
	DH = seconds
	DL = hundredths
--------D-@00600027--------------------------
CALL 0060h:0027h - Eagle MS-DOS v1.25 IO.SYS - CLEAR KEYBOARD BUFFER
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:0003h,@0060h:0006h

(Table F013)
Call Eagle MS-DOS entry point 0027h with:
	nothing
Return: ZF set
--------D-@0060002A--------------------------
CALL 0060h:002Ah - Eagle MS-DOS v1.25 IO.SYS - SEARCH FOR NEXT DISK FORMAT
InstallCheck:	MS-DOS v1.25 must be installed
SeeAlso: @0060h:0000h,@0060h:001Bh

(Table F014)
Call Eagle MS-DOS entry point 002Ah with:
	AL = drive table number
Return: AL = next drive table number with matching disk sector size and media
	      ID byte
--------D-@00600039--------------------------
CALL 0060h:0039h - Eagle MS-DOS v1.25 IO.SYS - CONFIGURE FROM SYSINFO.SYS
InstallCheck:	MS-DOS v1.25 must be installed
Note:	reads the first 144 bytes of SYSINFO.SYS from the current drive into
	  an internal configuration buffer
SeeAlso: @0060h:0000h
--------V-@C0000003--------------------------
CALL C000h:0003h - VIDEO BIOS INITIALIZATION
InstallCheck:	C000h:0000h must contain the word AA55h and the 
		  512*BYTE[C000h:0002h] bytes must sum to 00h (mod 256)
Note:	is normally called only by the System ROM BIOS initialization code
--------V-@C0000064--------------------------
CALL C000h:0064h U - ATI Mach32 VIDEO BIOS - ???
InstallCheck: ATI Mach32 video board must be installed
SeeAlso: @C000h:0068h"Mach32",@C000h:006Ch,@C000h:0070h

(Table F015)
Call ATI Mach32 entry point with:
	AL = function
	    00h ???
	    01h,02h ???
	    11h,12h ???
	    21h,22h ???
	    41h,42h ???
	    81h,82h ???
Return: CF clear if successful
	CF set on error
--------V-@C0000064--------------------------
CALL C000h:0064h U - ATI Mach64 VIDEO BIOS - ALTERNATE INT 10/AH=A0h (IRET)
InstallCheck: ATI Mach64 video board must be installed
SeeAlso: @C000h:0068h"Mach64",INT 10/AH=A0h"Mach64"
--------V-@C0000068--------------------------
CALL C000h:0068h U - ATI Mach32 VIDEO BIOS - ???
InstallCheck: ATI Mach32 video board must be installed
SeeAlso: @C000h:0064h"Mach32",@C000h:006Ch,@C000h:0070h

(Table F016)
Call ATI Mach32 entry point with:
	AL = ??? (00h-02h)
	???
Return: ???
--------V-@C0000068--------------------------
CALL C000h:0068h U - ATI Mach64 VIDEO BIOS - ALTERNATE INT 10/AH=A0h (RETF)
InstallCheck: ATI Mach64 video board must be installed
SeeAlso: @C000h:0064h"Mach64",INT 10/AH=A0h"Mach64"
--------V-@C000006C--------------------------
CALL C000h:006Ch - ATI Mach32 VIDEO BIOS - 
InstallCheck: ATI Mach32 video board must be installed
SeeAlso: @C000h:0064h,@C000h:0068h,@C000h:0070h

(Table F017)
Call ATI Mach32 entry point with:
	AL = function
	    00h get ???
		Return: AX = ??? (019Eh)
	    01h get ??? information
		ES:BX -> buffer for ??? information (see #F018)
		Return: buffer filled
	    02h get ???
		Return: AX = ??? (0250h)
			BX = ??? (0A00h)
			CX = ??? (0200h)
			DX = ??? (0003h)
Return: CF clear if successful
	CF set if invalid function
	all other registers preserved
Note:	officially (Programmer's Reference Guide), interrupts should be
	  disabled (CLI) during a function 01h call

Format of ATI Mach32 ??? information:
Offset	Size	Description	(Table F018)
 00h	WORD	number of bytes of data returned (0116h for tested BIOS)
 02h  2 BYTEs	??? (00h 00h and 00h 05h seen)
 04h	WORD	offset of video mode records??? (0028h)
 06h	BYTE	length of one video mode record??? (22h)
 07h	BYTE	???
 08h	BYTE	??? (00h/01h, reflects bit 1 of port 36EEh)
 09h	BYTE	??? (01h)
 0Ah	BYTE	???
 0Bh	BYTE	memory size
		00h = 256K, 01h = 512K, 02h = 1024K, 03h = 2M, 04h = 4M
 0Ch	BYTE	???
 0Dh	BYTE	???
 0Eh	BYTE	???
 0Fh	BYTE	??? (bits 6-4 of port 42E8h)
 10h	BYTE	???
 11h	BYTE	???
 12h	BYTE	???
 13h	BYTE	???
 14h	WORD	???
 16h	BYTE	???
 17h	BYTE	???
 18h	BYTE	???
 19h 14 BYTEs	unused
 27h	BYTE	scratch byte used by ROM code
 28h 34N BYTEs	??? video mode records (see #F019)
SeeAlso: #F017

Format of ATI Mach32 ??? video mode record:
Offset	Size	Description	(Table F019)
 00h	WORD	horizontal resolution in pixels
 02h	WORD	vertical resolution in pixels
 04h 30 BYTEs	???
SeeAlso: #F018
--------V-@C0000070--------------------------
CALL C000h:0070h U - ATI Mach32 VIDEO BIOS - ???
InstallCheck: ATI Mach32 video board must be installed
SeeAlso: @C000h:0064h,@C000h:0068h,@C000h:006Ch

(Table F020)
Call ATI Mach32 entry point with:
	AH = function
	    00h ???
	    01h ???
	    02h ???
		AL = subfunction
		    00h ???
		    01h ???
	    03h ???
		AL = ??? (00h/nonzero)
Return: CF clear if successful
	CF set on error
--------B-@F000E739--------------------------
CALL F000h:E739h - ROM BIOS INT 14 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000E82E--------------------------
CALL F000h:E82Eh - ROM BIOS INT 16 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000EC59--------------------------
CALL F000h:EC59h - ROM BIOS INT 13 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000EFD2--------------------------
CALL F000h:EFD2h - ROM BIOS INT 17 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000F065--------------------------
CALL F000h:F065h - ROM BIOS INT 10 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000F841--------------------------
CALL F000h:F841h - ROM BIOS INT 12 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000F84D--------------------------
CALL F000h:F84Dh - ROM BIOS INT 11 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000F859--------------------------
CALL F000h:F859h - ROM BIOS INT 15 HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------B-@F000FE6E--------------------------
CALL F000h:FE6Eh - ROM BIOS INT 1A HANDLER
InstallCheck:	present if BIOS is 100% compatible with original IBM PC
--------H-@F000FFF0--------------------------
CALL F000h:FFF0h - COLD-BOOT ADDRESS
InstallCheck:	always present
SeeAlso: @FFFFh:0000h
--------H-@FFFF0000--------------------------
CALL FFFFh:0000h - COLD-BOOT ADDRESS
InstallCheck:	always present
Note:	this address is another way of expressing F000h:FFF0h
SeeAlso: @F000h:FFF0h
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - 10NET - 10MEMMGR.SYS
InstallCheck:	see INT 21/AX=4402h"10MEMMGR"
SeeAlso: INT 21/AX=4402h"10MEMMGR"
--------t-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Alternate Multiplex Interrupt Specification TSRs
InstallCheck:	see INT 2D"AMIS"
SeeAlso: INT 2D"AMIS"
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - AutoCAD Device Interface
InstallCheck:	see INT 7A/AX=0001h
SeeAlso: INT 7A/AX=0001h
----------@xxxxxxxx---------------------------
CALL xxxxh:xxxxh - BIOS32 Service Directory
InstallCheck:	scan paragraph boundaries E000h to FFFFh for signature string
	"_32_", followed by a valid header structure (see #F021)
Notes:	a 32-bit-code alternate PCI BIOS entry point may be found (if
	  supported) by requesting the entry point for the API with
	  identifier "$PCI"
	an alternate entry point for INT 1A/AH=B4h may be found (if
	  supported) by requesting the entry point for the API with identifier
	  "$ACF"
SeeAlso: INT 1A/AX=B100h

Format of BIOS32 Service Directory header structure:
Offset	Size	Description	(Table F021)
 00h  4 BYTEs	signature "_32_"
 04h	DWORD	physical address of BSD entry point (see #F022)
 08h	BYTE	header structure version number (currently 00h)
 09h	BYTE	header structure length in paragraphs (currently 01h)
 0Ah	BYTE	checksum (8-bit sum of all bytes in structure, including this
		  one, should equal zero)
 0Bh  5 BYTEs	reserved (0)

(Table F022)
Call BIOS32 Service Directory entry point with:
	EBX = function
	    00000000h get service entry point
		EAX = service identifier
		    49435024h ("ICP$") PCI BIOS
		    46434124h ("FCA$") Plug-and-Play Auto-Configuration
		Return: AL = status
			    00h successful
				 EBX = base address of handler's code seg
				 ECX = size of code segment
				 EDX = offset of handler in code seg
			    80h unknown service identifier
	    else
		Return: AL = 81h invalid function
Notes:	the BSD handler assumes that it is running in a 32-bit code segment
	the returned entry points for PCI BIOS and Auto-Config must be called
	  with the same registers as the real-mode INT 1Ah interface,
	  including the value B1h or B4h in AH (AMI BIOS v1.00.05.AX1 returns
	  the same entry point for both interfaces and uses AH to distinguish
	  which API is desired)
	some references indicate that only BL is used for the function number,
	  though at least one implementation actually checks the entire EBX
	  register; for maximum compatibility, the upper 24 bits of EBX should
	  be cleared when calling the entry point
SeeAlso: #F021
--------E-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Borland TKERNEL
InstallCheck:	see INT 2F/AX=FBA1h/BX=0082h
SeeAlso: INT 2F/AX=FBA1h/BX=0082h
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Buffit v3.0
InstallCheck:	see INT 60"Buffit"
SeeAlso: INT 60"Buffit"
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - CEMM v5.10+ Private API
InstallCheck:	see INT 21/AX=4402h/SF=00h
SeeAlso: INT 21/AX=4402h/SF=00h
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Cloaking - PROTECTED-MODE API
InstallCheck:	see INT 2C/AX=001Dh
SeeAlso: INT 2C/AX=001Dh
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Cloaking - REAL-MODE API
InstallCheck:	see INT 2F/AX=4310h"Cloaking"
SeeAlso: INT 2F/AX=4310h"Cloaking"
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - CTMMSYS.SYS - API
InstallCheck:	see INT 21/AX=4402h"CTMMSYS"
Program: CTMMSYS.SYS is the Creative DOS Multimedia Architecture Integration
	  driver
SeeAlso: INT 21/AX=4402h"CTMMSYS"
--------Q-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DESQview XDI - Driver API
InstallCheck:	see INT 2F/AX=DE01h
SeeAlso: INT 2F/AX=DE01h
--------D-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Device Drivers
InstallCheck:	see INT 21/AH=52h
SeeAlso: INT 21/AH=52h
--------E-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Protected-Mode Interface - MODE SWITCH
InstallCheck:	see INT 2F/AX=1687h
SeeAlso: INT 2F/AX=1687h
--------E-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Protected-Mode Interface - Phar Lap RUN286
InstallCheck:	see INT 2F/AX=168Ah
SeeAlso: INT 2F/AX=168Ah
--------E-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Protected-Mode Interface - Vendor-Specific APIs
InstallCheck:	see INT 31/AX=0A00h
SeeAlso: INT 31/AX=0A00h
--------E-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Protected-Mode Interface - Windows Support
InstallCheck:	see INT 2F/AX=168Ah
SeeAlso: INT 2F/AX=168Ah
--------E-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Protected-Mode Services
InstallCheck:	see INT 2F/AX=43E0h
SeeAlso: INT 2F/AX=43E1h
--------T-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Task Switcher - Callout
InstallCheck:	see INT 2F/AX=4B01h
SeeAlso: INT 2F/AX=4B01h
--------T-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - DOS Task Switcher
InstallCheck:	see INT 2F/AX=4B02h
SeeAlso: INT 2F/AX=4B02h
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Enhanced Parallel Port (EPP) BIOS
InstallCheck:	see INT 17/AX=0200h/BX=5050h
SeeAlso: INT 17/AX=0200h/BX=5050h
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Extended Memory Specification (XMS)
InstallCheck:	see INT 2F/AX=4300h
SeeAlso: INT 2F/AX=4310h
--------c-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - FASTOPEN
InstallCheck:	see INT 2F/AX=122Ah
SeeAlso: INT 2F/AX=122Ah
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - HIGHUMM.SYS
InstallCheck:	see INT 21/AX=4402h"HIGHUMM"
SeeAlso: INT 21/AX=4402h"HIGHUMM"
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - HugeRealMode Driver
InstallCheck:	see INT 78/AX=0000h,INT 78/AX=0001h
SeeAlso: INT 78/AX=0001h
--------V-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - IBM 8514/A Adapter Interface (HDILOAD)
InstallCheck:	see INT 7F/AX=0105h
SeeAlso: INT 7F/AX=0105h
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - IBM 8516 Touch Screen Device Driver
InstallCheck:	see INT 7F/AX=ABCDh
SeeAlso: INT 7F/AX=ABCDh
--------u-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - IBM System 36/38 Workstation Emulation
InstallCheck:	see INT 0C"SYSTEM 36/38"
SeeAlso: INT 0C"SYSTEM 36/38"
--------D-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - IFS Drivers
InstallCheck:	see INT 21/AH=52h
SeeAlso: INT 21/AH=52h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - IFSHLP.SYS
InstallCheck:	see INT 21/AH=3Fh"IFSHLP"
SeeAlso: INT 21/AH=3Fh"IFSHLP"
--------b-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Intel BIOS Upgrade
InstallCheck:	scan paragraph boundaries from 0F0000h to 0FFFFFh for signature
	  string "$IBU" (see #F023)
SeeAlso: INT 15/AX=D042h/BL=00h
!!! IAL\PROCESSR\PPROBIOS.PDF page 60

Format of Intel BIOS Upgrade header:
Offset	Size	Description	(Table F023)
 00h  4 BYTEs	signature "$IBU"
 04h	BYTE	IBU specification version (currently 01h = 1.0)
 05h	BYTE	length of entire header structure in bytes (currently 17h)
 06h	BYTE	checksum (forces 8-bit sum of all header bytes to 00h)
 07h	DWORD	real-mode entry point address
 0Bh	WORD	offset of 16-bit protected mode entry point
 0Dh	DWORD	segment base address of 16-bit protected-mode entry point
 11h	WORD	real-mode data segment address
 13h	DWORD	segment base address of 16-bit protected-mode data segment
Notes:	calls from 32-bit protected mode may be made to the 16-bit entry
	  point, but must ensure that any stack arguments are pushed as
	  16-bit values instead of 32-bit values
	the entry point uses standard C calling conventions to implement
	  functions prototyped as
		int far (*entrypoint)(int function, ...)
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Interrupt Sharing Protocol
InstallCheck:	see INT 2D"AMIS"
SeeAlso: INT 2D"AMIS"
--------X-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Intel System Management Bus BIOS
InstallCheck:	see INT 15/AX=53B0h/BH=01h,INT 15/AX=53B0h/BH=02h
SeeAlso: INT 15/AX=53B0h/BH=01h,INT 15/AX=53B0h/BH=05h
--------G-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - INTRSPY v1.0 only
InstallCheck:	see INT 60"INTRSPY"
SeeAlso: INT 60"INTRSPY"
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Memory Managers
InstallCheck:	see INT 21/AX=4402h/SF=00h
SeeAlso: INT 21/AX=4402h/SF=00h
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Microsoft EMM386.EXE
InstallCheck:	see INT 67/AX=FFA5h
SeeAlso: INT 67/AX=FFA5h
--------M-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Microsoft Mouse Driver - Alternate Entry Point
InstallCheck:	INT 33 must be non-NULL, and must not point at an IRET
	  instruction; the alternate entry point is located two bytes past
	  the INT 33 handler
Note:	this alternate entry point accepts the same arguments as the
	  INT 33 interface, but is invoked with a FAR CALL instead of INT 33.
SeeAlso: INT 33/AX=0000h
--------k-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Microsoft Real-Time Compression Interface (MRCI)
InstallCheck:	see INT 1A/AX=B001h
SeeAlso: INT 1A/AX=B001h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Microsoft Workgroup Connection - WORKGRP.SYS
InstallCheck:	see INT 21/AH=3Fh"WORKGRP.SYS"
SeeAlso: INT 21/AX=4402h"WORKGRP.SYS"
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - DOSMGR Device
InstallCheck:	see INT 2F/AX=1684h/BX=0015h
SeeAlso: INT 2F/AX=1684h/BX=0015h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - EDOS Device
InstallCheck:	see INT 2F/AX=1684h/BX=2925h
SeeAlso: INT 2F/AX=1684h/BX=2925h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - POSTMSG Device
InstallCheck:	see INT 2F/AX=1684h/BX=8888h
SeeAlso: INT 2F/AX=1684h/BX=8888h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - REBOOT Device
InstallCheck:	see INT 2F/AX=1684h/BX=0009h
SeeAlso: INT 2F/AX=1684h/BX=0009h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - SHELL Device
InstallCheck:	see INT 2F/AX=1684h/BX=0017h
SeeAlso: INT 2F/AX=1684h/BX=0017h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - VADMAD Device
InstallCheck:	see INT 2F/AX=1684h/BX=0444h
SeeAlso: INT 2F/AX=1684h/BX=0444h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - VbillD Device
InstallCheck:	see INT 2F/AX=1684h/BX=8888h
SeeAlso: INT 2F/AX=1684h/BX=8888h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - VSWITCHD Device
InstallCheck:	see INT 2F/AX=1684h/BX=0750h
SeeAlso: INT 2F/AX=1684h/BX=0750h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - VTD Device
InstallCheck:	see INT 2F/AX=1684h/BX=0005h
SeeAlso: INT 2F/AX=1684h/BX=0005h
--------W-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - MS Windows - WPS Device
InstallCheck:	see INT 2F/AX=1684h/BX=310Eh
SeeAlso: INT 2F/AX=1684h/BX=310Eh
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Netroom RM386 v6.00
InstallCheck:	see INT 2F/AX=4310h
SeeAlso: INT 2F/AX=4310h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell - ODI Link Support Layer
InstallCheck:	see INT 2F/AX=C000h"LSL.COM"
SeeAlso: INT 2F/AX=C000h"LSL.COM"
--------O-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell DOS 7 DELWATCH.EXE
InstallCheck:	see INT 2F/AX=10FEh
SeeAlso: INT 2F/AX=10FEh
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell DOS 7 EMM386.EXE
InstallCheck:	see INT 2F/AX=12FFh/BX=0106h
SeeAlso: INT 2F/AX=12FFh/BX=0106h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - Access Server Driver
InstallCheck:	see INT 2F/AX=7AF1h
SeeAlso: INT 2F/AX=7AF1h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - DOS Requester
InstallCheck:	see INT 2F/AX=7A20h/BX=0000h
SeeAlso: INT 2F/AX=7A20h/BX=0000h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell Netware - Event Service Layer
InstallCheck:	see INT 2F/AX=C000h"NESL"
SeeAlso: INT 2F/AX=C000h"NESL"
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - IPX
InstallCheck:	see INT 2F/AX=7A00h
SeeAlso: INT 2F/AX=7A00h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - IPXODI
InstallCheck:	see INT 2F/AX=7A2Fh
SeeAlso: INT 2F/AX=7A2Fh
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - TCP/IP Protocol Stack
InstallCheck:	see INT 2F/AX=7A40h
SeeAlso: INT 2F/AX=7A40h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - VLM
InstallCheck:	see INT 2F/AX=7A20h/BX=0000h
SeeAlso: INT 2F/AX=7A20h/BX=0000h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - VLM CallA
InstallCheck:	see INT 2F/AX=7A20h/BX=0001h
SeeAlso: INT 2F/AX=7A20h/BX=0001h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - VLM Multicast
InstallCheck:	see INT 2F/AX=7A20h/BX=0004h
SeeAlso: INT 2F/AX=7A20h/BX=0004h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - VLM Multiplex
InstallCheck:	see INT 2F/AX=7A20h/BX=0002h
SeeAlso: INT 2F/AX=7A20h/BX=0002h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare - VLM Parse API
InstallCheck:	see INT 2F/AX=7A20h/BX=0003h
SeeAlso: INT 2F/AX=7A20h/BX=0003h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare Lite - CLIENT
InstallCheck:	see INT 2F/AX=D800h
SeeAlso: INT 2F/AX=D800h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare Lite - NLCACHE/NWCACHE
InstallCheck:	see INT 2F/AX=D8C0h
SeeAlso: INT 2F/AX=D8C0h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Novell NetWare Lite - SERVER
InstallCheck:	see INT 2F/AX=D880h
SeeAlso: INT 2F/AX=D880h
--------R-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - pcANYWHERE IV/LAN
InstallCheck:	see INT 21/AX=2B44h/BX=4D41h
SeeAlso: INT 21/AX=2B44h/BX=4D41h
--------X-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - PCI BIOS v2.0c Protected-Mode API
InstallCheck:	see INT 1A/AX=B101h
SeeAlso: INT 1A/AX=B101h
----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - PenDOS PENDEV.SYS
InstallCheck:	see INT 21/AX=4402h"PENDEV"
SeeAlso: INT 21/AX=4402h"PENDEV"
--------E-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Phar Lap 386/DOS-Extender v4.1
InstallCheck:	see INT 2F/AX=ED03h
SeeAlso: INT 2F/AX=ED03h
--------X-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Plug-and-Play BIOS v1.0A
InstallCheck:	scan paragraph boundaries F000h to FFFFh for signature string
	  "$PnP" followed by a valid Plug-and-Play header structure
	  (see #F024)
SeeAlso: @xxxxh:xxxxh"BIOS32 Service Directory",INT 1A/AH=B4h

Format of Plug-and-Play Installation Structure:
Offset	Size	Description	(Table F024)
 00h  4 BYTEs	signature "$PnP"
 04h	BYTE	Plug-and-Play version (major in high nybble, BCD minor in low)
		10h for current specification
 05h	BYTE	length of Installation Structure in bytes
 06h	WORD	control field
		bits 15-2 reserved
		bits 1-0: event notification mechanism
		     00 not supported
		     01 polling
		     10 asynchronous (interrupt time)
 08h	BYTE	checksum (8-bit sum of all bytes in structure, including this
		  one, should equal zero)
 09h	DWORD	physical address of event notification flag if using polling
		(bit 0 set when a system even occurs)
 0Dh	WORD	real mode entry offset (see #F025)
 0Fh	WORD	real mode code segment
 11h	WORD	16-bit protected mode entry point offset (see #F025)
 13h	DWORD	16-bit protected mode code segment base address
 17h	DWORD	OEM device identifier
 1Bh	WORD	real mode data segment
 1Dh	DWORD	16-bit protected mode data segment base address

(Table F025)
Call Plug-and-Play BIOS entry point with:
	STACK:	WORD	function number
			0000h Get Number of System Device Nodes (see #F026)
			0001h Get System Device Node (see #F027)
			0002h Set System Device Node (see #F028)
			0003h Get Event (see #F029)
			0004h Send Message (see #F031)
			0005h Get Docking Station Information (see #F033)
			0006h reserved for future versions
			0007h Select Primary Boot Devices (see #F034)
			0008h Get Primary Boot Devices (see #F035)
			0009h Set Statically Allocated Resource Information
			      (see #F037)
			000Ah Get Statically Allocated Resource Information
			      (see #F038)
			000Bh Get APM ID Table (see #F039)
			0040h Get Plug-and-Play ISA Configuration Structure
			      (see #F041)
			0041h Get Extended System Configuration Data Info
			      (see #F043)
			0042h Read Extended SYstem Configuration Data
			      (see #F044)
			0043h Write Extended SYstem Configuration Data
			      (see #F045)
			---Desktop Management Interface v2.0---
			0050h Get DMI Information (see #F046)
			0051h Get DMI structure (see #F047)
			---BIOS Boot Specification---
			0060h Get Version and Installation Check (see #F048)
			0061h Get IPL Device Count (see #F049)
			0062h Get Boot Priority and IPL Table (see #F050)
			0063h Set Boot Priority (see #F051)
			0064h Get IPL Device from Last Boot (see #F052)
			0065h Get Boot First (see #F053)
			0066h Set Boot First (see #F054)
			0067h-006Fh reserved
		var	function arguments
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Notes:	the caller must provide at least 1024 bytes of stack space for use by
	  the Plug-and-Play BIOS
	this API is bi-modal; all calls are available in both real mode and
	  16-bit protected mode (if calling from 32-bit protected mode, care
	  must be taken to ensure proper alignment of the stack arguments)
SeeAlso: #F024

(Table F026)
Call Plug-and-Play BIOS function 00h with:
	STACK:	WORD	0000h (function "Get Number of System Device Nodes")
		DWORD	-> BYTE in which to return number of device nodes
		DWORD	-> WORD in which to return size of largest device node
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned int *, unsigned int);

(Table F027)
Call Plug-and-Play BIOS function 01h with:
	STACK:	WORD	0001h (function "Get System Device Node")
		DWORD	-> BYTE containing node number or handle
		DWORD	-> buffer for device node
		WORD	control flag
			bits 15-2 reserved (0)
			bit 1: get static config (values for next boot)
			bit 0: get current (dynamic) configuration
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, DEV_NODE *, unsigned int,
		unsigned int);
	exactly one of the two defined bits in the control flag must be set

(Table F028)
Call Plug-and-Play BIOS function 02h with:
	STACK:	WORD	0002h (function "Set System Device Node")
		DWORD	-> BYTE containing node number or handle
		DWORD	-> buffer containing device node
		WORD	control flag
			bits 15-2 reserved (0)
			bit 1: set static config (values for next boot)
			bit 0: set current (dynamic) configuration
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, DEV_NODE *, unsigned int,
		unsigned int);
	exactly one of the two defined bits in the control flag must be set

(Table F029)
Call Plug-and-Play BIOS function 03h with:
	STACK:	WORD	0003h (function "Get Event")
		DWORD	-> WORD buffer for event message identifier (see #F030)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned int *, unsigned int);

(Table F030)
Values for PnP Event Identifier:
 0001h	"ABOUT_TO_CHANGE_CONFIG" preliminary notification of changes, including
	  docking and undocking
 0002h	"DOCK_CHANGED" devices have been added to or removed from system
 0003h	"SYSTEM_DEVICE_CHANGED" removable system devices have been inserted
	  or removed
 0004h	"CONFIG_CHANGE_FAILED" error detected while atempting to add or remove
	  devices
 8000h-FFFEh OEM-defined events
 FFFFh	"UNKNOWN_SYSTEM_EVENT"

(Table F031)
Call Plug-and-Play BIOS function 04h with:
	STACK:	WORD	0004h (function "Send Message")
		WORD	message identifier (see #F032)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned int, unsigned int);
SeeAlso: #F031,#F033

(Table F032)
Values for PnP Message Identifier:
 0000h	"OK"
 0001h	"ABORT" action which caused an ABOUT_TO_X message
 0002h-003Fh reserved for future Response Messages
 0040h	"UNDOCK_DEFAULT_ACTION"
 0041h	"POWER_OFF"
 0042h	"PNP_OS_ACTIVE"
 0043h	"PNP_OS_INACTIVE"
 0044h-007Fh reserved for future Control Messages
 8000h-FFFFh OEM-defined messages

(Table F033)
Call Plug-and-Play BIOS function 05h with:
	STACK:	WORD	0005h (function "Get Docking Station Information")
		DWORD	-> buffer for docking station info (see #F036)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned int);
SeeAlso: #F031,#F034

(Table F034)
Call Plug-and-Play BIOS function 07h with:
	STACK:	WORD	0007h (function "Select Primary Boot Devices")
		WORD	type of primary boot device
			0000h primary input
			0001h primary output
			0002h primary IPL
		DWORD	Plug-and-Play 32-bit device ID or FFFFFFFFh for ISA
		DWORD	device serial number or FFFFFFFFh
		DWORD	32-bit logical device ID or FFFFFFFFh for ISA device
		WORD	physical unit number
		WORD	control flag
			bits 15-1 reserved (0)
			bit 0: do not check for attached device during PnP POST
				  boot device selection
		DWORD	-> preferred resource allocation or -> END_TAG if none
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, int, unsigned long, unsigned long, unsigned long,
		int, int, char *, unsigned int);

(Table F035)
Call Plug-and-Play BIOS function 08h with:
	STACK:	WORD	0008h (function "Get Primary Boot Devices")
		WORD	type of primary boot device
			0000h primary input
			0001h primary output
			0002h primary IPL
		DWORD	-> DWORD buffer for Plug-and-Play 32-bit device ID
		DWORD	-> DWORD buffer for device serial number
		DWORD	-> DWORD buffer for logical device ID
		DWORD	-> WORD buffer for physical unit number
		DWORD	-> buffer for preferred resource allocation
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, int, unsigned long *, unsigned long *,
		unsigned long *, unsigned int *, char *, unsigned int);

Format of Plug-and-Play Docking Station Information:
Offset	Size	Description	(Table F036)
 00h	DWORD	docking station location identifier (EISA device ID format)
		FFFFFFFFh if unknown or no product identifier
 04h	DWORD	serial number or 00000000h
 08h	WORD	capabilities
		bits 15-3 reserved (0)
		bits 2-1: hot-pluggability
		    00 power-down required to dock/undock
		    01 must be in suspend mode ("warm" dock/undock)
		    10 system can be hot-docked
		    11 reserved
		bit 0: docking station provides support for controlling
		      sequence of docking/undocking

(Table F037)
Call Plug-and-Play BIOS function 09h with:
	STACK:	WORD	0009h (function "Set Statically Allocated Resource
			  Information")
		DWORD	-> block of statically-allocated resources as described
			  in the Plug-and-Play ISA Spec
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned int);
	if the returned status is 008Dh, the Plug-and-Play BIOS supports
	  ESCD, and the caller should thus use functions 41h to 43h instead
	  of 09h and 0Ah

(Table F038)
Call Plug-and-Play BIOS function 0Ah with:
	STACK:	WORD	000Ah (function "Get Statically Allocated Resource
			  Information")
		DWORD	-> buffer for statically-allocated resources as
			  described in the Plug-and-Play ISA Spec
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned int);
	if the returned status is 008Dh, the Plug-and-Play BIOS supports
	  ESCD, and the caller should thus use functions 41h to 43h instead
	  of 09h and 0Ah

(Table F039)
Call Plug-and-Play BIOS function 0Bh with:
	STACK:	WORD	000Bh (function "Get APM ID Table")
			  Information")
		DWORD	-> WORD buffer for size of data buffer
		DWORD	-> buffer for storing APM ID table (see #F040)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Desc:	copies the Advanced Power Management v1.1 device identifier table to
	  Plug-and-Play device identifier mappings
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned int *, unsigned char *, unsigned int);
SeeAlso: INT 15/AX=5300h

Format of Plug-and-Play APM ID Table:
Offset	Size	Description	(Table F040)
 00h	DWORD	Plug-and-Play device identifier
 04h	WORD	APM v1.1+ identifier
SeeAlso: #F039

(Table F041)
Call Plug-and-Play BIOS function 40h with:
	STACK:	WORD	0040h (function "Get Plug-and-Play ISA Configuration
			  Structure")
		DWORD	-> buffer for configuration structure (see #F042)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned int);

Format of Plug-and-Play ISA Configuration Structure:
Offset	Size	Description	(Table F042)
 00h	BYTE	structure revision level (01h)
 01h	BYTE	total Card Select Numbers (CSNs) assigned
 02h	WORD	ISA Read Data Port (see also PORT 0A79h)
 04h	WORD	reserved (0)
SeeAlso: #F041

(Table F043)
Call Plug-and-Play BIOS function 41h with:
	STACK:	WORD	0041h (function "Get Extended System Configuration
			  Information")
		DWORD	-> WORD buffer for size of nonvolatile storage
		DWORD	-> WORD buffer for size of ESCD allocated
		DWORD	-> DWORD buffer for physical base address of NV storage
			  (if memory-mapped, else 00000000h)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned int *, unsigned int *, unsigned long *,
		  unsigned int);
SeeAlso: INT 1A/AX=B401h

(Table F044)
Call Plug-and-Play BIOS function 42h with:
	STACK:	WORD	0042h (function "Read Extended System Configuration
			  Data")
		DWORD	-> buffer for storing ESCD
		WORD	read/writable selector for ESCD if memory-mapped and
			  called in protected mode (ignored otherwise)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned int, unsigned int);
	if an ESCD selector is required, the caller must construct a 16-bit
	  data segment selector with a limit of 64K

(Table F045)
Call Plug-and-Play BIOS function 43h with:
	STACK:	WORD	0043h (function "Write Extended System Configuration
			  Data")
		DWORD	-> buffer containing ESCD
		WORD	read/writable selector for ESCD if memory-mapped and
			  called in protected mode (ignored otherwise)
		WORD	PnP BIOS writable segment/selector
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned int, unsigned int);
	if an ESCD selector is required, the caller must construct a 16-bit
	  data segment selector with a limit of 64K

(Table F046)
Call Desktop Management Specification function 50h with:
	STACK:	WORD	0050h (function "Get DMI Information")
		DWORD	-> buffer for ASCIZ DMI BIOS revision string
		DWORD	-> WORD to receive number of DMI structures
		DWORD	-> WORD to receive DMI structure size
		DWORD	-> DWORD to receive DMI storage base address
		DWORD	-> WORD to receive DMI storage size
		WORD	BIOS selector
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  short (*entry)(int, unsigned char *, unsigned short *,
			unsigned short *, unsigned long *, unsigned short *,
			unsigned short) ;
SeeAlso: #F047

(Table F047)
Call Desktop Management Specification function 51h with:
	STACK:	WORD	0051h (function "Get DMI Structure")
		DWORD	-> WORD "structure"
		DWORD	-> buffer for DMI structure
		WORD	DMI selector
		WORD	BIOS selector
Return: AX = status (see #F055) 
Note:	the large-model c declaration is
	  short (*entry)(int, unsigned short *, unsigned char *, unsigned short,
			unsigned short) ;
SeeAlso: #F046

(Table F048)
Call BIOS Boot Specification function 60h with:
	STACK:	WORD	0060h (function "Get Version and Installation Check")
		DWORD	-> WORD buffer for BIOS Boot Spec version number (BCD)
Return: AX = status (see #F055)
	   0081h if BIOS Boot not available
Note:	the large-model C declaration is
	  int (*entry)(int, int *) ;
SeeAlso: #F049,#F050,#F051,#F052

(Table F049)
Call BIOS Boot Specification function 61h with:
	STACK:	WORD	0061h (function "Get IPL Device Count")
		DWORD	-> WORD buffer for number of IPL devices in system
		DWORD	-> WORD buffer for max. number of IPL devices supported
		DWORD	-> WORD buffer for size of an IPL table entry
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned int *, unsigned int *, unsigned int *) ;
SeeAlso: #F048,#F050,#F051,#F052

(Table F050)
Call BIOS Boot Specification function 62h with:
	STACK:	WORD	0062h (function "Get Boot Priority and IPL Table")
		DWORD	-> buffer for copy of boot priority stored in NVRAM
		DWORD	-> buffer for IPL table
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned char *, unsigned char *) ;
	the size of the boot priority buffer must be at least MaxIPL bytes
	  (see #F049), of which the first CurrentIPL bytes are valid, with
	  the lowest-valued byte indicating the device which should attempt
	  booting first, the next lowest second, etc.
	the size of the IPL table buffer must be at least MaxIPL + IPLsize
	  bytes (see #F049)
SeeAlso: #F048,#F049,#F051,#F052

(Table F051)
Call BIOS Boot Specification function 63h with:
	STACK:	WORD	0063h (function "Set Boot Priority")
		DWORD	-> buffer containing new boot priority list (see #F050)
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned char *) ;
SeeAlso: #F048,#F049,#F050,#F052

(Table F052)
Call BIOS Boot Specification function 64h with:
	STACK:	WORD	0064h (function "Get IPL Device from Last Boot")
		DWORD	-> WORD buffer for index in IPL table of boot device
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, unsigned int *) ;
SeeAlso: #F048,#F049,#F050,#F051,#F053

(Table F053)
Call BIOS Boot Specification function 65h with:
	STACK:	WORD	0065h (function "Get Boot First")
		DWORD	-> WORD buffer for index in IPL table of current
			  first boot device
Return: AX = status (see #F055)
Notes:	the large-model C declaration is
	  int (*entry)(int, unsigned int *) ;
	the boot-first device will attempt booting before the boot-priority
	  list is considered
SeeAlso: #F048,#F049,#F050,#F051,#F054

(Table F054)
Call BIOS Boot Specification function 66h with:
	STACK:	WORD	0066h (function "Set Boot First")
		DWORD	-> WORD containing index in IPL table of new device
			  from which to attempt booting first before
			  considering the boot priority list
Return: AX = status (see #F055)
Note:	the large-model C declaration is
	  int (*entry)(int, 
SeeAlso: #F048,#F049,#F050,#F051,#F053

(Table F055)
Values for Plug-and-Play function status code:
 0000h	successful
 0001h	boot device resource configuration not saved to nonvolatile memory
 0002h-007Eh reserved for future warnings
 0055h	unable to read/write Extended System Config Data from nonvolatile mem
 0056h	no valid Extended System Configuration Data in nonvolatile storage
 0059h	user's buffer was too small for Extended System Configuration Data
 007Fh	device could not be configured statically, but dynamic config succeeded
 0081h	unknown function
 0082h	unsupported function
 0083h	invalid device node (or DMI structure) number/handle
 0084h	bad parameter
 0085h	failure setting device node
	invalid DMI subfunction
 0086h	no pending events
 0087h	system not docked
 0088h	no ISA Plug-and-Play cards installed
 0089h	unable to determine docking station's capabilities
 008Ah	undocking sequence failed because system unit does not have a battery
 008Bh	resource conflict with a primary boot device
 008Ch	buffer provided by user was too small
 008Dh	must use ESCD support for specified device
 008Eh	message not supported
 008Fh	hardware error
SeeAlso: #0939

Format of Option ROM header:
Offset	Size	Description	(Table F056)
 00h	WORD	AA55h signature
 02h	BYTE	length of option ROM in 512-byte pages (should be multiple 4)
 03h  4 BYTEs	standard initialization entry point
		(called with ES:DI -> PnP Installation Structure)
 07h 19 BYTEs	reserved
 1Ah	WORD	offset to PnP Expansion Header

Format of Expansion Header:
Offset	Size	Description	(Table F057)
 00h  4 BYTEs	signature ("$PnP" for Plug-and-Play expansion header)
 04h	BYTE	structure version number
 05h	BYTE	length of entire header in paragraphs
 06h	WORD	offset to next header or 0000h
 08h	BYTE	reserved
 09h	BYTE	checksum (sum of all bytes in header, including this one,
		  mod 256 should equal zero)
---PnP Expansion Header---
 0Ah	DWORD	Plug-and-Play device identifier
 0Eh	WORD	offset of manufacturer ID string in Option ROM or 0000h
 10h	WORD	offset of product name string in Option ROM or 0000h
 12h  3 BYTEs	device type code (see #F059)
		byte 0: base type (general kind of device)
		byte 1: device subtype
		byte 2: device programming interface
 15h	BYTE	device indicator flags (see #F058)
 16h	WORD	Boot Connection Vector offset (real/protected mode) or 0000h
		(see #F062)
 18h	WORD	Disconnect Vector offset (real/protected mode) or 0000h
		far-called by system BIOS is boot attempt failed
 1Ah	WORD	bootstrap entry point (real/protected mode) or 0000h
 1Ch	WORD	reserved (0)
 1Eh	WORD	Static Resource Information offset (real/prot mode) or 0000h
		should be used only by non-PnP devices to make them PnP-aware
		  (see #F063)

Bitfields for Plug-and-Play device indicator flags:
Bit(s)	Description	(Table F058)
 7	supports Device Driver Initialization model
 6	may be shadowed in RAM
 5	may be read cached
 4	only required if device used for booting
 3	reserved (0)
 2	device is Initial Program Load (IPL, i.e. boot) device
 1	device is Input device
 0	device is Display device
SeeAlso: #F059

(Table F059)
Values for Plug-and-Play device type code:
Type	Subtype		Description
 00h	---	reserved
 01h	---	mass storage
	00h	  SCSI controller
	01h	  IDE controller
	02h	  floppy controller (NEC 765-compatible)
	03h	  IPI controller
	04h	  RAID controller
	80h	  other
 02h	---	network interface controller
	00h	  Ethernet
	01h	  Token Ring
	02h	  FDDI
	03h	  ATM
	80h	  other
 03h	---	display controller
	00h	  VGA
	01h	  SuperVGA
	02h	  XGA
	80h	  other
 04h	---	multi-media controller
	00h	  video
	01h	  audio
	80h	  other
 05h	---	memory
	00h	  RAM
	01h	  Flash memory
	80h	  other
 06h	---	bridge controller
	00h	  host processor bridge
	01h	  ISA bridge
	02h	  EISA bridge
	03h	  MicroChannel bridge
	04h	  PCI bridge
	05h	  PCMCIA bridge
	06h	  NuBus bridge
	07h	  CardBus bridge
	80h	  other
 07h	---	communications device
	00h	  XT-compatible RS-232
	01h	  AT-compatible parallel port
	80h	  other
 08h	---	system peripherals
	00h	  8259-compatible Programmable Interrupt Controller
	01h	  8237-compatible DMA Controller
	02h	  8254-compatible system timer
	03h	  real-time clock
	80h	  other
 09h	---	input device
	00h	  keyboard controller
	01h	  digitizer/pen
	02h	  mouse
	80h	  other
 0Ah	---	docking station
	00h	  generic docking station
	80h	  other
 0Bh	---	CPU
	00h	  386-based
	01h	  486-based
	02h	  Pentium-based
	03h	  Pentium-Pro (P6)
	10h	  DEC Alpha
	40h	  coprocessor
 0Ch	---	Serial Bus controller
	00h	  Firewire (IEEE 1394)
	01h	  ACCESS.bus
	02h	  SSA
	03h	  Universal Serial Bus (USB)
			programming interface 10h = OpenHCI Host Controller
SeeAlso: #F058,#F060,#0798

(Table F060)
Values for Plug-and-Play generic EISA device ID:
 PNP0xxx	system devices
 PNP00xx	  interrupt controller
 PNP0000		AT interrupt controller
 PNP0001		EISA interrupt controller
 PNP0002		MCA interrupt controller
 PNP0003		APIC
 PNP0004		Cyrix SLiC MP interrupt controller
 PNP01xx	  timer
 PNP0100		AT timer
 PNP0101		EISA timer
 PNP0102		MCA timer
 PNP02xx	  DMA controller
 PNP0200		AT DMA controller
 PNP0201		EISA DMA controller
 PNP0202		MCA DMA controller
 PNP03xx	  keyboard
 PNP0300		PC/XT keyboard controller (83-key)
 PNP0301		PC/AT keyboard controller (84-key)
 PNP0302		PC/XT keyboard controller (84-key)
 PNP0303		IBM enhanced keyboard (101/102-key, PS/2 mouse)
 PNP0304		Olivetti keyboard (83-key)
 PNP0305		Olivetti keyboard (102-key)
 PNP0306		Olivetti keyboard (86-key)
 PNP0307		enhanced keyboard with Windows keys
 PNP0308		General Input Device Emulation Interface (GIDEI) legacy
 PNP0309		Olivetti keyboard (A101/102-key)
 PNP030A		AT&T 302 keyboard
 PNP04xx	  parallel port
 PNP0400		standard printer port
 PNP0401		ECP printer port
 PNP05xx	  serial port
 PNP0500		standard 8250/16450 UART
 PNP0501		16550A-compatible UART
 PNP06xx	  disk controller
 PNP0600		generic ESDI/IDE/ATA controller
 PNP0601		Plus Hardcard II
 PNP0602		Plus Hardcard IIXL/EX
 PNP0700	  standard floppy controller
 PNP0800	  PC speaker
 PNP09xx	  display adapter
 PNP0900		VGA-compatible
 PNP0Axx	  periperal bus
 PNP0A00		ISA
 PNP0A01		EISA
 PNP0A02		MCA
 PNP0A03		PCI
 PNP0A04		VESA/VL bus
 PNP0A05		generic ACPI bus
 PNP0A06		extended IO bus
 PNP0A07		SMB bus
 PNP0A08		ACPI three-wire device bus
 PNP0A09		ACPI two-wire device bus
 PNP0B00	  AT-style real-time clock
 PNP0Cxx	  BIOS/system board
 PNP0C00		Plug-and-Play BIOS
 PNP0C01		system board
 PNP0C02		(PnP-reserved resources)
 PNP0C03		Plug-and-Play event notification interrupt
 PNP0C04		math coprocessor
 PNP0C08		ACPI driver/BIOS
 PNP0C09		embedded controller device
 PNP0C0A		control method battery
 PNP0C0B		fan
 PNP0C0C		power button
 PNP0C0D		lid
 PNP0Exx	  PCMCIA controller chipset
 PNP0E00		Intel 82365-compatible
 PNP0Fxx	  mouse
 PNP8xxx	network adapter
 PNP9xxx	modem
 PNPAxxx	SCSI controller/proprietary CD-ROM controller
 PNPA000		Adaptec 154x-compatible
 PNPA001		Adaptec 174x-compatible
 PNPA002		Future Domain 16-700-compatible
 PNPBxxx	sound/video/multimedia
 PNPB000		Sound Blaster 1.5
 PNPB001		Sound Blaster 2.0
 PNPB002		Sound Blaster Pro
 PNPB004		Thunderboard
 PNPB005		Adlib-compatible FM synthesis
 PNPB006		MPU-401
 PNPB007		Microsoft Windows Sound System
 PNPB008		Compaq Waveform
 PNPB010		Motion Video device (MCI)
 PNPB011		MIDI Sequencer (MCI)
 PNPB012		Wave Audio (MCI)
 PNPB013		VISCA VCR (MCI)
 PNPB014		Pioneer Laserdisk (MCI)	
 PNPB015		CD Audio (MCI)
 PNPB020		Yamaha OPL3-compatible FM synthesis
 PNPB02F		joystick/game port
 ACPI0001	three-wire serial memory device
 ACPI0002	two-wire serial memory device
SeeAlso: #F059,#F061

(Table F061)
Values for data tags:
 22h	IRQ descriptor, no flags
 23h	IRQ descriptor, with flags
 2Ah	DMA descriptor
 30h	Dependent Function start
 31h	Dependent Function start, with priority byte
 38h	Dependent Function end
 47h	I/O port descriptor
 4Bh	fixed-location I/O port descriptor
 78h	"END_TAG" end of resource descriptors
SeeAlso: #F060

(Table F062)
Values Boot Connection Vector is called with:
	AX = which vectors to hook
	   bit 2: connect as IPL (INT 13)
	   bit 1: connect as primary video (INT 10)
	   bit 0: connect as primary input (INT 09)
	ES:DI -> system BIOS PnP Installation Check Structure
	BX = Card Select Number for this card (ISA bus only)
	DX = read data port (ISA only) or FFFFh
SeeAlso: #F063

(Table F063)
Values Static Resource Information vector is called with:
	ES:DI -> buffer for device's static resource config info (at least 1024
		  bytes)
SeeAlso: #F062

Format of Plug-and-Play System Device Node:
Offset	Size	Description	(Table F064)
 00h	WORD	size of device node in bytes
 02h	BYTE	device node number/handle
 03h	DWORD	EISA product identifier
 07h  3 BYTEs	device type code
 0Ah	WORD	attribute flags
		bits 15-9 reserved (0)
		bits 8-7: configurability
		    00 can only be statically configured for next boot
		    01 can be dynamically configured at runtime
		    10 reserved
		    11 can only be dynamically configured
		bit 6: removable device
		bit 5: docking station
		bit 4: capable of being primary IPL (boot) device
		bit 3: capable of being primary input device
		bit 2: capable of being primary output device
		bit 1: device is not configurable
		bit 0: device can not be disabled
 0Ch	var	allocated resource configuration descriptors
	var	possible resource configuration descriptors
	var	compatible device identifiers
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - POST Memory Manager Specification (PMM) v1.0
InstallCheck:	scan paragraph boundaries E000h to FFFFh for signature string
	  "$PMM" followed by a valid PMM header structure (see #F065)
Note:	the PMM is only available at system boot -- between the completion
	  of the memory check and the call to INT 19; this includes Option
	  ROM initialization and Plug-and-Play Boot Connection Vectors, but
	  not the Bootstrap Entry Vector (which is called after INT 19)
SeeAlso: INT 2F/AX=4300h,INT 67/AH=40h

Format of POST Memory Manager Specification structure:
Offset	Size	Description	(Table F065)
 00h  4 BYTEs	signature "$PMM"
 04h	BYTE	structure version number (01h)
 05h	BYTE	length of structure in bytes
 06h	BYTE	checksum of structure (value needed to force byte-wise sum
		of entire structure to be 00h)
 07h	DWORD	-> PMM entry point (real mode only) (see #F066)
 0Bh  5 BYTEs	reserved (0)
SeeAlso: #F024

(Table F066)
Call POST Memory Manager Specification entry point with:
	STACK:	WORD	function number
			0000h pmmAllocate (see #F067)
			0001h pmmFind (see #F068)
			0002h pmmDeallocate (see #F069)
		additional parameters vary by function
Notes:	PMM calls use standard large-model C-language calling conventions
	the caller must provide at least 256 bytes of stack space; BIOSes
	  which support this specification will provide at least 1024 bytes
	  of stack space when calling a ROM initialization vector, Boot
	  Connection Vector, or Bootstrap Entry Vector (thus allowing the
	  Option ROM's code to provide sufficient stack space when calling
	  the PMM)

(Table F067)
Call PMM "pmmAllocate" entry point with:
	STACK:	WORD	0000h (function "pmmAllocate")
		DWORD	length of memory block, in paragraphs
			if 00000000h, only get size of largest available block
		DWORD	handle to assign to memory block, or FFFFFFFh for
			  "anonymous" block
		WORD	option flags
			bit 0: allocate from conventional memory
			bit 1: allocate from extended memory
			bit 2: use alignment based on least-significant set
				bit of requested length
Return: DX:AX = 32-bit physical address of allocated memory block, or
	      size of largest available block in paragraphs, or
	      00000000h if specified handle is already in use, or
	      FFFFFFFFh if allocation failed
Notes:	at least one of bits 0 and 1 must be set in the option flags; both
	  may be set if the location of the memory block is not important
	the specification requires that an Option ROM must use handles
	  compliant with the Plug-and-Play specification (high 16 bits are
	  manufacturer's vendor ID, low 16 bits are vendor-defined); handles
	  whose highest bit is set or highest six bits are all clear are
	  reserved for the BIOS, and the BIOS may flag attempts to use such
	  reserved handles
SeeAlso: #F066,#F068,#F069

(Table F068)
Call PMM "pmmFind" entry point with:
	STACK:	WORD	0001h (function "pmmFind")
		DWORD	handle to be found
Return: DX:AX = 32-bit physical address of allocated memory block, or
	      00000000h if handle is not in use
Desc:	get the address of the memory block associated with the given handle
SeeAlso: #F066,#F067,#F069

(Table F069)
Call PMM "pmmDeallocate" entry point with:
	STACK:	WORD	0002h (function "pmmDeallocate")
		DWORD	physical address of block (as returned by pmmAllocate)
Return: DX:AX = FFFFFFFFh on error
Notes:	the memory block is cleared to all zeros by the PMM
	invalid functions (0003h-FFFFh) return DX:AX = FFFFFFFFh
SeeAlso: #F066,#F067,#F068
--------b-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - BIOS Boot Specification (BBS)
InstallCheck:	perform Plug-and-Play installation check, then call PnP
	  function 60h
SeeAlso: @xxxxh:xxxxh"Plug-and-Play"
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - QEMM Programming Interface (QPI)
InstallCheck:	see INT 67/AH=3Fh
SeeAlso: INT 67/AH=3Fh
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - QEXT.SYS Private API
InstallCheck:	see INT 15/AX=11DEh
SeeAlso: INT 15/AX=11DEh
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Quarterdeck VIDRAM
InstallCheck:	see INT 2F/AX=D201h/BX=5649h
SeeAlso: INT 2F/AX=D201h/BX=5649h
--------s-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - SoundBlaster Speech Driver
InstallCheck:	see INT 2F/AX=FBFBh
SeeAlso: INT 2F/AX=FBFBh
--------k-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Stacker
InstallCheck:	see INT 2F/AX=4A12h/CX=5354h
SeeAlso: INT 2F/AX=4A12h/CX=5354h
--------s-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - VESA Audio Interface Driver
InstallCheck:	see INT 10/AX=4F13h/BX=0002h
SeeAlso: INT 10/AX=4F13h/BX=0002h
--------m-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - Virtual Control Program Interface (VCPI) - Protected-Mode
InstallCheck:	see INT 67/AX=DE01h
SeeAlso: INT 67/AX=DE01h
--------N-@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - WEB v4.02 - MODULE APIs
InstallCheck:	see INT 2F/AH=EEh
SeeAlso: INT 2F/AH=EEh
---------------------------------------------


----------@xxxxxxxx--------------------------
CALL xxxxh:xxxxh - 
InstallCheck:	
SeeAlso: 
--------!---Admin----------------------------
Highest Table Number = F069
--------!---FILELIST-------------------------
Please redistribute all of the files comprising the interrupt list (listed at
the beginning of the list and in INTERRUP.1ST) unmodified as a group, in a
quartet of archives named INTER55A through INTER55D (preferably the original
authenticated PKZIP archives), and the utility and hypertext conversion
programs in three additional archives called INTER55E.ZIP to INTER55G.ZIP

Copyright (c) 1989,1990,1991,1992,1993,1994,1995,1996,1997 Ralf Brown
--------!---CONTACT_INFO---------------------
Internet: ralf@pobox.com (currently forwards to ralf@telerama.lm.com)
UUCP: {uunet,harvard}!pobox.com!ralf
FIDO: Ralf Brown 1:129/26.1
	or post a message to me in the DR_DEBUG echo (I probably won't see it
	unless you address it to me)
CIS:  >INTERNET:ralf@pobox.com
