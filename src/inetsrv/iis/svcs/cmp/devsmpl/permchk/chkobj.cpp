// ChkObj.cpp : Implementation of CPermChkApp and DLL registration.

#include "stdafx.h"
#include "PermChk.h"
#include "ChkObj.h"
#include "util.h"

////////////////////////////////////////////////////////////////
//
// Utility functions

//
// Try to open file to see if read access is allowed
//

static VARIANT_BOOL DoesUserHaveAccessToFile(LPCTSTR ptszFilename)
{
    HANDLE hFile = 
        ::CreateFile(ptszFilename, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                     NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return VARIANT_FALSE;
    ::CloseHandle(hFile);
    return VARIANT_TRUE;
}

static VARIANT_BOOL DoesUserHaveAccessToFile(BSTR bstrFilename)
{
    USES_CONVERSION;    // needed for OLE2T
    LPCTSTR ptszFilename = OLE2T(bstrFilename);
    return DoesUserHaveAccessToFile(ptszFilename);
}

////////////////////////////////////////////////////////////////
//

//
//

CPermissionChecker::CPermissionChecker()
{
}

//
//

CPermissionChecker::~CPermissionChecker()
{
}

//
//  Generated by ATL wizard
//

STDMETHODIMP CPermissionChecker::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPermissionChecker,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//
// ASP gets loaded.
// Keep pointer to the Server object from Scripting Context.
//

STDMETHODIMP CPermissionChecker::OnStartPage(IUnknown* pUnk)
{
    if (pUnk == NULL)
        return ::ReportError(E_POINTER);

    // Get the IScriptingContext Interface
    CComQIPtr<IScriptingContext, &IID_IScriptingContext> pContext(pUnk);

    if (!pContext)
        return ::ReportError(E_NOINTERFACE);

    // Get Server Object Pointer
    return pContext->get_Server(&m_piServer);
}

//
// ASP goes out of context.
// Release script context.
//

STDMETHODIMP CPermissionChecker::OnEndPage()
{
    m_piServer.Release();
    return S_OK;
}

//
// Checks the persmissions for the context user to access
// a page, or a file
//

STDMETHODIMP CPermissionChecker::HasAccess(
    BSTR bstrLocalUrl,
    VARIANT_BOOL *pfRetVal)
{
    if (bstrLocalUrl == NULL || pfRetVal == NULL)
        return ::ReportError(E_POINTER);

    *pfRetVal = VARIANT_FALSE;

    // Do we have a valid Server object?
    if (!m_piServer)
        return ::ReportError(E_NOINTERFACE);

    // Map logical filename to a physical filesystem name
    CComBSTR bstrPhysicalFile;
    HRESULT  hr = m_piServer->MapPath(bstrLocalUrl, &bstrPhysicalFile);

    if (SUCCEEDED(hr))
        *pfRetVal = ::DoesUserHaveAccessToFile(bstrPhysicalFile);
    else // failed to map as URL, try as regular path
        *pfRetVal = ::DoesUserHaveAccessToFile(bstrLocalUrl);

    return S_OK;
}