// ChkObj.cpp : Implementation of CPermChkApp and DLL registration.

#include "stdafx.h"
#include <new>
#include "PermChk.h"
#include "ChkObj.h"
#include "util.h"
#include "context.h"

////////////////////////////////////////////////////////////////
//
// Utility functions

//
// Try to open file to see if read access is allowed
//

static VARIANT_BOOL DoesUserHaveAccessToFile(LPCTSTR ptszFilename)
{
    HANDLE hFile = 
        ::CreateFile(ptszFilename, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                     NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return VARIANT_FALSE;
    ::CloseHandle(hFile);
    return VARIANT_TRUE;
}

static VARIANT_BOOL DoesUserHaveAccessToFile(BSTR bstrFilename)
{
    USES_CONVERSION;    // needed for OLE2T
    LPCTSTR ptszFilename = OLE2T(bstrFilename);
    return DoesUserHaveAccessToFile(ptszFilename);
}

////////////////////////////////////////////////////////////////
//

//
//

CPermissionChecker::CPermissionChecker()
{
}

//
//

CPermissionChecker::~CPermissionChecker()
{
}

//
//  Generated by ATL wizard
//

STDMETHODIMP CPermissionChecker::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPermissionChecker,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


//
// Checks the persmissions for the context user to access
// a page, or a file
//

STDMETHODIMP CPermissionChecker::HasAccess(
    BSTR bstrLocalUrl,
    VARIANT_BOOL *pfRetVal)
{
	HRESULT rc = E_FAIL;

	try
	{
		if (bstrLocalUrl == NULL || pfRetVal == NULL)
			return ::ReportError(E_POINTER);

		*pfRetVal = VARIANT_FALSE;

		CContext cxt;
		if ( cxt.Init( CContext::get_Server ) != S_OK )
		{
			return ::ReportError( E_NOINTERFACE );
		}

		// Map logical filename to a physical filesystem name
		CComBSTR bstrPhysicalFile;
		HRESULT  hr = cxt.Server()->MapPath(bstrLocalUrl, &bstrPhysicalFile);

		if (SUCCEEDED(hr))
			*pfRetVal = ::DoesUserHaveAccessToFile(bstrPhysicalFile);
		else // failed to map as URL, try as regular path
			*pfRetVal = ::DoesUserHaveAccessToFile(bstrLocalUrl);

	    rc = S_OK;
	}
	catch( std::bad_alloc &)
	{
		rc = E_OUTOFMEMORY;
	}
	catch( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}
