/*++

	SDCACHE.CPP

	This file implements the security descriptor cache.
	Our goal is to enable the file handle cache to consume less memory
	representing security descriptors, by enabling duplicate 
	security descriptors to be detected and referenced in here.

--*/

#include	<windows.h>
#include	<dbgtrace.h>
#include	"fdlhash.h"
#include	"rwnew.h"
#include	"refptr2.h"
#include	"xmemwrpr.h"
#include	"sdcache.h"
//#include	"cintrnl.h"


BOOL
IsSelfRelativeSecurityDescriptor(	PSECURITY_DESCRIPTOR	pSecDesc ) {
	SECURITY_DESCRIPTOR_CONTROL	control ;
	DWORD	dwRevision ;
	if (GetSecurityDescriptorControl( pSecDesc, &control, &dwRevision ))
		return	(control & SE_SELF_RELATIVE) != 0;
	else
		return FALSE;
}



BOOL
CSDKey::IsValid()	{
/*++

Routine Description : 

	This function validates that the key object is correctly constructed.
	We do NOT allow any NULL pointers, and we must have valid self relative
	security descriptors embedded.

Arguments : 

	NONE.

Return Value : 

	TRUE if correctly initialized, FALSE otherwise 

--*/

	_ASSERT( m_pMapping != 0 ) ;
	_ASSERT( m_pSecDesc != 0 ) ;
	_ASSERT( IsValidSecurityDescriptor( m_pSecDesc ) ) ;
	_ASSERT( IsSelfRelativeSecurityDescriptor( m_pSecDesc ) ) ;
	_ASSERT( m_cbSecDesc > 0 ) ;
	_ASSERT( (DWORD)m_cbSecDesc == GetSecurityDescriptorLength( m_pSecDesc ) ) ;

	return	m_pMapping != 0 &&
			m_pSecDesc != 0 &&
			IsValidSecurityDescriptor( m_pSecDesc ) &&
			IsSelfRelativeSecurityDescriptor( m_pSecDesc ) &&
			m_cbSecDesc > 0 && 
			(DWORD)m_cbSecDesc == GetSecurityDescriptorLength( m_pSecDesc ) ;
}

int	
CSDKey::MatchKey(	CSDKey left, 
					CSDKey	right 
					) {
/*++

Routine Description : 

	This function must compare 2 security descriptor keys, 
	and correctly define an ordering on the keys.
	(The hash table we're used in sorts buckets).

Arguments : 

	left, right - the two keys to be compared 
	
Return Value : 

	-1 if left < right
	0  if left == right
	1  if left > right 

--*/

	//
	//	Validate our arguments !
	//
	_ASSERT( left.IsValid() ) ;
	_ASSERT( right.IsValid() ) ;
	//
	//	perform the comparison !
	//
	int	iResult = memcmp( left.m_pMapping, right.m_pMapping, sizeof(GENERIC_MAPPING));
	if( iResult != 0 ) {
		iResult = left.m_cbSecDesc - right.m_cbSecDesc ;
		if( iResult == 0 ) {
			iResult = memcmp( left.m_pSecDesc, right.m_pSecDesc, left.m_cbSecDesc ) ;
		}
	}
	return	iResult ;
}

DWORD
CSDKey::HashKey(	CSDKey	Key ) {
/*++

Routine Description : 

	This function computes a hash on security descriptors.
	We ignore the GENERIC_MAPPING part of the key - this 
	will vary very rarely.
	We're a static function so we can be passed as a function 
	pointer.
	We simply look at the security descriptor as an array of DWORD's
	and sum them up.

Arguments : 

	Key - compute the hash of this security descriptor	

Return Value : 

	A Hash Value - no failure cases can occur

--*/


	//
	//	Very simple - sum all of the bits in the security descriptor !
	//
	_ASSERT( Key.IsValid() ) ;

	DWORD	cb = (DWORD)Key.m_cbSecDesc ;
	cb /= 4 ;

	DWORD*	pdw = (DWORD*)Key.m_pSecDesc ;
	DWORD*	pdwEnd = pdw + cb ;
	DWORD	Sum = 0 ;
	while( pdw != pdwEnd )	{
		Sum += *pdw++ ;
	}
	return	Sum ;
}



void*
CSDObject::operator	new(	size_t	size,	
							CSDKey&	key 
							)	{
/*++

Routine Description : 

	This function allocates memory of a CSDObject, 
	we require special handle because CSDObjects are variable length.

Arguments : 

	size - the size as generated by the compiler
	key -  the security descriptor we're going to stick in here

Return Value : 

	Allocated memory - NULL if failure 

--*/


	_ASSERT( size >= sizeof(CSDObject) ) ;
	_ASSERT( key.IsValid() ) ;

	size += key.m_cbSecDesc - sizeof( DWORD ) ;

	return	::new	BYTE[size] ;
} 


void
CSDObject::operator delete(	void*	lpv ) {
/*++

Routine Description : 

	Release a CSDObject !

Arguments : 
	
	lpv - where the CSDObject was before it was destructed

Return Value : 

	None.

--*/

	::delete(lpv) ;
}


long
CSDObject::Release()	{
/*++

Routine Description : 

	This function drops a reference to a CSDObject.
	WARNING - we will grab locks on the CSDObjectContainer 
	that is holding this item, the last reference MUST NEVER
	BE RELEASED WITHIN A LOCK !

	If the reference count drops to one, that means that the only reference
	remaining on the object is the one from the hash table.
	So we grab the hash table lock exclusively, so we can prevent new references
	from being added, and we then do a InterlockedCompareExchange to drop 
	the reference count to 0.  We need to do this to ensure that between
	the time we decrement the ref. count and the time we grab the lock, that 
	another user doesn't simultaneously raise and drop the ref. count.

Arguments : 

	None.

Return Value : 

	the resulting refcount.

--*/
	_ASSERT( IsValid() ) ;
	CSDObject*	pdelete = 0 ;
	long l = InterlockedDecrement( (long*)&m_cRefCount ) ;
	_ASSERT( l>=1 ) ;
	if( l == 1 ) {
		m_pContainer->m_lock.ExclusiveLock() ;		
		if( InterlockedCompareExchange( (long*)&m_cRefCount, 0, 1) == 1 ) {
			m_pContainer->m_table.Delete( this ) ;
			pdelete = this ;
		}
		m_pContainer->m_lock.ExclusiveUnlock() ;
	}
	if( pdelete )	{
		delete	pdelete ;
		l = 0 ;
	}
	return	l ;
}


//
//	Check that we are a valid object !
//
BOOL
CSDObject::IsValid()	{
/*++

Routine Description : 

	This function checks that we were properly constructed - 
	if allocation of our memory succeeds, nothing should stand
	in the way of producing a completely initialized object !

Arguments : 

	None.

Return Value : 

	TRUE if correctly constructed, FALSE otherwise !

--*/
	_ASSERT( m_dwSignature == SIGNATURE ) ;
	_ASSERT( m_pContainer != 0 ) ;
	_ASSERT( m_cRefCount >= 0 ) ;

	CSDKey	key( &m_mapping, SecurityDescriptor() ) ;
	_ASSERT( key.IsValid() ) ;
	_ASSERT( CSDKey::HashKey( key ) == m_dwHash ) ;

	return	m_dwSignature == SIGNATURE &&
			m_pContainer != 0 && 
			m_cRefCount >= 0 &&
			key.IsValid() &&
			CSDKey::HashKey( key ) == m_dwHash ;
}

BOOL
CSDObject::AccessCheck(	HANDLE	hToken, 
						ACCESS_MASK	accessMask,
						CACHE_ACCESS_CHECK	pfnAccessCheck
						)	{
/*++

Routine Description : 

	This function performs an ACCESS Check to determine whether
	a client has the specified permissions to the object.


Arguments : 

	hToken - Client Token
	accessMask - the Client's desired access 

Return Value : 

	TRUE if the client has access, 
	FALSE otherwise !

--*/


	if( hToken == 0 ) 
		return	TRUE ;

	_ASSERT( hToken != 0 ) ;
	_ASSERT( accessMask != 0 ) ;
	_ASSERT( IsValid() ) ;

    BYTE    psFile[256] ;
    DWORD   dwPS = sizeof( psFile ) ;
    DWORD   dwGrantedAccess = 0 ;
    BOOL    fAccess = FALSE ;

    BOOL    f = FALSE ;

	if( pfnAccessCheck ) {
		f = pfnAccessCheck(	SecurityDescriptor(),
							hToken,
							accessMask, 
							&m_mapping, 
							(PRIVILEGE_SET*)psFile, 
							&dwPS, 
							&dwGrantedAccess, 
							&fAccess
							) ;
	}	else	{
		f = ::AccessCheck(  SecurityDescriptor(),
                            hToken,
                            accessMask,
                            &m_mapping,
                            (PRIVILEGE_SET*)psFile,
                            &dwPS,
                            &dwGrantedAccess,
                            &fAccess
                            ) ;
	}
    DWORD   dw = GetLastError() ;

	return	f && fAccess ;
}



//
//	Now - find or create a given security descriptor 
//	item !
//
CSDObject*
CSDObjectContainer::FindOrCreate(	DWORD	dwHash, 
									CSDKey&	key 
									)	{
/*++

Routine Description : 

	This function will either locate a matching security 
	descriptor in the cache, or return a pointer to a new
	CSDObject created and placed into the cache.

	NOTE : We must always ADD a reference while the lock is held, 
	because Release() will try to re-enter the lock and remove
	the object from the hash table !

Arguments : 

	dwHash - the hash of the sought security descriptor
	key -	describes the security descriptor and GENERIC_MAPPING
		we are to locate !

Return Value : 

	A pointer to a CSDObject in the cache, or NULL if failure.
	A NULL means the object was not found, and we couldn't allocate
	memory to insert a new one !

--*/

	_ASSERT( key.IsValid() ) ;
	_ASSERT( CSDKey::HashKey(key) == dwHash ) ;

	CSDObject*	pObject = 0 ;
	m_lock.ShareLock() ;
	SDTABLE::ITER	iter = 
		m_table.SearchKeyHashIter(	dwHash,		
									key, 
									pObject
									) ;
	if( pObject )	{	
		pObject->AddRef() ;
		m_lock.ShareUnlock() ;
	}	else	{
		if( !m_lock.SharedToPartial() ) {
			m_lock.ShareUnlock() ;
			m_lock.PartialLock() ;
			iter = m_table.SearchKeyHashIter(	dwHash,
												key, 
												pObject
												) ;
		} 
		if( pObject != 0 ) {
			pObject->AddRef() ;
		}	else	{
			pObject = new( key )	CSDObject( dwHash, key, this ) ;
			if( pObject != 0 ) {
				m_lock.FirstPartialToExclusive() ;
				BOOL	fInsert = 
					m_table.InsertDataHashIter(	iter, 
												dwHash, 
												key, 
												pObject
												) ;	
				m_lock.ExclusiveUnlock() ;
				if( !fInsert ) {
					pObject->Release() ;
					pObject = 0 ;
				}
				return	pObject ;
			}
		}	
		m_lock.PartialUnlock() ;
	}	
	return	pObject ;
}	// End FindOrCreate()


CSDMultiContainer::Init()	{
/*++

Routine Description : 

	Initialize everything so we're ready to go !

Arguments : 

	None.

Return Value : 

	TRUE if successfull, FALSE otherwise !


--*/

	BOOL	fReturn = TRUE ;
	for( int i=0; i<CONTAINERS && fReturn; i++ )	{
		fReturn &= m_rgContainer[i].Init() ;
	}
	return	fReturn ;
}
