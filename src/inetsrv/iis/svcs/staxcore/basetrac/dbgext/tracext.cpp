//-----------------------------------------------------------------------------
//
//
//  File: traceext.cpp
//
//  Description:    Debug extension to dump callstack info generated by 
//      basetrac.lib
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/29/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <string.h>
#include <dbgtrace.h>
#include <imagehlp.h>

//Since we are a debugger extension...we will do away with the niceties of C++
//Object encapsulation
#define protected   public
#define private     public

#include <basetrac.h>
#include <transdbg.h>

TRANS_DEBUG_EXTENSION(dumpcallstack)
{
    CCallStackEntry_Base *pkbebAddress = NULL; //address in other process
    BYTE pbCallStack[sizeof(CCallStackEntry_Base)];
    CCallStackEntry_Base *pkbeb = (CCallStackEntry_Base *) pbCallStack;
    DWORD_PTR rgdwptrCallStack[100]; //Buffer for storing call stack data
    DWORD dwStackDepth = 0;
    UCHAR  szSymbol[100];
    ULONG_PTR Displacement = 0;
    ULONG cbBytesRead = 0;
    LPSTR szCallStackType = NULL;

    if (!szArg)
    {
        dprintf("ERROR: Unable to parse arg\n");
        return;
    }

    pkbebAddress = (CCallStackEntry_Base *) GetExpression(szArg);
    if (!ReadMemory((ULONG_PTR) pkbebAddress, pbCallStack,
                    sizeof(CCallStackEntry_Base), &cbBytesRead))
    {
        dprintf("ERROR: Unable to read call stack entry\n");
        return;
    }
    
    if (!ReadMemory((ULONG_PTR) pkbeb->m_pdwptrCallers, 
                    (BYTE *) rgdwptrCallStack, 
                    sizeof(DWORD_PTR)*pkbeb->m_dwCallStackDepth,
                    &cbBytesRead))
    {
        dprintf("ERROR: Unable to read call stack info\n");
        return;
    }

    //See if this entry was ever used..don't dump it if it wasn't
    if (TRACKING_OBJECT_UNUSED == pkbeb->m_dwCallStackType)
        return;

    dprintf("======================================================\n");
    switch(pkbeb->m_dwCallStackType)
    {
      case TRACKING_OBJECT_CONSTRUCTOR:
         szCallStackType = "Object Creation";
         break;
      case TRACKING_OBJECT_ADDREF:
         szCallStackType = "AddRef";
         break;
      case TRACKING_OBJECT_RELEASE:
         szCallStackType = "Release";
         break;
      case TRACKING_OBJECT_DESTRUCTOR:
         szCallStackType = "Object Descructor";
         break;
      default:
         szCallStackType = "User Defined";
    }
    dprintf("Call stack Type: %s (0x%08X)\n", szCallStackType, pkbeb->m_dwCallStackType);
    dprintf("Call stack Depth: %d\n", pkbeb->m_dwCallStackDepth);
    dprintf("Dumping info stored at 0x%08X\n", pkbebAddress);
    for(dwStackDepth = 0; dwStackDepth < pkbeb->m_dwCallStackDepth; dwStackDepth++)
    {
        if (!rgdwptrCallStack[dwStackDepth])
            break;
        GetSymbol((PVOID) rgdwptrCallStack[dwStackDepth], szSymbol, &Displacement);
        dprintf("\t(0x%08X) - %s+0x%X\n", rgdwptrCallStack[dwStackDepth], 
                 szSymbol, Displacement);
    }
    dprintf("======================================================\n");
}

//---[ dumpstacks ]------------------------------------------------------------
//
//
//  Description: 
//      Debugger extension to handle dumping callstack info generated by
//      basetrac.lib
//  Parameters: 
//      szArg    String passed in by debugger
//        ptracbAddress    Pointer to CDebugTrackingObject_Base
//  Returns:
//      -
//  History:
//      10/29/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
TRANS_DEBUG_EXTENSION(dumpstacks)
{
    CDebugTrackingObject_Base *ptracbAddress = NULL; //address on other process
    BYTE pbTrackingObj[sizeof(CDebugTrackingObject_Base)];
    CDebugTrackingObject_Base *ptracb = (CDebugTrackingObject_Base *) pbTrackingObj;
    CCallStackEntry_Base *pkbebAddress = NULL; //address in other process
    ULONG cbBytesRead = 0;
    CHAR szAddress[20];
    DWORD cEntriesToPrint = 0;
    DWORD c2ndPassEntriesToPrint = 0;


    if (!szArg)
    {
        dprintf("USAGE: dumpstacks <address>\n");
        return;
    }
    
    //Get address and read object into memory
    ptracbAddress = (CDebugTrackingObject_Base *) GetExpression(szArg);
    if (!ReadMemory((ULONG_PTR) ptracbAddress, pbTrackingObj, 
                    sizeof(CDebugTrackingObject_Base), &cbBytesRead))
    {
        dprintf("ERROR: Unable to read memory at location 0x%%08X\n", ptracbAddress);
        return;
    }

    if (TRACKING_OBJ_SIG != ptracb->m_dwSignature)
    {
        dprintf("ERROR: Invalid Signature on tracking object\n");
        return;
    }


    //Loop through stack entries and dump them
    pkbebAddress = ptracb->m_pkbebCallStackEntries;

    cEntriesToPrint = ptracb->m_cCurrentStackEntries;
    if (cEntriesToPrint > ptracb->m_cCallStackEntries) //we've wrapped
    {
        cEntriesToPrint = ptracb->m_cCallStackEntries - 
                 (ptracb->m_cCurrentStackEntries % ptracb->m_cCallStackEntries);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                 + ((ptracb->m_cCurrentStackEntries % 
                     ptracb->m_cCallStackEntries)) *
                   ptracb->m_cbCallStackEntries);
        
        c2ndPassEntriesToPrint = ptracb->m_cCallStackEntries - cEntriesToPrint;
    }

    dprintf("======================================================\n");
    dprintf("Dumping saved call stack info\n");
    dprintf("\t%d Call Stack Entries Logged\n", ptracb->m_cCurrentStackEntries);
    dprintf("\t%d Call Stack Entries Saved\n", c2ndPassEntriesToPrint+cEntriesToPrint);

    if (!cEntriesToPrint) //Nothing to do
        return;

    while(pkbebAddress && cEntriesToPrint)
    {
        wsprintf(szAddress, "0x%08X", pkbebAddress);
        dumpcallstack(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szAddress);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                        + ptracb->m_cbCallStackEntries);
        cEntriesToPrint--;
    }

    //OK Reset the address and do the first half of the circular buffer.
    pkbebAddress = ptracb->m_pkbebCallStackEntries;
    while(pkbebAddress && c2ndPassEntriesToPrint)
    {
        wsprintf(szAddress, "0x%08X", pkbebAddress);
        dumpcallstack(hCurrentProcess, hCurrentThread, dwCurrentPc, 
                      pExtensionApis, szAddress);
        pkbebAddress = (CCallStackEntry_Base *) ( ((BYTE *)pkbebAddress) 
                        + ptracb->m_cbCallStackEntries);
        c2ndPassEntriesToPrint--;
    }
}
  



