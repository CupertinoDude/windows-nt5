//+---------------------------------------------------------------
//
//  File:   Abtype.h
//
//  Synopsis:   Includes all defs and datatype used in MSN Address Book 2.x
//
//  Copyright (C) 1995 Microsoft Corporation
//          All rights reserved.
//
//  History:    SunShaw     Created                 30 Jan 1996
//              FeiSu       modified error code     21 May 1996
//
//----------------------------------------------------------------



#ifndef  _AB_TYPE_H_
#define  _AB_TYPE_H_


#include <wtypes.h>
#include <dbsqltyp.h>


#define AB_API_SIGNATURE    (DWORD) 'PABA'
#define AB_DOMAIN_LIST_SIG  (DWORD) 'ldbA'

//+---------------------------------------------------------------
//
// Definitions used in MSN Address Book 2.x
//
//----------------------------------------------------------------

#define AB_MAX_MONIKER  (250)
#define AB_MAX_LOGIN    (64)

#define AB_MAX_EMAIL    (AB_MAX_LOGIN)
#define AB_MAX_DOMAIN   (250)
#define AB_MAX_FULL_EMAIL_WO_NULL   (AB_MAX_LOGIN + AB_MAX_DOMAIN + 1)
#define AB_MAX_INTERNAL_FULL_EMAIL  (AB_MAX_LOGIN + AB_MAX_DOMAIN + 1 + 1)
#define AB_MAX_CONTEXT_NAME (16)
#define AB_MAX_CONFIG   (512)
#define AB_MAX_VROOT    (250)
#define AB_MAX_LDAP_DN  (AB_MAX_INTERNAL_FULL_EMAIL)
#define AB_MAX_AUTOREPLY_SUBJECT (250)

#define AB_SUCCESS                  0x00000000  //  Success
#define AB_SUCCESS_NOTLOCAL         0x00000001  //  AB Internal Use only

#define MAX_SERVERNAME          31  // same value, different name as defined in sqlfront.h
#define MAX_NAME                30  // same value, different name as defined in sqlfront.h

/////////////////////////////////////////////////////////////////////
//
//  Abook error codes are moved to abmsg.h, which is generated by abmsg.mc
//  To add a new error code, check both abmsg.mc and abget.cpp
//
/////////////////////////////////////////////////////////////////////
#define WIN32_ERROR_FROM_AB

//+---------------------------------------------------------------
//
// Types used in MSN Address Book 2.x
//
//----------------------------------------------------------------

typedef DWORD ABRETC;   // Address Book Return Code


typedef struct tagDOMAIN_LIST {
    DWORD       dwSignature;
    CHAR        szDomainName[AB_MAX_DOMAIN+1];
    LIST_ENTRY  list;
} DOMAIN_LIST;


// added june 5th 1996
typedef struct tagABUSER {
    CHAR    szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    CHAR    szForward[AB_MAX_INTERNAL_FULL_EMAIL];
    BOOL    fLocal;
    DWORD   cbMailBoxSize;
    DWORD   cbMailBoxMessageSize;
    CHAR    szVRoot[AB_MAX_VROOT];
} ABUSER;

typedef struct tagABDL {
    CHAR    szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    DWORD   dwToken;
} ABDL;


//  The ABROUTING structure contains the information necessary for
//  the mail servers to route mail to a user.
typedef enum tagABSTATUS {
    absUnknown      = 0,    // CAddr should be initialize with this value
    absLocal        = 1,
    absUnresolved   = 3,
    absNotLocal     = 4,
    absNotUsed      = 6,    // Just discard the CAddr
    absNotDelivered = 7,    // Local mail delivery failed
    absAccessDenied = 8,    // Access Denied to usage the DL
    absDelivered    = 9,    // Need for DL to file
    //
    // Values from 60 to 200 are reserved for Abook Internal Use Only
    //
    absInPartial    = 60,
    absInDistList   = 64,   // Is Small DL with no public token, needs to call GetAccountRight
    absInDistListEx = 128   // Is Large DL with no public token, needs to call
                            //      GetAccountRight then AbResolveAddressEx

} ABSTATUS;

#define ABROUTING_SIGNATURE 'gtRA'

typedef struct tagABROUTING {
    DWORD       dwSignature;
    ABSTATUS    abstatus;
    CHAR        szEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];
    CHAR        szVRoot[AB_MAX_MONIKER];
    CHAR        szDN[AB_MAX_LDAP_DN];
    CHAR        szAutoReplySubject[AB_MAX_AUTOREPLY_SUBJECT];
    DWORD       cbMaxInbox;
    DWORD       cbMaxInboxMessages;
    BOOL        fAutoReply;
} ABROUTING, *PABROUTING;

#define ABRESOLVE_SIGNATURE 'vsRA'
typedef struct tagABRESOLVE
{
    DWORD       dwSignature;
    HANDLE      hConnection;
    PVOID       dbproc;
} ABRESOLVE, *PABRESOLVE;

typedef struct tagABPARTIALINFO {
    DWORD   dwAbMagicId;
    DWORD   dwAbInfoId;
    DWORD   dwAbToken;
    DWORD   dwAbType;
} ABPARTIALINFO, *PABPARTIALINFO;




typedef struct tagABROUTINGEX {
    ABSTATUS    abs;
    CHAR        szFullEmail[AB_MAX_INTERNAL_FULL_EMAIL];
    ABROUTING   abrouting;
} ABROUTINGEX, *PABROUTINGEX;


typedef ULONG ABIID;        // AbInfoId

// Address Book Type Search Flag
typedef ULONG ABTSF;
#define ABTSF_ACCOUNT       0x00000001      // 1
#define ABTSF_NORMAL_DL     0x00000040      // 64
#define ABTSF_EXTENED_DL    0x00000080      // 128
#define ABTSF_DOMAIN_DL     0x00000100      // 256
#define ABTSF_SITE_DL       0x00000200      // 512
#define ABTSF_DISTLIST      (ABTSF_NORMAL_DL | ABTSF_EXTENDED_DL | ABTSF_DOMAIN_DL | ABTSF_SITE_DL)
#define ABTSF_ALLTYPE       0xffffffff

typedef enum {
    abtUnknown      = 0,
    abtAccount      = ABTSF_ACCOUNT,
    abtNormalDL     = ABTSF_NORMAL_DL,
    abtExtendedDL   = ABTSF_EXTENED_DL,
    abtDomainDL     = ABTSF_DOMAIN_DL,
    abtSiteDL       = ABTSF_SITE_DL
} ABTYPE;

typedef enum {
    abasValid   = 0,
    abasExpired = 1
} ABACCTSTATUS;


typedef struct tagABINFO_COM {
    ABIID   abiid;
    ABTYPE  abt;
    CHAR    szEmail[AB_MAX_EMAIL];
    CHAR    szDomain[AB_MAX_DOMAIN];
    INT     nDomainId;
} ABINFO_COM, *PABINFO_COM;


typedef struct tagABINFO_ACCOUNT {
    ABIID       abiid;
    ABTYPE      abt;
    CHAR        szEmail[AB_MAX_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];    //
    INT         nDomainId;                  // Reserved for Internal use, must set to -1.
    HACCT       hAcct;                      //
    DWORD       dwGroupId;
    DWORD       dwFlags;
} ABINFO_ACCOUNT, *PABINFO_ACCOUNT;


typedef struct tagABINFO_DISTLIST {
    ABIID       abiid;
    ABTYPE      abt;
    CHAR        szEmail[AB_MAX_EMAIL];
    CHAR        szDomain[AB_MAX_DOMAIN];
    INT         nDomainId;
    HACCT       hAcctOwner;
    TOKEN       token;
    DWORD       dwSecureLevel;
} ABINFO_DISTLIST, *PABINFO_DISTLIST;




typedef struct tagABSERVER_INFO {
    DWORD   dwServerId;
    DWORD   dwTypeFlags;
    CHAR    szServerName[MAX_PATH];
} ABSRVR_INFO, *PABSRVR_INFO;


union ABINFO_SUPERSET {
    ABINFO_ACCOUNT      abiacc;
    ABINFO_DISTLIST     abidl;
    ABSRVR_INFO         absrvr;
};


typedef struct tagAbPersistDomainInfo {
    CHAR        szDomainName[AB_MAX_DOMAIN];    // ie uk.eu.msn.com
    BOOL        fLocal;                         // Local to current site
    BOOL        fReplicate;                     // Not local but just want to subscribe to the info
    CHAR        szParentDomain[AB_MAX_DOMAIN];  // ie eu.msn.com
    LIST_ENTRY  list;                           // list pointers
} ABPDI, *PABPDI;

typedef struct tagAbSource {
    CHAR        szConfig[AB_MAX_CONFIG];
    LIST_ENTRY  list;
} ABSOURCE, *PABSOURCE;

typedef struct tagAbSourceEntry {
    LONG            lType;
    LONG            lMaxCnx;
    LONG            lQueryTimeOut;
    DWORD           dwRecoverTime;

    CHAR            szServerName[MAX_SERVERNAME + 1];
    CHAR            szDBName[MAX_NAME + 1];
    CHAR            szLoginName[MAX_NAME + 1];
    CHAR            szPassWord[MAX_NAME +1];

    DWORD           dwAction;

    LIST_ENTRY      list;

    void* operator new(size_t size);
    void  operator delete(void* pvMem, size_t size);
} ABSOURCE_ENTRY, *PABSOURCE_ENTRY;

typedef struct tagAbAddrStatistic {
    BOOL    cRemote;            // Number of remote recips to return
    BOOL    cLocal;             // Number of local recips to return
    DWORD   cUnresolved;        // Number of unresolved recips to return
} ABADDRSTAT,*PABADDRSTAT;


typedef enum {
    abatResolveDL = 1,
    abatMatchName = 2,
    abatServerList= 3,
    abatDomainList= 4,
    abatEnumResolveEx=5,
    abatEnumUserGroup=6
} ABACTIONTYPE;

typedef struct tagABENUM {
    ABRETC          abrcLastError;
    BOOL            fCheckRights;
    HACCT           hAcct;
    DWORD           dwRights;
    DWORD           cRowSoFar;
    DWORD           cRowRejected;
    DWORD           cRowMatched;
    DWORD           cRowReturned;
    PVOID           dbproc;
    HANDLE          hconn;  // HANDLE returned from DbGetConnection() in dbcon.dll
    ABACTIONTYPE    abat;
    BOOL            fUseLastRow;
    ABINFO_SUPERSET rgbLastRow;
} ABENUM, *PABENUM;

typedef struct _ABOOKDB_STATISTICS_0
{
    DWORD               NumResolvedAddresses;
    DWORD               NumUnresolvedAddresses;

    // Distribution List specific
    DWORD               NumDLsExpanded;
    DWORD               NumSmallDLsExpanded;
    DWORD               NumLargeDLsExpanded;
    DWORD               TimeResolvingSmallDLs;
    DWORD               TimeResolvingLargeDLs;

    // Api call frequency
    DWORD               NumAbResolveAddressCalls;
    DWORD               NumAbResolveAddressExCalls;
    DWORD               NumAbGetUserMailRootCalls;
    DWORD               NumAbGetUserMailRootFromHacctCalls;

    DWORD               NumAbCreateDL;
    DWORD               NumAbUpdateDL;
    DWORD               NumAbDeleteDL;
    DWORD               NumAbAddDLMember;
    DWORD               NumAbDeleteDLMember;

    DWORD               NumAbCreateInternetAcct;
    DWORD               NumAbDeleteInternetAcct;

    DWORD               NumAbCreateLocalUser;
    DWORD               NumAbCreateRemoteUser;
    DWORD               NumAbDeleteUser;

    DWORD               NumAbGetAbinfoFromEmail;
    DWORD               NumAbGetAbinfoFromAbiid;

    DWORD               NumAbResolveDLMembers;
    DWORD               NumAbMatchSimilarName;
    DWORD               NumAbGetServerList;
    DWORD               NumAbGetDomainList;
    DWORD               NumAbGetSiteList;

    // Data Base specific
    DWORD               NumDBFailures;
    DWORD               NumAuthenticationRequested;

} ABOOKDB_STATISTICS_0, *PABOOKDB_STATISTICS_0;

//
//  Completion callback from ABResolveAddress
//
typedef VOID (__stdcall *LPFNRESOLVECOMPLETE)(
    DWORD dwErr,
    PVOID pContext,
    PABADDRSTAT pAddrStat,
    PABRESOLVE pAbresolve);
//
//  Callback from TransactionLogging
//
typedef VOID  (__stdcall *LPFNLOGTRANX)(LPCSTR,LPCSTR,LPCSTR,DWORD);

#endif
