//
// hTblGlyf.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Compute the hash value for the glyf table,
// which includes getting values from other
// tables.
//
// Functions in this file:
//   print_tabs
//   CreateNode
//   AppendNode
//   FreeList
//   ConcatList
//   GetCmapInfo
//   GetGlyphInfo
//   FirstPresentGlyph
//   NextPresentGlyph
//   FirstKeepGlyph
//   NextKeepGlyph
//   HashValueMissingGlyphs
//   MergeSubtreeHashes
//   HashValueGlyphRange
//   HashTable_glyf
//

// DEBUG_HTBLGLYF
// 2: print out the characters in the cmap file and
//    the glyphs generated by MakeKeepGlyphList.
// 1: print out the hash value generated along
//    with stats about how many nodes were touched, etc.
#define DEBUG_HTBLGLYF 2

// For printing out the recursion
#define TREETRACE 0

#define APPENDTRACE 1

#include "hTblGlyf.h"
#include "glyphExist.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"

#include "subset.h"


// constructor for CHashTableGlyfContext
//
// The flag fDsigInfo indicates whether the given DsigInfo is valid.
CHashTableGlyfContext::CHashTableGlyfContext
					(TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                     BOOL fDsigInfo,
					 CDsigInfo *pDsigInfo,
					 UCHAR *puchKeepList,
					 DWORD cbHash,
					 HCRYPTPROV hProv,
                     ALG_ID alg_id)
{
	HRESULT fReturn E_FAIL;

	this->pFileBufferInfo = pFileBufferInfo;
    this->fDsigInfo = fDsigInfo;
	this->pDsigInfo = pDsigInfo;
	ulNumMissing = pDsigInfo->GetNumMissingGlyphs();
	ulOffsetMissing = 0;
	pbOldMissingHashValues = pDsigInfo->GetMissingGlyphs();
	pHashListNodeHead = NULL;
	pHashListNodeTail = NULL;
	this->hProv = hProv;
	hashAlg = alg_id;
	this->cbHash = cbHash;
	usNumGlyphs = GetNumGlyphs (pFileBufferInfo);
	this->puchKeepList = puchKeepList;

	ulMissingHashValues = 0;
	ulNodesTouched = 0;
	ulHashComputations = 0;

    
    // allocate memory for puchPresentList
    if ((puchPresentList = new UCHAR [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new UCHAR.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

	// set the present list
	if ((fReturn = GetPresentGlyphList (this->pFileBufferInfo,
                                        puchPresentList,
                                        usNumGlyphs)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetPresentGlyphList.\n");
#endif
		goto done;
	}

	// allocate memory for pGlyphInfo
	if ((pGlyphInfo = new GlyphInfo [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new GlyphInfo.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	// set the GlyphInfo structure
	if ((fReturn = GetGlyphInfo (pGlyphInfo)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetGlyphInfo.\n");
#endif
		goto done;
	}

    // NOTE: There is a small inefficiency in the calls to GetPresentGlyphList
    // and GetGlyphInfo above.  Each of the two functions needs to read the cmap
    // table.  A function that did both of these tasks could read through
    // the cmap table once, but it wouldn't be as modular.

	fReturn = S_OK;
done:
    if (fReturn != S_OK) {
        exit (fReturn);
    }
}


// destructor for CHashTableGlyfContext
CHashTableGlyfContext::~CHashTableGlyfContext ()
{
	// Free resources
	if (pGlyphInfo) {
//		PrintGlyphInfo (pGlyphInfo, usNumGlyphs);
		FreeGlyphInfo (pGlyphInfo, usNumGlyphs);
	}

	delete [] puchPresentList;
	puchPresentList = NULL;

	delete [] puchKeepList;
	puchKeepList = NULL;
}


void print_tabs (int i)
{
#if MSSIPOTF_DBG
	for (; i > 0; i--) {
		DbgPrintf ("  ");
	}
#endif
}


////--------
//// Routines to manipulate a linked list
//// of hash values.

// Create node
// Given the range of missing hash value and
// a pointer to cb bytes, return
// in ppNew a new node.
HRESULT CreateNode (USHORT low, USHORT high, BYTE *pb, ULONG cb, ListNode **ppNew)
{
	HRESULT fReturn = E_FAIL;

	if ((*ppNew = new ListNode) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new ListNode.",
            NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	(*ppNew)->low = low;
	(*ppNew)->high = high;

	if (((*ppNew)->pb = new BYTE [cb]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif

        delete *ppNew;
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	ByteCopy ((*ppNew)->pb, pb, cb);
	(*ppNew)->cb = cb;
	(*ppNew)->next = NULL;

	fReturn = S_OK;

done:
	return fReturn;
}


// Append
// Given a pointer to the head and tail nodes,
// add the given node to the list at the tail.
HRESULT AppendNode (ListNode *pNew, ListNode **ppHead, ListNode **ppTail)
{
	if (*ppHead == NULL) {
		assert (*ppTail == NULL);
		pNew->next = NULL;
		*ppTail = pNew;
		*ppHead = pNew;
	} else {
		assert ((*ppTail)->next == NULL);
		(*ppTail)->next = pNew;
		pNew->next = NULL;
		*ppTail = pNew;
	}

	return S_OK;
}


// Free an entire list
HRESULT FreeList (ListNode *pHead)
{
	ListNode *pCurrent = pHead;
	ListNode *pNext;

	while (pCurrent != NULL) {
		pNext = pCurrent->next;
		delete [] pCurrent->pb;
		delete pCurrent;
		pCurrent = pNext;
	}

	return S_OK;
}


// Given the head of a list, concatenate all of the
// hash values in the list (from head to tail) as a
// single stream of bytes and return it in ppNew.
// Also, return in pNumElem the number of elements in the list
HRESULT ConcatList (ListNode *pHead, USHORT *pNumElem, BYTE **ppNew, ULONG *cb)
{
	HRESULT fReturn = E_FAIL;

	ListNode *pTempOld;	// for walking down the linked list
	BYTE *pTempNew;			// for walking down the ppNew memory

	// Compute how many elements and
	// compute how many bytes in the entire list
	*pNumElem = 0;
	*cb = 0;
	pTempOld = pHead;
	while (pTempOld != NULL) {
		(*pNumElem)++;
		(*cb) += pTempOld->cb;
		pTempOld = pTempOld->next;
	}

	// Allocate space for the new byte stream
	if ((*ppNew = new BYTE [*cb]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	// Walk down the list, copying each range and hash value
	// into the new space.
	pTempOld = pHead;
	pTempNew = *ppNew;
	while (pTempOld != NULL) {
		ByteCopy (pTempNew, pTempOld->pb, pTempOld->cb);
		pTempNew += pTempOld->cb;
		pTempOld = pTempOld->next;
	}

	fReturn = S_OK;
done:
	return fReturn;
}


////--------

//
// Set the cmap part of the GlyphInfo structure.
// Return a list of present glyphs, as defined
// by the cmap table and a call to automap.
//
// Note that there are two passes over the cmap
// table.  One pass is to construct a list of
// characters in the cmap table.  The second
// pass is in MakeKeepGlyphList when the characters
// are mapped to glyphs.
//
HRESULT CHashTableGlyfContext::GetCmapInfo (GlyphInfo *pGlyphInfo,
                                            UCHAR **ppuchPresentGlyphsList)
{
	HRESULT fReturn = E_FAIL;

    uint16 usFoundEncoding;
	CMAP_FORMAT4 CmapFormat4;
	FORMAT4_SEGMENTS *Format4Segments = NULL;
	GLYPH_ID * GlyphId = NULL;

	USHORT usSegCount;
	USHORT usCharListCount = 0;
	uint16 *pusCharPresentList = NULL;
	USHORT usCharListIndex;

	USHORT charsInSeg;

	uint16 usMaxGlyphIndexUsed = 0;
	uint16 usGlyphKeepCount = 0;

	USHORT i;
	USHORT j;


	// Allocate memory for *ppuchPresentGlyphsList
	assert (*ppuchPresentGlyphsList == NULL);
	if ((*ppuchPresentGlyphsList =
			new BYTE [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	//// Get the list of characters from the cmap table
	if (ReadAllocCmapFormat4(pFileBufferInfo,
                    3,	// platform. BUGBUG: need to make this more general
                    1,	// encoding. BUGBUG: need to make this more general
                    &usFoundEncoding,
                    &CmapFormat4,
                    &Format4Segments,
                    &GlyphId ) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading the cmap table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

	// Compute how many characters are represented in the cmap table
	usSegCount = CmapFormat4.segCountX2 / 2;
	for (i = 0; i < usSegCount; i++) {
		usCharListCount +=
			Format4Segments[i].endCount - Format4Segments[i].startCount + 1;
	}
	// allocate memory for puchCharPresentList
	if ((pusCharPresentList =
		    new uint16 [usCharListCount]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new uint16.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	// Run through the segments and set the pusCharPresentList array
	usCharListIndex = 0;
	for (i = 0; i < usSegCount; i++) {
		charsInSeg = Format4Segments[i].endCount - Format4Segments[i].startCount + 1;
		for (j = 0; j < charsInSeg; j++) {
			pusCharPresentList[usCharListIndex] = Format4Segments[i].startCount + j;
			usCharListIndex++;
		}
	}

#if (DEBUG_HTBLGLYF == 2)
#if MSSIPOTF_DBG
	// print out the list of characters
	DbgPrintf ("Character list:\n");
	DbgPrintf ("0:\t");
	for (i = 0; i < usCharListCount; i++) {
		DbgPrintf ("%d\t", pusCharPresentList[i]);
		if (((i + 1) % 8) == 0) {
			DbgPrintf ("\n");
			DbgPrintf ("%d:\t", i + 1);
		}
	}
	DbgPrintf ("\n");
#endif
#endif

	// initialize the present glyphs array
	for (i = 0; i < usNumGlyphs; i++) {
		(*ppuchPresentGlyphsList)[i] = FALSE;
	}

	//// Call MakeKeepGlyphList to get the list of referenced
	//// glyphs from the characters in the cmap table in the TTF file.
	if (MakeKeepGlyphList(pFileBufferInfo, // ttfacc info
                        0, // 0 = character list, 1 = glyph list
                        3, // cmap platform to look for
                        1, // cmap encoding to look for
                        pusCharPresentList, // list of chars to keep - from client
                        usCharListCount,	// count of list of chars to keep
                        *ppuchPresentGlyphsList,	// an array of chars representing
                                                    // glyphs 0-usGlyphListCount.
                        usNumGlyphs,        // count of puchKeepGlyphList array
                        &usMaxGlyphIndexUsed,
                        &usGlyphKeepCount) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in MakeKeepGlyphList.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

#if (DEBUG_HTBLGLYF == 2)
#if MSSIPOTF_DBG
	// print out the list of glyphs
	DbgPrintf ("Glyph list:\n");
	DbgPrintf ("0:\t");
	for (i = 0; i < usNumGlyphs; i++) {
		if ((*ppuchPresentGlyphsList)[i]) {
			DbgPrintf ("1\t");
		} else {
			DbgPrintf ("0\t");
		}
		if (((i + 1) % 8) == 0) {
			DbgPrintf ("\n");
			DbgPrintf ("%d:\t", i + 1);
		}
	}
	DbgPrintf ("\n");
#endif
#endif

	fReturn =  S_OK;

done:
	if (Format4Segments)
		free (Format4Segments);

	if (GlyphId)
		free (GlyphId);

	delete [] pusCharPresentList;

	return fReturn;
}


//
// Return an array of GlyphInfo structures that
// contains all of the information needed to compute
// a hash value for glyphs 0 through usNumGlyphs.
//
HRESULT CHashTableGlyfContext::GetGlyphInfo (GlyphInfo *pGlyphInfo)
{
	HRESULT fReturn = E_FAIL;
	USHORT i;

	ULONG ulGlyfOffset;
	ULONG *pulLoca = NULL;

	// characters that map to glyphs
	for (i = 0; i < usNumGlyphs; i++) {
		pGlyphInfo[i].pusCmap = NULL;
		pGlyphInfo[i].usNumMapped = 0;	
	}

	// glyf table data
	ulGlyfOffset = TTTableOffset (pFileBufferInfo, GLYF_TAG);
	if ((pulLoca = new ULONG [usNumGlyphs + 1]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new ULONG.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	if (GetLoca(pFileBufferInfo, pulLoca, usNumGlyphs + 1) == 0L) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in GetLoca.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}
	for (i = 0; i < usNumGlyphs; i++) {
		pGlyphInfo[i].ulGlyf = ulGlyfOffset + pulLoca[i];
		pGlyphInfo[i].ulLength =  pulLoca[i+1] - pulLoca[i];
	}


	// advance width and left side bearing

	// kerning pairs
	for (i = 0; i < usNumGlyphs; i++) {
		pGlyphInfo[i].pKern = NULL;
		pGlyphInfo[i].usNumKern = 0;	
	}

	// ypel value

	// advance height and top side bearing

	fReturn = S_OK;

done:
	// Free resources
	if (pulLoca)
		delete [] pulLoca;

	return fReturn;
}


// Return the first present glyph in puchPresentList.
void CHashTableGlyfContext::FirstPresentGlyph (LONG *present)
{
	*present = 0;
	for ( ; (*present <= usNumGlyphs) && (puchPresentList[*present] == FALSE);
		(*present)++) {
	}
	if (*present > usNumGlyphs) {
		*present = NONEXT;
	}
}


// Given the current present glyph, return in *present
// the next present glyph.  If there is no next present
// glyph, return NONEXT.
void CHashTableGlyfContext::NextPresentGlyph (LONG *present)
{
	// if *present = NONEXT, then we leave *present = NONEXT
	if (*present != NONEXT) {
		(*present)++;
		for ( ; (*present <= usNumGlyphs) && (puchPresentList[*present] == FALSE);
			(*present)++) {
		}
		if (*present > usNumGlyphs) {
			*present = NONEXT;
		}
	}
}


// Return the first keep glyph in puchKeepList.
void CHashTableGlyfContext::FirstKeepGlyph (LONG *keep)
{
	*keep = 0;
	for ( ; (*keep <= usNumGlyphs) && (puchKeepList[*keep] == FALSE);
		(*keep)++) {
	}
	if (*keep > usNumGlyphs) {
		*keep = NONEXT;
	}
}


// Given the current keep glyph, return in *keep
// the next keep glyph in puchKeepList.
// If there is no next keep glyph, return NONEXT.
void CHashTableGlyfContext::NextKeepGlyph (LONG *keep)
{
	// if *keep = NONEXT, then we leave *keep = NONEXT
	if (*keep != NONEXT) {
		(*keep)++;
		for ( ; (*keep <= usNumGlyphs) && (puchKeepList[*keep] == FALSE);
			(*keep)++) {
		}
		if (*keep > usNumGlyphs) {
			*keep = NONEXT;
		}
	}
}


// Return in pbHash the next hash value in the static
// variable pbMissingHashValues.  The static variable
// ulOffsetMissing points to the hash value to be returned.
// The funtion then updates the static variable
// ulOffsetMissing to point to the next missing hash value.
//
// This function assumes that pbOldMissingHashValues points
// to a number of bytes that is a multiple of cbHash.
HRESULT CHashTableGlyfContext::HashValueMissingGlyphs (BYTE *pbHash)
{
	HRESULT fReturn = E_FAIL;

	// check if there are too few missing hash values
	if ((ulOffsetMissing / cbHash) >= ulNumMissing) {
#if MSSIPOTF_ERROR
		SignError ("Not enough missing hash values.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}
	// Get the bytes
	ByteCopy (pbHash, pbOldMissingHashValues + ulOffsetMissing, cbHash);
	ulOffsetMissing += cbHash;

	ulMissingHashValues++;
	ulNodesTouched++;

	fReturn = S_OK;

done:
	return fReturn;
}



// Perform a hash on the concatentation of the low and high hash values
// and place the result in hashValue.
HRESULT CHashTableGlyfContext::MergeSubtreeHashes (BYTE *pbHashLow,
                                                   BYTE *pbHashHigh,
                                                   BYTE *pbHash)
{
    HRESULT fReturn = E_FAIL;
    HCRYPTHASH hHash;

    //// Create a hash object, feed the two hash values into
    //// CryptHashData, and return the resulting hash value.

    // Set hHash to be the hash object.
    if (!CryptCreateHash(hProv, hashAlg, 0, 0, &hHash)) {
#if MSSIPOTF_ERROR
        SignError ("Error during CryptCreateHash.",
                "MergeSubtreeHashes", TRUE);
#endif
        fReturn = MSSIPOTF_E_CRYPT;
        goto done;
	}

	// Feed pbHashLow and pbHashHigh into CryptHashData
	if (!CryptHashData(hHash, pbHashLow, cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	if (!CryptHashData(hHash, pbHashHigh, cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value).", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// pbHash now contains the hash value.

	ulNodesTouched += 3;
	ulHashComputations++;

	fReturn = S_OK;

done:
	// Free resources
	if (hHash)
		CryptDestroyHash (hHash);

	return fReturn;
}



#define LEFT_SUBTREE 0
#define RIGHT_SUBTREE 1
#define OUTSIDE_TREE 2

// Return the hash value of a range of glyph numbers.
HRESULT CHashTableGlyfContext::HashValueGlyphRange
					(USHORT i, USHORT j,
                     LONG *next_present, LONG *next_keep,
                     int fSuppressAppend,
                     BYTE *pbHash,
                     int level)
{
	HRESULT fReturn = E_FAIL;
    
    USHORT numNodes;	// number of nodes in the (sub)tree,
					// which equals j - i + 1
	USHORT near2NumNodes;	// closest power of 2 to numNodes
							// (== near_2 (numNodes)).

	USHORT numLeft;	// number of nodes in the left subtree
	int where_next_keep_preleft;	// which subtree (or possibly outside the tree) the
									// next keep glyph is before left subtree traversal
	int where_next_keep_postleft;	// which subtree (or possibly outside the tree) the
									// next keep glyph is just after left subtree traversal
	int fSuppressLeftSubtree, fSuppressRightSubtree;
	BYTE *pbHashLow = NULL;		// hash value for left subtree
	BYTE *pbHashHigh = NULL;	// hash value for right subtree
	ListNode *pMissingHashNode;

	

#if TREETRACE
#if MSSIPOTF_DBG
	print_tabs (level);
	DbgPrintf ("Dealing with [%d, %d].\n", i, j);
#endif
#endif

	assert((*next_keep == NONEXT) || (*next_keep >= *next_present));

    if ((*next_present < i) && (*next_present != NONEXT)) {

        // we should have already dealt with the next present
        // glyph and advanced it beyond i
#if MSSIPOTF_DBG
		DbgPrintf ("Error: *next_present < i.\n");
#endif
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;

	} else if (i == j) {
		if (*next_present == i) {
			NextPresentGlyph (next_present);  // advance to next glyph
            if (*next_present == NONEXT) {
                *next_keep = NONEXT;
            }
			while ((*next_keep != NONEXT) && (*next_keep < *next_present)) {
				NextKeepGlyph (next_keep);
			}
            // generate the hash value for the glyph
			fReturn = HashGlyph (i, pbHash);

//			cout << "Hash value of glyph " << dec << i << ":" << endl;
//			PrintBytes (pbHash, cbHash);

		} else if (this->fDsigInfo) {
            // Glyph i is not present and the DsigInfo is valid, so
            // we must retrieve its hash value from the DsigInfo
		    if ((fReturn = HashValueMissingGlyphs (pbHash)) != NO_ERROR) {
#if MSSIPOTF_DBG
			    DbgPrintf ("Error in HashValueMissingGlyphs.\n");
#endif
			    goto done;
		    }

#if APPENDTRACE
#if MSSIPOTF_DBG
		print_tabs (level + 1);
		DbgPrintf ("Retrieved missing hash value for [%d, %d].\n", i, j);
		PrintBytes (pbHash, cbHash);
#endif
#endif

        } else {
			// Glyph i is not present and the DsigInfo is not valid, so
            // we must generate a hash value for the missing (null) glyph.
			fReturn = HashGlyphNull (pbHash);
		}

	} else if ( ((*next_present > j) || (*next_present == NONEXT)) &&
                (this->fDsigInfo) ) {

        // the next present glyph is outside the range of i and j and
        // the DsigInfo is valid, so we retrieve its hash value from DsigInfo
		if ((fReturn = HashValueMissingGlyphs (pbHash)) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in HashValueMissingGlyphs.\n");
#endif
			goto done;
		}

#if APPENDTRACE
#if MSSIPOTF_DBG
		print_tabs (level + 1);
		DbgPrintf ("Retrieved missing hash value for [%d, %d].\n", i, j);
		PrintBytes (pbHash, cbHash);
#endif
#endif

	} else {

        // Either there is a present glyph in the range [i,j] (inclusive) or
        // the DsigInfo is invalid (which means we need to generate the hash
        // value of this node of the tree by recursively generating the hash
        // values of the subtrees).

		numNodes = j - i + 1;
		assert (numNodes >= 2);

		near2NumNodes = near_2 (numNodes);

		// At this point, if (numNodes == near2NumNodes), then 
		// numNodes is a power of 2, and both subtrees are full
		// binary trees.  So, the number of nodes in each subtree
		// is near2NumNodes / 2.  Otherwise,
		// (near2NumNodes / 2) + min(near2NumNodes / 2, (numNodes - // near2NumNodes))
		// is the number of nodes in the left subtree, and
		// numNodes - (# in left subtree) is the number of nodes in
		// the right subtree.
		if (numNodes == near2NumNodes) {
			numLeft = near2NumNodes / 2;
			// numRight = near2NumNodes / 2;
		} else {
			numLeft = (near2NumNodes / 2) + 
					__min(near2NumNodes / 2, (numNodes - near2NumNodes));
		}


		//// Here is a chart that describes what flag to pass down and
		//// whether to append a hash value.
		//
		// Value of where_next_keep_preleft
		// before left subtree traversal:  Action:
		//   LEFT_SUBTREE                  inherit fSuppressAppend
		//   RIGHT_SUBTREE                 suppress left subtree, append left subtree hash
		//   OUTSIDE_TREE                  suppress both subtrees, append combined hash
		//
		// If where_next_keep_preleft equals LEFT_SUBTREE before the left subtree traversal,
		//   then we check *next_keep again after the left subtree traversal.  Then:
		// If *next_keep is in the right subtree, then the call to the right subtree
		//   inherits fSuppressAppend.
		// If *next_keep is outside the tree, then we suppress the right subtree and
		//   append the right subtree hash.
		//
		// If where_next_keep_preleft does not equal LEFT_SUBTREE before the left subtree
		//   traversal, then *next_keep should not have changed values after
		//   traversing the left subtree (and so where_next_keep_preleft should
		//   equal where_next_keep_postleft).
		////
		////

		// which subtree is the next keep glyph in
		if ((i <= *next_keep) && (*next_keep <= i + numLeft - 1)) {
			where_next_keep_preleft = LEFT_SUBTREE;
		} else if ((i + numLeft <= *next_keep) && (*next_keep <= j)) {
			where_next_keep_preleft = RIGHT_SUBTREE;
		} else {
			where_next_keep_preleft = OUTSIDE_TREE;
		}

		fSuppressLeftSubtree =
			(fSuppressAppend || (where_next_keep_preleft != LEFT_SUBTREE)) ?
			TRUE: FALSE;

		// Allocate memory for pbHashLow
		if ((pbHashLow = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		//// Traverse the left subtree
		if ((fReturn = HashValueGlyphRange (i, i + numLeft - 1,
								next_present, next_keep,
								fSuppressLeftSubtree,
								pbHashLow,
								level + 1)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in HashValueGlyphRange [%d, %d].\n",
				i, i + numLeft - 1);
#endif
			goto done;
		}
		if ((!fSuppressAppend) && (where_next_keep_preleft == RIGHT_SUBTREE)) {
			// Append a node to the linked list of hashes
			if ((fReturn = CreateNode (i, i + numLeft - 1,
								pbHashLow, cbHash, &pMissingHashNode)) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CreateNode.\n");
#endif
				goto done;
			}
			AppendNode (pMissingHashNode, &pHashListNodeHead, &pHashListNodeTail);
#if APPENDTRACE
#if MSSIPOTF_DBG
			print_tabs (level + 1);
			DbgPrintf ("Appending hash value for [%d, %d].\n",
				i, i + numLeft - 1);
			PrintBytes (pbHashLow, cbHash);
#endif
#endif

		}

		// which subtree is the next keep glyph in
		if ((i <= *next_keep) && (*next_keep <= i + numLeft - 1)) {
			// this branch should not be taken
			where_next_keep_postleft = LEFT_SUBTREE;
			assert (0);
		} else if ((i + numLeft <= *next_keep) && (*next_keep <= j)) {
			where_next_keep_postleft = RIGHT_SUBTREE;
		} else {
			where_next_keep_postleft = OUTSIDE_TREE;
		}

		if (where_next_keep_preleft == LEFT_SUBTREE) {
			if (where_next_keep_postleft == RIGHT_SUBTREE) {
				fSuppressRightSubtree = fSuppressAppend;
			} else {
				assert (where_next_keep_postleft == OUTSIDE_TREE);
				fSuppressRightSubtree = TRUE;
			}
		} else {
			assert (where_next_keep_preleft == where_next_keep_postleft);
			fSuppressRightSubtree =
				(fSuppressAppend || (where_next_keep_preleft == OUTSIDE_TREE)) ?
				TRUE : FALSE;
		}

		// Allocate memory for pbHashHigh
		if ((pbHashHigh = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		//// Traverse the right subtree
		if ((fReturn = HashValueGlyphRange (i + numLeft, j,
								next_present, next_keep,
								fSuppressRightSubtree,
								pbHashHigh,
                                level + 1)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in HashValueGlyphRange [%d, %d].\n",
				i + numLeft, j);
#endif
			goto done;
		}

		if ((!fSuppressAppend) &&
			(where_next_keep_preleft == LEFT_SUBTREE) &&
			(where_next_keep_postleft == OUTSIDE_TREE)) {
			// Append a node to the linked list of hashes
			if ((fReturn = CreateNode (i + numLeft, j,
							pbHashHigh, cbHash, &pMissingHashNode)) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CreateNode.\n");
#endif
				goto done;
			}
			AppendNode (pMissingHashNode, &pHashListNodeHead, &pHashListNodeTail);
#if APPENDTRACE
#if MSSIPOTF_DBG
			print_tabs (level + 1);
			DbgPrintf ("Appending hash value for [%d, %d].\n",
				i + numLeft, j);
			PrintBytes (pbHashHigh, cbHash);
#endif
#endif
		}

		//// Combine the hash values of the two subtrees
		if ((fReturn =
			MergeSubtreeHashes (pbHashLow, pbHashHigh, pbHash)) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MergeSubtreeHashes.\n");
#endif
			goto done;
		}

		if ((!fSuppressAppend) && (where_next_keep_preleft == OUTSIDE_TREE)) {
			// Append a node to the linked list of hashes
			if ((fReturn = CreateNode (i + numLeft, j,
							pbHash, cbHash, &pMissingHashNode)) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CreateNode.\n");
#endif
				goto done;
			}
			AppendNode (pMissingHashNode, &pHashListNodeHead, &pHashListNodeTail);
#if APPENDTRACE
#if MSSIPOTF_DBG
			print_tabs (level + 1);
			DbgPrintf ("Appending hash value for [%d, %d].\n", i, j);
			PrintBytes (pbHash, cbHash);
#endif
#endif
		}

		assert (fReturn == NO_ERROR);

	}

#if TREETRACE
#if MSSIPOTF_DBG
	print_tabs (level);
	DbgPrintf ("Done with [%d, %d].\n", i, j);
#endif
#endif

done:
	// Free resources
    delete [] pbHashLow;

    delete [] pbHashHigh;

#if MSSIPOTF_DBG
	if (fReturn != S_OK)
		DbgPrintf ("Error in [%d, %d].\n", i, j);
#endif

	return fReturn;
}




//
// HashTable_glyf
//
// Compute the hash value for the glyf table of the given
// TTF file.  The number of bytes of the hash value is given
// in cbHash by the caller.  Place the hash value in pbHash.
// In pbMissingHashValues and cMissingHashValues, place the
// missing hash values corresponding to the file that would
// result if it were subsetted according to puchKeepList.
// If puchKeepList is NULL, then no (further) subsetting of
// the file is performed.
//
// Computing the hash value of the glyf table involves
// computing hash values for the individual glyphs.  These
// hash values are organized in a tree of hash values.
// The hash value at the root of this tree is the hash value
// of the glyf table.
//
// Computing the hash value of an individual glyph involves
// not only using the bytes associated with that glyph in the
// glyf table, but also values in other tables (e.g., character
// numbers that map to the glyph (cmap), advance width and
// left side bearing (hmtx), etc.).  Refer to the function
// HashGlyph for a more complete description of how the hash
// value is computed.
//
// If fSupressAppend is FALSE, then this function will return
// in pbNewMissingHashValues, cNewMissingHashValues, and
// cbNewMissingHashValues a set
// of missing hash values corresponding to the keep list.
//
// When using this function to get only a hash value for the
// glyphs, fSuppressAppend should be set to TRUE and the keep
// list should be the all 1's array.
//
// When using this function to further subset a font, fSuppressAppend
// should be se to FALSE, with the appropriate subset specified
// in puchKeepList.
//
// This function assumes that pbHash points to a block
// of memory needed for the given hash algorithm
// and that cbHash is set to the hash value size.
//
HRESULT CHashTableGlyfContext::HashTable_glyf
                (int fSuppressAppend,
                 BYTE *pbHash,
                 BYTE **ppbNewMissingHashValues,
                 USHORT *pcNewMissingHashValues,
                 ULONG *pcbNewMissingHashValues)
{
	HRESULT fReturn = E_FAIL;

	LONG present = 0;
	LONG keep = 0;


	FirstPresentGlyph (&present);
	FirstKeepGlyph (&keep);
	while ((keep != NONEXT) && (keep < present)) {
		NextKeepGlyph (&keep);
	}
#if (DEBUG_HTBLGLYF == 1)
#if MSSIPOTF_DBG
	DbgPrintf ("present = %d\n", present);
	DbgPrintf ("keep    = %d\n", keep);
#endif
#endif

	if ((fReturn = HashValueGlyphRange (0, usNumGlyphs - 1,
                                    &present, &keep,
                                    fSuppressAppend,
                                    pbHash,
                                    0)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in HashValueGlyphRange.\n");
#endif
		goto done;
	}

	// Verify that there aren't any extra missing hash values
	if ((ulOffsetMissing / cbHash) != ulNumMissing) {
#if MSSIPOTF_ERROR
		SignError ("Too many missing hash values.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

	// Gather all the missing hash values and their ranges
	if (!fSuppressAppend) {
		ConcatList (pHashListNodeHead,
				pcNewMissingHashValues,
				ppbNewMissingHashValues,
				pcbNewMissingHashValues);
		FreeList (pHashListNodeHead);
	}

#if (DEBUG_HTBLGLYF == 1)
#if MSSIPOTF_DBG
	// post mortem
	DbgPrintf ("\n---- Post Mortem:\n");
	DbgPrintf ("The hash value of the glyf table is:\n");
	PrintBytes (pbHash, cbHash);
	DbgPrintf ("Number of missing hash values retrieved: %d.\n",
		ulMissingHashValues);
	DbgPrintf ("Number of hash computations performed  : %d.\n",
		ulHashComputations);
	DbgPrintf ("Number of nodes touched                : %d.\n",
		ulNodesTouched);
	DbgPrintf ("\n");
#endif
#endif

	fReturn = S_OK;
done:

	return fReturn;
}
