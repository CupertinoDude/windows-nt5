//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2000  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	WriteDib.cpp
//    
//
//  PURPOSE:  
//      
//      This includes funtions
//
//	Functions:
//
//		
//
//
//  PLATFORMS:  Windows NT/2000
//
//  31-May-2000 Wed 19:12:09 updated  -by-  Daniel Chou (danielc)
//      Major rewrite
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "debug.h"
#include "multicoloruni.h"


#define GET_SI_CB(pbEnd, Idx)                                               \
    pHPOutData->ScanInfo[Idx].cb=(DWORD)((pbEnd)-pHPOutData->ScanInfo[Idx].pb)


#define REMOVE_RIGHT_ZEROS(pbScan, cbScan)                                  \
{                                                                           \
    LPBYTE  pbCur;                                                          \
    BYTE    bSave;                                                          \
                                                                            \
    if (*(pbCur = pbScan + cbScan - 1) == 0) {                              \
                                                                            \
        bSave   = *pbScan;                                                  \
        *pbScan = (BYTE)0xFF;                                               \
                                                                            \
        while (*pbCur == 0) {                                               \
                                                                            \
            --pbCur;                                                        \
        }                                                                   \
                                                                            \
        if (((*pbScan = bSave) == 0) &&                                     \
            (pbCur == pbScan)) {                                            \
                                                                            \
            cbScan = 0;                                                     \
                                                                            \
        } else {                                                            \
                                                                            \
            cbScan = (DWORD)(pbCur - pbScan + 1);                           \
        }                                                                   \
    }                                                                       \
}


//==========================================================================
// Following are local structures that only used in this file
//==========================================================================

typedef union _DW4B {
    DWORD   dw;
    WORD    w[2];
    BYTE    b[4];
    } DW4B, *PDW4B;


//
// INKDATA structure that store CMYK planner data as following, each ink has
// two plane that can make up to 4 levels (0 to 3)
//
//  cm.b[0] - Plane 1 of cyan ink
//  cm.b[1] - Plane 2 of cyan ink       cm.w[0] -- Cyan Ink
//  cm.b[2] - Plane 1 of magenta ink
//  cm.b[3] - Plane 2 of magenta ink    cm.w[1] -- Magenta Ink
//  yk.b[0] - Plane 1 of yellow ink
//  yk.b[1] - Plane 2 of yellow ink     yk.w[0] -- Yellow Ink
//  yk.b[2] - Plane 1 of black ink
//  yk.b[3] - Plane 2 of black ink      yk.w[1] -- Black Ink
//

typedef struct _INKDATA {
    DW4B    cm;
    DW4B    yk;
    } INKDATA, *PINKDATA;


//===========================================================================
// Local used glbal data
//===========================================================================

static const BYTE cPlane[] = { 0, 1, 2, 2, 3, 3, 3, 3 };
static const BYTE HPBegRaster[] = "\x1B*r1A\x1B*b0m";  // "\x1B*r1A\x1B*b0M";
static const BYTE HPEndRaster[] = "0M\x1B*rC";

//
// HP 600C600K black gen data. it is generated by the MakeHPBlackGen()
//

BYTE     HPBlackGen[0x124 + 1] = { 0xFF };

//
// InkData is computed base on the mode, it is used to tranlate a multiple
// coloe 8bpp byte into the CMYK, planner format,

INKDATA  InkData[0x6f + 1];


#if DBG && defined(DBG_WRITEDIB)

#define BLANK_WIDTH     256



HRESULT
APIENTRY
MultiColor_WriteFileHeader(
    PMULTICOLORPDEV     pMultiColorPDEV,
    LPWSTR              pFileName,
    LPBITMAPINFOHEADER  pbih,
    BOOL                bBlanked
    )

/*++

Routine Description:

    This function write out the bitmap file header for the band, the color
    table is stored in the Our PDEV

Arguments:

    ...


Return Value:




Author:

    06-Jun-2000 Tue 19:51:17 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    FILE                *fp;
    BITMAPFILEHEADER    bfh;
    BITMAPINFOHEADER    bih;
    UINT                i;


    bih = *pbih;

    ASSERT(bih.biSize == sizeof(BITMAPINFOHEADER));
    ASSERT(bih.biPlanes == 1);
    ASSERT(bih.biBitCount == 8);
    ASSERT((DWORD)bih.biWidth == pMultiColorPDEV->cx);

    if (bBlanked) {

        bih.biWidth  = BLANK_WIDTH;
    }

    bih.biClrUsed      = 256;
    bih.biClrImportant = 0;
    bih.biSizeImage    = bih.biHeight * ROUNDUP_DWORD(bih.biWidth);

    bfh.bfType         = ((WORD)'M' << 8) | (WORD)'B';
    bfh.bfSize         = sizeof(BITMAPFILEHEADER) +
                               bih.biSize +
                               (sizeof(RGBQUAD) * bih.biClrUsed) +
                               bih.biSizeImage;
    bfh.bfReserved1    = 0;
    bfh.bfReserved2    = 0;
    bfh.bfOffBits      = sizeof(BITMAPFILEHEADER) +
                               bih.biSize +
                               (sizeof(RGBQUAD) * bih.biClrUsed);

    if (!(pMultiColorPDEV->fp = fp = _wfopen(pFileName, __TEXT("wb")))) {
#if DBG
        DbgPrint("\nOpen File=%ws FAILED", pFileName);
#endif
        return(E_FAIL);
    }

    fwrite(&bfh, sizeof(BITMAPFILEHEADER), 1, fp);
    fwrite(&bih, bih.biSize, 1, fp);

    for (i = 0; i < 256; i++) {

        RGBQUAD rgbQ;

        rgbQ.rgbRed      = pMultiColorPDEV->HTPal[i].peRed;
        rgbQ.rgbGreen    = pMultiColorPDEV->HTPal[i].peGreen;
        rgbQ.rgbBlue     = pMultiColorPDEV->HTPal[i].peBlue;
        rgbQ.rgbReserved = 0;

        fwrite(&rgbQ, sizeof(RGBQUAD), 1, fp);
    }

    return(S_OK);
}




HRESULT
APIENTRY
MultiColor_WriteFile(
    PDEVOBJ             pDevObj,
    LPWSTR              pFileName,
    LPBITMAPINFOHEADER  pbih,
    LPBYTE              pBits,
    PIPPARAMS           pIPParams,
    DWORD               iPage,
    DWORD               iBand
    )

/*++

Routine Description:

    This function writes out the bitmap image into a DIB file, this will
    write is out band by band and write it as up-side-down for the DIB

Arguments:

    ..


Return Value:

    HRESULT


Author:

    06-Jun-2000 Tue 19:49:05 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    PMULTICOLORPDEV     pMultiColorPDEV;
    DWORD               cb;
    FILE                *fp;


    pMultiColorPDEV = (PMULTICOLORPDEV)(pDevObj->pdevOEM);

    if (MultiColor_WriteFileHeader(pMultiColorPDEV,
                                   pFileName,
                                   pbih,
                                   pIPParams->bBlankBand) != S_OK) {

        return(E_FAIL);
    }

    if (fp = pMultiColorPDEV->fp) {

        LPBYTE  pb;
        DWORD   cbScan;
        LONG    cxDelta;
        LONG    cy;

        //
        // Write it up-side-down for DIB
        //

        if (pIPParams->bBlankBand) {

            BYTE    Buf[BLANK_WIDTH + 4];

            ZeroMemory(Buf, sizeof(Buf));

            cbScan   = ROUNDUP_DWORD(BLANK_WIDTH);
            cy       = pbih->biHeight;

            while (cy--) {

                fwrite(Buf, cbScan, 1, fp);
            }

        } else {

            cbScan   = ROUNDUP_DWORD(pbih->biWidth);
            cxDelta  = -(LONG)cbScan;
            cy       = pbih->biHeight;
            pBits   += (cbScan * cy);

            while (cy--) {

                fwrite(pBits += cxDelta, cbScan, 1, fp);
            }
        }

        fclose(fp);
        pMultiColorPDEV->fp = NULL;

        return(S_OK);
    }

    return(E_FAIL);
}

#endif




VOID
MakeHPBlackGen(
    VOID
    )

/*++

Routine Description:

    This function will generate an array of byte table that will convert a
    combined two ink pixels to form a black with a color ink byte, this assume
    that each pixel of ink intensity will from 0 to 2.

    The format of the table indices are generated as following, each of color
    ink density is occupy three bits, the current pixel color ink is added to
    the next pixel color ink and forming this data indices.

        Index = (UINT)(CurPixel & 0x03) + (UINT)(NextPixel & 0x03) +
                (((UINT)(CurPixel & 0xfc) + (UINT)(NextPixel & 0xfc)) << 1);

             + +------b1-----+
             1 7 6 5 4 3 2 1 0
             +===+ +===+ +===+
               C     M     Y

    The maximum intensity of each ink is 0 to 2 (3 levels) and when adding
    current pixel with next pixel, it will have maximum of 0 - 4 (5 levels) to
    replace current pixel to a black ink (which has correct black rather than
    cyan, magenta and yellow mix.

        1. Each of inks levels (C, M, Y) must greater than one (1)
        2. there must at least two inks levels greater than two (2)

    If all above conditions are met then a black inks is used for current pixel
    and the next pixel will be a total inks levels from addition subtractive a
    black (2 levels of each cyan, magenta and yellow)

    the maximum size of table is based on the fact that maximum ink levels is
    two (2) and two pixel addtion make it maximum of 4 levels so the maximum
    from the above is

             + +------b1-----+
             1 7 6 5 4 3 2 1 0
             +===+ +===+ +===+
               C     M     Y
             |     |     |
             +     +     +
             1 0 0 1 0 0 1 0 0  = 0x124 plus index 0
             + +-----+ +-----+


    This table only used if the output format is MCM_600C600K which we want to
    replaced more ink mix with black then GDI Halftone provided because the
    HP inks mix just does not get black enough on the shadow area.

    You can run ICM on top this rendering to get a better matching profile.

Arguments:

    None


Return Value:

    None


Author:

    30-May-2000 Tue 15:18:48 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    //
    // Only do this if we haven't do it yet
    //

    if (HPBlackGen[0] == 0xFF) {

        BYTE    cC;
        BYTE    cM;
        BYTE    cY;
        BYTE    cZ;
        BYTE    bData;
        UINT    i;

        for (i = 0; i < sizeof(HPBlackGen); i++) {

            bData = 0;
            cC    = (BYTE)((i & 0x1c0) >> 6);
            cM    = (BYTE)((i & 0x038) >> 3);
            cY    = (BYTE)((i & 0x007) >> 0);

            if ((cC <= 4) && (cM <= 4) && (cY <= 4) &&
                (cC >= 2) && (cM >= 2) && (cY >= 2)) {

                cC -= 2;
                cM -= 2;
                cY -= 2;
                cZ   = (cC == 0) ? 1 : 0;

                if (cM == 0) {

                    ++cZ;
                }

                if (cY == 0) {

                    ++cZ;
                }

                if (cZ <= 1) {

                    bData = (cC << 5) | (cM << 2) | (cY);
#if DBG
                    DbgPrint("\n%3ld: CMY=%ld:%ld:%ld ---> %ld:%ld:%ld + K",
                            i, cC + 2, cM + 2, cY + 2, cC, cM, cY);
#endif
                }
            }

            HPBlackGen[i] = bData;
        }
    }
}



VOID
MakeHPCMYKInkData(
    ULONG   ColorMode,
    BYTE    k0,
    BYTE    k1,
    BYTE    KData,
    BYTE    BlackMask
    )

/*++

Routine Description:

    This function compose a cyan, magenta, yellow and black ink data array
    table that to be used to convert a 8bpp 3:3:2 pixel byte to a ink that
    can be used on cmyk planner format.

    This data make one step access to all CMYK planner data.  The maximum of
    table entries is based on the HP300K600C that has maximum of 3 levels
    each which is 0x6f from MAKE_CMYMASK_BYTE() pluse index 0

Arguments:

    ColorMode   - This can be one of the MCM_xxxx format, currently this
                  only support MCM_600C600K and MCM_300C600K

    k0          - The black plane 1 pixel data when ink is black

    k1          - The black plane 2 pixel data when ink is black

    kData       - The extra color plane data when ink is black

    BlackMask   - The black byte that form from MAKE_CMYMASK_BYTE() macro


Return Value:

    VOID


Author:

    31-May-2000 Wed 14:20:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    static ULONG    HPClrMode = 0xFFFF;

    DbgPrint("\nColorMode=%ld, k0=%02lx, k1=%02lx, KData=%02lx, Mask=%02lx",
                ColorMode, k0, k1, KData, BlackMask);

    if (HPClrMode != ColorMode) {

        PINKDATA    pInkData;
        BYTE        bData;
        BYTE        Idx;
        BYTE        k[2];

        HPClrMode = ColorMode;
        k[0]       =
        k[1]       = 0;

        //
        // Only generate black data for this mode
        //

        if (HPClrMode == MCM_600C600K) {

            MakeHPBlackGen();
        }

        for (Idx = 0, pInkData = &InkData[0];
             Idx <= BlackMask;
             Idx++, pInkData++) {

            if ((bData = Idx) == BlackMask) {

                bData = KData;
                k[0]  = k0;
                k[1]  = k1;
            }

            pInkData->cm.b[0] = ((bData >> 5) & 0x01);      // c0
            pInkData->cm.b[1] = ((bData >> 6) & 0x01);      // c1
            pInkData->cm.b[2] = ((bData >> 2) & 0x01);      // m0
            pInkData->cm.b[3] = ((bData >> 3) & 0x01);      // m1
            pInkData->yk.b[0] = ((bData >> 0) & 0x01);      // y0
            pInkData->yk.b[1] = ((bData >> 1) & 0x01);      // y1
            pInkData->yk.b[2] = k[0];
            pInkData->yk.b[3] = k[1];

            if (bData != Idx) {

                DbgPrint("\n%ld/%02lx: C=%ld/%ld, M=%ld/%ld, Y=%ld/%ld, K=%ld/%ld",
                            HPClrMode, Idx,
                            pInkData->cm.b[1], pInkData->cm.b[0],
                            pInkData->cm.b[3], pInkData->cm.b[2],
                            pInkData->yk.b[1], pInkData->yk.b[0],
                            pInkData->yk.b[3], pInkData->yk.b[2]);
            }
        }
    }
}



HRESULT
WriteHP600C600K(
    PMULTICOLORPDEV pMCPDev
    )

/*++

Routine Description:

    This function write a 600x600 DPI both color and black to the HP970c.
    The output is in 3 levels 0, 1, 2

Arguments:

    pHPOutData  - Pointer to the HPOUTDATA structure,
                  the InkData[] and HPBlackGen[] must already generated.


Return Value:

    TRUE if OK, FALSE if failed


Author:

    31-May-2000 Wed 15:22:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pk1     (HPOutData.ScanInfo[0].pb)
#define pc1     (HPOutData.ScanInfo[1].pb)
#define pc2     (HPOutData.ScanInfo[2].pb)
#define pm1     (HPOutData.ScanInfo[3].pb)
#define pm2     (HPOutData.ScanInfo[4].pb)
#define py1     (HPOutData.ScanInfo[5].pb)
#define py2     (HPOutData.ScanInfo[6].pb)


    PHPOUTDATA  pHPOutData;
    HPOUTDATA   HPOutData;
    HRESULT     hResult;
    DWORD       cx;
    DWORD       cy;
    UINT        Index;
    DW4B        cm;
    DW4B        yk;
    BYTE        bData;
    BYTE        bDataR;
    DWORD       cbW;


    hResult    = S_OK;
    pHPOutData = &pMCPDev->HPOutData;
    cy         = pHPOutData->cy;

    while ((hResult == S_OK) && (cy--)) {

        HPOutData         = *pHPOutData;
        pHPOutData->pbIn += HPOutData.cxDelta;
        cx                = HPOutData.cx;

        //
        // Do first (cx - 1) pixels
        //

        REMOVE_RIGHT_ZEROS(HPOutData.pbIn, cx);

        if (cx == 0) {

            pMCPDev->HPOutData.cBlankY++;

        } else {

            Index  = (UINT)HPOutData.c1stByte;
            cm.dw  =
            yk.dw  = 0;
            bData  = 0;
            bDataR = *HPOutData.pbIn++;

            while (--cx) {

                BYTE    b;

                bData  = bDataR;
                bDataR = *HPOutData.pbIn++;

                //
                // The HPBlackGen is in the format of 3 bits each of cyan,
                // magenta and yellow
                //

                if (b = HPBlackGen[((UINT)((bData & 0x03)+(bDataR & 0x03)))  +
                                   ((UINT)((bData & 0xfc)+(bDataR & 0xfc))<<1)]) {

                    bData  = HPOutData.bBlack;
                    bDataR = b;
                }

                yk.dw <<= 1;
                cm.dw <<= 1;

                if (bData) {

                    yk.dw |= InkData[bData].yk.dw;
                    cm.dw |= InkData[bData].cm.dw;
                }

                if (!(--Index)) {

                    *pc1++ = cm.b[0];
                    *pc2++ = cm.b[1];
                    *pm1++ = cm.b[2];
                    *pm2++ = cm.b[3];
                    *py1++ = yk.b[0];
                    *py2++ = yk.b[1];
                    *pk1++ = yk.b[2];
                    cm.dw  =
                    yk.dw  = 0;
                    Index  = 8;

                }
            }

            //
            // Do the last pixel, remember to shift last byte into the left most
            // bit
            //

            --Index;

            yk.dw  = ((yk.dw << 1) | InkData[bDataR].yk.dw) << Index;
            cm.dw  = ((cm.dw << 1) | InkData[bDataR].cm.dw) << Index;
            *pc1++ = cm.b[0];
            *pc2++ = cm.b[1];
            *pm1++ = cm.b[2];
            *pm2++ = cm.b[3];
            *py1++ = yk.b[0];
            *py2++ = yk.b[1];
            *pk1++ = yk.b[2];

            //
            // Now output the converted planner scan line using compression
            // we have save the cb back, since we remove the end of the
            // line blanks above, we need to pass the correct cb to the
            // TIFF compression
            //

            GET_SI_CB(pk1, 0);
            GET_SI_CB(pc1, 1);
            GET_SI_CB(pc2, 2);
            GET_SI_CB(pm1, 3);
            GET_SI_CB(pm2, 4);
            GET_SI_CB(py1, 5);
            GET_SI_CB(py2, 6);

            hResult = OutputRTLScan(pMCPDev);
        }
    }

    return(hResult);

#undef pk1
#undef pc1
#undef pc2
#undef pm1
#undef pm2
#undef py1
#undef py2
}




HRESULT
WriteHP300C600K(
    PMULTICOLORPDEV pMCPDev
    )

/*++

Routine Description:

    This function write a 300x300 DPI color and 600x600 DPI black to the
    HP970c. The output is in 4 levels 0, 1, 2, 3

    When we mapping the black it will map to 3K + one C1M1Y1. (see InkData)

Arguments:

    pHPOutData  - Pointer to the HPOUTDATA structure,
                  the InkData[] and HPBlackGen[] must already generated.



Return Value:


    TRUE if OK, FALSE if failed



Author:

    31-May-2000 Wed 15:22:26 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
#define pk1     (HPOutData.ScanInfo[0].pb)
#define pk2     (HPOutData.ScanInfo[1].pb)
#define pc1     (HPOutData.ScanInfo[2].pb)
#define pc2     (HPOutData.ScanInfo[3].pb)
#define pm1     (HPOutData.ScanInfo[4].pb)
#define pm2     (HPOutData.ScanInfo[5].pb)
#define py1     (HPOutData.ScanInfo[6].pb)
#define py2     (HPOutData.ScanInfo[7].pb)


    PHPOUTDATA  pHPOutData;
    HPOUTDATA   HPOutData;
    HRESULT     hResult;
    DWORD       cx;
    DWORD       cy;
    UINT        Index;
    DW4B        cm;
    DW4B        yk;
    BYTE        bData;
    DWORD       cbW;
    UINT        pkAdd;


    //
    // If we have less then 5 pixel on the first byte then the black scan
    // must skip one byte, this is true because the black is moving 2 bits
    // at one time in this mode
    //

    hResult    = S_OK;
    pHPOutData = &pMCPDev->HPOutData;
    pkAdd      = (pHPOutData->c1stByte <= 4) ? 1 : 0;
    cy         = pHPOutData->cy;

    while ((hResult == S_OK) && (cy--)) {

        HPOutData         = *pHPOutData;
        pHPOutData->pbIn += HPOutData.cxDelta;
        cx                = HPOutData.cx;

        REMOVE_RIGHT_ZEROS(HPOutData.pbIn, cx);

        if (cx == 0) {

            pMCPDev->HPOutData.cBlankY++;

        } else {

            pk1   += pkAdd;
            pk2   += pkAdd;
            Index  = (UINT)HPOutData.c1stByte;
            cm.dw  =
            yk.dw  = 0;

            while (cx--) {

                bData     = *HPOutData.pbIn++;
                yk.w[0] <<= 1;
                yk.w[1] <<= 2;
                cm.dw   <<= 1;

                if (bData) {

                    cm.dw |= InkData[bData].cm.dw;
                    yk.dw |= InkData[bData].yk.dw;
                }

                if ((!(--Index)) || (!cx)) {

                    if (Index) {

                        //
                        // Shift the last byte data into the left most side, the
                        // index could range from 0 to 7, if Index is not zero then
                        // we face it when cx is zero (last pixel)
                        //

                        cm.dw   <<= Index;
                        yk.w[0] <<= Index;

                        if (Index >= 4) {

                            Index -= 4;
                        }

                        //
                        // The index should be 0 to 3 now, black move two (2) bits
                        // at a time to move all pixel to align at left side.
                        //

                        yk.w[1] <<= (Index << 1);
                    }

                    *pc1++ = cm.b[0];
                    *pc2++ = cm.b[1];
                    *pm1++ = cm.b[2];
                    *pm2++ = cm.b[3];
                    *py1++ = yk.b[0];
                    *py2++ = yk.b[1];
                    *pk1++ = yk.b[2];
                    *pk2++ = yk.b[3];
                    cm.dw  =
                    yk.dw  = 0;
                    Index  = 8;

                } else if (Index == 4) {

                    *pk1++  = yk.b[2];
                    *pk2++  = yk.b[3];
                    yk.w[1] = 0;
                }
            }

            //
            // Now output the converted planner scan line using compression
            // we have save the cb back, since we remove the end of the
            // line blanks above, we need to pass the correct cb to the
            // TIFF compression
            //

            GET_SI_CB(pk1, 0);
            GET_SI_CB(pk2, 1);
            GET_SI_CB(pc1, 2);
            GET_SI_CB(pc2, 3);
            GET_SI_CB(pm1, 4);
            GET_SI_CB(pm2, 5);
            GET_SI_CB(py1, 6);
            GET_SI_CB(py2, 7);

            hResult = OutputRTLScan(pMCPDev);
        }
    }

    return(hResult);

#undef pk1
#undef pk2
#undef pc1
#undef pc2
#undef pm1
#undef pm2
#undef py1
#undef py2

}



HRESULT
SetupBandData(
    PMULTICOLORPDEV pMCPDev,
    PPOINTL         pptlDst
    )

/*++

Routine Description:

    This function setup the HPOUTDATA that relevant to the current bitmap,
    the band bitmap pointer and size will not setup at here,

    the pptlDst is passed so that we can aligned the cursor, for this driver
    this will always 0,0.  But for 300C600K mode, the cursor have to move to
    a 300 DPI location so there must a compensation for the black by moving
    only at multiple of 4.


Arguments:

    pMCPDev - Pointer to our PDEV

    pptlDst - Pointer to the destination started


Return Value:




Author:

    08-Jun-2000 Thu 11:22:12 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE      pb;
    DWORD       AlignMask;
    DWORD       cxExtra;
    UINT        cbCMY;
    UINT        cbK;
    UINT        iCMY;
    UINT        i;
    DWORD       iScanInfo;
    DWORD       cbCompress;
    DWORD       cbTot;


    iCMY                             = (UINT)cPlane[pMCPDev->cC] +
                                       (UINT)cPlane[pMCPDev->cM] +
                                       (UINT)cPlane[pMCPDev->cY];
    pMCPDev->HPOutData.bBlack        = pMCPDev->BlackMask;
    AlignMask                        = (pMCPDev->KMulX > 1) ? 0x07 : 0x00;
    cxExtra                          = pptlDst->x & AlignMask;
    pMCPDev->HPOutData.c1stByte      = (BYTE)(8 - cxExtra);
    cxExtra                         += pMCPDev->cx;
    pptlDst->x                      &= ~AlignMask;

    //
    // Now, compute all the data count
    //

    cbCMY      = (DWORD)((cxExtra + 7) >> 3);
    cbK        = (DWORD)(((cxExtra * (DWORD)pMCPDev->KMulX) + 7) >> 3);
    cbCompress = (cbK + EXTRA_COMPRESS_BUF_SIZE +
                  (((cbK / TIFF_MAX_LITERAL) + 2) * 2));
    cbTot      = cbCompress + (cbK * (DWORD)pMCPDev->KMulY) + (cbCMY * iCMY);

    DbgPrint("\ncbK=%ld, cbCMY=%ld, iCMY=%ld, KMul=%ld/%ld, cbCompress=%ld, cbTot=%d",
            cbK, cbCMY, iCMY, pMCPDev->KMulX, pMCPDev->KMulY, cbCompress, cbTot);

    //
    // the sequence of the color to be send is K0, K1, C0, C1, M0, M1, Y0, Y1
    //

    if (!(pb = pMCPDev->HPOutData.pbAlloc = new BYTE[cbTot])) {

        return(E_FAIL);
    }

    ZeroMemory(pb, cbTot);

    //
    // Set up the scan info data
    //

    pMCPDev->HPOutData.pbCompress     = pb;
    pb                               += cbCompress;
    pMCPDev->HPOutData.pbEndCompress  = pb;

    for (i = 0, iScanInfo = 0;
         i < (UINT)pMCPDev->KMulY;
         i++, iScanInfo++, pb += cbK) {

        pMCPDev->HPOutData.ScanInfo[iScanInfo].pb = pb;
        pMCPDev->HPOutData.ScanInfo[iScanInfo].cb = cbK;
    }

    for (i = 0; i < iCMY; i++, iScanInfo++, pb += cbCMY) {

        pMCPDev->HPOutData.ScanInfo[iScanInfo].pb = pb;
        pMCPDev->HPOutData.ScanInfo[iScanInfo].cb = cbCMY;
    }

    pMCPDev->HPOutData.cScanInfo = (BYTE)iScanInfo;

    return(S_OK);
}




HRESULT
APIENTRY
MultiColor_WriteBand(
    PMULTICOLORPDEV     pMCPDev,
    PBITMAPINFOHEADER   pbih,
    PBYTE               pBits,
    PIPPARAMS           pIPParams,
    DWORD               iPage,
    DWORD               iBand
    )
/*++

Routine Description:

    This function will setup necessary parameter and find all bounding
    rectangle in the bitmap specified then output to the hp multiple color
    density printer

    This function writes out the bitmap image into a PCL printer. This function
    assumes that the printer is in a mode such that the Black dots is at twice
    the DPI of the color dots. eg. HP DeskJet 970 Printers) So every color
    pixel in the bitmap corresponds to 1 color dot of Cyan, Magenta and Yellow
    and four black dots.

    IPrintOemDriverUni::DrvWriteSpoolBuf is called to send data to the spooler
    which sends it to the PCL printer. Please refer to the PCL Reference Guide
    for detailed description of PCL commands.

Arguments:

    pMCPDev     - our PDEV

    pbih        - Pointer to the bitmap header

    pBits       - Pointer to the first scan line of bitmap

    pIPParams   - Pointer to the PIOPARAMS

    iPage       - Current Page number from 1

    iBand       - Current band number from 0

Return Value:




Author:

    12-Jun-1998 Fri 16:05:16 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    HRESULT hResult = S_OK;
    DWORD   cbW;


    ASSERT((DWORD)pMCPDev->cx == (DWORD)pbih->biWidth);

    if (IS_FIRST_BAND(iBand)) {

        EnterRTLScan(pMCPDev);
    }

    if (pIPParams->bBlankBand) {

        //
        // This is a blank band and pBits is invalid. So we will simply adding
        // the blank lines that we have to skip
        //

        pMCPDev->HPOutData.cBlankY += pbih->biHeight;

    } else {

        //
        // setup current band bitmap information
        //

        pMCPDev->HPOutData.pbIn     = pBits;
        pMCPDev->HPOutData.cx       = pbih->biWidth;
        pMCPDev->HPOutData.cy       = pbih->biHeight;
        pMCPDev->HPOutData.cxDelta  = (LONG)ROUNDUP_DWORD(pbih->biWidth);

        DbgPrint("pbIn=%08lx, %ldx%ld, cxDelta=%ld",
                pBits,pbih->biWidth, pbih->biHeight, pMCPDev->HPOutData.cxDelta);

        //
        // If we never output anything for this page yet, then setup it up now
        // we will do this for every page, since we do not know when the page
        // will be end, at later we may want to do deleting at DisablePDEV
        //

        if (!pMCPDev->HPOutData.pbAlloc) {

            POINTL  ptlDst;

            //
            // Reset my cursor position so that first one will be output correctly
            //

            ptlDst.x =
            ptlDst.y = 0;

            if (hResult = SetupBandData(pMCPDev, &ptlDst) != S_OK) {

                return(E_FAIL);
            }
        }

        if (hResult == S_OK) {

            hResult = pMCPDev->WriteHPMCFunc(pMCPDev);
        }
    }

    if (IS_LAST_BAND(iBand)) {

        ExitRTLScan(pMCPDev);
    }

    return(hResult);
}
