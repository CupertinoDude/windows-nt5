
/*************************************************
 *  sortptbl.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  This file is used to sort Phone Unicode Table.
//
//   the original file contains lots of lines, every line follows below format:
//        XXXXTCFRL
//    X:   Key Code,
//    T:   Tab,  0x0009
//    C:   Unicode for this Character
//    F:   L' ' or L'*'
//    R:   0x000D
//    L:   0x000A
//
//  we will sort this file on pattern which is generated by XXXX
//


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )

WCHAR   Seq2Key[43] = { 0,
        L'1',  L'Q', L'A', L'Z', L'2', L'W', L'S', L'X',
        L'E',  L'D', L'C', L'R', L'F', L'V', L'5', L'T',
        L'G',  L'B', L'Y', L'H', L'N', L'U', L'J', L'M',
        L'8',  L'I', L'K', L',', L'9', L'O', L'L', L'.',
        L'0',  L'P', L';', L'/', L'-', L' ', L'6', L'3',
        L'4',  L'7' };


DWORD  GetPattern( WORD  *pWord )
{
  int   i, j;
  WORD  wValue;
  DWORD dwPat, dwSeq;

  dwPat = 0;

  for (i=0; i<3; i++) {

      wValue = *(pWord+i);
      dwSeq = 0;

      if ( wValue != L' ' ) { 
         
         for (j=0; j<43; j++) {
             if ( wValue == Seq2Key[j] ) {
                dwSeq = j;
                break;
             }
         }
      }
      dwPat = (dwPat << 6)  + dwSeq;
  }

// handle the last character, it should be one of five tones.

  wValue = *(pWord+3);
  dwSeq = 0;
  for (j=38; j<43; j++) {
      if ( wValue == Seq2Key[j] ) {
         dwSeq = j;
         break;
      }
  }

  dwPat = (dwPat << 6) + dwSeq;

  return dwPat; 

}

int __cdecl Mycompare(const void *elem1, const void *elem2 )
{
  WORD  *pWord1, *pWord2;
  DWORD dwPatn1, dwPatn2;
  WORD  wCode1,  wCode2;

  pWord1 = (WORD *)elem1;
  pWord2 = (WORD *)elem2;

 
  dwPatn1 = GetPattern(pWord1);
  dwPatn2 = GetPattern(pWord2);

  if ( dwPatn1 > dwPatn2 )  
     return 1;
  if ( dwPatn1 < dwPatn2 )  
     return -1;

//  if the pattern is identical, the smaller ucode will be got first.

  wCode1 = *(pWord1 +  5);
  wCode2 = *(pWord2 +  5);

  if ( wCode1 > wCode2 )  return 1;
  if ( wCode1 < wCode2 )  return -1;
 
  return 0;

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile;
  HANDLE   hInMap;
  LPBYTE   lpInFile, lpStart;
  DWORD    dwInFileSize; 

  if ( argc != 2 ) {
    printf("usage: sortptbl UnicdeTableFile \n");
    return; 
  }


  hInFile = CreateFile(argv[1],          // pointer to name of the file
                       GENERIC_READ | GENERIC_WRITE, //access(read-write)mode
                       FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode
                       NULL,             // pointer to security attributes
                       OPEN_EXISTING,    // how to create
                       FILE_ATTRIBUTE_NORMAL,  // file attributes
                       NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);

  dwInFileSize -= 2;
    
  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READWRITE, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_WRITE, 0, 0, 0);

  printf("dwInFileSize=%d ", dwInFileSize);

  lpStart = lpInFile + 2;  // skip UNICODE signature FEFF
  
  qsort((void *)lpStart,(size_t)(dwInFileSize/LINELEN),(size_t)LINELEN,Mycompare);

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);

  return;

} 
