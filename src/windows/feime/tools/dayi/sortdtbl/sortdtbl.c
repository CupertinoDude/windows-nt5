
/*************************************************
 *  sortdtbl.c                                   *
 *                                               *
 *  Copyright (C) 1999 Microsoft Inc.            *
 *                                               *
 *************************************************/

//
//  This file is used to sort Dayi Unicode Table.
//
//   the original file contains lots of lines, every line follows below format:
//        XXXXTCFRL
//    X:   Key Code,
//    T:   Tab,  0x0009
//    C:   Unicode for this Character
//    F:   Flag: L' 'or L'*'
//    R:   0x000D
//    L:   0x000A
//
//  we will sort this file on pattern which is generated by XXXX
//


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define  LINELEN   (9 * sizeof(WORD) )


const DWORD dwChar2SeqTbl[0x42] = {
    //  ' '   !     "     #     $     %     &     ' - char code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, // sequence code

    //  (     )     *     +     ,     -     .     /
        0x00, 0x00, 0x00, 0x00, 0x27, 0x33, 0x28, 0x29,

    //  0     1     2     3     4     5     6     7
        0x0A, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,

    //  8     9     :     ;     <     =     >     ?
        0x08, 0x09, 0x00, 0x1E, 0x00, 0x2F, 0x00, 0x00,

    //  @     A     B     C     D     E     F     G
        0x00, 0x15, 0x24, 0x22, 0x17, 0x0D, 0x18, 0x19,

    //  H     I     J     K     L     M     N     O
        0x1A, 0x12, 0x1B, 0x1C, 0x1D, 0x26, 0x25, 0x13,

    //  P     Q     R     S     T     U     V     W
        0x14, 0x0B, 0x0E, 0x16, 0x0F, 0x11, 0x23, 0x0C,

    //  X     Y     Z     [     \     ]     ^     _
        0x21, 0x10, 0x20, 0x31, 0x34, 0x32, 0x00, 0x00,

    //  `     a
        0x35, 0x00  };


DWORD  GetPattern( WORD  *pWord )
{
  int   i, j;
  DWORD dwPat, dwSeq;

  dwPat = 0;

  for (i=0; i<4; i++) {

      dwSeq = dwChar2SeqTbl[ pWord[i] - L' '];
      dwPat = (dwPat << 6)  + dwSeq;
  }

  return dwPat; 

}


int __cdecl Mycompare(const void *elem1, const void *elem2 )
{
  WORD  *pWord1, *pWord2;
  DWORD dwPatn1, dwPatn2;

  pWord1 = (WORD *)elem1;
  pWord2 = (WORD *)elem2;

 
  dwPatn1 = GetPattern(pWord1);
  dwPatn2 = GetPattern(pWord2);

  if ( dwPatn1 > dwPatn2 )  
     return 1;
  if ( dwPatn1 < dwPatn2 )  
     return -1;

// if the pattern is the same, just sort by uCode.

  if ( *(pWord1+5)  >  *(pWord2+5) )   return 1;
  if ( *(pWord1+5)  <  *(pWord2+5) )   return -1;
 
  return 0;

}

void  _cdecl main( int  argc,  TCHAR **argv) {

  HANDLE   hInFile;
  HANDLE   hInMap;
  LPBYTE   lpInFile, lpStart;
  DWORD    dwInFileSize; 

  if ( argc != 2 ) {
    printf("usage: sortdtbl UnicdeTableFile \n");
    return; 
  }


  hInFile = CreateFile(argv[1],          // pointer to name of the file
                       GENERIC_READ | GENERIC_WRITE, //access(read-write)mode
                       FILE_SHARE_READ | FILE_SHARE_WRITE,  // share mode
                       NULL,             // pointer to security attributes
                       OPEN_EXISTING,    // how to create
                       FILE_ATTRIBUTE_NORMAL,  // file attributes
                       NULL);    

  if ( hInFile == INVALID_HANDLE_VALUE )  return;

  dwInFileSize = GetFileSize(hInFile, NULL);

  dwInFileSize -= 2;
    
  hInMap = CreateFileMapping(hInFile,       // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READWRITE, // protection for mapping object
                             0,             // high-order 32 bits of object size
                             0,             // low-order 32 bits of object size
                             NULL);         // name of file-mapping object);
  if ( !hInMap ) {
    printf("hInMap is NULL\n");
    return;
  } 

  lpInFile = (LPBYTE) MapViewOfFile(hInMap, FILE_MAP_WRITE, 0, 0, 0);

  printf("dwInFileSize=%d ", dwInFileSize);

  lpStart = lpInFile + 2;  // skip UNICODE signature FEFF
  
  qsort((void *)lpStart,(size_t)(dwInFileSize/LINELEN),(size_t)LINELEN,Mycompare);

  UnmapViewOfFile(lpInFile);

  CloseHandle(hInMap);

  CloseHandle(hInFile);

  return;

} 
