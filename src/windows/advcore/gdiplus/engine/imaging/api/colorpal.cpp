/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   colorpal.cpp
*
* Abstract:
*
*   Color palette related functions
*
* Revision History:
*
*   05/17/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

//
// Default 1bpp color palette
//

#define MAKEPALENTRY(r, g, b) MAKEARGB(255, r, g, b)

struct
{
    UINT flags;
    UINT count;
    ARGB entries[2];
}
const Default1bppColorPalette =
{
    PALFLAG_GRAYSCALE,
    2,

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0xff, 0xff, 0xff)
};

//
// Default 4bpp color palette - VGA palette
//

struct
{
    UINT flags;
    UINT count;
    ARGB entries[16];
}
const Default4bppColorPalette =
{
    0,
    16,

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0x80, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x80, 0x00),
    MAKEPALENTRY(0x80, 0x80, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x80),
    MAKEPALENTRY(0x80, 0x00, 0x80),
    MAKEPALENTRY(0x00, 0x80, 0x80),
    MAKEPALENTRY(0x80, 0x80, 0x80),
    MAKEPALENTRY(0xC0, 0xC0, 0xC0),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF)
};

//
// Default 8bpp color palette
//

struct
{
    UINT flags;
    UINT count;
    ARGB entries[256];
}
const Default8bppColorPalette =
{
    PALFLAG_HALFTONE,
    256,

    MAKEPALENTRY(0x00, 0x00, 0x00),     // 16 VGA colors
    MAKEPALENTRY(0x80, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x80, 0x00),
    MAKEPALENTRY(0x80, 0x80, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x80),
    MAKEPALENTRY(0x80, 0x00, 0x80),
    MAKEPALENTRY(0x00, 0x80, 0x80),
    MAKEPALENTRY(0x80, 0x80, 0x80),
    MAKEPALENTRY(0xC0, 0xC0, 0xC0),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF),

    0,                                  // 24 unused entries
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,

    // !!! TODO
    //  Use simple 4x4 dither cell for now.
    //  Eventually should switch to Daniel's supercells.

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x33),
    MAKEPALENTRY(0x00, 0x00, 0x66),
    MAKEPALENTRY(0x00, 0x00, 0x99),
    MAKEPALENTRY(0x00, 0x00, 0xCC),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0x33, 0x00),
    MAKEPALENTRY(0x00, 0x33, 0x33),
    MAKEPALENTRY(0x00, 0x33, 0x66),
    MAKEPALENTRY(0x00, 0x33, 0x99),
    MAKEPALENTRY(0x00, 0x33, 0xCC),
    MAKEPALENTRY(0x00, 0x33, 0xFF),
    MAKEPALENTRY(0x00, 0x66, 0x00),
    MAKEPALENTRY(0x00, 0x66, 0x33),
    MAKEPALENTRY(0x00, 0x66, 0x66),
    MAKEPALENTRY(0x00, 0x66, 0x99),
    MAKEPALENTRY(0x00, 0x66, 0xCC),
    MAKEPALENTRY(0x00, 0x66, 0xFF),
    MAKEPALENTRY(0x00, 0x99, 0x00),
    MAKEPALENTRY(0x00, 0x99, 0x33),
    MAKEPALENTRY(0x00, 0x99, 0x66),
    MAKEPALENTRY(0x00, 0x99, 0x99),
    MAKEPALENTRY(0x00, 0x99, 0xCC),
    MAKEPALENTRY(0x00, 0x99, 0xFF),
    MAKEPALENTRY(0x00, 0xCC, 0x00),
    MAKEPALENTRY(0x00, 0xCC, 0x33),
    MAKEPALENTRY(0x00, 0xCC, 0x66),
    MAKEPALENTRY(0x00, 0xCC, 0x99),
    MAKEPALENTRY(0x00, 0xCC, 0xCC),
    MAKEPALENTRY(0x00, 0xCC, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x33),
    MAKEPALENTRY(0x00, 0xFF, 0x66),
    MAKEPALENTRY(0x00, 0xFF, 0x99),
    MAKEPALENTRY(0x00, 0xFF, 0xCC),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0x33, 0x00, 0x00),
    MAKEPALENTRY(0x33, 0x00, 0x33),
    MAKEPALENTRY(0x33, 0x00, 0x66),
    MAKEPALENTRY(0x33, 0x00, 0x99),
    MAKEPALENTRY(0x33, 0x00, 0xCC),
    MAKEPALENTRY(0x33, 0x00, 0xFF),
    MAKEPALENTRY(0x33, 0x33, 0x00),
    MAKEPALENTRY(0x33, 0x33, 0x33),
    MAKEPALENTRY(0x33, 0x33, 0x66),
    MAKEPALENTRY(0x33, 0x33, 0x99),
    MAKEPALENTRY(0x33, 0x33, 0xCC),
    MAKEPALENTRY(0x33, 0x33, 0xFF),
    MAKEPALENTRY(0x33, 0x66, 0x00),
    MAKEPALENTRY(0x33, 0x66, 0x33),
    MAKEPALENTRY(0x33, 0x66, 0x66),
    MAKEPALENTRY(0x33, 0x66, 0x99),
    MAKEPALENTRY(0x33, 0x66, 0xCC),
    MAKEPALENTRY(0x33, 0x66, 0xFF),
    MAKEPALENTRY(0x33, 0x99, 0x00),
    MAKEPALENTRY(0x33, 0x99, 0x33),
    MAKEPALENTRY(0x33, 0x99, 0x66),
    MAKEPALENTRY(0x33, 0x99, 0x99),
    MAKEPALENTRY(0x33, 0x99, 0xCC),
    MAKEPALENTRY(0x33, 0x99, 0xFF),
    MAKEPALENTRY(0x33, 0xCC, 0x00),
    MAKEPALENTRY(0x33, 0xCC, 0x33),
    MAKEPALENTRY(0x33, 0xCC, 0x66),
    MAKEPALENTRY(0x33, 0xCC, 0x99),
    MAKEPALENTRY(0x33, 0xCC, 0xCC),
    MAKEPALENTRY(0x33, 0xCC, 0xFF),
    MAKEPALENTRY(0x33, 0xFF, 0x00),
    MAKEPALENTRY(0x33, 0xFF, 0x33),
    MAKEPALENTRY(0x33, 0xFF, 0x66),
    MAKEPALENTRY(0x33, 0xFF, 0x99),
    MAKEPALENTRY(0x33, 0xFF, 0xCC),
    MAKEPALENTRY(0x33, 0xFF, 0xFF),
    MAKEPALENTRY(0x66, 0x00, 0x00),
    MAKEPALENTRY(0x66, 0x00, 0x33),
    MAKEPALENTRY(0x66, 0x00, 0x66),
    MAKEPALENTRY(0x66, 0x00, 0x99),
    MAKEPALENTRY(0x66, 0x00, 0xCC),
    MAKEPALENTRY(0x66, 0x00, 0xFF),
    MAKEPALENTRY(0x66, 0x33, 0x00),
    MAKEPALENTRY(0x66, 0x33, 0x33),
    MAKEPALENTRY(0x66, 0x33, 0x66),
    MAKEPALENTRY(0x66, 0x33, 0x99),
    MAKEPALENTRY(0x66, 0x33, 0xCC),
    MAKEPALENTRY(0x66, 0x33, 0xFF),
    MAKEPALENTRY(0x66, 0x66, 0x00),
    MAKEPALENTRY(0x66, 0x66, 0x33),
    MAKEPALENTRY(0x66, 0x66, 0x66),
    MAKEPALENTRY(0x66, 0x66, 0x99),
    MAKEPALENTRY(0x66, 0x66, 0xCC),
    MAKEPALENTRY(0x66, 0x66, 0xFF),
    MAKEPALENTRY(0x66, 0x99, 0x00),
    MAKEPALENTRY(0x66, 0x99, 0x33),
    MAKEPALENTRY(0x66, 0x99, 0x66),
    MAKEPALENTRY(0x66, 0x99, 0x99),
    MAKEPALENTRY(0x66, 0x99, 0xCC),
    MAKEPALENTRY(0x66, 0x99, 0xFF),
    MAKEPALENTRY(0x66, 0xCC, 0x00),
    MAKEPALENTRY(0x66, 0xCC, 0x33),
    MAKEPALENTRY(0x66, 0xCC, 0x66),
    MAKEPALENTRY(0x66, 0xCC, 0x99),
    MAKEPALENTRY(0x66, 0xCC, 0xCC),
    MAKEPALENTRY(0x66, 0xCC, 0xFF),
    MAKEPALENTRY(0x66, 0xFF, 0x00),
    MAKEPALENTRY(0x66, 0xFF, 0x33),
    MAKEPALENTRY(0x66, 0xFF, 0x66),
    MAKEPALENTRY(0x66, 0xFF, 0x99),
    MAKEPALENTRY(0x66, 0xFF, 0xCC),
    MAKEPALENTRY(0x66, 0xFF, 0xFF),
    MAKEPALENTRY(0x99, 0x00, 0x00),
    MAKEPALENTRY(0x99, 0x00, 0x33),
    MAKEPALENTRY(0x99, 0x00, 0x66),
    MAKEPALENTRY(0x99, 0x00, 0x99),
    MAKEPALENTRY(0x99, 0x00, 0xCC),
    MAKEPALENTRY(0x99, 0x00, 0xFF),
    MAKEPALENTRY(0x99, 0x33, 0x00),
    MAKEPALENTRY(0x99, 0x33, 0x33),
    MAKEPALENTRY(0x99, 0x33, 0x66),
    MAKEPALENTRY(0x99, 0x33, 0x99),
    MAKEPALENTRY(0x99, 0x33, 0xCC),
    MAKEPALENTRY(0x99, 0x33, 0xFF),
    MAKEPALENTRY(0x99, 0x66, 0x00),
    MAKEPALENTRY(0x99, 0x66, 0x33),
    MAKEPALENTRY(0x99, 0x66, 0x66),
    MAKEPALENTRY(0x99, 0x66, 0x99),
    MAKEPALENTRY(0x99, 0x66, 0xCC),
    MAKEPALENTRY(0x99, 0x66, 0xFF),
    MAKEPALENTRY(0x99, 0x99, 0x00),
    MAKEPALENTRY(0x99, 0x99, 0x33),
    MAKEPALENTRY(0x99, 0x99, 0x66),
    MAKEPALENTRY(0x99, 0x99, 0x99),
    MAKEPALENTRY(0x99, 0x99, 0xCC),
    MAKEPALENTRY(0x99, 0x99, 0xFF),
    MAKEPALENTRY(0x99, 0xCC, 0x00),
    MAKEPALENTRY(0x99, 0xCC, 0x33),
    MAKEPALENTRY(0x99, 0xCC, 0x66),
    MAKEPALENTRY(0x99, 0xCC, 0x99),
    MAKEPALENTRY(0x99, 0xCC, 0xCC),
    MAKEPALENTRY(0x99, 0xCC, 0xFF),
    MAKEPALENTRY(0x99, 0xFF, 0x00),
    MAKEPALENTRY(0x99, 0xFF, 0x33),
    MAKEPALENTRY(0x99, 0xFF, 0x66),
    MAKEPALENTRY(0x99, 0xFF, 0x99),
    MAKEPALENTRY(0x99, 0xFF, 0xCC),
    MAKEPALENTRY(0x99, 0xFF, 0xFF),
    MAKEPALENTRY(0xCC, 0x00, 0x00),
    MAKEPALENTRY(0xCC, 0x00, 0x33),
    MAKEPALENTRY(0xCC, 0x00, 0x66),
    MAKEPALENTRY(0xCC, 0x00, 0x99),
    MAKEPALENTRY(0xCC, 0x00, 0xCC),
    MAKEPALENTRY(0xCC, 0x00, 0xFF),
    MAKEPALENTRY(0xCC, 0x33, 0x00),
    MAKEPALENTRY(0xCC, 0x33, 0x33),
    MAKEPALENTRY(0xCC, 0x33, 0x66),
    MAKEPALENTRY(0xCC, 0x33, 0x99),
    MAKEPALENTRY(0xCC, 0x33, 0xCC),
    MAKEPALENTRY(0xCC, 0x33, 0xFF),
    MAKEPALENTRY(0xCC, 0x66, 0x00),
    MAKEPALENTRY(0xCC, 0x66, 0x33),
    MAKEPALENTRY(0xCC, 0x66, 0x66),
    MAKEPALENTRY(0xCC, 0x66, 0x99),
    MAKEPALENTRY(0xCC, 0x66, 0xCC),
    MAKEPALENTRY(0xCC, 0x66, 0xFF),
    MAKEPALENTRY(0xCC, 0x99, 0x00),
    MAKEPALENTRY(0xCC, 0x99, 0x33),
    MAKEPALENTRY(0xCC, 0x99, 0x66),
    MAKEPALENTRY(0xCC, 0x99, 0x99),
    MAKEPALENTRY(0xCC, 0x99, 0xCC),
    MAKEPALENTRY(0xCC, 0x99, 0xFF),
    MAKEPALENTRY(0xCC, 0xCC, 0x00),
    MAKEPALENTRY(0xCC, 0xCC, 0x33),
    MAKEPALENTRY(0xCC, 0xCC, 0x66),
    MAKEPALENTRY(0xCC, 0xCC, 0x99),
    MAKEPALENTRY(0xCC, 0xCC, 0xCC),
    MAKEPALENTRY(0xCC, 0xCC, 0xFF),
    MAKEPALENTRY(0xCC, 0xFF, 0x00),
    MAKEPALENTRY(0xCC, 0xFF, 0x33),
    MAKEPALENTRY(0xCC, 0xFF, 0x66),
    MAKEPALENTRY(0xCC, 0xFF, 0x99),
    MAKEPALENTRY(0xCC, 0xFF, 0xCC),
    MAKEPALENTRY(0xCC, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0xFF, 0x00, 0x33),
    MAKEPALENTRY(0xFF, 0x00, 0x66),
    MAKEPALENTRY(0xFF, 0x00, 0x99),
    MAKEPALENTRY(0xFF, 0x00, 0xCC),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x33, 0x00),
    MAKEPALENTRY(0xFF, 0x33, 0x33),
    MAKEPALENTRY(0xFF, 0x33, 0x66),
    MAKEPALENTRY(0xFF, 0x33, 0x99),
    MAKEPALENTRY(0xFF, 0x33, 0xCC),
    MAKEPALENTRY(0xFF, 0x33, 0xFF),
    MAKEPALENTRY(0xFF, 0x66, 0x00),
    MAKEPALENTRY(0xFF, 0x66, 0x33),
    MAKEPALENTRY(0xFF, 0x66, 0x66),
    MAKEPALENTRY(0xFF, 0x66, 0x99),
    MAKEPALENTRY(0xFF, 0x66, 0xCC),
    MAKEPALENTRY(0xFF, 0x66, 0xFF),
    MAKEPALENTRY(0xFF, 0x99, 0x00),
    MAKEPALENTRY(0xFF, 0x99, 0x33),
    MAKEPALENTRY(0xFF, 0x99, 0x66),
    MAKEPALENTRY(0xFF, 0x99, 0x99),
    MAKEPALENTRY(0xFF, 0x99, 0xCC),
    MAKEPALENTRY(0xFF, 0x99, 0xFF),
    MAKEPALENTRY(0xFF, 0xCC, 0x00),
    MAKEPALENTRY(0xFF, 0xCC, 0x33),
    MAKEPALENTRY(0xFF, 0xCC, 0x66),
    MAKEPALENTRY(0xFF, 0xCC, 0x99),
    MAKEPALENTRY(0xFF, 0xCC, 0xCC),
    MAKEPALENTRY(0xFF, 0xCC, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x33),
    MAKEPALENTRY(0xFF, 0xFF, 0x66),
    MAKEPALENTRY(0xFF, 0xFF, 0x99),
    MAKEPALENTRY(0xFF, 0xFF, 0xCC),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF)
};

/**************************************************************************\
*
* Function Description:
*
*   Get default color palette for the specified pixel format
*
* Arguments:
*
*   pixfmt - Specifies the pixel format
*       must be one of the indexed color formats
*
* Return Value:
*
*   Pointer to the requested default color palette
*
\**************************************************************************/

const ColorPalette*
GetDefaultColorPalette(
    PixelFormatID pixfmt
    )
{
    const ColorPalette* pal;

    switch (pixfmt)
    {
    case PIXFMT_1BPP_INDEXED:

        pal = (const ColorPalette*) &Default1bppColorPalette;
        break;

    case PIXFMT_4BPP_INDEXED:
        pal = (const ColorPalette*) &Default4bppColorPalette;
        break;

    case PIXFMT_8BPP_INDEXED:
        pal = (const ColorPalette*) &Default8bppColorPalette;
        break;

    default:
        RIP(("Invalid pixel format in GetDefaultColorPalette"));
        pal = NULL;
        break;
    }

    return pal;
}


/**************************************************************************\
*
* Function Description:
*
*   Make a copy of the specified color palette
*
* Arguments:
*
*   oldpal - Specifies the palette to be copied
*   useCoalloc - Use CoTaskMemAlloc or malloc to allocate memory?
*
* Return Value:
*
*   Pointer to the new copy of the palette
*   NULL if there is an error
*
\**************************************************************************/

ColorPalette*
CloneColorPalette(
    const ColorPalette* oldpal,
    BOOL useCoalloc
    )
{

    // Allocate memory for the new palette

    ColorPalette* newpal;
    UINT size;

    size = offsetof(ColorPalette, Entries) + oldpal->Count * sizeof(ARGB);
    newpal = (ColorPalette*) (useCoalloc ? GpCoAlloc(size) : GpMalloc(size));

    if (newpal != NULL)
    {
        // Copy the input palette contents

        memcpy(newpal, oldpal, size);
    }
    else
    {
        WARNING(("Out of memory in CloneColorPalette"));
    }

    return newpal;
}

/**************************************************************************\
*
* Function Description:
*
* Make a copy of the specified color palette, padding the end so that
* the result has the given number of entries.
*
* Arguments:
*
*   oldpal     - Specifies the palette to be copied
*   numEntries - The number of entries the new palette should have
*   fillColor  - The color to use for the extra entries (if any)
*
* Notes:
*
*   Doesn't handle shrinks. numEntries must be at least as much as the
*   number of entries in the original palette.
*
* Return Value:
*
*   Pointer to the new copy of the palette
*   NULL if there is an error
*
\**************************************************************************/

ColorPalette*
CloneColorPaletteResize(
    const ColorPalette* oldpal,
    UINT numEntries,
    ARGB fillColor
    )
{
    ASSERT(numEntries >= oldpal->Count);
    
    // Allocate memory for the new palette

    ColorPalette* newpal;
    UINT oldsize, newsize;

    oldsize = offsetof(ColorPalette, Entries) + oldpal->Count * sizeof(ARGB);
    newsize = oldsize + (numEntries - oldpal->Count) * sizeof(ARGB);
    
    newpal = static_cast<ColorPalette*>(GpMalloc(newsize));

    if (newpal != NULL)
    {
        // Copy the input palette contents

        memcpy(newpal, oldpal, oldsize);
        newpal->Count = numEntries;
        
        UINT i;
        ARGB *ptr = &(newpal->Entries[oldpal->Count]);
        
        for (i=oldpal->Count;i<numEntries;i++)
        {
            *ptr++ = fillColor;
        }
    }
    else
    {
        WARNING(("Out of memory in CloneColorPaletteResize"));
    }

    return newpal;
}


