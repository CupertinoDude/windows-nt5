//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------

import "objidl.idl";
import "shtypes.idl";
import "shobjidl.idl";
import "unknwn.idl";
import "wtypes.idl";
import "prsht.idl";
import "msxml.idl";

//
// Forward Declarations
//

interface IDispatch;

cpp_quote("#include <pshpack8.h>")


cpp_quote("#include <poppack.h>") /* Return to byte packing */



[
    helpstring("Interface to Customize Icons For Shell Objects"),
    uuid(7E23D323-36D6-4eb2-A654-387832868EA3),
    object,
]
interface ICustomIconManager : IUnknown
{
    HRESULT SetIcon([in, string] LPCWSTR pszIconPath, [in] int iIcon);
    HRESULT GetIcon([out, size_is(cch)] LPWSTR pszIconPath, [in] int cch, [out] int *piIconIndex);
    HRESULT GetDefaultIconHandle([out] HICON *phIcon);
    HRESULT SetDefaultIcon();
}

typedef [v1_enum] enum tagBNSTATE
{
    BNS_NORMAL = 0,         // Normal state that we are in
    BNS_BEGIN_NAVIGATE = 1, // A Begin navigate event has happened.
    BNS_NAVIGATE = 2        // A Navigate event has happened..."

} BNSTATE; // The navigate state..."

cpp_quote("#ifdef MIDL_PASS")
typedef DWORD RGBQUAD;
cpp_quote("#endif")

[
    uuid(4D4BE85C-9BF6-4218-999A-8EA489F08EF7),
    helpstring("Image List private interface for saving to a stream in a compatible manner."),
    local
]
interface IImageListPersistStream : IUnknown
{
    HRESULT LoadEx(DWORD dwFlags, IStream* pstm);
    HRESULT SaveEx(DWORD dwFlags, IStream* pstm);
};


[
    uuid(E94CC23B-0916-4ba6-93F4-AA52B5355EE8),
    helpstring("Image List private interface."),
    local
]
interface IImageListPriv : IUnknown
{
    HRESULT SetFlags(UINT flags);
    HRESULT GetFlags(UINT* pflags);
    HRESULT SetColorTable(int start, int len, RGBQUAD *prgb, int* pi);
    HRESULT GetPrivateGoo(HBITMAP* hbmp, HDC* hdc, HBITMAP* hbmpMask, HDC* hdcMask);
    HRESULT GetMirror(REFIID riid, PVOID* ppv);
    HRESULT CopyDitherImage( WORD iDst, int xDst, int yDst, IUnknown* punk, int iSrc, UINT fStyle);
};

[
    uuid(01e13875-2e58-4671-be46-59945432be6e),
    local
]
interface IMarkupCallback : IUnknown
{
    HRESULT GetState(UINT uState);
    HRESULT Notify(int nCode, int iLink);
    HRESULT InvalidateRect(RECT* prc);
    HRESULT OnCustomDraw(DWORD dwDrawStage, HDC hdc, const RECT *prc, DWORD dwItemSpec, UINT uItemState, LRESULT *pdwResult);
};

cpp_quote("#define MARKUPSIZE_CALCWIDTH         0   // calculates width without restriction")
cpp_quote("#define MARKUPSIZE_CALCHEIGHT        1   // prc->right contains max width")
cpp_quote("#define MARKUPLINKTEXT_URL           0   // get the URL")
cpp_quote("#define MARKUPLINKTEXT_ID            1   // get the id text associated with the url")
cpp_quote("#define MARKUPLINKTEXT_TEXT          2   // get the plain text associated with the url")
cpp_quote("#define MARKUPSTATE_FOCUSED          0x00000001")
cpp_quote("#define MARKUPSTATE_ENABLED          0x00000002")
cpp_quote("#define MARKUPSTATE_VISITED          0x00000004")
cpp_quote("#define MARKUPSTATE_ALLOWMARKUP      0x80000000")
cpp_quote("#define MARKUPMESSAGE_KEYEXECUTE     0")
cpp_quote("#define MARKUPMESSAGE_CLICKEXECUTE   1")
cpp_quote("#define MARKUPMESSAGE_WANTFOCUS      2")

typedef HANDLE HTHEME;

[
    uuid(50cf8c58-029d-41bf-b8dd-4ce4f95d9257),
    local
]
interface IControlMarkup : IUnknown
{
    HRESULT SetCallback(IUnknown* punk);
    HRESULT GetCallback(REFIID riid, [out, iid_is(riid)] void** ppvUnk);
    HRESULT SetFonts(HFONT hFont, HFONT hFontUnderline);
    HRESULT GetFonts(HFONT* phFont, HFONT* phFontUnderline);
    HRESULT SetText(LPCWSTR pwszText);
    HRESULT GetText(BOOL bRaw, LPWSTR pwszText, DWORD *pdwCch);
    HRESULT SetLinkText(int iLink, UINT uMarkupLinkText, LPCWSTR pwszText);
    HRESULT GetLinkText(int iLink, UINT uMarkupLinkText, LPWSTR pwszText, DWORD *pdwCch);
    HRESULT SetRenderFlags(UINT uDT);
    HRESULT GetRenderFlags(UINT *puDT, HTHEME *phTheme, int *piPartId, int *piStateIdNormal, int *piStateIdLink);
    HRESULT SetThemeRenderFlags(UINT uDT, HTHEME hTheme, int iPartId, int iStateIdNormal, int iStateIdLink);    
    HRESULT GetState(int iLink, UINT uStateMask, UINT* puState); 
    HRESULT SetState(int iLink, UINT uStateMask, UINT uState);  
        
    HRESULT DrawText(HDC hdcClient, LPCRECT prcClient);
    HRESULT SetLinkCursor();    
    HRESULT CalcIdealSize(HDC hdc, UINT uMarkUpCalc, RECT* prc);
    HRESULT SetFocus();
    HRESULT KillFocus();
    HRESULT IsTabbable();

    HRESULT OnButtonDown( POINT pt );
    HRESULT OnButtonUp( POINT pt);
    HRESULT OnKeyDown(UINT uVitKey);
    HRESULT HitTest(POINT pt, UINT* pidLink);

    // Reinsert this if you'd like to use it to conveniently process WM_BUTTONDOWN, 
    //  WM_BUTTONUP, WM_KEYDOWN messages. The "correct" way is to process these messages
    //  yourself and use OnButtonDown, OnButtonUp, OnKeyDown instead.
    //HRESULT HandleEvent(BOOL keys, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

interface IBasePropPage;
interface IAdvancedDialog;

cpp_quote("#if _WIN32_IE >= 0x0600")

cpp_quote("// INTERFACE: IThemeUIPages")
cpp_quote("// DESCRIPTION:")
cpp_quote("// This interface is used by all the pages in the Display Control Panel.  They allow the")
cpp_quote("// base pages (Theme, Background, ScreenSaver, Appearance, and Settings) to specify that")
cpp_quote("// they want to add pages to the Advanced Display Properties dialog. (Theme Settings, ")
cpp_quote("// Appearance, Web, and Effects)")
cpp_quote("// DisplayAdvancedDialog() will open the adv dialog.  When this object opens the dialog,")
cpp_quote("// it will add the appropriate pages, check when anyone's state gets dirty,")
cpp_quote("// and then merge the state from the advanced pages back into the base pages.")
cpp_quote("// This object will see if the IAdvancedDialog pages get dirty, and if one is and the")
cpp_quote("// user clicked OK instead of CANCEL, then it will use IAdvancedDialog::OnClose()")
cpp_quote("// to let the IAdvancedDialog object merge it's state into IBasePropPage.")
cpp_quote("// This object is used to allow desk.cpl, shell32.dll, and ThemeUI.dll control the dialog.")
cpp_quote("// ")
cpp_quote("// This object may implement IEnumUnknown to allow callers to access the list of IBasePropPage")
cpp_quote("// objects.  IPersist::GetClassID() should be used to identify one IBasePropPage object")
cpp_quote("// from another.  This is also true for IAdvancedDialog objects.")
cpp_quote("// ")
cpp_quote("// AddPage: This is used by desk.cpl to ask ThemeUI for the pages it wants to add to the base dlg.")
cpp_quote("//          This allows the pages to be put in a specific order.")
cpp_quote("// AddAdvancedPage: This is used by shell32.dll's Background tab to let ThemeUI know")
cpp_quote("//          that it wants to add a page to the advanced dialog (the Web tab).")
cpp_quote("// DisplayAdvancedDialog: This is used by any of the base pages to open the advanced page.")
cpp_quote("// ApplyPressed: Each page in the base dialog needs to call this method when they receive")
cpp_quote("//               PSN_APPLY.  This will allow the IThemeUIPages to notify every object")
cpp_quote("//               that the state should be applied, even if their dlgproc was never activated.")
cpp_quote("// ")
cpp_quote("// Values for nPageID in IThemeUIPages::AddPage()")
cpp_quote("#define PAGE_DISPLAY_THEMES        0")
cpp_quote("#define PAGE_DISPLAY_APPEARANCE    1")
cpp_quote("#define PAGE_DISPLAY_SETTINGS      2")
cpp_quote("// ")
cpp_quote("// Values for dwFlags in IThemeUIPages::ApplyPressed()")
cpp_quote("#define TUIAP_NONE                 0x00000000")
cpp_quote("#define TUIAP_CLOSE_DIALOG         0x00000001")
cpp_quote("#define TUIAP_WAITFORAPPLY         0x00000002")
cpp_quote("// Values for dwEM in IThemeUIPages::SetExecMode()")
cpp_quote("#define EM_NORMAL            0x00000001")
cpp_quote("#define EM_SETUP             0x00000002")
cpp_quote("#define EM_DETECT            0x00000003")
cpp_quote("#define EM_INVALID_MODE      0x00000004")
[
    uuid(7bba4934-ac4b-471c-a3e7-252c5ff3e8dd),
    helpstring("Theme UI property pages private interface."),
    local
]
interface IThemeUIPages : IUnknown
{
    HRESULT AddPage([in] LPFNSVADDPROPSHEETPAGE pfnAddPage, [in] LPARAM lParam, [in] long nPageID);
    HRESULT AddBasePage([in] IBasePropPage * pBasePage);
    HRESULT ApplyPressed([in] DWORD dwFlags);
    HRESULT GetBasePagesEnum([out] IEnumUnknown ** ppEnumUnknown);
    HRESULT UpdatePreview([in] DWORD dwFlags);
    HRESULT AddFakeSettingsPage([in] LPVOID pVoid);
    HRESULT SetExecMode([in] DWORD dwEM);
    HRESULT GetExecMode([out] DWORD* pdwEM);
    HRESULT LoadMonitorBitmap([in] BOOL fFillDesktop, [out] HBITMAP* phbmMon);
    HRESULT DisplaySaveSettings([in] PVOID pContext, [in] HWND hwnd, [out] int* piRet);
};


cpp_quote("// INTERFACE: IAdvancedDialog")
cpp_quote("// DESCRIPTION:")
cpp_quote("// ")
cpp_quote("// DisplayAdvancedDialog: Display the Advanced Dialog.")
cpp_quote("//          hwndParent: Parent the dialog on this hwnd.")
cpp_quote("//          pBasePage: Load the state from this propertybag.  Save the state here if OK is pressed.")
cpp_quote("//          pfEnableApply: Tell the parent dialog if they should enable the Apply button.")
[
    uuid(9DD92CA7-BF27-4fcb-AE95-1EAC48FC254D),
    helpstring("An advanced property page private negociation interface."),
    local
]
interface IAdvancedDialog : IUnknown
{
    HRESULT DisplayAdvancedDialog([in] HWND hwndParent, [in] IPropertyBag * pBasePage, [in] BOOL * pfEnableApply);
};


cpp_quote("// INTERFACE: IBasePropPage")
cpp_quote("// DESCRIPTION:")
cpp_quote("//     This interface is implemented by IShellPropSheetExt objects which want to add pages to")
cpp_quote("// the advanced dialog.  When one of the base dialog pages clicks on a button that")
cpp_quote("// should open the advanced dialog, IThemeUIPages::DisplayAdvancedDialog() will call")
cpp_quote("// each object's IBasePropPage::GetAdvancedPage() method.  The base page will then")
cpp_quote("// create an IAdvancedDialog object to add the advanced pages and track the state.  If the")
cpp_quote("// advanced dlg clicks OK, then the state should move back into the IBasePropPage")
cpp_quote("// object, via IAdvancedDialog::OnClose(, pBasePropPage).  Then the base dlg object can")
cpp_quote("// persist the state when the dialog receives an OK or APPLY command.")
cpp_quote("// This object may want to implement IObjectWithSite so it can get a IUnknown pointer to")
cpp_quote("// the IThemeUIPages object.  This will allow this object's base pages to open the")
cpp_quote("// advanced dialog via IBasePropPage::GetAdvancedPage().")
cpp_quote("// ")
cpp_quote("// GetAdvancedPage: The callee will create the IAdvancedDialog object and return it.")
cpp_quote("//          Note that the state may be dirty if the user already opened and closed the")
cpp_quote("//          advanced dialog without clicking Apply.")
cpp_quote("// OnClose: The page will be called when the base dialog is closing.  This will allow")
cpp_quote("//          the object to persist it's state.")

typedef [
helpstring("Constants that define the OnApply action")
] enum tagPropPageOnApply
{  
    PPOAACTION_CANCEL, // = 0
    PPOAACTION_OK, // = 1
    PPOAACTION_APPLY  // = 2
} PROPPAGEONAPPLY; 

[
    uuid(B34E525B-9EB4-433b-8E0F-019C4F21D7E7),
    helpstring("A base property page private negociation interface."),
    local
]
interface IBasePropPage : IShellPropSheetExt
{
    HRESULT GetAdvancedDialog([out] IAdvancedDialog ** ppAdvDialog);
    HRESULT OnApply([in] PROPPAGEONAPPLY oaAction);
};


cpp_quote("// INTERFACE: IPreviewSystemMetrics")
cpp_quote("// DESCRIPTION:")
cpp_quote("// This object will allow the negociation with a preview of the system metrics.")
[
    uuid(FC0A77D2-2ADF-4ede-A885-523A3A74A145),
    helpstring("This object will allow the negociation with a preview of the system metrics."),
    local
]
interface IPreviewSystemMetrics : IUnknown
{
    HRESULT RefreshColors(void);
    HRESULT UpdateDPIchange(void);
    HRESULT UpdateCharsetChanges(void);
    HRESULT DeskSetCurrentScheme([in, string] LPCWSTR pwzSchemeName);
};

cpp_quote("#define SZ_PBPROP_SCREENSAVER_PATH           TEXT(\"ScreenSaver_Path\")")
cpp_quote("#define SZ_PBPROP_BACKGROUND_PATH            TEXT(\"Background_Path\")")
cpp_quote("#define SZ_PBPROP_BACKGROUNDSRC_PATH         TEXT(\"BackgroundSrc_Path\")                    // The source path of the background.  This is before it was converted to a .bmp.")
cpp_quote("#define SZ_PBPROP_BACKGROUND_TILE            TEXT(\"Background_TILE\")                       // VT_UI4 with WPSTYLE_ flags from WALLPAPEROPT in IActiveDesktop::SetWallpaperOptions()")
cpp_quote("#define SZ_PBPROP_VISUALSTYLE_PATH           TEXT(\"VisualStyle_Path\")                      // VT_BSTR with the visual style path (.mstheme file)")
cpp_quote("#define SZ_PBPROP_VISUALSTYLE_COLOR          TEXT(\"VisualStyle_Color\")                     // VT_BSTR with the visual style Color Style")
cpp_quote("#define SZ_PBPROP_VISUALSTYLE_SIZE           TEXT(\"VisualStyle_Size\")                      // VT_BSTR with the visual style size")
cpp_quote("#define SZ_PBPROP_SYSTEM_METRICS             TEXT(\"SystemMetrics\")                         // VT_BYREF byref pointer to SYSTEMMETRICSALL")
cpp_quote("#define SZ_PBPROP_PREVIEW1                   TEXT(\"Preview1\")                              // VT_UNKNOWN to object w/IThemePreview")
cpp_quote("#define SZ_PBPROP_PREVIEW2                   TEXT(\"Preview2\")                              // VT_UNKNOWN to object w/IThemePreview")
cpp_quote("#define SZ_PBPROP_PREVIEW3                   TEXT(\"Preview3\")                              // VT_UNKNOWN to object w/IThemePreview")
cpp_quote("#define SZ_PBPROP_CUSTOMIZE_THEME            TEXT(\"Theme_CustomizeTheme\")                  // VT_EMPTY. Used to indicate that the theme settings have changed")
cpp_quote("#define SZ_PBPROP_WEBCOMPONENTS              TEXT(\"WebComponents\")                         // VT_UNKNOWN. Get or Set the IActiveDesktop interface containing the ActiveDesktop components")
cpp_quote("#define SZ_PBPROP_OPENADVANCEDDLG            TEXT(\"OpenAdvancedDialog\")                    // VT_BOOL. Tells the IPropertyBag to open the Advanced dialog when opening.  If read, this indicates if the base dialog should go away when the Adv dlg closes.")
cpp_quote("#define SZ_PBPROP_BACKGROUND_COLOR           TEXT(\"BackgroundColor\")                       // VT_UI4. Get or set the COLORREF (RGB) color for the background system metric.")
cpp_quote("#define SZ_PBPROP_THEME_LAUNCHTHEME          TEXT(\"ThemeLaunchTheme\")                      // VT_LPWSTR. This will be the path to the .theme file to open.")
cpp_quote("#define SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME   TEXT(\"AppearanceLaunchMSTheme\")               // VT_LPWSTR. This will be the path to the .mstheme file to open.")
cpp_quote("#define SZ_PBPROP_PREOPEN                    TEXT(\"PreOpen\")                               // VARIANT is NULL. This is sent right before the dialog opens.")
cpp_quote("#define SZ_PBPROP_DPI_MODIFIED_VALUE         TEXT(\"Settings_DPIModifiedValue\")             // VT_I4 specifying the currently modified DPI")
cpp_quote("#define SZ_PBPROP_DPI_APPLIED_VALUE          TEXT(\"Settings_DPIAppliedValue\")              // VT_I4 specifying the currently applied DPI")



cpp_quote("// Display Control Panel flags to specify an opening page.")
cpp_quote("// You can launch \"rundll32.exe shell32.dll,Control_RunDLL desk.cpl ,@Settings\" ")
cpp_quote("// which will launch the Display CPL to the Settings tab.")
cpp_quote("// These names are canonical so they will work on all languages.  The tab order")
cpp_quote("// will change when admin policies are applied or when the OS revs the UI and")
cpp_quote("// these names will always work.")
cpp_quote("#define SZ_DISPLAYCPL_OPENTO_THEMES            TEXT(\"Themes\")              // Themes tab")
cpp_quote("#define SZ_DISPLAYCPL_OPENTO_DESKTOP           TEXT(\"Desktop\")             // Desktop tab")
cpp_quote("#define SZ_DISPLAYCPL_OPENTO_SCREENSAVER       TEXT(\"ScreenSaver\")         // Screen Saver tab")
cpp_quote("#define SZ_DISPLAYCPL_OPENTO_APPEARANCE        TEXT(\"Appearance\")          // Appearance tab")
cpp_quote("#define SZ_DISPLAYCPL_OPENTO_SETTINGS          TEXT(\"Settings\")            // Settings tab")


cpp_quote("#endif // _WIN32_IE >= 0x0600")

//
//  SHAssocEnumHandlers returns an IEnumAssocHandlers object.
//
[
    helpstring("Enumerate handlers"),
    uuid(973810ad-9599-4b88-9e4d-6ee98c9552da),
    object,
    pointer_default(unique),
    local
]
interface IAssocHandler : IUnknown
{
    HRESULT GetName([string, out] LPWSTR *ppsz);
    HRESULT GetUIName([string, out] LPWSTR *ppsz);
    HRESULT GetIconLocation([string, out]LPWSTR *ppszPath, int *pIndex);
    HRESULT IsRecommended();
    HRESULT MakeDefault([in, string] LPCWSTR pszDescription);
    HRESULT Exec([in] HWND hwnd, [in, string] LPCWSTR pszFile);
    //  CHEATING here, need to move CMINVOKECOMMANDINFOEX into shtypes.idl
    HRESULT Invoke([in] void *pici, [in, string] LPCWSTR pszFile);
};
    
[
    helpstring("Enumerate handlers"),
    uuid(973810ae-9599-4b88-9e4d-6ee98c9552da),
    object,
    pointer_default(unique),
    local
]
interface IEnumAssocHandlers : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] IAssocHandler **rgelt,
        [out] ULONG *pceltFetched);
        
//    HRESULT Skip([in] ULONG celt);
//    HRESULT Reset();
//    HRESULT Clone([out] IEnumAssocHandlers **ppEnumHandlers);
};

//-------------------------------------------------------------------------
//
// Hardware Event interfaces
//
//-------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
//
[
    object,
    uuid(99BC7510-0A96-43fa-8BB1-C928A0302EFB),
    helpstring("Hardware Event Device Info Interface"),
    pointer_default(unique)
]
interface IHWDevice : IUnknown
{
    HRESULT Init([in, string] LPCWSTR pszDeviceID);

    HRESULT AutoplayHandler([in, string] LPCWSTR pszEventType,
        [in, string] LPCWSTR pszHandler);
};

cpp_quote("#define HWDEVCUSTOMPROP_USEVOLUMEPROCESSING      0x00000001")

[
    object,
    uuid(77D5D69C-D6CE-4026-B625-26964EEC733F),
    helpstring("HW Device Custom Properties"),
    pointer_default(unique)
]
interface IHWDeviceCustomProperties : IUnknown
{
    HRESULT InitFromDeviceID([in, string] LPCWSTR pszDeviceID, [in] DWORD dwFlags);
    HRESULT InitFromDevNode([in, string] LPCWSTR pszDevNode, [in] DWORD dwFlags);

    HRESULT GetDWORDProperty([in, string] LPCWSTR pszPropName, 
        [out] DWORD* pdwProp);

    // Will not retrieve REG_MULTI_SZ values
    HRESULT GetStringProperty([in, string] LPCWSTR pszPropName, 
        [out, string] LPWSTR* ppszProp);

    // Will not retrieve REG_SZ values
    // The MultiSz string is in ppblob->asData
    HRESULT GetMultiStringProperty([in, string] LPCWSTR pszPropName,
        [in] BOOL fMergeMultiSz, [out] WORD_BLOB** ppblob);

    HRESULT GetBlobProperty([in, string] LPCWSTR pszPropName,
        [out] BYTE_BLOB** ppblob);
};

///////////////////////////////////////////////////////////////////////////////
//
[
    object,
    uuid(66057ABA-FFDB-4077-998E-7F131C3F8157),
    helpstring("Autoplay Handler Enumerator Interface"),
    pointer_default(unique)
]
interface IEnumAutoplayHandler : IUnknown
{
    HRESULT Next([out, string] LPWSTR* ppszHandler,
        [out, string] LPWSTR* ppszAction,
        [out, string] LPWSTR* ppszProvider,
        [out, string] LPWSTR* ppszIconLocation);
};

///////////////////////////////////////////////////////////////////////////////
//
// We want to make sure not to use 0x1 as it is S_FALSE
cpp_quote("#define HANDLERDEFAULT_USERCHOSENDEFAULT                0x00000002")
cpp_quote("#define HANDLERDEFAULT_EVENTHANDLERDEFAULT              0x00000004")
cpp_quote("#define HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED      0x00000008")
cpp_quote("#define HANDLERDEFAULT_DEFAULTSAREDIFFERENT             0x00000010")

cpp_quote("#define HANDLERDEFAULT_MAKERETURNVALUE(a) MAKE_HRESULT(0, FACILITY_ITF, (a))")
cpp_quote("#define HANDLERDEFAULT_GETFLAGS(a) HRESULT_CODE((a))")

[
    object,
    uuid(335E9E5D-37FC-4d73-8BA8-FD4E16B28134),
    helpstring("Autoplay Handler Interface"),
    pointer_default(unique)
]
interface IAutoplayHandler : IUnknown
{
    HRESULT Init([in, string] LPCWSTR pszDeviceID,
        [in, string] LPCWSTR pszEventType);
    HRESULT InitWithContent([in, string] LPCWSTR pszDeviceID,
        [in, string] LPCWSTR pszEventType,
        [in, string] LPCWSTR pszContentTypeHandler);

    HRESULT EnumHandlers([out] IEnumAutoplayHandler** ppenum);

    // Will return other S_* success codes than S_OK and S_FALSE.
    HRESULT GetDefaultHandler([out, string] LPWSTR* ppszHandler);
    HRESULT SetDefaultHandler([in, string] LPCWSTR pszHandler);
};

///////////////////////////////////////////////////////////////////////////////
//
[
    object,
    uuid(557730F6-41FA-4d11-B9FD-F88AB155347F),
    helpstring("Autoplay Handler Properties Interface"),
    pointer_default(unique)
]
interface IAutoplayHandlerProperties : IUnknown
{
    HRESULT Init([in, string] LPCWSTR pszHandler);

    HRESULT GetInvokeProgIDAndVerb([out, string] LPWSTR* ppszInvokeProgID,
        [out, string] LPWSTR* ppszInvokeVerb);
};

///////////////////////////////////////////////////////////////////////////////
//
cpp_quote("#include <pshpack8.h>")

typedef struct tagVOLUMEINFO
{
    DWORD dwState;                      // State of volume 
    LPWSTR pszDeviceIDVolume;           // \\?\STORAGE#Volume#...{...GUID...}
    LPWSTR pszVolumeGUID;               // \\?\Volume{...GUID...}
    DWORD dwVolumeFlags;                // see HWDVF_... flags
    DWORD dwDriveType;                  // see HWDT_... flags
    DWORD dwDriveCapability;            // see HWDDC_... flags
    LPWSTR pszLabel;                    
    LPWSTR pszFileSystem;               
    DWORD dwFileSystemFlags;            
    DWORD dwMaxFileNameLen;             
    DWORD dwRootAttributes;             
    DWORD dwSerialNumber;               // 
    DWORD dwDriveState;                 // see HWDDS_...; 
    DWORD dwMediaState;                 // see HWDMS_...; 
    DWORD dwMediaCap;                   // see HWDMC_...; 
    LPWSTR pszAutorunIconLocation;      // Autorun IconLocation from autorun.inf 
    LPWSTR pszAutorunLabel;             // Autorun Label from autorun.inf 
    LPWSTR pszIconLocationFromService;  // Icon location from Custom Properties
    LPWSTR pszNoMediaIconLocationFromService;  // Icon location from Custom Properties
    LPWSTR pszLabelFromService;         // Label from Custom Properties
} VOLUMEINFO;

typedef struct tagVOLUMEINFO2
{
    DWORD cbSize;

    WCHAR szDeviceIDVolume[200];
    WCHAR szVolumeGUID[50];
    WCHAR szLabel[33];
    WCHAR szFileSystem[30];

    DWORD dwState;
    DWORD dwVolumeFlags;
    DWORD dwDriveType;
    DWORD dwDriveCapability;
    DWORD dwFileSystemFlags;
    DWORD dwMaxFileNameLen;
    DWORD dwRootAttributes;
    DWORD dwSerialNumber;
    DWORD dwDriveState;
    DWORD dwMediaState;
    DWORD dwMediaCap;
    DWORD oAutorunIconLocation;
    DWORD oAutorunLabel;
    DWORD oIconLocationFromService;
    DWORD oNoMediaIconLocationFromService;
    DWORD oLabelFromService;

    WCHAR szOptionalStrings[1];
} VOLUMEINFO2;

typedef struct tagHWDEVICEINFO
{
    DWORD cbSize;

    WCHAR szDeviceIntfID[200];
    GUID  guidInterface;

    DWORD dwState;
    DWORD dwDeviceFlags;
} HWDEVICEINFO;

cpp_quote("#define SHHARDWAREEVENT_VOLUMEARRIVED            0x00000001")
cpp_quote("#define SHHARDWAREEVENT_VOLUMEUPDATED            0x00000002")
cpp_quote("#define SHHARDWAREEVENT_VOLUMEREMOVED            0x00000004")
cpp_quote("#define SHHARDWAREEVENT_MOUNTPOINTARRIVED        0x00000008")
cpp_quote("#define SHHARDWAREEVENT_MOUNTPOINTREMOVED        0x00000010")
cpp_quote("#define SHHARDWAREEVENT_DEVICEARRIVED            0x00000020")
cpp_quote("#define SHHARDWAREEVENT_DEVICEUPDATED            0x00000040")
cpp_quote("#define SHHARDWAREEVENT_DEVICEREMOVED            0x00000080")
cpp_quote("#define SHHARDWAREEVENT_VOLUMEMOUNTED            0x00000100")
cpp_quote("#define SHHARDWAREEVENT_VOLUMEDISMOUNTED         0x00000200")
//  dont use these escaped misnames..
cpp_quote("#define SHHARDWAREEVENT_MOUNTDEVICEARRIVED       0x00000020 // is really DEVICEARRIVED")
cpp_quote("#define SHHARDWAREEVENT_MOUNTDEVICEUPDATED       0x00000040 // is really DEVICEUPDATED")
cpp_quote("#define SHHARDWAREEVENT_MOUNTDEVICEREMOVED       0x00000080 // is really DEVICEREMOVED")

cpp_quote("#define MAX_FILESYSNAME         30")
cpp_quote("#define MAX_LABEL_NTFS           32  // not including the NULL")
cpp_quote("#define MAX_LABEL               MAX_LABEL_NTFS + 1")
cpp_quote("#define MAX_ICONLOCATION           MAX_PATH + 12 // + 12 for comma and index")
cpp_quote("#define MAX_VOLUMEINFO2 (sizeof(VOLUMEINFO2) + (4 * MAX_ICONLOCATION + 1 * MAX_LABEL) * sizeof(WCHAR))")

typedef struct tagSHHARDWAREEVENT
{
    DWORD   cbSize;
    DWORD   dwEvent;
    BYTE    rgbPayLoad[1];
} SHHARDWAREEVENT;

typedef struct tagMTPTADDED
{
    WCHAR szMountPoint[260/*MAX_PATH*/];
    WCHAR szDeviceIDVolume[200/*MAX_DEVICEID*/];
} MTPTADDED;

cpp_quote("#include <poppack.h>") /* Return to byte packing */

// All this information comes from the HW.  No information that is not HW
//     related should be added to this.

// Media State
cpp_quote("#define HWDMS_PRESENT                                 0x10000000")
cpp_quote("#define HWDMS_FORMATTED                               0x20000000")
//cpp_quote("#define HWDMS_WRITEPROTECTED_SUPPORTDETECTION         0x40000000")
//cpp_quote("#define HWDMS_WRITEPROTECTED                          0x80000000")

// Media Capabilities
cpp_quote("#define HWDMC_WRITECAPABILITY_SUPPORTDETECTION        0x00000001")
cpp_quote("#define HWDMC_CDROM                                   0x00000002")
cpp_quote("#define HWDMC_CDRECORDABLE                            0x00000004")
cpp_quote("#define HWDMC_CDREWRITABLE                            0x00000008")
cpp_quote("#define HWDMC_DVDROM                                  0x00000010")
cpp_quote("#define HWDMC_DVDRECORDABLE                           0x00000020")
cpp_quote("#define HWDMC_DVDREWRITABLE                           0x00000040")
cpp_quote("#define HWDMC_DVDRAM                                  0x00000080")
cpp_quote("#define HWDMC_ANALOGAUDIOOUT                          0x00000100")

cpp_quote("#define HWDMC_RANDOMWRITE                             0x00001000")

cpp_quote("#define HWDMC_HASAUTORUNINF                           0x00002000")
cpp_quote("#define HWDMC_HASAUTORUNCOMMAND                       0x00004000")
cpp_quote("#define HWDMC_HASDESKTOPINI                           0x00008000")
cpp_quote("#define HWDMC_HASDVDMOVIE                             0x00010000")
cpp_quote("#define HWDMC_HASAUDIOTRACKS                          0x00020000")
cpp_quote("#define HWDMC_HASDATATRACKS                           0x00040000")
cpp_quote("#define HWDMC_HASAUDIOTRACKS_UNDETERMINED             0x00080000")
cpp_quote("#define HWDMC_HASDATATRACKS_UNDETERMINED              0x00100000")
cpp_quote("#define HWDMC_HASUSEAUTOPLAY                          0x00200000")

cpp_quote("#define HWDMC_CDTYPEMASK                              (HWDMC_CDROM | HWDMC_CDRECORDABLE | HWDMC_CDREWRITABLE | HWDMC_DVDROM | HWDMC_DVDRECORDABLE | HWDMC_DVDREWRITABLE | HWDMC_DVDRAM)")

// Drive State
//cpp_quote("#define HWDDS_PRESENT_SUPPORTDETECTION                0x10000000")
//cpp_quote("#define HWDDS_PRESENT                                 0x20000000")
//cpp_quote("#define HWDDS_SLEEPING_SUPPORTDETECTION               0x40000000")
//cpp_quote("#define HWDDS_SLEEPING                                0x80000000")

// Drive Capabilities
cpp_quote("#define HWDDC_CAPABILITY_SUPPORTDETECTION             HWDMC_WRITECAPABILITY_SUPPORTDETECTION ")
cpp_quote("#define HWDDC_CDROM                                   HWDMC_CDROM                            ")
cpp_quote("#define HWDDC_CDRECORDABLE                            HWDMC_CDRECORDABLE                     ")
cpp_quote("#define HWDDC_CDREWRITABLE                            HWDMC_CDREWRITABLE                     ")
cpp_quote("#define HWDDC_DVDROM                                  HWDMC_DVDROM                           ")
cpp_quote("#define HWDDC_DVDRECORDABLE                           HWDMC_DVDRECORDABLE                    ")
cpp_quote("#define HWDDC_DVDREWRITABLE                           HWDMC_DVDREWRITABLE                    ")
cpp_quote("#define HWDDC_DVDRAM                                  HWDMC_DVDRAM                           ")
cpp_quote("#define HWDDC_ANALOGAUDIOOUT                          HWDMC_ANALOGAUDIOOUT                   ")

cpp_quote("#define HWDDC_RANDOMWRITE                             HWDMC_RANDOMWRITE")
cpp_quote("#define HWDDC_NOSOFTEJECT                             0x00002000")
cpp_quote("#define HWDDC_FLOPPYSOFTEJECT                         0x00004000")
cpp_quote("#define HWDDC_REMOVABLEDEVICE                         0x00008000")

cpp_quote("#define HWDDC_CDTYPEMASK                              HWDMC_CDTYPEMASK")

// Volume flags
cpp_quote("#define HWDVF_STATE_SUPPORTNOTIFICATION               0x00000001")
cpp_quote("#define HWDVF_STATE_ACCESSDENIED                      0x00000002")
cpp_quote("#define HWDVF_STATE_DISMOUNTED                        0x00000004")
cpp_quote("#define HWDVF_STATE_HASAUTOPLAYHANDLER                0x00000008")
cpp_quote("#define HWDVF_STATE_DONOTSNIFFCONTENT                 0x00000010")
cpp_quote("#define HWDVF_STATE_JUSTDOCKED                        0x00000020")

// Drive Type
// Watch out not to have these conflict with capabilities reporting
cpp_quote("#define HWDTS_FLOPPY35                                0x00000001")
cpp_quote("#define HWDTS_FLOPPY525                               0x00000002")
cpp_quote("#define HWDTS_REMOVABLEDISK                           0x00000004")
cpp_quote("#define HWDTS_FIXEDDISK                               0x00000008")
cpp_quote("#define HWDTS_CDROM                                   0x00000010")

// Device Flags
cpp_quote("#define HWDDF_HASDEVICEHANDLER                        0x00000001")
cpp_quote("#define HWDDF_HASDEVICEHANDLER_UNDETERMINED           0x00000002")
cpp_quote("#define HWDDF_REMOVABLEDEVICE                         0x00000004")
cpp_quote("#define HWDDF_REMOVABLEDEVICE_UNDETERMINED            0x00000008")

[
    object,
    uuid(99B732C2-9B7B-4145-83A4-C45DF791FD99),
    helpstring("Hardware Device Callback Interface"),
    pointer_default(unique)
]
interface IHardwareDeviceCallback : IUnknown
{
    HRESULT VolumeAddedOrUpdated(
        [in] BOOL fAdded,                        // TRUE: Added, FALSE: Updated
        [in] VOLUMEINFO* pvolinfo);

    HRESULT VolumeRemoved([in, string] LPCWSTR pszDeviceIDVolume);

    HRESULT MountPointAdded(
        [in, string] LPCWSTR pszMountPoint,     // "c:\", or "d:\MountFolder\"
        [in, string] LPCWSTR pszDeviceIDVolume);// \\?\STORAGE#Volume#...{...GUID...}

    HRESULT MountPointRemoved([in, string] LPCWSTR pszMountPoint);

    HRESULT DeviceAdded([in, string] LPCWSTR pszDeviceID,
        [in] GUID guidDeviceID);

    HRESULT DeviceUpdated([in, string] LPCWSTR pszDeviceID);

    HRESULT DeviceRemoved([in, string] LPCWSTR pszDeviceID);
};

[
    object,
    uuid(553A4A55-681C-440e-B109-597B9219CFB2),
    helpstring("Hardware Device Enumerator"),
    pointer_default(unique)
]
interface IHardwareDevicesEnum : IUnknown
{
    HRESULT Next(
        [out, string] LPWSTR* ppszDeviceID,
        [out] GUID* pguidDeviceID);
};

[
    object,
    uuid(3342BDE1-50AF-4c5d-9A19-DABD01848DAE),
    helpstring("Hardware Device Volumes Enumerator"),
    pointer_default(unique)
]
interface IHardwareDevicesVolumesEnum : IUnknown
{
    HRESULT Next([out] VOLUMEINFO* pvolinfo);
};

[
    object,
    uuid(EE93D145-9B4E-480c-8385-1E8119A6F7B2),
    helpstring("Hardware Device MountPoints Enumerator"),
    pointer_default(unique)
]
interface IHardwareDevicesMountPointsEnum : IUnknown
{
    HRESULT Next(
        [out, string] LPWSTR* ppszMountPoint,     // "c:\", or "d:\MountFolder\"
        [out, string] LPWSTR* ppszDeviceIDVolume);// \\?\STORAGE#Volume#...{...GUID...}
};

// HWDEV: HardWareDevice EnumVolume
cpp_quote("#define HWDEV_GETCUSTOMPROPERTIES                 0x000000001")

[
    object,
    uuid(CC271F08-E1DD-49bf-87CC-CD6DCF3F3D9F),
    helpstring("Hardware Device Interface"),
    pointer_default(unique)
]
interface IHardwareDevices : IUnknown
{
    HRESULT EnumVolumes([in] DWORD dwFlags, [out] IHardwareDevicesVolumesEnum** ppenum);
    HRESULT EnumMountPoints([out] IHardwareDevicesMountPointsEnum** ppenum);
    HRESULT EnumDevices([out] IHardwareDevicesEnum** ppenum);

    HRESULT Advise([in] DWORD dwProcessID,
        [in] ULONG_PTR hThread, [in] ULONG_PTR pfctCallback, [out] DWORD* pdwToken);

    HRESULT Unadvise([in] DWORD dwToken);
};





[
    uuid(ec35e37a-6579-4f3c-93cd-6e62c4ef7636),
    local
]
interface IStartMenuPin : IUnknown
{

cpp_quote("#define SMPIN_POS(i) (LPCITEMIDLIST)MAKEINTRESOURCE((i)+1)")
cpp_quote("#define SMPINNABLE_EXEONLY          0x00000001") // allow only EXEs to be pinned
cpp_quote("#define SMPINNABLE_REJECTSLOWMEDIA  0x00000002") // reject slow media

    HRESULT EnumObjects([out] IEnumIDList **ppenumIDList);
    //
    //  Pin:        pidlFrom = NULL, pidlTo = pidl
    //  Unpin:      pidlFrom = pidl, pidlTo = NULL
    //  Update:     pidlFrom = old,  pidlTo = new
    //  Move:       pidlFrom = pidl, pidlTo = SMPINPOS(iPos)
    HRESULT Modify(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo);

    HRESULT GetChangeCount([out] ULONG *pulOut);

    //
    //  pdto = data object to test
    //  dwFlags is an SMPINNABLE_* flag
    //  *ppidl receives pidl being pinned
    //
    HRESULT IsPinnable([in] IDataObject *pdto,
                       [in] DWORD dwFlags,
                       [optional,out] LPITEMIDLIST *ppidl); // S_FALSE if not

    //
    //  Find the pidl on the pin list and resolve the shortcut that
    //  tracks it.
    //
    //  Returns S_OK if the pidl changed and was resolved.
    //  Returns S_FALSE if the pidl did not change.
    //  Returns an error if the Resolve failed.
    //
    HRESULT Resolve([in] HWND hwnd, DWORD dwFlags, [in] LPCITEMIDLIST pidl, [out] LPITEMIDLIST *ppidlResolved);
}

cpp_quote("#if _WIN32_IE >= 0x0600")

typedef struct tagCATLIST
{
    const GUID* pguid;
    const SHCOLUMNID* pscid;
} CATLIST;


[
    uuid(509767BF-AC06-49f8-9E76-8BBC17F0EE93),
    local
]
interface IDefCategoryProvider : IUnknown
{
    HRESULT Initialize(const GUID* pguid,               // Default GUID to group by
                       const SHCOLUMNID* pscid,         // Default SCID to group by
                       const SHCOLUMNID* pscidExclude,  // array of SHCOLUMNIDs to exlude. Terminated by GUID_NULL
                       HKEY hkey,                       // The registry key to add categorizers from (Close key after call)
                       const CATLIST* pcl,              // an array of CATLIST entries terminated by a NULL entry
                       IShellFolder* psf);              // The shell folder that implements IShellFolder2 to group. Needs to implement IPersistFolder2
}

cpp_quote("#define MB_STATE_TRACK 1")
cpp_quote("#define MB_STATE_MENU  2")
cpp_quote("#define MB_STATE_ITEM  4")

[
    uuid(b6664df7-0c46-460e-ba97-82ed46d0289e),
    local
]
interface IInitAccessible : IUnknown
{
    HRESULT InitAcc([in] int iState, [in] IMenuBand *pmb, [in] int iIndex, [in] HMENU hmenu, [in] WORD wID);
};

[
    uuid(4a7efa30-795c-4167-8676-b78fc5330cc7),
    local
]
interface IInitTrackPopupBar : IUnknown
{
    HRESULT InitTrackPopupBar([in] void* pvContext, [in] int iID, [in] HMENU hmenu, [in] HWND hwnd);
};

//   ICompositeFolder::InitComposite
//       initializes a composite folder with the information necessary to aggregate
//       the child folders

typedef [v1_enum] enum _CFITYPE
{
    CFITYPE_CSIDL   = 0,    // Use COMPFOLDERINIT.csidl
    CFITYPE_PIDL,           // Use COMPFOLDERINIT.pidl
    CFITYPE_PATH,           // Use COMPFOLDERINIT.pszPath
} CFITYPE;

[v1_enum] enum 
{
    CFINITF_CHILDREN    = 0x0000,   //  each composite folder will show up as a child
    CFINITF_FLAT        = 0x0001,   //  each folder's children show up flat together
};

typedef UINT CFINITF;

typedef struct _COMPFOLDERINIT 
{
    UINT uType;
    [switch_type(UINT), switch_is(uType)] union 
    {
    [case(CFITYPE_CSIDL)]   int csidl;     
    [case(CFITYPE_PIDL)]    LPCITEMIDLIST pidl;
    [case(CFITYPE_PATH)]    [string] LPOLESTR pszPath;
    } DUMMYUNIONNAME;
    LPOLESTR pszName;
} COMPFOLDERINIT;

[
    helpstring("ICompositeFolder"),
    uuid(601ac3dd-786a-4eb0-bf40-ee3521e70bfb),  // IID_ICompositeFolder
    object,
    pointer_default(unique)
]
interface ICompositeFolder : IUnknown
{
    HRESULT InitComposite(
        [in] WORD wSignature, 
        [in] REFCLSID refclsid, 
        [in] CFINITF flags,
        [in] ULONG celt, 
        [in, size_is(celt)] const COMPFOLDERINIT *rgCFs);

    HRESULT BindToParent(
        [in] LPCITEMIDLIST pidl,
        [in] REFIID riid, 
        [out, iid_is(riid)] void **ppv,
        [out] LPITEMIDLIST *ppidlLast);
};

cpp_quote("#endif // _WIN32_IE >= 0x0600")

cpp_quote("#include <pshpack8.h>")

typedef struct _tagSHELLREMINDER
{
    DWORD  cbSize;
    LPWSTR pszName;
    LPWSTR pszTitle;
    LPWSTR pszText;
    LPWSTR pszTooltip;
    LPWSTR pszIconResource;
    LPWSTR pszShellExecute;
    GUID*  pclsid;
    DWORD  dwShowTime;
    DWORD  dwRetryInterval;
    DWORD  dwRetryCount;
    DWORD  dwTypeFlags;
} SHELLREMINDER;

cpp_quote("#include <poppack.h>")

[
    uuid(6c6d9735-2d86-40e1-b348-08706b9908c0),     // IID_IEnumShellReminder
    local
]
interface IEnumShellReminder : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] SHELLREMINDER** rgelt,
        [out] ULONG *pceltFetched);
        
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumShellReminder **ppesr);
};

[
    uuid(968edb91-8a70-4930-8332-5f15838a64f9),     // IID_IShellReminderManager
    local
]
interface IShellReminderManager : IUnknown
{
    HRESULT Add(const SHELLREMINDER* psr);
    HRESULT Delete(LPCWSTR pszName);
    HRESULT Enum(IEnumShellReminder** ppesr);
};

cpp_quote("#if _WIN32_IE >= 0x0400")

[
    object,
    uuid(5dd6b79a-3ab7-49c0-ab82-6b2da7d78d75)
]
interface IDeskBandEx : IUnknown
{
    HRESULT MoveBand();
};

cpp_quote("#endif // _WIN32_IE >= 0x0400")

cpp_quote("#include <pshpack8.h>")

typedef struct tagNOTIFYITEM
{
    LPWSTR      pszExeName;
    LPWSTR      pszIconText;
    HICON       hIcon;
    HWND        hWnd;
    DWORD       dwUserPref;
    UINT        uID;
    GUID        guidItem;
} NOTIFYITEM, *LPNOTIFYITEM;

cpp_quote("#include <poppack.h>")

[
    object,
    uuid(d782ccba-afb0-43f1-94db-fda3779eaccb),     // IID_INotificationCB
    pointer_default(unique)
]
interface INotificationCB : IUnknown
{
    HRESULT Notify([in] DWORD dwMessage, [in] LPNOTIFYITEM pNotifyItem);
};

[
    object,
    uuid(fb852b2c-6bad-4605-9551-f15f87830935),     // IID_ITrayNotify
    pointer_default(unique)
]
interface ITrayNotify : IUnknown
{
    HRESULT RegisterCallback([in] INotificationCB* pNotifyCB);
    HRESULT SetPreference([in] LPNOTIFYITEM pNotifyItem);
    HRESULT EnableAutoTray([in] BOOL bTraySetting);
};

[
    uuid(3037B6E1-0B58-4c34-AA63-A958D2A4413D),
    local
]
interface IMagic : IUnknown
{
    enum
    {
        MAGIC_ALIGN_BOTTOMLEFT      = 0x00000001,
        MAGIC_ALIGN_BOTTOMRIGHT     = 0x00000002,
        MAGIC_ALIGN_TOPLEFT         = 0x00000003,
        MAGIC_ALIGN_TOPRIGHT        = 0x00000004,
        MAGIC_ALIGN_CENTER          = 0x00000005,
    };
    typedef DWORD MAGIC_ALIGN;

    [helpstring("Plays an animation (Alpha specified in uId + 1) for each frame in interval. The bitmap is divided by frames to get the size")]
    HRESULT Illusion(HMODULE hmod, UINT uId, UINT cFrames, UINT interval, MAGIC_ALIGN align, RECT rc);

    HRESULT BlinkFrom(HDC hdcFrom, RECT* rc);
    HRESULT BlinkMove(RECT* rc);
    HRESULT BlinkTo(HDC hdcTo, UINT cFrames);
}

// a resouce map object defines via XML the mapping of canonical IDs for resources
// to the resources that should be loaded for controls.  
//
// a client will CoCreate this object, and call IPersistFile::Load to specify the URL
// to a XML file which contains the mapping.  then whe the client is read to start
// mapping resources they do the following:
//
//      // from the resource map, pick up the defn for a wizard with the id 'WebPublishing'
//      LoadResourceMap(L"wizard", L"WebPublishing");     
//
//      // load the caption resource from that defn
//      LoadString(NULL, L"caption"), szBuffer, ARRAYSIZE(szBuffer))
//
// resources can also be scoped on a particular sub-resource (eg. a dialog in a particular
// map).   this is achived by selecting a scope for the resources, eg:
//
//      // select the dialog 'welcome' from the current resource map
//      IXMLDOMNode *pdn;
//      hr = SelectResourceScope(L"dialog", L"welcome", &pdn);
//      if (SUCCEEDED(hr))
//      {
//          // load the caption string
//          LoadString(pdn, L"caption", szBuffer, ARRAYSIZE(szBuffer))
//      }

[
    uuid(9c50a798-5d90-4130-83da-38da83456711),
    helpstring("Resource Mapping Object"),
    local 
]
interface IResourceMap : IUnknown
{
    HRESULT LoadResourceMap([in, string] LPCWSTR pszResourceClass, [in, string] LPCWSTR pszID);
    HRESULT SelectResourceScope([in, string] LPCWSTR pszResourceType, [in, string] LPCWSTR pszID, [in, out] IXMLDOMNode **ppdnScope);
    HRESULT LoadString([in] IXMLDOMNode *pdnScope, [in, string] LPCWSTR pszID, [in, out] LPWSTR pszBuffer, [in] int cch);
    HRESULT LoadBitmap([in] IXMLDOMNode *pdnScope, [in, string] LPCWSTR pszID, [in, out] HBITMAP *pbm);
};

cpp_quote("#define SID_ResourceMap IID_IResourceMap")


cpp_quote("#define HNET_SHARECONNECTION     0x00000001")
cpp_quote("#define HNET_FIREWALLCONNECTION  0x00000002")
cpp_quote("#define HNET_SHAREPRINTERS       0x00000004")
cpp_quote("#define HNET_SETCOMPUTERNAME     0x00000008")
cpp_quote("#define HNET_SETWORKGROUPNAME    0x00000010")
cpp_quote("#define HNET_SHAREFOLDERS        0x00000020")
cpp_quote("#define HNET_BRIDGEPRIVATE       0x00000040")
cpp_quote("#define HNET_ICSCLIENT           0x00000080      // Only on W9x")
cpp_quote("#define HNET_LOG                 0x80000000      // Output results to a log file before configuring homenet (TODO)")

[
    object,
    uuid(543c4fa4-52dd-421a-947a-4d7f92b8860a),     // IID_IHomeNetworkWizard
    pointer_default(unique)
]
interface IHomeNetworkWizard : IUnknown
{
    HRESULT ConfigureSilently(LPCWSTR pszPublicConnection, DWORD hnetFlags, BOOL* pfRebootRequired);
    HRESULT ShowWizard(HWND hwndParent, BOOL* pfRebootRequired);
};




[
    helpstring("Shell Namespace enumerator"),
    uuid(70629033-e363-4a28-a567-0db78006e6d7),
    object,
    pointer_default(unique)
]
interface IEnumShellItems : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] IShellItem **rgelt,
        [out] ULONG *pceltFetched);
        
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumShellItems **ppenum);
};

[
    helpstring("IParentAndItem"),
    uuid(b3a4b685-b685-4805-99d9-5dead2873236),  // IID_IParentAndItem
    object,
    pointer_default(unique)
]
interface IParentAndItem : IUnknown
{
    // 2 ways to init
    //      pidlParent == NULL
    //      psf is folder, pidlChild is child relative to psf
    HRESULT SetParentAndItem([in] LPCITEMIDLIST pidlParent, [in] IShellFolder *psf,  [in] LPCITEMIDLIST pidlChild);
    // all params optional
    //      ppidlParent gets full pidl to parent of item
    //      ppsf gets parent folder for item
    //      ppidlChild gets item relitve to psf
    HRESULT GetParentAndItem([out] LPITEMIDLIST *ppidlParent, [out] IShellFolder **ppsf, [out] LPITEMIDLIST *ppidlChild);
};

//  BindHandler GUIDs for IShellItemArray::BindToHandler (defined in shlguid.h)")
//  BHID_DataObject           Ask shellItemArray for its Dataobject")

[
    helpstring("Shell Item Container"),
    uuid(787F8E92-9837-4011-9F83-7DE593BDC002),
    object,
    pointer_default(unique)
]
interface IShellItemArray : IUnknown
{
    typedef [v1_enum] enum
    {
        SIATTRIBFLAGS_AND               = 0x00000001, // if multiple items and the attirbutes together.
        SIATTRIBFLAGS_OR                = 0x00000002, // if multiple items or the attributes together.
        SIATTRIBFLAGS_APPCOMPAT         = 0x00000003, // Call GetAttributes directly on the ShellFolder for multiple attributes

        SIATTRIBFLAGS_MASK              = 0x00000003,    
    } SIATTRIBFLAGS;

    HRESULT BindToHandler(
        [in] IBindCtx *pbc, 
        [in] REFGUID rbhid,
        [in] REFIID riid, 
        [out, iid_is(riid)] void **ppvOut);

    HRESULT GetAttributes(
        [in] SIATTRIBFLAGS dwAttribFlags,
        [in] SFGAOF sfgaoMask, 
        [out] SFGAOF *psfgaoAttribs);

    HRESULT GetCount(
        [out] DWORD *pdwNumItems);

    HRESULT GetItemAt(
        [in] DWORD dwIndex,
        [out] IShellItem **ppsi);

    HRESULT EnumItems(
        [out] IEnumShellItems **ppenumShellItems);
};


[
    uuid(198a5f2d-e19f-49ea-9033-c975e0f376ec),
    object,
]
interface IItemHandler : IPersist
{
    HRESULT SetItem(IShellItem *psi);
    HRESULT GetItem(IShellItem **ppsi);
};

[
    helpstring("IShellFolderNames"),
    uuid(6cd8f9cc-dfe7-48f2-a60a-3831e26af734),
    object,
    pointer_default(unique)
]
interface IShellFolderNames : IUnknown
{
    [v1_enum] enum
    {
        SIPDNF_FROMEDITING          = 0x00000001,
    };
    typedef UINT SIPDNF;
    
    HRESULT ParseIncremental(
        [in] SIPDNF flags,
        [in, string] LPCOLESTR pszName,
        [in] IBindCtx *pbc, 
        [out] LPITEMIDLIST *ppidl,
        [out] UINT *pcchNext);

    HRESULT GetDisplayName(
        [in] LPCITEMIDLIST pidl,
        [in] SIGDN sigdnName, 
        [out, string] LPOLESTR *ppszName);
};

[
    helpstring("IFolderItemsView"),
    uuid(0be044ca-f8a3-49b8-bdb2-5f5319e9de89),
    object,
    pointer_default(unique)
]
interface IFolderItemsView : IUnknown
{
    HRESULT GetCurrentViewMode([out] UINT *pViewMode);
    HRESULT SetCurrentViewMode([in] UINT ViewMode);

    HRESULT GetFolder([in] REFIID riid, [out, iid_is(riid)] void **ppv);
    HRESULT GetFolderItem([out] IShellItem **ppsiFolder);

    HRESULT ItemCount([in] UINT *pcItems);
    HRESULT EnumItems([out] IEnumShellItems **ppenum);

    HRESULT SelectedItemCount([out] UINT *pcSelected);
    HRESULT EnumSelectedItems([out] IEnumShellItems **ppenum);
    
    //  view index based methods
    HRESULT Item([in] int iViewIndex, [out] IShellItem **ppsi);
    HRESULT ItemIndex([in] IShellItem *psi, [out] int *piViewIndex);

    // uses IShellView, SVSI_ flags
    HRESULT SelectItem([in] int iViewIndex, [in] SVSIF svsif);
    // index of item with SVSI_SELECTIONMARK
    HRESULT SelectionMark([in] int *piViewIndex);
};


[
    helpstring("Assist legacy applications to use IShellItem"),
    uuid(679d9e36-f8f9-11d2-8deb-00c04f6837d5),
    object,
]
interface ILocalCopy : IUnknown
{
//  flags for ILocalCopy methods")
//  LCDOWN_READONLY            read only helper, Upload() fails with E_ACCESSDENIED")
//  LCDOWN_SAVEAS              write only helper, no download required for Download()")
//  LC_FORCEROUNDTRIP          never use local cache (always roundtrip both Upload() and Download())")
    enum
    {
        LCDOWN_READONLY     = 0x00000001,
        LC_SAVEAS           = 0x00000002,
        LC_FORCEROUNDTRIP   = 0x00000010,
    };

    typedef DWORD LCFLAGS;

    HRESULT Download([in] LCFLAGS flags, [in] IBindCtx *pbc, [out, string] LPWSTR *ppszPath);
    HRESULT Upload([in] LCFLAGS flags, [in] IBindCtx *pbc);
};


[
    uuid(985F64F0-D410-4E02-BE22-DA07F2B5C5E1),
    object,
    pointer_default(unique)
]
interface IDefViewFrame3 : IUnknown
{
    // for borrowing/returning the listview
    HRESULT GetWindowLV(HWND * phwnd);
    HRESULT ShowHideListView(); // must call before returning from function that called GetWindowLV2!!!
    HRESULT OnResizeListView();
    HRESULT ReleaseWindowLV();

    // to help with context menu operations on the listview
    HRESULT DoRename(); // REVIEW: needs QueryRename() and needs to be on a different interface (IContextMenuUIHelper? has to be able to be a different object than IContextMenuSite...)
};



cpp_quote("#define DS_BACKUPDISPLAYCPL  0x00000001")

[
    uuid(610d76de-7861-4715-9d08-b6e297c3985b),
    helpstring("For enumerating and displaying display settings"),
    local
]
interface IDisplaySettings : IUnknown
{
    HRESULT SetMonitor([in] DWORD dwMonitor);
    HRESULT GetModeCount([out] DWORD* pdwCount, [in] BOOL fOnlyPreferredModes);
    HRESULT GetMode([in] DWORD dwMode, [in] BOOL fOnlyPreferredModes, [out] DWORD* pdwWidth, [out] DWORD* pdwHeight, [out] DWORD* pdwColor);
    HRESULT SetSelectedMode([in] HWND hwnd, [in] DWORD dwWidth, [in] DWORD dwHeight, [in] DWORD dwColor, [out] BOOL* pfApplied, [in] DWORD dwFlags);
    HRESULT GetSelectedMode([out] DWORD* pdwWidth, [out] DWORD* pdwHeight, [out] DWORD* pdwColor);
    HRESULT GetAttached([out] BOOL* pfAttached);
    HRESULT SetPruningMode([in] BOOL fIsPruningOn);
    HRESULT GetPruningMode([out] BOOL* pfCanBePruned, [out] BOOL* pfIsPruningReadOnly, [out] BOOL* pfIsPruningOn);
};

[
    uuid(b80df3d8-82db-4e8d-8097-8c2c0e746470),
    helpstring("For getting around IDLs default interface requirement"),
    local
]
interface IScreenResFixer : IUnknown
{
};

typedef struct tagTREEWALKERSTATS {
    int nFiles;                 // number of files we have seen
    int nFolders;               // number of folders we have seen (does not include the root)
    int nDepth;                 // the current depth
    DWORD dwClusterSize;        // cluster size of the disk we are currently on
    ULONGLONG ulTotalSize;      // total size of all files we have seen
    ULONGLONG ulActualSize;     // total size on disk of all files, taking into account compression, sparse files, and cluster slop
} TREEWALKERSTATS;

// All callbacks receives fully-qualified paths to the item found, being
// entered, being left, etc.
//
// Return values for all methods:
// S_OK    -- Normal, continue processing files, skip the problem file in error case
// S_FALSE -- Conitnue but quit the current directory
// E_NOTIMPL -- same as S_OK
// E_* -- Stop right away.

[
    uuid(95CE8411-7027-11D1-B879-006008059382),
    helpstring("The callback interface for IShellTreeWalker"),
]
interface IShellTreeWalkerCallBack : IUnknown
{
    HRESULT FoundFile([in, string] LPCWSTR pwszPath, [in] TREEWALKERSTATS *ptws, [in] WIN32_FIND_DATAW * pwfd);
    HRESULT EnterFolder([in, string] LPCWSTR pwszPath, [in] TREEWALKERSTATS *ptws, [in] WIN32_FIND_DATAW * pwfd);
    HRESULT LeaveFolder([in, string] LPCWSTR pwszPath, [in] TREEWALKERSTATS *ptws);
    HRESULT HandleError([in, string] LPCWSTR pwszPath, [in] TREEWALKERSTATS *ptws, [in] HRESULT hrError);
};

[
    uuid(95CE8410-7027-11D1-B879-006008059382),
    helpstring("The common File System tree traversal interface in shell"),
]
interface IShellTreeWalker : IUnknown
{
    enum
    {
        WT_FOLDERFIRST          = 0x00000001, // default to files first
        WT_MAXDEPTH             = 0x00000002, // specify the maximum depth we go into
        WT_FOLDERONLY           = 0x00000004, // only walks directories: default is to only return files
        WT_NOTIFYFOLDERENTER    = 0x00000008, // notifies whenever entering a folder :default is to notify on every file
        WT_NOTIFYFOLDERLEAVE    = 0x00000010, // notifies whenever leaving a folder
        WT_GOINTOREPARSEPOINT   = 0x00000020, // default is to stop at any reparse points
        WT_EXCLUDEWALKROOT      = 0x00000040, // default is to EnterFolder the starting point
        WT_ALL                  = 0x0000007F, // ;internal
    };

    typedef DWORD STWFLAGS;
    // dwFlags      -- search flags: details above
    // pwszWalkRoot -- the root directory to start from
    // pwszWalkSpec -- the spec used to match files
    // iMaxDepth    -- maximum depth to go into
    // pstwcb       -- pointer to the callback interface
    //
    // Return Value:
    // S_OK -- succeeded
    // E_*  -- failed

    HRESULT WalkTree([in] DWORD dwFlags, [in, string] LPCWSTR pwszWalkRoot, [in, string] LPCWSTR pwszWalkSpec, [in] int iMaxPath, [in] IShellTreeWalkerCallBack * pstwcb);
};



cpp_quote("_inline void FreeIDListArray(LPITEMIDLIST *ppidls, UINT cItems)")
cpp_quote("{                                        ")
cpp_quote("     UINT i;                             ")
cpp_quote("     for (i = 0; i < cItems; i++)        ")
cpp_quote("     {                                   ")
cpp_quote("         CoTaskMemFree(ppidls[i]);       ")
cpp_quote("     }                                   ")
cpp_quote("     CoTaskMemFree(ppidls);              ")
cpp_quote("}                                        ")



[
    uuid(EC6FE84F-DC14-4FBB-889F-EA50FE27FE0F),
    pointer_default(unique)
]
interface IUIElement : IUnknown
{
    HRESULT get_Name([in] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszName);
    HRESULT get_Icon([in] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszIcon); // we support icon resource strings like: "shell32,-123" 
    HRESULT get_Tooltip([in] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszInfotip);
};

typedef enum tagUISTATE
{
    UIS_ENABLED  = 0,
    UIS_DISABLED = 1,
    UIS_HIDDEN   = 2
} UISTATE;

[
    uuid(4026DFB9-7691-4142-B71C-DCF08EA4DD9C),
    pointer_default(unique)
]
interface IUICommand : IUIElement
{
    HRESULT get_CanonicalName([out] GUID* pguidCommandName);
    HRESULT get_State([in] IShellItemArray *psiItemArray, [in] BOOL fOkToBeSlow, [out] UISTATE* puisState);
    HRESULT Invoke([in] IShellItemArray *psiItemArray, [in, optional] IBindCtx *pbc);
};

[
    uuid(869447DA-9F84-4E2A-B92D-00642DC8A911),
    pointer_default(unique)
]
interface IEnumUICommand : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] IUICommand** pUICommand, [out] ULONG *pceltFetched);
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumUICommand **ppenum);
};

[
    uuid(2CB95001-FC47-4064-89B3-328F2FE60F44),
    pointer_default(unique)
]
interface IUICommandTarget : IUnknown
{
    HRESULT get_Name([in] REFGUID guidCanonicalName, [in] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszName);
    HRESULT get_Icon([in] REFGUID guidCanonicalName, [in] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszIcon); // we support icon resource strings like: "shell32,-123" 
    HRESULT get_Tooltip([in] REFGUID guidCanonicalName, [in] IShellItemArray *psiItemArray, [out, string] LPWSTR *ppszInfotip);
    HRESULT get_State([in] REFGUID guidCanonicalName, [in] IShellItemArray *psiItemArray, [out] UISTATE* puisState);
    HRESULT Invoke([in] REFGUID guidCanonicalName, [in] IShellItemArray *psiItemArray, [in, optional] IBindCtx *pbc);
};


interface ITransferDest;

typedef GUID STGTRANSCONFIRMATION, *LPSTGTRANSCONFIRMATION;

// Custom Confirmation
//
// Contains the information required to display a custom confirmation. In addition
// to this information, data about the item as obtained from the STATSTG structure
// can also be used.


typedef struct tagCUSTOMCONFIRMATION
{
    DWORD   cbSize;                 // sizeof this structure
    DWORD   dwFlags;                // CCF_*flags to controll what is displayed
    DWORD   dwButtons;              // CCB_*value that determines what options are valid responses
    LPWSTR  pwszTitle;              // The title of this confirmation, for example what would be used as a dialog title.
    LPWSTR  pwszDescription;        // The description of problem being confirmed
    HICON   hicon;                  // OPTIONAL. If provided, the icon is displayed as an indication of what type of operation is being confirmed
    LPWSTR  pwszAdvancedDetails;    // OPTIONAL. If provided, contains further details about what is being confirmed.
} CUSTOMCONFIRMATION, *LPCUSTOMCONFIRMATION;


// Implementing this interface implies that your storage is filesystem
// based. If the source and destination are both filesystem based then
// moves and copies can be done using win32 filesystem APIs.

[
    object,
    uuid(E820910B-1910-404D-AFAF-5D7298B9B28D),
    helpstring("IFileSystemStorage"),
    pointer_default(unique)
]
interface IFileSystemStorage : IUnknown
{
    // Returns the full filesystem path to the stogage
    HRESULT GetPath([out] WCHAR *pszName, [in] DWORD cch);
    HRESULT GetAttributes([in, string] const WCHAR *pszName, [in] DWORD dwMask, [out] DWORD *pdwAttribs);
};


//-------------------------------------------------------------------------
//
// IStorageProcessor interface
//
//
// [Member functions]
//
// IStorageProcessor::Run(pstgSrc, pstgDest, dwOperation, dwOptions)
//    Launches an operation on the specified storage(s).
//
//-------------------------------------------------------------------------

// Storage operation tags.                                        

typedef [v1_enum] enum tagSTGOP
{
    STGOP_MOVE               = 1,
    STGOP_COPY               = 2,
    STGOP_SYNC               = 3,
    STGOP_DIFF               = 4,
    STGOP_REMOVE             = 5,
    STGOP_RENAME             = 6,
    STGOP_STATS              = 7,
    STGOP_COPY_PREFERHARDLINK = 8,
} STGOP, *LPSTGOP;

// Options governing the overall operation

typedef [v1_enum] enum tagSTGPROCOPTIONS
{
    STOPT_ROOTONLY           = 0x00000004,  // Operation applies only and directly to the root
    STOPT_NOCONFIRMATIONS    = 0x00000008,  // No confirmations at all
    STOPT_NOPROGRESSUI       = 0x00000010,  // No default progress UI
    STOPT_NOSTATS            = 0x00000020, // no stats calculations
} STGPROCOPTIONS, *LPSTGPROCOPTIONS;


// dynamic storage object, used for collecting items before passing to the storage
// transfer engine.

[
    helpstring("Interface to in-memory bundle PIDLs, IStreams, IStorages"),
    uuid(c7bfc3d0-8939-4d9d-8973-654099329956),
    object,
]
interface IDynamicStorage : IUnknown
{
    typedef [v1_enum] enum
    {
        DSTGF_NONE          = 0x0,
        DSTGF_ALLOWDUP      = 0x1,
    } DSTGF;

    HRESULT AddIDList([in] DWORD cpidl, [in, size_is(cpidl)] LPITEMIDLIST* rgpidl, DSTGF dstgf);
    HRESULT BindToItem([in, string] LPCWSTR pwszName, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
    HRESULT EnumItems([out] IEnumShellItems **ppesi);
};

//-------------------------------------------------------------------------
//
// ITransferAdviseSink interface
//
//-------------------------------------------------------------------------

// ITransferAdviseSink response codes

cpp_quote("#define STRESPONSE_CONTINUE               S_OK")
cpp_quote("#define STRESPONSE_RENAME                 MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 20)")
cpp_quote("#define STRESPONSE_SKIP                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 21)")
cpp_quote("#define STRESPONSE_CANCEL                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 22)")
cpp_quote("#define STRESPONSE_RETRY                  HRESULT_FROM_WIN32(ERROR_RETRY)")

[
    object,
    uuid(D082C196-A2B2-41ff-A5E5-80EFF91B7D79),
    helpstring("ITransferAdviseSink"),
    pointer_default(unique)
]
interface ITransferAdviseSink : IQueryContinue
{
    // Before an operation such as a copy, move, or delete is about
    // to be performed the storage will advise the sink via this method.

    HRESULT PreOperation (     [in] const STGOP          op,
                               [in] IShellItem           *psiItem,
                               [in] IShellItem           *psiDest);

    // When the storage believes that user confirmation or acknowledgement
    // is required, it asks the advise to seek it via this method.
    // pwszItem is [in,out] non-const because rename can massage the name.

    HRESULT ConfirmOperation(  [in] IShellItem               *psiItem,
                               [in] IShellItem               *psiDest,
                               [in] STGTRANSCONFIRMATION     stc, 
                               [in, unique] LPCUSTOMCONFIRMATION pcc);

    // As the operation (copy, move, etc) proceeds the storage calls
    // this method on the sink.  There is no guarantee of service but
    // intervals of one second between updates are ideal.

    HRESULT OperationProgress( [in]  const STGOP            op,
                               [in]  IShellItem             *psiItem,
                               [in]  IShellItem             *psiDest,
                               [in]  ULONGLONG              ulTotal,
                               [in]  ULONGLONG              ulComplete);

    // When an operation is complete or if it is aborted the storage advises 
    // the sink via this method and provides the final status (S_OK, failure, 
    // etc) of the task.  Certain operations can provide extra information
    // describing the results, such as when a file is renamed on a copy collision.

    HRESULT PostOperation(     [in]  const STGOP            op,
                               [in]  IShellItem             *psiItem,
                               [in]  IShellItem             *psiDest,
                               [in]  HRESULT                hrResult);
}


//-------------------------------------------------------------------------
//
// ITransferDest interface
//
//-------------------------------------------------------------------------

cpp_quote("#define STGX_MOVE_MOVE           0x00000000")
cpp_quote("#define STGX_MOVE_COPY           0x00000001")
cpp_quote("#define STGX_MOVE_ONLYIFEXISTS   0x00000002   // Only perform if target already exists")
cpp_quote("#define STGX_MOVE_ATOMIC         0x00000004   // Operation must be immediate, all-or-nothing.  If a storage must be walked and each sub-element moved/copied that is not atomic, but if the entire storage can be moved/copied in one step that is atomic.  If a move must be done as a seperate copy and a delete that is not atomic.")
cpp_quote("#define STGX_MOVE_TESTONLY       0x00000008   // Test whether operation is valid only, do not perform.  Useful in testing for ATOMIC before trying an operation.")
cpp_quote("#define STGX_MOVE_NORECURSION    0x00000010   // When moving/copying storages, do not move/copy their contents")
cpp_quote("#define STGX_MOVE_FORCE          0x00001000")
cpp_quote("#define STGX_MOVE_PREFERHARDLINK 0x00002000   // default to hard linking instead of a full file copy/move")

typedef DWORD STGXMOVE;

cpp_quote("#define STGX_MODE_READ               0x00000000L")
cpp_quote("#define STGX_MODE_WRITE              0x00000001L")
cpp_quote("#define STGX_MODE_READWRITE          0x00000002L")
cpp_quote("#define STGX_MODE_ACCESSMASK         0x0000000FL")

cpp_quote("#define STGX_MODE_SHARE_DENY_NONE    0x00000040L")
cpp_quote("#define STGX_MODE_SHARE_DENY_READ    0x00000030L")
cpp_quote("#define STGX_MODE_SHARE_DENY_WRITE   0x00000020L")
cpp_quote("#define STGX_MODE_SHARE_EXCLUSIVE    0x00000010L")
cpp_quote("#define STGX_MODE_SHAREMASK          0x000000F0L")

cpp_quote("#define STGX_MODE_OPEN               0x00000100L   // default is to open an existing item and fail if its not there")
cpp_quote("#define STGX_MODE_CREATE             0x00000200L   // Create a new item.  If an old item has the same name delete it first.")
cpp_quote("#define STGX_MODE_FAILIFTHERE        0x00000400L   // Use with CREATE. Create a new item but fail if an item with that name already exists.")
cpp_quote("#define STGX_MODE_OPENEXISTING       0x00000800L   // Use with CREATE. If the item already exists open the item, otherwise create the item.")
cpp_quote("#define STGX_MODE_CREATIONMASK       0x00000F00L")


cpp_quote("#define STGX_MODE_FORCE            0x00001000")

typedef DWORD STGXMODE;

cpp_quote("#define STGX_DESTROY_FORCE               0x00001000")

typedef DWORD STGXDESTROY;

typedef [v1_enum] enum tagSTGXTYPE
{
    STGX_TYPE_ANY               = 0x00000000L,
    STGX_TYPE_STORAGE           = 0x00000001L,
    STGX_TYPE_STREAM            = 0x00000002L,
} STGXTYPE;

cpp_quote("#define STGX_E_INCORRECTTYPE                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_STORAGE, 0x300) // Tried to open a storage/stream but a stream.storage with the same name already exists")
cpp_quote("#define STGX_E_NOADVISESINK                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_STORAGE, 0x301) // Needed to confirm something but no advise sink was set")
cpp_quote("#define STGX_E_CANNOTRECURSE                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_STORAGE, 0x302) // A move or copy of a storage failed to recurse.  The storage itself was copied, but none of its contents were.")

[
    object,
    uuid(9FE3A135-2915-493b-A8EE-3AB21982776C),
    helpstring("ITransferDest"),
    pointer_default(unique)
]
interface ITransferDest : IUnknown
{
    HRESULT Advise(
        [in]         ITransferAdviseSink *pAdvise,
        [out,retval] DWORD              *pdwCookie);

    HRESULT Unadvise([in] DWORD dwCookie);

    // Create or open an element, either storage or stream
    HRESULT OpenElement(
        [in, string] const WCHAR *pwcsName,
        [in] STGXMODE     grfMode,
        [in, out] DWORD *pdwType,
        [in] REFIID       riid,
        [out, iid_is(riid)] void **ppunk);

    HRESULT CreateElement(
        [in, string] const WCHAR *pwcsName,
        [in] IShellItem *psiTemplate,
        [in] STGXMODE     grfMode,
        [in] DWORD        dwType,
        [in] REFIID       riid,
        [out, iid_is(riid)] void **ppunk);

    // Move or copy an element, either storage or stream
    HRESULT MoveElement(
        [in] IShellItem *psiItem,                     // item to be moved (source)
        [in, string] WCHAR       *pwcsNewName,    // Pointer to new name of element in destination
        [in] STGXMOVE              grfOptions);    // Options (STGMOVEEX_ enum)

    HRESULT DestroyElement(
        [in, string] const WCHAR *pwcsName,
        [in] STGXDESTROY grfOptions);

    //HRESULT RenameElement(                     is this really necessary?  We can OpenElements IShellItem and do whatever we want
    //    [in, string] const WCHAR *pwcsName,
    //    [in, string] const WCHAR *pwcsNewName);
};

[
    object,
    uuid(5AE334C5-06DD-4321-B44F-63B1D23F2E57),
    helpstring("IStorageProcessor"),
    pointer_default(unique)
]
interface IStorageProcessor : IUnknown
{
    HRESULT Advise(
                [in] ITransferAdviseSink *pAdvise,
                [out,retval] DWORD *dwCookie);

    HRESULT Unadvise(
                [in] DWORD     dwCookie);

    HRESULT Run([in]  IEnumShellItems *penum, 
                [in]  IShellItem *psiDest,                            
                [in]  STGOP      dwOperation, 
                [in]  DWORD      dwOptions);
    
    HRESULT SetProgress([in] IActionProgress *pap);
};

// Custom Confirmation Flags
//
// For use in the dwFlags member of a CUSTOMCONFIRMATION struct.

cpp_quote("#define CCF_SHOW_SOURCE_INFO        0x00000001   // if set, information about the source will be shown. Information will be gotten from IShellFolder if possible, or a STATSTG structure otherwise.")
cpp_quote("#define CCF_SHOW_DESTINATION_INFO   0x00000002   // If set, information about the destination will be shown. Information will be gotten from IShellFolder if possible, or a STATSTG structure otherwise.")
cpp_quote("#define CCF_USE_DEFAULT_ICON        0x00000004   // If set, hicon is ignored and a default is selected based on the current operation.")


// Custom Confirmation Buttons
//
// For use in the dwButtons member of a CUSTOMCONFIRMATION struct.

cpp_quote("#define CCB_YES_SKIP_CANCEL            1")
cpp_quote("#define CCB_RENAME_SKIP_CANCEL         2")
cpp_quote("#define CCB_YES_SKIP_RENAME_CANCEL     3")
cpp_quote("#define CCB_RETRY_SKIP_CANCEL          4")
cpp_quote("#define CCB_OK                         5")


// Confirmation Response.
//
// These are the possible results that IStgTransConfirmation::Confirm can return.

typedef [v1_enum] enum tagCONFIRMATIONRESPONSE
{
    CONFRES_CONTINUE    = 0x00000000,   // When warned of side effects, user said "Yes, do it anyway"
    CONFRES_SKIP        = 0x00000001,   // Skip the current item, but continue with any other items if possible
    CONFRES_RETRY       = 0x00000002,   // Retry the given operation because the user has made some extrenal change that should effect the outcome
    CONFRES_RENAME      = 0x00000003,   // Try the operation again, but use a different name for the destination (i.e. rename on collision or truncate name on "path to long
    CONFRES_CANCEL      = 0x00000004,   // Cancel this and all further operations
    CONFRES_UNDO        = 0x00000005,   // Cancel the current operation and undo any operations already completed if possible.  If undo is unavailable, treat like "cancel".

} CONFIRMATIONRESPONSE, *LPCONFIRMATIONRESPONSE;


// Describes the source, destination, and operation that needs to be confirmed

typedef struct tagCONFIRMOP
{
    STGOP dwOperation;          // the type of operation requiring a confirmation (i.e. STGOP_*value)
    STGTRANSCONFIRMATION stc;   // the condition that needs to be confirmed
    CUSTOMCONFIRMATION *pcc;    // OPTIONAL: If non-NULL, points to custom information to be displayed in the confirmation.  Must be provided if a custom STGTRANSCONFIRMATION is provided.
    UINT cRemaining;            // the count of operations remaining after the operation being confirmed.

    IShellItem *psiItem;        // the sorce
    IShellItem *psiDest;        // the destination, or destination item in case target already exists
    LPCWSTR pwszRenameTo;       // used only during "rename" confirmations, contains the new target name
    IUnknown *punkSite;         // the parent site for the dialog we will create
} CONFIRMOP, *PCONFIRMOP;

[
    object,
    uuid(FC45985F-07F8-48E3-894C-7DEE8ED66EE5),
    helpstring("ITransferConfirmation Interface"),
    pointer_default(unique)
]
interface ITransferConfirmation : IUnknown
{
    // Warns of any side effects and confirms that the operation should proceed.
    HRESULT Confirm([in] CONFIRMOP *pcop, [out] LPCONFIRMATIONRESPONSE pcr, [out] BOOL *pbAll);
};

[
    uuid(c3d92d66-68ad-4b2a-86f5-4dfe97fbd2c7),
    helpstring("private helpers for cd burning"),
]
interface ICDBurnPriv : IUnknown
{
    HRESULT GetMediaCapabilities([out] DWORD *pdwCaps, [out] BOOL *pfUDF);
    HRESULT GetContentState([out] BOOL *pfStagingHasFiles, [out] BOOL *pfDiscHasFiles);
    HRESULT IsWizardUp();  // S_OK means wizard is up, S_FALSE means its not.
};

[
    uuid(98467961-4f27-4a1f-9629-22b06d0b5ccb),
    helpstring("drive folder extension"),
]
interface IDriveFolderExt : IUnknown
{
    HRESULT DriveMatches([in] int iDrive);
    HRESULT Bind([in] LPCITEMIDLIST pidl, [in] IBindCtx *pbc, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
    HRESULT GetSpace([out] ULONGLONG *pcbTotal, [out] ULONGLONG *pcbFree);
};

cpp_quote("#if _WIN32_IE >= 0x0600")
[
    uuid(da22171f-70b4-43db-b38f-296741d1494c),
    helpstring("used to modify the behavior of an IQueryInfo implementation"),
]
interface ICustomizeInfoTip : IUnknown
{
    HRESULT SetPrefixText([in, string] LPCWSTR pszPrefix);
    HRESULT SetExtraProperties([in, size_is(cscid)] const SHCOLUMNID *pscid, [in] UINT cscid);
};

[
    uuid(fadb55b4-d382-4fc4-81d7-abb325c7f12a),
    helpstring("fades a rectangle on the screen"),
    local,
]
interface IFadeTask : IUnknown
{
    HRESULT FadeRect([in] LPCRECT prc);
};

//
//  If a shell folder exposes ISetFolderEnumRestriction, you can use
//  SetEnumRestriction to specify bits that are always set or always cleared
//  in the grfFlags parameter to IShellFolder::EnumObjects.
//

[
    uuid(76347b91-9846-4ce7-9a57-69b910d16123),
    local
]
interface ISetFolderEnumRestriction : IUnknown
{
    HRESULT SetEnumRestriction(DWORD dwRequired, DWORD dwForbidden);
};

cpp_quote("#endif // _WIN32_IE >= 0x0600")

[
    object,
    uuid(5747C63F-1DE8-423f-980F-00CB07F4C45B),
    pointer_default(unique),
    local
]
interface IObjectWithRegistryKey : IUnknown
{
    HRESULT SetKey([in] HKEY hk);
    HRESULT GetKey([out] HKEY *phk);
}

//
//  0--| IQuerySource - direct wrapper for single HKEY 
//
//      IQuerySource is an abstract representation of the 
//  methods typically used to directly access a registry HKEY.  
//  This allows querying against existing keys, while not
//  binding objects implemented with IQuerySource to always
//  use HKEYs for all sources.  IQS implementations that do 
//  wrap an HKEY should also expose IObjectWithRegistryKey.
//      

[
    object,
    uuid(c7478486-7583-49e7-a6c2-faf8f02bc30e),
    pointer_default(unique)
]
interface IQuerySource : IUnknown
{
    HRESULT EnumValues([out] IEnumString **ppenum);
    HRESULT EnumSources([out] IEnumString **ppenum);

    HRESULT QueryValueString(
        [in, string] LPCWSTR pszSubSource, 
        [in, string] LPCWSTR pszValue, 
        [out, string] LPWSTR *ppsz);

    HRESULT QueryValueDword(
        [in, string] LPCWSTR pszSubSource, 
        [in, string] LPCWSTR pszValue, 
        [out] DWORD *pdw);

    HRESULT QueryValueExists(
        [in, string] LPCWSTR pszSubSource, 
        [in, string] LPCWSTR pszValue); 

    //  used for Query/SetValueDirect
    //  in QueryValueDirect pblob->fFlags = qvt
    [v1_enum] enum
    {
        QVT_EMPTY                   = 0, // REG_NONE
        QVT_STRING                  = 1, // REG_SZ
        QVT_EXPANDABLE_STRING       = 2, // REG_EXPAND_SZ
        QVT_BINARY                  = 3, // REG_BINARY
        QVT_DWORD                   = 4, // REG_DWORD
        QVT_MULTI_STRING            = 7, // REG_MULTI_SZ
    };

    HRESULT QueryValueDirect(
        [in, string] LPCWSTR pszSubSource, 
        [in, string] LPCWSTR pszValue, 
        [out] FLAGGED_BYTE_BLOB **ppblob);

    HRESULT OpenSource(
        [in] LPCWSTR pszSubSource,
        [in] BOOL fCreate,
        [out] IQuerySource **ppqs);

    HRESULT SetValueDirect(
        [in, string] LPCWSTR pszSubSource, 
        [in, string] LPCWSTR pszValue, 
        [in] ULONG qvt,
        [in] DWORD cbData,
        [in, size_is(cbData)] BYTE *pbData);
};

[
    object,
    uuid(3c44ba76-de0e-4049-b6e4-6b31a5262707),
    pointer_default(unique)
]
interface IPersistString2 : IPersist
{
    HRESULT SetString([in, string] LPCWSTR psz);
    HRESULT GetString([out, string] LPWSTR *ppsz);
};

[
    object,
    uuid(b3dcb623-4280-4eb1-84b3-8d07e84f299a),
    pointer_default(unique)
]
interface IObjectWithQuerySource : IUnknown
{
    HRESULT SetSource([in] IQuerySource *pqs);
    HRESULT GetSource([in] REFIID riid, [out, iid_is(riid)] void **ppv);
};

typedef [v1_enum] enum tagASSOCQUERY
{
//  each ASSOCQUERY identifier is composed of 
//  HIWORD:  the type and capabilities (AQF bits)
//  LOWORD:  the ordinal relative to its type
    AQ_NOTHING  = 0,

//  simple queries where pszCue is unused (AQF type 0x000)
    AQS_FRIENDLYTYPENAME            = 0x00170000, //  friendly name of the document type
    AQS_DEFAULTICON                 = 0x00070001, //  Default icon resource string call PathParseIconLocation() to use
    AQS_CONTENTTYPE                 = 0x80070002, //  MIME Content type
    AQS_CLSID                       = 0x00070003, //  CLSID associated with class
    AQS_PROGID                      = 0x00070004, //  ProgID associated with class
    
//  simple queries where pszCue identifies the value (AQF type 0x010)
    AQN_NAMED_VALUE                 = 0x010f0000, //  querys directly for value named by pszCue
    AQNS_NAMED_MUI_STRING           = 0x01170001, //  as ASSOCQUERY_NAMED_VALUE and loads it using MUI semantics SHLoadIndirectString()
    AQNS_SHELLEX_HANDLER            = 0x81070002, //  ..\Shellex\%pszCue% returns a CLSID string for the value.

//  queries that require delegation to the static verb element for completion, pszCue is the verb (AQF type 0x020)
    AQVS_COMMAND                    = 0x02070000, //  ...\shell\verb\command, template for CreateProcess()
    AQVS_DDECOMMAND                 = 0x02070001, //  ...\shell\verb\ddeexec, template for DDE conversation
    AQVS_DDEIFEXEC                  = 0x02070002, //  ...\shell\verb\ddeexec\ifexec, replaces DDECOMMAND after calling CreateProcess(AQVS_COMMAND)
    AQVS_DDEAPPLICATION             = 0x02070003, //  ...\shell\verb\ddeexec\application, Application name in DDE broadcast
    AQVS_DDETOPIC                   = 0x02070004, //  ...\shell\verb\ddeexec\topic, Topic Name in DDE broadcast
    AQV_NOACTIVATEHANDLER           = 0x02060005, //  ...\shell\verb\ddeexec!NoActivateHandler restrict attempts to activate window
    AQVD_MSIDESCRIPTOR              = 0x02060006, //  Component Descriptor to pass to MSI APIs
    AQVS_APPLICATION_PATH           = 0x02010007, //  path to executable
    AQVS_APPLICATION_FRIENDLYNAME   = 0x02170008, //  friendly name of associated application

//  delegate objects retrievable through QueryObject (AQF type 0x022)
    AQVO_SHELLVERB_DELEGATE         = 0x02200000, //  CAssocShellVerbElement init'd with ...\shell\verb
    AQVO_APPLICATION_DELEGATE       = 0x02200001, //  CAssocApplicationElement init'd with AQVS_APPLICATION_PATH

//  flags that hint to the implementation the purpose of the ASSOCQUERY
    AQF_STRING                      = 0x00010000,   // supports QueryString()
    AQF_EXISTS                      = 0x00020000,   // supports QueryExists()
    AQF_DIRECT                      = 0x00040000,   // supports QueryDirect()
    AQF_DWORD                       = 0x00080000,   // supports QueryDword()
    AQF_MUISTRING                   = 0x00100000,   // supports QueryString(), but also does a SHLoadIndirectString()
    AQF_OBJECT                      = 0x00200000,   // supports QueryObject()
    AQF_CUEIS_UNUSED                = 0x00000000,   // pszCue is unused, in IAssociation* Query methods
    AQF_CUEIS_NAME                  = 0x01000000,   // pszCue is the name of the value being queried for, in IAssociation* Query methods
    AQF_CUEIS_SHELLVERB             = 0x02000000,   // pszCue is the Shell\Verb, in IAssociation* Query methods
    AQF_QUERY_INITCLASS             = 0x80000000,   // for values that hang off the extension, etc.
} ASSOCQUERY; 

//
//  0--| IAssociationElement - indirect wrapper for HKEY and subkeys/values
//
//      IAssociationElement wraps the logic used to access values
//  under an HKEY.  The methods are essentially identical, just changing
//  for the return type.
//      * ASSOCQUERY    - enum names the query for the association.  the 
//          query's bits define what methods and return values are valid.
//          NOTE - Not all ASSOCQUERY's are supported by all elements.
//      * pszCue        - string that is used with some queries.
//          if (query & AQF_CUEIS_SHELLVERB) then pszCue is the static verb
//          if (query & AQF_CUEIS_NAME) then pszCue is name for the value or subkey
//

[
    object,
    uuid(e58b1abf-9596-4dba-8997-89dcdef46992),
    pointer_default(unique)
]
interface IAssociationElement : IUnknown
{
    HRESULT QueryString(
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [out, string] LPWSTR *ppsz);

    HRESULT QueryDword(
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [out] DWORD *pdw);

    HRESULT QueryExists(
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue);

    HRESULT QueryDirect(
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [out] FLAGGED_BYTE_BLOB **ppblob);

    HRESULT QueryObject(
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);
};

[
    object,
    uuid(a6b0fb57-7523-4439-9425-ebe99823b828),
    pointer_default(unique)
]
interface IEnumAssociationElements : IUnknown
{
    HRESULT Next(
        [in] ULONG celt, 
        [out, size_is(celt), length_is(*pceltFetched)] IAssociationElement ** rgelt, 
        [out] ULONG *pceltFetched);
        
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumAssociationElements **ppenum);
};

[v1_enum] enum tagASSOCELEM
{
    ASSOCELEM_DATA              = 0x00000001, //  InsertElements(ASSOCELEM_DATA)
    ASSOCELEM_USER              = 0x00000002, //  APPLICATION or progid
    ASSOCELEM_DEFAULT           = 0x00000004, //  ClsId or progid
    ASSOCELEM_SYSTEM_EXT        = 0x00000010, //  HKCR\SFA\.ext
    ASSOCELEM_SYSTEM_PERCEIVED  = 0x00000020, //  HKCR\SFA\PerceivedType
    ASSOCELEM_SYSTEM            = 0x00000030, //  use SystemFileAssociations
    ASSOCELEM_BASEIS_FOLDER     = 0x00000100, //  HKCR\Folder
    ASSOCELEM_BASEIS_STAR       = 0x00000200, //  HKCR\*
    ASSOCELEM_BASE              = 0x00000300, //  FOLDER | STAR
    ASSOCELEM_EXTRA             = 0x00010000, //  InsertElements(ASSOCELEM_EXTRA)

    ASSOCELEMF_INCLUDE_SLOW     = 0x80000000, //  include elements that maybe slow

    ASSOCELEM_MASK_QUERYNORMAL  = 0x0000FFFF, 
    ASSOCELEM_MASK_ENUMCONTEXTMENU = -1,      //  context menus usually try everything
    ASSOCELEM_MASK_ALL        = -1,
};

typedef DWORD ASSOCELEM_MASK;

[
    object,
    uuid(ee9165bf-a4d9-474b-8236-6735cb7e28b6),
    pointer_default(unique)
]
interface IAssociationArrayInitialize : IUnknown
{
    HRESULT InitClassElements(
        [in] ASSOCELEM_MASK maskBase,   //  FOLDER || STAR
        [in] LPCWSTR pszClass);
        
    HRESULT InsertElements(
        [in] ASSOCELEM_MASK mask,
        [in] IEnumAssociationElements *peae);

    HRESULT FilterElements([in] ASSOCELEM_MASK maskInclude);
};

//
//  0--| IAssociationArray - manages querying an array of IAssociationElement's
//      IAssociationArray wraps an array of objects implementing IAssociationElement.
//  It calls the elements in priority order, starting with the most specific 
//  (ASSOCELEM_DATA) to the least specific (ASSOCELEM_EXTRA).  IAssociationArray
//  combined with IAssociationArrayInitialize is a superset of IQueryAssociations.
//
//  Which elements are in the array and how they are initialized depends on
//  how IAssociationArrayInitialize::InitClassElements() was called.
//       _________________________________
//      |       CLSID_QueryAssociations   |
//   0--| IAssociationArrayInitialize     |
//   0--| IAssociationArray               |
//   0--| IQueryAssociations              |
//      |_________________________________|
//            | |       ________________________________
//            | |      |    CLSID_AssocShellElement     |
//            | +--<0--|IPersistString2 - initializer   |
//            +----<0--|IAssociationElement             |
//                  0--|IObjectWithQuerySource          |
//                     |________________________________|
//                            |      ________________________
//                            |     | IQuerySource on HKEY   |
//                            +-<0--|IQuerySource            |
//                               0--|IObjectWithRegistryKey  |
//                                  |________________________|
[
    object,
    uuid(3b877e3c-67de-4f9a-b29b-17d0a1521c6a),
    pointer_default(unique)
]
interface IAssociationArray : IUnknown
{
    HRESULT EnumElements(
        [in] ASSOCELEM_MASK mask, 
        [out] IEnumAssociationElements **ppeae);

    HRESULT QueryString(
        [in] ASSOCELEM_MASK mask, 
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [out, string] LPWSTR *ppsz);

    HRESULT QueryDword(
        [in] ASSOCELEM_MASK mask, 
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [out] DWORD *pdw);

    HRESULT QueryExists(
        [in] ASSOCELEM_MASK mask, 
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue);

    HRESULT QueryDirect(
        [in] ASSOCELEM_MASK mask, 
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [out] FLAGGED_BYTE_BLOB **ppblob);

    HRESULT QueryObject(
        [in] ASSOCELEM_MASK mask, 
        [in] ASSOCQUERY query, 
        [in, string] LPCWSTR pszCue, 
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);
};


//
// IAlphaThumbnailExtractor
// 
// private interface used by CFolderExtractImage
// 
[
    uuid(0F97F9D3-A7E2-4db7-A9B4-C540BD4B80A9),
    local
]
interface IAlphaThumbnailExtractor : IUnknown
{
    HRESULT RequestAlphaThumbnail();
};

cpp_quote("#if (_WIN32_IE >= 0x0600)")
//
// IQueryPropertyFlags
//
// Private interface used by CPropStgColumns, implemented by the shmedia property storage
// Used to determine properties that are expensive to extract.
//
[
    uuid(85DCA855-9B96-476d-8F35-7AF1E733CAAE),
    local
]
interface IQueryPropertyFlags : IUnknown
{
    HRESULT GetFlags(const PROPSPEC *pspec, SHCOLSTATEF *pcsFlags);
};

cpp_quote("#endif // _WIN32_IE >= 0x0600)")




[
    uuid(f4f1ef99-4d0e-43ca-90b6-2e30e4056975)
]
library ShellPrivateObjects
{
    // CLSID_HWEventSettings
    [ uuid(5560c070-114e-4e97-929a-7e39f40debc7) ] coclass HWEventSettings { interface IAutoplayHandler; }

    // CLSID_AutoplayHandlerProperties
    [ uuid(11F6B41F-3BE5-4ce3-AF60-398551797DF6) ] coclass AutoplayHandlerProperties { interface IAutoplayHandlerProperties; }

    // CLSID_HWDevice
    [ uuid(aac41048-53e3-4867-a0aa-5fbceae7e5f5) ] coclass HWDevice { interface IHWDevice; }

    // CLSID_HardwareDevices
    [ uuid(dd522acc-f821-461a-a407-50b198b896dc) ] coclass HardwareDevices { interface IHardwareDevices; }

    // CLSID_HWDeviceCustomProperties
    [ uuid(555F3418-D99E-4e51-800A-6E89CFD8B1D7) ] coclass HWDeviceCustomProperties { interface IHWDeviceCustomProperties; }

    // CLSID_IDefCategoryProvider
    [ uuid(B2F2E083-84FE-4a7e-80C3-4B50D10D646E) ] coclass DefCategoryProvider { interface IDefCategoryProvider; }

    // CLSID_VersionColProvider
    [ uuid(66742402-F9B9-11D1-A202-0000F81FEDEE) ] coclass VersionColProvider { interface IPersist; }

    // CLSID_ThemeUIPages
    [ uuid(B12AE898-D056-4378-A844-6D393FE37956) ] coclass ThemeUIPages { interface IThemeUIPages; }

    // CLSID_ScreenSaverPage
    [ uuid(ADB9F5A4-E73E-49b8-99B6-2FA317EF9DBC) ] coclass ScreenSaverPage { interface IPropertyBag; }

    // CLSID_ScreenResFixer
    [ uuid(5a3d988e-820d-4aaf-ba87-440081768a17) ] coclass ScreenResFixer { interface IScreenResFixer; }

    // CLSID_SettingsPage
    [ uuid(4c892621-6757-4fe0-ad8c-a6301be7fba2) ] coclass SettingsPage { interface IBasePropPage; }

    // CLSID_DisplaySettings
    [ uuid(c79d1575-b8c6-4862-a284-788836518b97) ] coclass DisplaySettings { interface IDisplaySettings; }

    // CLSID_VideoThumbnail
    [ uuid(c5a40261-cd64-4ccf-84cb-c394da41d590) ] coclass VideoThumbnail { interface IPersist; }

//    ThumbnailFCNHandler is already defined in uuidcom.lib -> uuid.lib
//    [ uuid(cefc65d8-66d8-11d1-8d8c-0000f804b057)] coclass ThumbnailFCNHandler { interface IThumbnailExtractor; }

    // CLSID_StartMenuPin
    [ uuid(a2a9545d-a0c2-42b4-9708-a0b2badd77c8) ] coclass StartMenuPin { interface IStartMenuPin; }

    // CLSID_ClientExtractIcon, with dummy interface to make midl happy
    [ uuid(25585dc7-4da0-438d-ad04-e42c8d2d64b9) ] coclass ClientExtractIcon { interface IPersist; }

    // CLSID_MediaDeviceFolder
    [ uuid(640167b4-59b0-47a6-b335-a6b3c0695aea) ] coclass MediaDeviceFolder { interface IShellFolder; }

    // CLSID_CDBurnFolder
    [ uuid(00eebf57-477d-4084-9921-7ab3c2c9459d) ] coclass CDBurnFolder { interface IShellFolder; }

    // CLSID_BurnAudioCDExtension
    [ uuid(f83cbf45-1c37-4ca1-a78a-28bcb91642ec) ] coclass BurnAudioCDExtension { interface ICDBurnExt; }

    // CLSID_Accessible
    [ uuid(7e653215-fa25-46bd-a339-34a2790f3cb7) ] coclass Accessible { interface IInitAccessible; }

    // CLSID_TrackPopupBar
    [ uuid(acf35015-526e-4230-9596-becbe19f0ac9) ] coclass TrackPopupBar { interface IInitTrackPopupBar; }

    // CLSID_SharedDocuments    
    [ uuid(59031a47-3f72-44a7-89c5-5595fe6b30ee) ] coclass SharedDocuments { interface IShellFolder; }

    // CLSID_PostBootReminder
    [ uuid(7849596a-48ea-486e-8937-a2a3009f31a9) ] coclass PostBootReminder { interface IShellReminderManager; }

    // CLSID_AudioMediaProperties
    [ uuid(875CB1A1-0F29-45de-A1AE-CFB4950D0B78) ] coclass AudioMediaProperties { interface IPersist; }

    // CLSID_VideoMediaProperties
    [ uuid(40C3D757-D6E4-4b49-BB41-0E5BBEA28817) ] coclass VideoMediaProperties { interface IPersist; }

    // CLSID_AVWavProperties
    [ uuid(E4B29F9D-D390-480b-92FD-7DDB47101D71) ] coclass AVWavProperties { interface IPersist; }

    // CLSID_AVAviProperties
    [ uuid(87D62D94-71B3-4b9a-9489-5FE6850DC73E) ] coclass AVAviProperties { interface IPersist; }

    // CLSID_AVMidiProperties
    [ uuid(A6FD9E45-6E44-43f9-8644-08598F5A74D9) ] coclass AVMidiProperties { interface IPersist; }

    // CLSID_TrayNotify
    [ uuid(25dead04-1eac-4911-9e3a-ad0a4ab560fd) ] coclass TrayNotify { interface ITrayNotify; }

    // CLSID_CompositeFolder
    [ uuid(FEF10DED-355E-4e06-9381-9B24D7F7CC88) ] coclass CompositeFolder { interface ICompositeFolder; }

    // CLSID_DynamicStorage
    [ uuid(F46316E4-FB1B-46eb-AEDF-9520BFBB916A) ] coclass DynamicStorage { interface IDynamicStorage; }

    // CLSID_Magic
    [ uuid(8A037D15-3357-4b1c-90EB-7B40B74FC4B2) ] coclass Magic { interface IMagic; }

    // CLSID_HomeNetworkWizard
    [ uuid(2728520d-1ec8-4c68-a551-316b684c4ea7) ] coclass HomeNetworkWizard { interface IHomeNetworkWizard; }

    // CLSID_StartMenuFolder
    [ uuid(48e7caab-b918-4e58-a94d-505519c795dc) ] coclass StartMenuFolder { interface IShellFolder; }

    // CLSID_ProgramsFolder
    [ uuid(7be9d83c-a729-4d97-b5a7-1b7313c39e0a) ] coclass ProgramsFolder { interface IShellFolder; }

    // CLSID_MoreDocumentsFolder
    [ uuid(9387ae38-d19b-4de5-baf5-1f7767a1cf04) ] coclass MoreDocumentsFolder { interface IShellFolder; }

    // CLSID_LocalCopyHelper
    [ uuid(021003e9-aac0-4975-979f-14b5d4e717f8) ] coclass LocalCopyHelper { interface ILocalCopy; }

    // CLSID_ShellItem
    [ uuid(9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917) ] coclass ShellItem { interface IShellItem; }

    // CLSID_WirelessDevices
    [ uuid(30dd6b9c-47b7-4df5-94ae-f779aa7eb644) ] coclass WirelessDevices { interface IShellFolder; }

    // CLSID_FolderCustomize
    [ uuid(ef43ecfe-2ab9-4632-bf21-58909dd177f0) ] coclass FolderCustomize { interface IShellExtInit; }

    // A service to handle interfaces normally implemented for an Ole Control Site, like IOleControlSite, or
    // most importantly in our case, IDispatch, which handles ambient properties for the site.
    cpp_quote("#define SID_OleControlSite IID_IOleControlSite")

    // CLSID_WorkgroupNetCrawler
    [ uuid(72b3882f-453a-4633-aac9-8c3dced62aff) ] coclass WorkgroupNetCrawler { interface INetCrawler; }

    // CLSID_WebDocsNetCrawler
    [ uuid(8a2ecb17-9007-4b9a-b271-7509095c405f) ] coclass WebDocsNetCrawler { interface INetCrawler; }

    // CLSID_PublishedShareNetCrawler
    [ uuid(24eee191-5491-4dc3-bd03-c0627df6a70c) ] coclass PublishedShareNetCrawler { interface INetCrawler; }

    // CLSID_ImagePropertyHandler
    [ uuid(eb9b1153-3b57-4e68-959a-a3266bc3d7fe) ] coclass ImagePropertyHandler { interface IPersist; }

    // CLSID_WebViewRegTreeItem
    [ uuid(01E2E7C0-2343-407f-B947-7E132E791D3E) ] coclass WebViewRegTreeItem { interface IRegTreeItem; }

    // CLSID_ThemesRegTreeItem
    [ uuid(AABE54D4-6E88-4c46-A6B3-1DF790DD6E0D) ] coclass ThemesRegTreeItem { interface IRegTreeItem; }

    // CLSID_CShellTreeWalker
    [ uuid(95CE8412-7027-11D1-B879-006008059382) ] coclass CShellTreeWalker { interface IShellTreeWalker; }

    // CLSID_StorageProcessor
    [ uuid(6CF8E98C-5DD4-42A2-A948-BFE4CA1DC3EB) ] coclass StorageProcessor { interface IStorageProcessor; };

    // CLSID_TransferConfirmationUI
    [ uuid(6B831E4F-A50D-45FC-842F-16CE27595359) ] coclass TransferConfirmationUI { interface ITransferConfirmation; };

    // CLSID_ShellAutoplay
    [ uuid(995C996E-D918-4a8c-A302-45719A6F4EA7) ] coclass ShellAutoplay { interface IHWEventHandler; };

    // CLSID_PrintPhotosDropTarget
    [ uuid(60fd46de-f830-4894-a628-6fa81bc0190d) ] coclass PrintPhotosDropTarget { interface IDropTarget; };

    // CLSID_OrganizeFolder
    [ uuid(10612e23-7679-4dd9-95b8-8e71c461feb2) ] coclass OrganizeFolder { interface IPersist; }

    // CLSID_FadeTask
    [ uuid(7eb5fbe4-2100-49e6-8593-17e130122f91) ] coclass FadeTask { interface IFadeTask; }

    [ uuid(c461837f-ea59-494a-b7c6-cd040e37185e) ] coclass AssocShellElement { interface IAssociationElement; }
    [ uuid(9016d0dd-7c41-46cc-a664-bf22f7cb186a) ] coclass AssocProgidElement { interface IAssociationElement; }
    [ uuid(57aea081-5ee9-4c27-b218-c4b702964c54) ] coclass AssocClsidElement { interface IAssociationElement; }
    [ uuid(a6c4baad-4af5-4191-8685-c2c8953a148c) ] coclass AssocSystemElement { interface IAssociationElement; }
    [ uuid(0dc5fb21-b93d-4e3d-bb2f-ce4e36a70601) ] coclass AssocPerceivedElement { interface IAssociationElement; }
    [ uuid(0c2bf91b-8746-4fb1-b4d7-7c03f890b168) ] coclass AssocApplicationElement { interface IAssociationElement; }
    [ uuid(7566df7a-42cc-475d-a025-1205ddf4911f) ] coclass AssocFolderElement { interface IAssociationElement; }
    [ uuid(0633b720-6926-404c-b6b3-923b1a501743) ] coclass AssocStarElement { interface IAssociationElement; }
    [ uuid(3c81e7fa-1f3b-464a-a350-114a25beb2a2) ] coclass AssocClientElement { interface IAssociationElement; }

    [ uuid(f26a669a-bcbb-4e37-abf9-7325da15f931) ] coclass AutoPlayVerb { interface IDropTarget; }
}
