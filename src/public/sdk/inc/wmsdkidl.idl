//============================================================================
//
//  Microsoft Windows Media Technology
//  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.
//
//  File:        wmsdkidl.idl
//
//  Description: 
//
//============================================================================

cpp_quote( "//=========================================================================" )
cpp_quote( "//" )
cpp_quote( "// Microsoft Windows Media Technologies" )
cpp_quote( "// Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved." )
cpp_quote( "//" )
cpp_quote( "//=========================================================================" )

///////////////////////////////////////////////////////////////////////////////
//
// Enumerations and constants used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Imports, typedefs and forward declarations
//
import "oaidl.idl";
import "wmsbuffer.idl";
import "drmexternals.idl";

typedef unsigned __int64 QWORD;

//
// Here's a list of all the interfaces we define in this file:
//
interface IWMMediaProps;
interface IWMVideoMediaProps;

interface IWMWriter;
interface IWMInputMediaProps;

interface IWMReader;
interface IWMOutputMediaProps;

interface IWMReaderCallback;

interface IWMMetadataEditor;
interface IWMMetadataEditor2;

interface IWMHeaderInfo;

interface IWMProfile;
interface IWMProfileManager;
interface IWMStreamConfig;
interface IWMStreamList;
interface IWMMutualExclusion;
interface IWMPacketSize;

interface IWMWriterAdvanced;
interface IWMWriterAdvanced2;
interface IWMWriterSink;
interface IWMWriterFileSink;
interface IWMWriterNetworkSink;

interface IWMReaderAdvanced;
interface IWMReaderAdvanced2;
interface IWMReaderAdvanced3;
interface IWMReaderCallbackAdvanced;
interface IWMDRMReader;

interface IWMReaderNetworkConfig;

interface IWMLicenseBackup;
interface IWMLicenseRestore;
interface IWMBackupRestoreProps;

interface IWMCodecInfo;
interface IWMCodecInfo2;

///////////////////////////////////////////////////////////////////////////////
//
// Attributes
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are the special case attributes that give information " )
cpp_quote( "// about the Windows Media file." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMSpecialAttributes = 15;" )
cpp_quote( "static const WCHAR *g_wszWMDuration = L\"Duration\";" )
cpp_quote( "static const WCHAR *g_wszWMBitrate = L\"Bitrate\";" )
cpp_quote( "static const WCHAR *g_wszWMSeekable = L\"Seekable\";" )
cpp_quote( "static const WCHAR *g_wszWMStridable = L\"Stridable\";" )
cpp_quote( "static const WCHAR *g_wszWMBroadcast = L\"Broadcast\";" )
cpp_quote( "static const WCHAR *g_wszWMProtected = L\"Is_Protected\";" )
cpp_quote( "static const WCHAR *g_wszWMTrusted = L\"Is_Trusted\";" )
cpp_quote( "static const WCHAR *g_wszWMSignature_Name = L\"Signature_Name\";" )
cpp_quote( "static const WCHAR *g_wszWMHasAudio = L\"HasAudio\";" )
cpp_quote( "static const WCHAR *g_wszWMHasImage = L\"HasImage\";" )
cpp_quote( "static const WCHAR *g_wszWMHasScript = L\"HasScript\";" )
cpp_quote( "static const WCHAR *g_wszWMHasVideo = L\"HasVideo\";" )
cpp_quote( "static const WCHAR *g_wszWMCurrentBitrate = L\"CurrentBitrate\";" )
cpp_quote( "static const WCHAR *g_wszWMOptimalBitrate = L\"OptimalBitrate\";" )
cpp_quote( "static const WCHAR *g_wszWMHasAttachedImages = L\"HasAttachedImages\";" )
cpp_quote( "" )
cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// The content description object supports 5 basic attributes." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMContentAttributes = 5;" )
cpp_quote( "static const WCHAR *g_wszWMTitle = L\"Title\";" )
cpp_quote( "static const WCHAR *g_wszWMAuthor = L\"Author\";" )
cpp_quote( "static const WCHAR *g_wszWMDescription = L\"Description\";" )
cpp_quote( "static const WCHAR *g_wszWMRating = L\"Rating\";" )
cpp_quote( "static const WCHAR *g_wszWMCopyright = L\"Copyright\";" )
cpp_quote( "" )
cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These attributes are used to set DRM properties." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszWMUse_DRM = L\"Use_DRM\";" )
cpp_quote( "static const WCHAR *g_wszWMDRM_Flags = L\"DRM_Flags\";" )
cpp_quote( "static const WCHAR *g_wszWMDRM_Level = L\"DRM_Level\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are the additional attributes defined in the WM attribute" )
cpp_quote( "// namespace that give information about the content." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszWMAlbumTitle = L\"WM/AlbumTitle\";" )
cpp_quote( "static const WCHAR *g_wszWMTrack = L\"WM/Track\";" )
cpp_quote( "static const WCHAR *g_wszWMPromotionURL = L\"WM/PromotionURL\";" )
cpp_quote( "static const WCHAR *g_wszWMAlbumCoverURL = L\"WM/AlbumCoverURL\";" )
cpp_quote( "static const WCHAR *g_wszWMGenre = L\"WM/Genre\";" )
cpp_quote( "static const WCHAR *g_wszWMYear = L\"WM/Year\";" )
cpp_quote( "static const WCHAR *g_wszWMGenreID = L\"WM/GenreID\";" )
cpp_quote( "static const WCHAR *g_wszWMMCDI = L\"WM/MCDI\";" )
cpp_quote( "static const WCHAR *g_wszWMComposer = L\"WM/Composer\";" )
cpp_quote( "static const WCHAR *g_wszWMLyrics = L\"WM/Lyrics\";" )
cpp_quote( "static const WCHAR *g_wszWMTrackNumber = L\"WM/TrackNumber\";" )
cpp_quote( "static const WCHAR *g_wszWMToolName = L\"WM/ToolName\";" )
cpp_quote( "static const WCHAR *g_wszWMToolVersion = L\"WM/ToolVersion\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These optional attributes may be used to give information " )
cpp_quote( "// about the branding of the content." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszWMBannerImageType = L\"BannerImageType\";" )
cpp_quote( "static const WCHAR *g_wszWMBannerImageData = L\"BannerImageData\";" )
cpp_quote( "static const WCHAR *g_wszWMBannerImageURL = L\"BannerImageURL\";" )
cpp_quote( "static const WCHAR *g_wszWMCopyrightURL = L\"CopyrightURL\";" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// The NSC file supports the following attributes." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMNSCAttributes = 5;" )
cpp_quote( "static const WCHAR *g_wszWMNSCName = L\"NSC_Name\";" )
cpp_quote( "static const WCHAR *g_wszWMNSCAddress = L\"NSC_Address\";" )
cpp_quote( "static const WCHAR *g_wszWMNSCPhone = L\"NSC_Phone\";" )
cpp_quote( "static const WCHAR *g_wszWMNSCEmail = L\"NSC_Email\";" )
cpp_quote( "static const WCHAR *g_wszWMNSCDescription = L\"NSC_Description\";" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are setting names for use in Get/SetOutputSetting" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszEarlyDataDelivery = L\"EarlyDataDelivery\";" )
cpp_quote( "static const WCHAR *g_wszJustInTimeDecode = L\"JustInTimeDecode\";" )
cpp_quote( "static const WCHAR *g_wszSingleOutputBuffer = L\"SingleOutputBuffer\";" )
cpp_quote( "static const WCHAR *g_wszSoftwareScaling = L\"SoftwareScaling\";" )
cpp_quote( "static const WCHAR *g_wszDeliverOnReceive = L\"DeliverOnReceive\";" )
cpp_quote( "static const WCHAR *g_wszScrambledAudio = L\"ScrambledAudio\";" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are setting names for use in Get/SetInputSetting" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszDeinterlaceMode = L\"DeinterlaceMode\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// All known IWMPropertyVault property names" )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszOriginalSourceFormatTag = L\"_SOURCEFORMATTAG\";" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// Enumerations and flags used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Flags that can be passed into the Start method of IWMReader" )
cpp_quote( "//" )
cpp_quote( "#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )" )
cpp_quote( "" )

//
// Flag to force overwrite of existing license backup
//
cpp_quote( "#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)" )
cpp_quote( "#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)" )

//
// Wave format ex type
//
cpp_quote( "#define WAVE_FORMAT_DRM            0x0009" )

//
// The flags that can be set on a sample (input or output).
//
enum 
{
    WM_SF_CLEANPOINT = 0x1,
    WM_SF_DISCONTINUITY = 0x2,
    WM_SF_DATALOSS = 0x4,
};

//
// These flags might be set for a call to the IWMReaderAllocatorEx methods.
//
enum
{
    WM_SFEX_NOTASYNCPOINT = 0x2,
    WM_SFEX_DATALOSS = 0x4,
};

//
// Status messages that the reader and index objects can
// pass in the OnStatus call.
//
typedef enum WMT_STATUS
{
    WMT_ERROR                       =  0,
    WMT_OPENED                      =  1,
    WMT_BUFFERING_START             =  2,
    WMT_BUFFERING_STOP              =  3,
    WMT_EOF                         =  4,
    WMT_END_OF_FILE                 =  4,
    WMT_END_OF_SEGMENT              =  5,
    WMT_END_OF_STREAMING            =  6,
    WMT_LOCATING                    =  7,
    WMT_CONNECTING                  =  8,
    WMT_NO_RIGHTS                   =  9,
    WMT_MISSING_CODEC               = 10,
    WMT_STARTED                     = 11,
    WMT_STOPPED                     = 12,
    WMT_CLOSED                      = 13,
    WMT_STRIDING                    = 14,
    WMT_TIMER                       = 15,
    WMT_INDEX_PROGRESS              = 16,
    WMT_SAVEAS_START                = 17,
    WMT_SAVEAS_STOP                 = 18,
    WMT_NEW_SOURCEFLAGS             = 19,
    WMT_NEW_METADATA                = 20,
    WMT_BACKUPRESTORE_BEGIN         = 21,
    WMT_SOURCE_SWITCH               = 22,
    WMT_ACQUIRE_LICENSE             = 23,
    WMT_INDIVIDUALIZE               = 24,
    WMT_NEEDS_INDIVIDUALIZATION     = 25,
    WMT_NO_RIGHTS_EX                = 26,
    WMT_BACKUPRESTORE_END           = 27,
    WMT_BACKUPRESTORE_CONNECTING    = 28,
    WMT_BACKUPRESTORE_DISCONNECTING = 29,
    WMT_ERROR_WITHURL               = 30,
    WMT_RESTRICTED_LICENSE          = 31,
    WMT_CLIENT_CONNECT              = 32,
	WMT_CLIENT_DISCONNECT           = 33
} WMT_STATUS;

typedef enum WMT_RIGHTS
{
    WMT_RIGHT_PLAYBACK                  = 0x00000001,
    WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE   = 0x00000002,
    WMT_RIGHT_COPY_TO_CD                = 0x00000008,
    WMT_RIGHT_COPY_TO_SDMI_DEVICE       = 0x00000010,
    WMT_RIGHT_ONE_TIME                  = 0x00000020,
    WMT_RIGHT_SDMI_TRIGGER              = 0x00010000,
    WMT_RIGHT_SDMI_NOMORECOPIES         = 0x00020000
} WMT_RIGHTS;


//
// Stream selection statuses (stati?).
//
typedef enum WMT_STREAM_SELECTION
{
    WMT_OFF               = 0,
    WMT_CLEANPOINT_ONLY   = 1,
    WMT_ON                = 2,
} WMT_STREAM_SELECTION;

//
// Attribute datatypes.
//
typedef enum WMT_ATTR_DATATYPE
{

    WMT_TYPE_DWORD      = 0,
    WMT_TYPE_STRING     = 1,
    WMT_TYPE_BINARY     = 2,
    WMT_TYPE_BOOL       = 3,
    WMT_TYPE_QWORD      = 4,
    WMT_TYPE_WORD       = 5,
    WMT_TYPE_GUID       = 6,

} WMT_ATTR_DATATYPE;

//
// Types of images that can be stored in the header of a Windows Media File.
//
typedef enum WMT_ATTR_IMAGETYPE
{
    WMT_IMAGETYPE_BITMAP = 1,
    WMT_IMAGETYPE_JPEG = 2,
    WMT_IMAGETYPE_GIF = 3,
} WMT_ATTR_IMAGETYPE;

//
// Windows Media versions.
//
typedef enum WMT_VERSION
{
    WMT_VER_4_0 = 0x00040000,
    WMT_VER_7_0 = 0x00070000,
} WMT_VERSION;

//
// Protocols that the network sink supports.
//
typedef enum WMT_NET_PROTOCOL
{
    WMT_PROTOCOL_HTTP    = 0,
} WMT_NET_PROTOCOL;


//
// The reader supports a number of different types of playback, each with
// slightly different characteristics.
//
typedef enum WMT_PLAY_MODE
{
    WMT_PLAY_MODE_AUTOSELECT    = 0,
    WMT_PLAY_MODE_LOCAL         = 1,
    WMT_PLAY_MODE_DOWNLOAD      = 2,
    WMT_PLAY_MODE_STREAMING     = 3,
} WMT_PLAY_MODE;

//
// Network Proxy settings for the reader
//
typedef enum WMT_PROXY_SETTINGS
{
    WMT_PROXY_SETTING_NONE      = 0,
    WMT_PROXY_SETTING_MANUAL    = 1,
    WMT_PROXY_SETTING_AUTO      = 2,
    WMT_PROXY_SETTING_BROWSER   = 3,        // Only valid for HTTP 
} WMT_PROXY_SETTINGS;


typedef enum WMT_CODEC_INFO_TYPE
{
    WMT_CODECINFO_AUDIO         = 0,            // codec info is a word = wFormatTag
    WMT_CODECINFO_VIDEO         = 1,            // codec info is a dword = biCompression
    WMT_CODECINFO_UNKNOWN       = 0xFFFFFFFF,   // codec info is undefined
} WMT_CODEC_INFO_TYPE;
    
//
// These values can be passed in when setting the DeinterlaceMode
// setting on the writer
//
enum 
{
    WM_DM_NOTINTERLACED                  = 0,
    WM_DM_DEINTERLACE_NORMAL             = 1,
    WM_DM_DEINTERLACE_HALFSIZE           = 2,
    WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE = 3,
    WM_DM_DEINTERLACE_INVERSETELECINE    = 4,
    WM_DM_DEINTERLACE_VERTICALHALFSIZEDOUBLERATE = 5,
};

//
// Frame level access data structures - not supported in this version
//
typedef enum tagWMT_OFFSET_FORMAT
{
    WMT_OFFSET_FORMAT_100NS,
    WMT_OFFSET_FORMAT_SMPTE,
    WMT_OFFSET_FORMAT_FRAME_NUMBERS,
    WMT_OFFSET_FORMAT_PLAYLIST_OFFSET
}   WMT_OFFSET_FORMAT;

///////////////////////////////////////////////////////////////////////////////
//
// Structures used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////

//
// Writer Statistics struct
//
typedef struct _WMWriterStatistics
{
    QWORD qwSampleCount;
    QWORD qwByteCount;

    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;

    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;

    //
    // Sample rates are given as 1000 * (samples / second).
    //
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
} WM_WRITER_STATISTICS;

//
// Reader Statistics struct
//
typedef struct _WMReaderStatistics
{
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD  wQuality;
} WM_READER_STATISTICS;

//
// Reader Client Info struct
//
typedef struct _WMReaderClientInfo
{
    DWORD  cbSize;
    WCHAR  *wszLang;              // 2-3 letter language code 
    WCHAR  *wszBrowserUserAgent;  // Embedded browser's user-agent string
    WCHAR  *wszBrowserWebPage;    // The web page that contains the plugin
    QWORD  qwReserved;            // Reserved
    LPARAM *pReserved;            // Reserved
    WCHAR  *wszHostExe;           // iexplore.exe, netscape.exe dshow.exe, etc
    QWORD  qwHostVersion;         // Version of the host application e.g.:4.70.12.15
} WM_READER_CLIENTINFO;

typedef struct _WMClientProperties
{
    DWORD   dwIPAddress;
    DWORD   dwPort;
} WM_CLIENT_PROPERTIES;

//
// Inclusive port number range.  
// Used by IWMReaderNetworkConfig.
//
typedef struct _WMPortNumberRange
{
    WORD   wPortBegin;
    WORD   wPortEnd;
} WM_PORT_NUMBER_RANGE;

///////////////////////////////////////////////////////////////////////////////
//
// Structure needed for using GetDRMProperty.
//
///////////////////////////////////////////////////////////////////////////////
typedef struct  _WM_LICENSE_STATE_DATA
{
    DWORD   dwSize;         // Size of the entire structure.
    DWORD   dwNumStates;    // Number of state data passed back in array of structure below
    DRM_LICENSE_STATE_DATA stateData[1];
} WM_LICENSE_STATE_DATA;

///////////////////////////////////////////////////////////////////////////////
//
// Media-type structures and GUIDs.
//
///////////////////////////////////////////////////////////////////////////////

//
// We use DirectShow media types in this SDK. However, to avoid conflict with
// their names, we define our own version of the structure. This is exactly
// the same as an AM_MEDIA_TYPE!
//
typedef struct _WMMediaType
{
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    [size_is(cbFormat)] BYTE *pbFormat;
} WM_MEDIA_TYPE;


cpp_quote( "typedef struct tagWMVIDEOINFOHEADER" )
cpp_quote( "{" )
cpp_quote( "    //" )
cpp_quote( "    // The bit we really want to use." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcSource;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Where the video should go." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcTarget;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Approximate bit data rate." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Bit error rate for this stream." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitErrorRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Average time per frame (100ns units)." )
cpp_quote( "    //" )
cpp_quote( "    LONGLONG AvgTimePerFrame;" )
cpp_quote( "" )
cpp_quote( "    BITMAPINFOHEADER bmiHeader;" )
cpp_quote( "} WMVIDEOINFOHEADER;" )

cpp_quote( "typedef struct tagWMSCRIPTFORMAT" )
cpp_quote( "{" )
cpp_quote( "    GUID    scriptType; ")
cpp_quote( "} WMSCRIPTFORMAT;" )

//
// This special GUID is used to create a subtype from an audio format tag, or
// video four-character code. Just fill in the first DWORD of the GUID with
// the appropriate value.
//
cpp_quote( "// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_Base, " )
cpp_quote( "0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Video, " )
cpp_quote( "0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB1, " )
cpp_quote( "0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB4, " )
cpp_quote( "0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB8, " )
cpp_quote( "0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB565, " )
cpp_quote( "0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB555, " )
cpp_quote( "0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB24, " )
cpp_quote( "0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB32, " )
cpp_quote( "0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_I420, " )
cpp_quote( "0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_IYUV, " )
cpp_quote( "0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YV12, " )
cpp_quote( "0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YUY2, " )
cpp_quote( "0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_UYVY, " )
cpp_quote( "0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YVYU, " )
cpp_quote( "0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YVU9, " )
cpp_quote( "0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MP43, " )
cpp_quote( "0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MP4S, " )
cpp_quote( "0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMV1, " )
cpp_quote( "0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 32564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMV2, " )
cpp_quote( "0x32564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MSS1, " )
cpp_quote( "0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Audio, " )
cpp_quote( "0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_PCM, " )
cpp_quote( "0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_DRM, " )
cpp_quote( "0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

//
// WM Audio v2 and v7 are actually compatible bitstreams.
//
cpp_quote( "// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, " )
cpp_quote( "0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, " )
cpp_quote( "0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, " )
cpp_quote( "0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_Script " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Script, " )
cpp_quote( "0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31            WMMEDIATYPE_Image " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Image, " )
cpp_quote( "0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); " )

cpp_quote( "// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo " )
cpp_quote( "EXTERN_GUID(WMFORMAT_VideoInfo, " )
cpp_quote( "0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); " )

cpp_quote( "// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx " )
cpp_quote( "EXTERN_GUID(WMFORMAT_WaveFormatEx, " )
cpp_quote( "0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); " )

cpp_quote( "// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script " )
cpp_quote( "EXTERN_GUID(WMFORMAT_Script, " )
cpp_quote( "0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); " )

cpp_quote( "// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings " )
cpp_quote( "EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, " )
cpp_quote( "0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); " )

///////////////////////////////////////////////////////////////////////////////
//
// IID GUIDs defined here.
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );" )
cpp_quote( "EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMMetadataEditor2,    0x203cffe3,0x2e18,0x4fdf,0xb5,0x9d,0x6e,0x71,0x53,0x05,0x34,0xcf );" )
cpp_quote( "EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced3,    0x5dc0674b,0xf04b,0x4a4e,0x9f,0x2a,0xb1,0xaf,0xde,0x2c,0x81,0x00 );" )
cpp_quote( "EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );" )
cpp_quote( "EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);")
cpp_quote( "EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);")
cpp_quote( "EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);")
cpp_quote( "EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);")
cpp_quote( "EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);")
cpp_quote( "EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);")
cpp_quote( "EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);")
cpp_quote( "EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);")
cpp_quote( "EXTERN_GUID( IID_IWMCodecInfo2,         0xaa65e273,0xb686,0x4056,0x91,0xec,0xdd,0x76,0x8d,0x4d,0xf7,0x10);")
cpp_quote( "EXTERN_GUID( IID_IWMPropertyVault,      0x72995A79,0x5090,0x42a4,0x9C,0x8C,0xD9,0xD0,0xB6,0xD3,0x4B,0xE5 );" )


///////////////////////////////////////////////////////////////////////////////
//
// Other GUIDs defined here
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );" )


///////////////////////////////////////////////////////////////////////////////
//
// Max Video Streams / Bands 
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "#define WM_MAX_VIDEO_STREAMS            0x00c" )


///////////////////////////////////////////////////////////////////////////////
//
// Creation functions.
//
// The SDK supports 3 major objects:
// - CLSID_WMWriter - For writing out WM content.
// - CLSID_WMReader - For playing back WM content.
// - CLSID_WMMetadataEditor - For getting and editing header metadata in WM
//   content.
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateCertificate( IUnknown** pUnkCert );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );" )

cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );" )

///////////////////////////////////////////////////////////////////////////////
//
// The following interfaces define the media types that this SDK supports.
// These media types are used by the writer, the reader, and the profile
// object, to identify the media-type specific properties of a media stream.
//
// The main media type is stored in the WM_MEDIA_TYPE structure. Some
// interesting (option) parameters may exist for particular stream types;
// in that case, an IWM<x>MediaProps interface can be used to get and set
// these additional parameters.
//


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BCE-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMMediaProps : IUnknown
{
    //
    // GetType is provided for convenience; it returns the same as the
    // majortype of the WM_MEDIA_TYPE.
    //
    HRESULT GetType( [out] GUID *pguidType );

    HRESULT GetMediaType( [out] WM_MEDIA_TYPE *pType,
                          [in, out] DWORD *pcbType );
    HRESULT SetMediaType( [in] WM_MEDIA_TYPE *pType );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BCF-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMVideoMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMVideoMediaProps : IWMMediaProps
{
    HRESULT GetMaxKeyFrameSpacing( [out] LONGLONG *pllTime );
    HRESULT SetMaxKeyFrameSpacing( [in] LONGLONG llTime );

    HRESULT GetQuality( [out] DWORD *pdwQuality );
    HRESULT SetQuality( [in] DWORD dwQuality );
};


///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMWriter basic interfaces.
//
// Usage scenario is as follows:
// 1) SetProfile to define the configuration.
// 2) Set the outputs.
// 3) Call GetInputCount (which is valid after (1)), and GetInputProps for
//    each stream. Get the default input format, and change it if desired.
// 3.5) Call SetAttribute to add metadata to the header
// At this point, the writer has been configured.
// 4) Call WriteSample repeatedly, until done. (Note that the AllocateSample
//    call is just provided for convenience. You are welcome to pass in your
//    own samples.)
// 5) Call Flush to write out any buffered data, and update the header and
//    index.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD4-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriter Interface"),
    pointer_default(unique),
    local
]
interface IWMWriter : IUnknown
{
    // This interface QI's for IWMHeaderInfo, and IWMWriterAdvanced.

    //
    // There are 3 options for setting the profile on the writer. Note that
    // setting the profile means that the profile is copied into the writer.
    // Further editing of that profile object will have no effect, unless
    // SetProfile() is called again.
    //
    // Calling SetProfile() removes any previously set header attribute info
    //
    HRESULT SetProfileByID( [in] REFGUID guidProfile );
    HRESULT SetProfile( [in] IWMProfile *pProfile );

    //
    // The easiest way to use the writer is just to write to file.
    //
    HRESULT SetOutputFilename( [in] const WCHAR *pwszFilename );

    //
    // The user can enumerate through the various inputs, and get the input
    // format. Note that these are not ASF streams; one input stream may map
    // to multiple ASF streams in a MEB scenario.
    //
    // Manipulating the IWMInputMediaProps has no effect on the writer, unless
    // the user calls SetInputProps to configure the input.
    //
    HRESULT GetInputCount( [out] DWORD *pcInputs );
    HRESULT GetInputProps( [in] DWORD dwInputNum,
                           [out] IWMInputMediaProps **ppInput );
    HRESULT SetInputProps( [in] DWORD dwInputNum,
                           [in] IWMInputMediaProps *pInput );

    //
    // Used for determining all possible format types supported by this
    // input on the writer. 
    //
    HRESULT GetInputFormatCount(    [in] DWORD dwInputNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetInputFormat( [in] DWORD dwInputNumber,
                            [in] DWORD dwFormatNumber,
                            [out] IWMInputMediaProps** pProps );

    //
    // You must call BeginWriting before sending any samples, and
    // you must call EndWriting when you're done sending samples.
    //
    HRESULT BeginWriting();

    //
    // EndWriting flushes everything, updates indices and headers,
    // and closes the file.
    //
    HRESULT EndWriting();

    //
    // Allocate a sample. This is optional; the user is welcome to allocate
    // their own buffer class.
    //
    HRESULT AllocateSample( [in] DWORD dwSampleSize,
                            [out] INSSBuffer **ppSample );

    HRESULT WriteSample( [in] DWORD dwInputNum,
                         [in] QWORD cnsSampleTime,
                         [in] DWORD dwFlags,
                         [in] INSSBuffer *pSample );

    //
    // Flush() will flush the writer, but leaves the writer prepared to run
    // again, when WriteSample() is called again.
    // Flush() also causes an updated header to be sent to the sink.
    //
    HRESULT Flush();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD5-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMInputMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMInputMediaProps : IWMMediaProps
{
    HRESULT GetConnectionName( [out] WCHAR *pwszName,
                               [in, out] WORD *pcchName );
    HRESULT GetGroupName( [out] WCHAR *pwszName,
                          [in, out] WORD *pcchName );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 72995A79-5090-42a4-9C8C-D9D0B6D34BE5 ),
    helpstring( "IWMPropertyVault Interface"),
    pointer_default(unique),
    local
]
interface IWMPropertyVault : IUnknown
{
    HRESULT GetPropertyCount(
                              [in] DWORD   *pdwCount );

    HRESULT GetPropertyByName(
                              [in] LPCWSTR pszName,
                              [out] WMT_ATTR_DATATYPE *pType,
                              [out] BYTE *pValue,
                              [in,out] DWORD *pdwSize );

    HRESULT SetProperty(
                              [in] LPCWSTR pszName,
                              [in] WMT_ATTR_DATATYPE pType,
                              [in] BYTE *pValue,
                              [in] DWORD dwSize );

    HRESULT GetPropertyByIndex(
                              [in] DWORD   dwIndex,
                              [out] LPWSTR pszName,
                              [in, out]  DWORD   *pdwNameLen,
                              [out] WMT_ATTR_DATATYPE *pType,
                              [out] BYTE *pValue,
                              [in,out] DWORD *pdwSize );

    HRESULT CopyPropertiesFrom(
                              [in] IWMPropertyVault    *pIWMPropertyVault );

    HRESULT Clear();
};

///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMReader basic interfaces.
//
// Usage is as follows:
// 1) Call Open with a URL (possibly a local filename) and a user-supplied
//    callback. After open has completed, the file has been opened and parsed.
// 2) Call GetOutputCount, and GetOutputProps for each output. This
//    is valid after (1). This allows the user to get the output format for
//    each output.
// 3) Call Start. Status messages and samples will begin arriving in the
//    callback function.
// 4) Continue with any combination of Start/Stop/Pause/Seek/SetRate, until
//    finished.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD6-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReader Interface"),
    pointer_default(unique),
    local
]
interface IWMReader : IUnknown
{
    //
    // This interface QI's for IWMHeaderInfo, IWMProfile, IWMReaderAdvanced,
    // IWMReaderAdvanced2, and IWMReaderAdvanced3.
    //

    //
    // Open is an asynch call; it returns almost immediately (if the URL
    // is valid), and the user should wait for appropriate OnStatus calls to
    // be sent to the callback.
    //
    HRESULT Open( [in] const WCHAR *pwszURL,
                  [in] IWMReaderCallback *pCallback,
                  [in] void *pvContext );
    HRESULT Close();

    //
    // The user can enumerate through the various outputs, and get the
    // output format for that data.
    //
    // Manipulating the IWMOutputMediaProps has no effect on the output, unless
    // the user also calls SetOutputProps.
    //
    HRESULT GetOutputCount( [out] DWORD *pcOutputs );
    HRESULT GetOutputProps( [in] DWORD dwOutputNum,
                            [out] IWMOutputMediaProps **ppOutput );
    HRESULT SetOutputProps( [in] DWORD dwOutputNum,
                            [in] IWMOutputMediaProps *pOutput );

    //
    // Used for determining all possible format types supported by this
    // output on the reader. 
    //
    HRESULT GetOutputFormatCount(   [in] DWORD dwOutputNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetOutputFormat( [in] DWORD dwOutputNumber,
                             [in] DWORD dwFormatNumber,
                             [out] IWMOutputMediaProps** ppProps );
                             
    //
    // If duration is 0, play to the end of the file.
    // If msStart is set to WM_START_CURRENTPOSITION then don't perform a seek
    // operation.  A good use for this is when you want to change the rate but
    // not the current file position.  
    //
    // Note that any call to start while Paused will be treated as a seek.
    // Even calls to Start( WM_START_CURRENTPOSITION, ... ).  If your intention
    // is to seek (which will incur the buffering penalty from network files)
    // then you can go ahead and call Start.  However, if your intention was
    // to continue playing from where the user paused, you should call Resume
    // instead.
    //
    HRESULT Start( [in] QWORD cnsStart, 
                   [in] QWORD cnsDuration, 
                   [in] float fRate, 
                   [in] void *pvContext );
    HRESULT Stop();
    HRESULT Pause();
    HRESULT Resume();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD7-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMOutputMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMOutputMediaProps : IWMMediaProps
{
    //
    // A Stream Group and type together uniquely identify each output. (The
    // type is on IWMMediaProps).
    //
    HRESULT GetStreamGroupName( [out] WCHAR *pwszName,
                                [in, out] WORD *pcchName );
    HRESULT GetConnectionName( [out] WCHAR *pwszName,
                               [in, out] WORD *pcchName );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6d7cdc70-9888-11d3-8edc-00c04f6109cf ),
    helpstring( "IWMStatusCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMStatusCallback : IUnknown
{
    //
    // The contents of pValue depends on the Status.
    //
    HRESULT OnStatus( [in] WMT_STATUS Status, 
                      [in] HRESULT hr,
                      [in] WMT_ATTR_DATATYPE dwType,
                      [in] BYTE *pValue,
                      [in] void *pvContext );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD8-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderCallback : IWMStatusCallback
{
    //
    // cnsSampleDuration will be 0 for most media types.
    //
    HRESULT OnSample( [in] DWORD dwOutputNum,
                      [in] QWORD cnsSampleTime,
                      [in] QWORD cnsSampleDuration,
                      [in] DWORD dwFlags,
                      [in] INSSBuffer *pSample,
                      [in] void *pvContext );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 342e0eb7-e651-450c-975b-2ace2c90c48e ),
    helpstring( "IWMCredentialCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMCredentialCallback : IUnknown
{
    HRESULT AcquireCredentials( [in] WCHAR *pwszRealm,
                                [in] WCHAR *pwszSite,
                                [in, out, size_is( cchUser )] WCHAR *pwszUser,
                                [in] DWORD cchUser,
                                [in, out, size_is( cchPassword )] WCHAR *pwszPassword,
                                [in] DWORD cchPassword,
                                [in] HRESULT hrStatus,
                                [in, out] DWORD *pdwFlags );
};

///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMMetadataEditor basic interfaces.
//
// Usage:
// 1) Call Open with a filename.
// 2) QI for IWMHeaderInfo, and use that to get and set attributes as
//    needed.
// 3) Flush() will cause any changes to be written back to disk (if possible).
// 4) Close() closes the file without writing any changes to disk.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD9-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMetadataEditor Interface"),
    pointer_default(unique),
    local
]
interface IWMMetadataEditor : IUnknown
{
    // QI this for IWMHeaderInfo to edit the header attributes.

    //
    // Manage the file
    //
    HRESULT Open( [in] const WCHAR *pwszFilename );
    HRESULT Close();
    HRESULT Flush();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 203CFFE3-2E18-4fdf-B59D-6E71530534CF ),
    helpstring( "IWMMetadataEditor2 Interface" ),
    pointer_default(unique),
    local
]
interface IWMMetadataEditor2 : IWMMetadataEditor
{
    //
    // The flags to dwDesiredAccess and dwShareMode match the flags to
    // (the win32 API) CreateFile.
    //
    // Supported modes are:
    //   GENERIC_READ | GENERIC_WRITE, 0
    //   GENERIC_READ, 0 or
    //                 FILE_SHARE_READ or
    //                 FILE_SHARE_DELETE or
    //                 FILE_SHARE_READ | FILE_SHARE_DELETE
    //
    HRESULT OpenEx( [in] const WCHAR *pwszFilename, 
                    [in] DWORD dwDesiredAccess,
                    [in] DWORD dwShareMode );
};


///////////////////////////////////////////////////////////////////////////////
//
// Below are utility interfaces used across all 3 of the main objects.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDA-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMHeaderInfo Interface"),
    pointer_default(unique),
    local
]
//
// The 3 main interface (IWMWriter, IWMReader, and 
// IWMMetadataEditor) can be QI'd for this interface to get and set
// header attributes, and markers.
//
interface IWMHeaderInfo : IUnknown
{
    //
    // For attributes, the stream number passed in means:
    // -1 (0xffff) to specifies "any or no stream".
    // 0 specifies "no stream".
    // Any other value indicates the stream number.
    //
    // Windows Media version 4 and earlier does not support per stream
    // attributes, so any stream number other than 0 will fail.
    //
    HRESULT GetAttributeCount( [in] WORD wStreamNum,
                               [out] WORD *pcAttributes );
    HRESULT GetAttributeByIndex( [in] WORD wIndex,
                                 [in, out] WORD *pwStreamNum,
                                 [out] WCHAR *pwszName,
                                 [in,out] WORD *pcchNameLen,
                                 [out] WMT_ATTR_DATATYPE *pType,
                                 [out] BYTE *pValue,
                                 [in,out] WORD *pcbLength );
    HRESULT GetAttributeByName( [in, out] WORD *pwStreamNum,
                                [in] LPCWSTR pszName,
                                [out] WMT_ATTR_DATATYPE *pType,
                                [out] BYTE *pValue,
                                [in,out] WORD *pcbLength );
    HRESULT SetAttribute( [in] WORD wStreamNum,
                          [in] LPCWSTR pszName,
                          [in] WMT_ATTR_DATATYPE Type,
                          [in] const BYTE *pValue,
                          [in] WORD cbLength );

    //
    // Marker methods.
    //
    HRESULT GetMarkerCount( [out] WORD *pcMarkers );
    HRESULT GetMarker( [in] WORD wIndex,
                       [out] WCHAR *pwszMarkerName,
                       [in, out] WORD *pcchMarkerNameLen,
                       [out] QWORD *pcnsMarkerTime );
    HRESULT AddMarker( [in] WCHAR *pwszMarkerName,
                       [in] QWORD cnsMarkerTime );
    HRESULT RemoveMarker( [in] WORD wIndex );

    //
    // Script command methods.
    //
    HRESULT GetScriptCount( [out] WORD *pcScripts );
    HRESULT GetScript( [in] WORD wIndex,
                       [out] WCHAR *pwszType,
                       [in, out] WORD *pcchTypeLen,
                       [out] WCHAR *pwszCommand,
                       [in, out] WORD *pcchCommandLen,
                       [out] QWORD *pcnsScriptTime );
    HRESULT AddScript( [in] WCHAR *pwszType,
                       [in] WCHAR *pwszCommand,
                       [in] QWORD cnsScriptTime );
    HRESULT RemoveScript( [in] WORD wIndex );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 15CF9781-454E-482e-B393-85FAE487A810 ),
    helpstring( "IWMHeaderInfo Interface"),
    pointer_default(unique),
    local
]
//
// The 3 main interface (IWMWriter, IWMReader, and 
// IWMMetadataEditor) can be QI'd for this interface to get and set
// header attributes, and markers.
//
interface IWMHeaderInfo2 : IWMHeaderInfo
{
    HRESULT GetCodecInfoCount(  [out]   DWORD*  pcCodecInfos );
    HRESULT GetCodecInfo(       [in]    DWORD   wIndex,
                                [in,out] WORD*  pcchName,
                                [out]   WCHAR*  pwszName,
                                [in,out] WORD*  pcchDescription,
                                [out]   WCHAR*  pwszDescription,
                                [out]   WMT_CODEC_INFO_TYPE*    pCodecType,
                                [in,out] WORD*  pcbCodecInfo,
                                [out]   BYTE*   pbCodecInfo );
};


///////////////////////////////////////////////////////////////////////////////
//
// The profile API. The intention is that most users don't touch the profile
// API, but just use pre-existing profiles.
//
// Profiles define authoring configurations, such as stream types, bitrates,
// etc.
//
///////////////////////////////////////////////////////////////////////////////


[
    object,
    uuid( d16679f2-6ca0-472d-8d31-2f5d55aee155 ),
    helpstring( "IWMProfileManager Interface"),
    pointer_default(unique),
    local
]
interface IWMProfileManager : IUnknown
{
    //
    // Create a profile with nothing in it.
    //
    HRESULT CreateEmptyProfile( [in] WMT_VERSION dwVersion,
                                [out] IWMProfile **ppProfile );

    //
    // Load a system profile given its ID.
    //
    HRESULT LoadProfileByID( [in] REFGUID guidProfile,
                               [out] IWMProfile **ppProfile );

    //
    // Load a profile from a stored string.
    //
    HRESULT LoadProfileByData( [in] const WCHAR *pwszProfile,
                               [out] IWMProfile **ppProfile );

    //
    // Save profile specified by its string.
    //
    HRESULT SaveProfile( [in] IWMProfile *pIWMProfile, [in] WCHAR *pwszProfile, [in, out] DWORD *pdwLength );

    //
    // Iterate through the system profiles.
    //
    HRESULT GetSystemProfileCount( [out] DWORD *pcProfiles );
    HRESULT LoadSystemProfile( [in] DWORD dwProfileIndex,
                               [out] IWMProfile **ppProfile );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 7A924E51-73C1-494d-8019-23D37ED9B89A ),
    helpstring( "IWMProfileManager2 Interface"),
    pointer_default(unique),
    local
]
interface IWMProfileManager2 : IWMProfileManager
{
    //
    // Set the version number of the system profiles that the profile manager
    // will enumerate. WMT_VER_4_0 is the default, for compatibility reasons,
    // so be sure to set this to the latest version if that is the desired 
    // result.
    //
    HRESULT GetSystemProfileVersion( WMT_VERSION *pdwVersion );
    HRESULT SetSystemProfileVersion( WMT_VERSION dwVersion );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDB-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMProfile Interface"),
    pointer_default(unique),
    local
]
interface IWMProfile : IUnknown
{
    //
    // By default, when the user creates a profile, it will use the latest
    // version of Windows Media. To create a backward-compatible profile,
    // call IWMProfileManager::CreateEmptyProfile with the appropriate version
    // number.
    //
    HRESULT GetVersion( [out] WMT_VERSION *pdwVersion );

    //
    // Profiles have names and descriptions, for use when displaying lists
    // of profiles, etc.
    //
    HRESULT GetName( [out] WCHAR *pwszName,
                     [in, out] DWORD *pcchName );
    HRESULT SetName( [in] const WCHAR *pwszName );
    HRESULT GetDescription( [out] WCHAR *pwszDescription,
                            [in, out] DWORD *pcchName );
    HRESULT SetDescription( [in] const WCHAR *pwszDescription );

    //
    // Methods for enumerating the streams. Note that updating the
    // returned IWMStreamConfig has no effect on the profile until you
    // call ReconfigStream().
    //
    HRESULT GetStreamCount( [out] DWORD *pcStreams );
    HRESULT GetStream( [in] DWORD dwStreamIndex,
                       [out] IWMStreamConfig **ppConfig );
    HRESULT GetStreamByNumber( [in] WORD wStreamNum,
                               [out] IWMStreamConfig **ppConfig );
    //
    // Remove a stream.
    //
    HRESULT RemoveStream( [in] IWMStreamConfig *pConfig );
    HRESULT RemoveStreamByNumber( [in] WORD wStreamNum );

    //
    // Adding a stream copies the config into the profile. 
    //
    HRESULT AddStream( [in] IWMStreamConfig *pConfig );
    HRESULT ReconfigStream( [in] IWMStreamConfig *pConfig );

    //
    // Create a new stream config object (avoiding the need to CoCreate).
    // This will still need to be added to the profile using the AddStream()
    // call (but only after it has been configured).
    //
    HRESULT CreateNewStream( [in] REFGUID guidStreamType,
                             [out] IWMStreamConfig **ppConfig );

    //
    // Mutual Exclusion. As above, only Add and Remove actual change the
    // profile.
    //
    HRESULT GetMutualExclusionCount( [out] DWORD *pcME );
    HRESULT GetMutualExclusion( [in] DWORD dwMEIndex,
                                [out] IWMMutualExclusion **ppME );
    HRESULT RemoveMutualExclusion( [in] IWMMutualExclusion *pME );
    HRESULT AddMutualExclusion( [in] IWMMutualExclusion *pME );
    HRESULT CreateNewMutualExclusion( [out] IWMMutualExclusion **ppME );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 07E72D33-D94E-4be7-8843-60AE5FF7E5F5 ),
    helpstring( "IWMProfile2 Interface"),
    pointer_default(unique),
    local
]
interface IWMProfile2 : IWMProfile
{
    //
    // Get/set this profile's unique identifier
    //
    HRESULT GetProfileID( [out] GUID*       pguidID );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDC-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMStreamConfig Interface"),
    pointer_default(unique),
    local
]
//
// IWMStreamConfig represents an ASF stream.
//
interface IWMStreamConfig : IUnknown
{
    // This interface QI's for IWMMediaProps and one of it's inheritors.
    // (IWMVideoMediaProps, for instance). 

    HRESULT GetStreamType( [out] GUID *pguidStreamType );

    HRESULT GetStreamNumber( [out] WORD *pwStreamNum );
    HRESULT SetStreamNumber( [in] WORD wStreamNum );

    HRESULT GetStreamName( [out] WCHAR *pwszStreamName,
                           [in, out] WORD *pcchStreamName );
    HRESULT SetStreamName( [in] WCHAR *pwszStreamName );

    HRESULT GetConnectionName( [out] WCHAR *pwszInputName,
                               [in, out] WORD *pcchInputName );
    HRESULT SetConnectionName( [in] WCHAR *pwszInputName );

    HRESULT GetBitrate( [out] DWORD *pdwBitrate );
    HRESULT SetBitrate( [in] DWORD pdwBitrate );

    //
    // A buffer window of -1 (0xffffffff) indicates that the buffer window
    // is unknown. On the writer side, this means the writer can use whatever
    // buffer window it chooses.
    //
    HRESULT GetBufferWindow( [out] DWORD *pmsBufferWindow );
    HRESULT SetBufferWindow( [in] DWORD msBufferWindow );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( CDFB97AB-188F-40b3-B643-5B7903975C59 ),
    helpstring( "IWMPacketSize Interface"),
    pointer_default(unique),
    local
]
//
// Controls how big packets can get in an ASF file.
//
interface IWMPacketSize : IUnknown
{
    HRESULT GetMaxPacketSize( [out] DWORD *pdwMaxPacketSize );
    HRESULT SetMaxPacketSize( [in]  DWORD dwMaxPacketSize );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDD-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMStreamList Interface"),
    pointer_default(unique),
    local
]
//
// IWMStreamList is used for the various objects that define relationships
// between streams.
//
interface IWMStreamList : IUnknown
{
    HRESULT GetStreams( [out] WORD *pwStreamNumArray,
                        [in, out] WORD *pcStreams );

    HRESULT AddStream( [in] WORD wStreamNum );
    HRESULT RemoveStream( [in] WORD wStreamNum );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDE-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMutualExclusion Interface"),
    pointer_default(unique),
    local
]
//
// IWMMutualExclusion specifies a group of streams, of which only one can
// be played at once. These are used to do MEB (stream selection based on
// bandwidth).
//
interface IWMMutualExclusion : IWMStreamList
{
    //
    // The possible types of mutual exclusion are defined in the ASF
    // header.
    //
    HRESULT GetType( [out] GUID *pguidType );
    HRESULT SetType( [in] REFGUID guidType );
};



///////////////////////////////////////////////////////////////////////////////
//
// Advanced features.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE3-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterAdvanced : IUnknown
{
    //
    // Sinks are where the output ASF data goes.
    //
    HRESULT GetSinkCount( [out] DWORD *pcSinks );
    HRESULT GetSink( [in] DWORD dwSinkNum,
                     [out] IWMWriterSink **ppSink );
    HRESULT AddSink( [in] IWMWriterSink *pSink );
    HRESULT RemoveSink( [in] IWMWriterSink *pSink );

    //
    // By default, the user provides samples to an input on the
    // IWMWriter interface, and the samples may be compressed, put
    // into a MEB stream, etc. However, the user can use this interface to
    // put the samples directly into the ASF, with no compression etc.
    //
    HRESULT WriteStreamSample( [in] WORD wStreamNum,
                               [in] QWORD cnsSampleTime,
                               [in] DWORD msSampleSendTime,
                               [in] QWORD cnsSampleDuration,
                               [in] DWORD dwFlags,
                               [in] INSSBuffer *pSample );

    //
    // The writer may be running in real-time. If so, it's interesting to
    // get the current time from the writer.
    //
    HRESULT SetLiveSource( BOOL fIsLiveSource );
    HRESULT IsRealTime( [out] BOOL *pfRealTime );
    HRESULT GetWriterTime( [out] QWORD *pcnsCurrentTime );

    //
    // To get statistics, pass in a WM_WRITER_STATISTICS structure, which
    // will be filled out by the GetStatistics() call with the requested
    // stats.
    //
    // Pass in a stream number to get statistics for a specific stream, or
    // pass 0 to get statistics for the entire ASF file.
    //
    HRESULT GetStatistics( [in] WORD wStreamNum,
                           [out] WM_WRITER_STATISTICS *pStats );

    //
    // Sync tolerance determines how far out of sync the inputs will be allowed
    // to get before samples are thrown away.  Default is 3000 ms.
    //
    HRESULT SetSyncTolerance(   [in]    DWORD   msWindow );
    HRESULT GetSyncTolerance(   [out]   DWORD*  pmsWindow );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 962dc1ec-c046-4db8-9cc7-26ceae500817 ),
    helpstring( "IWMWriterAdvanced2 Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterAdvanced2 : IWMWriterAdvanced
{
    //
    // Retrieves a setting for a particular output by name
    //
    HRESULT GetInputSetting( 
                    [in] DWORD dwInputNum,
                    [in] LPCWSTR pszName,
                    [out] WMT_ATTR_DATATYPE *pType,
                    [out] BYTE *pValue,
                    [in,out] WORD *pcbLength );

    //
    // Sets a named setting for a particular input
    //
    HRESULT SetInputSetting(
                    [in] DWORD dwInputNum,
                    [in] LPCWSTR pszName,
                    [in] WMT_ATTR_DATATYPE Type,
                    [in] const BYTE *pValue,
                    [in] WORD cbLength );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( D9D6549D-A193-4f24-B308-03123D9B7F8D ),
    helpstring( "IWMWriterPostViewCallback Interface"),
    pointer_default(unique),
    local
]
//
// This is the interface that receives uncompressed samples from the writer 
// to preview (well, postview) what the codec is doing.
//
interface IWMWriterPostViewCallback : IWMStatusCallback
{

    //
    // cnsSampleDuration will be 0 for most media types.
    //
    HRESULT OnPostViewSample(   [in] WORD  wStreamNumber,
                                [in] QWORD cnsSampleTime,
                                [in] QWORD cnsSampleDuration,
                                [in] DWORD dwFlags,
                                [in] INSSBuffer *pSample,
                                [in] void *pvContext );

    HRESULT AllocateForPostView([in] WORD wStreamNum,
                                [in] DWORD cbBuffer,
                                [out] INSSBuffer **ppBuffer,
                                [in] void *pvContext );    

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 81E20CE4-75EF-491a-8004-FC53C45BDC3E ),
    helpstring( "IWMWriterPostView Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterPostView : IUnknown
{
    //
    // Specify the callback to use for PostView
    //
    HRESULT SetPostViewCallback( IWMWriterPostViewCallback*  pCallback, void* pvContext );

    //
    // Turns on delivery of postview samples for a given stream
    //
    HRESULT SetReceivePostViewSamples(  [in] WORD wStreamNum,
                                        [in] BOOL fReceivePostViewSamples );
    HRESULT GetReceivePostViewSamples(  [in] WORD wStreamNum,
                                        [out] BOOL *pfReceivePostViewSamples );

    //
    // The user can enumerate through the various outputs, and get the
    // output format for that data.
    //
    // Manipulating the IWMOutputMediaProps has no effect on the output, unless
    // the user also calls SetOutputProps.
    //
    HRESULT GetPostViewProps(   [in] WORD wStreamNumber,
                                [out] IWMMediaProps **ppOutput );
    HRESULT SetPostViewProps(   [in] WORD wStreamNumber,
                                [in] IWMMediaProps *pOutput );

    //
    // Used for determining all possible format types supported by this
    // output on the reader. 
    //
    HRESULT GetPostViewFormatCount( [in]  WORD wStreamNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetPostViewFormat(  [in] WORD  wStreamNumber,
                                [in] DWORD dwFormatNumber,
                                [out] IWMMediaProps** ppProps );

    //
    // The user can register himself to provide buffers for any of the outputs
    // (for instance, DDraw buffers). The actual allocation is on the
    // IWMReaderCallbackAdvanced interface.
    //
    HRESULT SetAllocateForPostView( [in] WORD wStreamNumber,
                                    [in] BOOL fAllocate );
    HRESULT GetAllocateForPostView( [in]  WORD wStreamNumber,
                                    [out] BOOL *pfAllocate );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE4-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterSink Interface"),
    pointer_default(unique),
    local
]
//
// This is the interface that receives raw ASF from the writer.
//
interface IWMWriterSink : IUnknown
{
    HRESULT OnHeader( [in] INSSBuffer *pHeader );

    //
    // Some sinks require that data be fed to them in real-time.
    //
    HRESULT IsRealTime( [out] BOOL *pfRealTime );

    HRESULT AllocateDataUnit( [in] DWORD cbDataUnit,
                              [out] INSSBuffer **ppDataUnit );
    HRESULT OnDataUnit( [in] INSSBuffer *pDataUnit );

    //
    // This function is called when the writer is done sending data.
    // 
    HRESULT OnEndWriting();
};



///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( CF4B1F99-4DE2-4e49-A363-252740D99BC1 ),
    helpstring( "IWMRegisterCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMRegisterCallback : IUnknown
{
    HRESULT Advise( [in]    IWMStatusCallback*  pCallback, 
                    [in]    void*               pvContext );

    HRESULT Unadvise( [in]  IWMStatusCallback*  pCallback,
                    [in]    void*               pvContext );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE5-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterFileSink Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterFileSink : IWMWriterSink
{
    HRESULT Open( [in] const WCHAR *pwszFilename );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 14282BA7-4AEF-4205-8CE5-C229035A05BC ),
    helpstring( "IWMWriterFileSink2 Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterFileSink2 : IWMWriterFileSink
{
    HRESULT Start(  [in]    QWORD cnsStartTime );
    HRESULT Stop(   [in]    QWORD cnsStopTime );
    HRESULT IsStopped(       [out] BOOL *pfStopped );

    HRESULT GetFileDuration( [out] QWORD *pcnsDuration );
    HRESULT GetFileSize(     [out] QWORD *pcbFile );

    HRESULT Close();
    HRESULT IsClosed(        [out] BOOL *pfClosed );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE7-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterNetworkSink Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterNetworkSink : IWMWriterSink
{
    //
    // Determine the maximum number of clients that can connect to this sink.
    // Default is 10.
    //
    HRESULT SetMaximumClients( [in] DWORD dwMaxClients );
    HRESULT GetMaximumClients( [out] DWORD *pdwMaxClients );

    //
    // The network protocol that the network sink will use.
    //
    HRESULT SetNetworkProtocol( [in] WMT_NET_PROTOCOL protocol );
    HRESULT GetNetworkProtocol( [out] WMT_NET_PROTOCOL *pProtocol );

    //
    // Find out the name of the URL on which we're broadcasting
    //
    HRESULT GetHostURL( [out] WCHAR *pwszURL,
                        [in, out] DWORD *pcchURL );

    //
    // The method claims the network port number. Close the sink to release
    // the port.
    //
    // Specify 0 for the port number and the sink will select a port for
    // the user.
    //
    HRESULT Open( [in, out] DWORD *pdwPortNum );

    //
    // Disconnect all connected clients.
    //
    HRESULT Disconnect();

    //
    // Close and release the open port.
    //
    HRESULT Close();
};



///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 73C66010-A299-41df-B1F0-CCF03B09C1C6 ),
    helpstring( "IWMClientConnections Interface"),
    pointer_default(unique),
    local
]
interface IWMClientConnections : IUnknown
{
    //
    // Determine the number of connected clients 
    //
    HRESULT GetClientCount( [out] DWORD* pcClients );

    //
    // Get information about a connected client
    //
    HRESULT GetClientProperties( [in] DWORD dwClientNum, 
                                 [out] WM_CLIENT_PROPERTIES *pClientProperties );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BEA-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// The reader can be QI'd for this interface for advanced functionality.
//
interface IWMReaderAdvanced : IUnknown
{
    //
    // The user may want to drive the clock himself, particularly if he wants
    // to source from a file faster-than-realtime. This call may fail if the
    // current source does not support user-driven clocks.
    //
    // The proper way for a user to drive the clock is for the user to call
    // DeliverTime, and then wait for the OnTime call on 
    // IWMReaderCallbackAdvanced to reach the time he specified.
    //
    HRESULT SetUserProvidedClock( [in] BOOL fUserClock );
    HRESULT GetUserProvidedClock( [out] BOOL *pfUserClock );
    HRESULT DeliverTime( [in] QWORD cnsTime );

    //
    // The user can select streams manually, instead of relying on the
    // automatic bandwidth stream selection that the reader will
    // normally do. To figure out what streams are in this ASF and what their
    // numbers are, QI for IWMProfile.
    //
    // When SetManualStreamSelection( TRUE ) is called, all streams are
    // selected by default.
    //
    HRESULT SetManualStreamSelection( [in] BOOL fSelection );
    HRESULT GetManualStreamSelection( [out] BOOL *pfSelection );
    HRESULT SetStreamsSelected( [in] WORD cStreamCount,
                                [in] WORD *pwStreamNumbers,
                                [in] WMT_STREAM_SELECTION *pSelections );
    HRESULT GetStreamSelected( [in] WORD wStreamNum,
                               [out] WMT_STREAM_SELECTION *pSelection );

    //
    // The user can also choose to get callbacks when automatic stream
    // selection occurs.
    //
    HRESULT SetReceiveSelectionCallbacks( [in] BOOL fGetCallbacks );
    HRESULT GetReceiveSelectionCallbacks( [in] BOOL *pfGetCallbacks );

    //
    // The user can register himself to receive samples directly from the
    // ASF streams, rather than letting the Reader decompress them. Note that
    // to do this, the IWMReaderCallback (supplied by the user) must support
    // IWMReaderCallbackAdvanced.
    //
    // To get actual information about the contents of a stream, QI the
    // object for IWMProfile.
    //
    HRESULT SetReceiveStreamSamples( [in] WORD wStreamNum,
                                     [in] BOOL fReceiveStreamSamples );
    HRESULT GetReceiveStreamSamples( [in] WORD wStreamNum,
                                     [out] BOOL *pfReceiveStreamSamples );

    //
    // The user can register himself to provide buffers for any of the outputs
    // (for instance, DDraw buffers). The actual allocation is on the
    // IWMReaderCallbackAdvanced interface.
    //
    HRESULT SetAllocateForOutput( [in] DWORD dwOutputNum,
                                  [in] BOOL fAllocate );
    HRESULT GetAllocateForOutput( [in] DWORD dwOutputNum,
                                  [out] BOOL *pfAllocate );

    HRESULT SetAllocateForStream( [in] WORD dwStreamNum,
                                  [in] BOOL fAllocate );
    HRESULT GetAllocateForStream( [in] WORD dwSreamNum,
                                  [out] BOOL *pfAllocate );

    //
    // Get statistics on demand
    //
    HRESULT GetStatistics( [in] WM_READER_STATISTICS *pStatistics );

    //
    // Set client side information used for logging
    //
    HRESULT SetClientInfo( [in] WM_READER_CLIENTINFO *pClientInfo );

    //
    // Get the maximum required buffer sizes that the SDK will allocate.
    // The first is for output buffers, the second for stream buffers.
    //
    HRESULT GetMaxOutputSampleSize( [in] DWORD dwOutput, [out] DWORD *pcbMax );
    HRESULT GetMaxStreamSampleSize( [in] WORD wStream, [out] DWORD *pcbMax );

    //
    // Used to notify the reader that it's delivering data
    // too slowly to the client.  The reader will try to speed
    // up.
    //
    HRESULT NotifyLateDelivery( QWORD cnsLateness );

};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( ae14a945-b90c-4d0d-9127-80d665f7d73e ),
    helpstring( "IWMReaderAdvanced2 Interface"),
    pointer_default(unique),
    local
]
//
// The reader can be QI'd for this interface for advanced functionality.
//
interface IWMReaderAdvanced2 : IWMReaderAdvanced
{
    //
    // Set the play mode to WMT_PLAY_MODE_AUTOSELECT to allow the reader
    // to pick the mode. (This is the default). If you select a play mode that
    // is impossible for the requested URL, an error will be returned when
    // the URL is opened.
    //
    HRESULT SetPlayMode( [in] WMT_PLAY_MODE Mode );

    //
    // Get the current play mode.
    //
    HRESULT GetPlayMode( [out] WMT_PLAY_MODE *pMode );

    //
    // Between WMT_BUFFERING_START and WMT_BUFFERING_STOP this call will
    // return progress values. pdwPercent returns the percentage of buffering
    // that has completed, and pcnsBuffering returns the amount of buffering
    // remaining.
    //
    HRESULT GetBufferProgress( [out] DWORD *pdwPercent, 
                               [out] QWORD *pcnsBuffering );

    //
    // When the play mode is WMT_PLAY_MODE_DOWNLOAD, this call will return
    // progress values. pdwPercent returns the percentage of the download
    // that has completed, pqwBytesDownloaded returns the number of bytes
    // that have been downloaded, and pcnsDownload returns the amount of
    // downloading remaining.
    //
    HRESULT GetDownloadProgress( [out] DWORD *pdwPercent,
                                 [out] QWORD *pqwBytesDownloaded,
                                 [out] QWORD *pcnsDownload );

    //
    // When saving a file, the operation may take awhile. Between
    // WMT_SAVEAS_START and WMT_SAVEAS_STOP, this call will return progress
    // values. pdwPercent returns the percentage of the save as that has
    // completed.
    //
    HRESULT GetSaveAsProgress( [out] DWORD *pdwPercent );

    //
    // Save the current file. This only works for WMT_PLAY_MODE_DOWNLOAD.
    // This operation is asynchronous; WMT_SAVEAS_STOP indicates that the
    // save has completed. Closing the reader will abort a save operation
    // that has not completed.
    //
    HRESULT SaveFileAs( [in] const WCHAR *pwszFilename );

    //
    // Returns the name of the protocol that is currently being used.
    // The protocol name is a URL scheme, such as "mmsu", "http", "file", etc.
    // Note, however, that the protocol name may differ from the URL scheme
    // that was specified in IWMReader::Open().
    // This method may return an empty string if the protocol name cannot be determined.
    //
    HRESULT GetProtocolName( [out] WCHAR *pwszProtocol, [in, out] DWORD *pcchProtocol );

    //
    // Same as IWMReader::Start, but uses a marker index instead of a time value.
    //
    HRESULT StartAtMarker( [in] WORD wMarkerIndex, 
                           [in] QWORD cnsDuration, 
                           [in] float fRate, 
                           [in] void *pvContext );

    //
    // Retrieves a setting for a particular output by name
    //
    HRESULT GetOutputSetting( 
                    [in] DWORD dwOutputNum,
                    [in] LPCWSTR pszName,
                    [out] WMT_ATTR_DATATYPE *pType,
                    [out] BYTE *pValue,
                    [in,out] WORD *pcbLength );

    //
    // Sets a named setting for a particular output
    //
    HRESULT SetOutputSetting(
                    [in] DWORD dwOutputNum,
                    [in] LPCWSTR pszName,
                    [in] WMT_ATTR_DATATYPE Type,
                    [in] const BYTE *pValue,
                    [in] WORD cbLength );

    //
    // Used to begin prerolling the reader.  Call this method
    // when you know you're going to call Start soon and want
    // to start buffering data in advance.  cnsStart, cnsDuration 
    // and fRate should be the same as the values you plan to pass 
    // to Start in the future.
    //
    HRESULT Preroll( 
                [in] QWORD cnsStart,
                [in] QWORD cnsDuration,
                [in] float fRate );

    //
    // Specifies whether the SDK should send the client's unique identifier
    // to the server when streaming.
    //
    HRESULT SetLogClientID( [in] BOOL fLogClientID );
    HRESULT GetLogClientID( [out] BOOL *pfLogClientID );

    //
    // This method requests that the Reader send WMT_BUFFERING_STOP as soon
    // as possible. The Reader will only honor the request if it is currently
    // buffering, i.e., it has sent a WMT_BUFFERING_START, but not yet sent the
    // corresponding WMT_BUFFERING_STOP.
    //
    HRESULT StopBuffering( );

    //
    // Same as IWMReader::Open but takes an IStream interface pointer instead
    // of an URL to be opened
    //
    HRESULT OpenStream( [in] IStream *pStream,
                        [in] IWMReaderCallback *pCallback,
                        [in] void *pvContext );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 5DC0674B-F04B-4a4e-9F2A-B1AFDE2C8100 ),
    helpstring( "IWMReaderAdvanced3 Interface" ),
    pointer_default(unique),
    local
]
//
// The reader can be QI'ed for this interface for frame access functionaly.
//
interface IWMReaderAdvanced3 : IWMReaderAdvanced2
{
    //
    // This method is used when you want to stop net streaming right away but
    // continue to receive samples that SDK have gotten so far.
    //
    // If it's successful, user should receive an END_OF_STREAMING quickly.
    //
    HRESULT StopNetStreaming( );

    //
    // This method is for frame based accessing, start with SMPTE time stamp etc.
    // It is not supported in current version, we'll start to support this from v9
    //
    HRESULT StartAtPosition(  [in] WORD              wStreamNum,
                              [in] void              *pvOffsetStart,
                              [in] void              *pvDuration,
                              [in] WMT_OFFSET_FORMAT dwOffsetFormat,
                              [in] float             fRate,
                              [in] void              *pvContext );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 9F762FA7-A22E-428d-93C9-AC82F3AAFE5A ),
    helpstring( "IWMReaderAllocatorEx Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderAllocatorEx : IUnknown
{
    HRESULT AllocateForStreamEx( [in] WORD wStreamNum,
                                 [in] DWORD cbBuffer,
                                 [out] INSSBuffer **ppBuffer,
                                 [in] DWORD dwFlags,
                                 [in] QWORD cnsSampleTime,
                                 [in] QWORD cnsSampleDuration,
                                 [in] void *pvContext );    
                               
    HRESULT AllocateForOutputEx( [in] DWORD dwOutputNum,
                                 [in] DWORD cbBuffer,
                                 [out] INSSBuffer **ppBuffer,
                                 [in] DWORD dwFlags,
                                 [in] QWORD cnsSampleTime,
                                 [in] QWORD cnsSampleDuration,
                                 [in] void *pvContext );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( FDBE5592-81A1-41ea-93BD-735CAD1ADC05 ),
    helpstring( "IWMReaderTypeNegotiation Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderTypeNegotiation : IUnknown
{
    HRESULT TryOutputProps( [in] DWORD dwOutputNum,
                            [in] IWMOutputMediaProps *pOutput );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BEB-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderCallbackAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// For some advanced functionality, the IWMReaderCallback must support this
// interface.
//
interface IWMReaderCallbackAdvanced : IUnknown
{
    //
    // Receive a sample directly from the ASF. To get this call, the user
    // must register himself to receive samples for a particular stream.
    //
    HRESULT OnStreamSample( [in] WORD wStreamNum,
                            [in] QWORD cnsSampleTime,
                            [in] QWORD cnsSampleDuration,
                            [in] DWORD dwFlags,
                            [in] INSSBuffer *pSample,
                            [in] void *pvContext );

    //
    // In some cases, the user may want to get callbacks telling what the
    // reader thinks the current time is. This is interesting in 2 cases:
    // - If the ASF has gaps in it; say no audio for 10 seconds. This call
    //   will continue to be called, while OnSample won't be called.
    // - If the user is driving the clock, the reader needs to communicate
    //   back to the user its time, to avoid the user overrunning the reader.
    //
    HRESULT OnTime( [in] QWORD cnsCurrentTime, [in] void *pvContext );

    //
    // The user can also get callbacks when stream selection occurs.
    //
    HRESULT OnStreamSelection( [in] WORD wStreamCount,
                               [in] WORD *pStreamNumbers,
                               [in] WMT_STREAM_SELECTION *pSelections,
                               [in] void *pvContext );


    //
    // Will be called if the user got an async result from their
    // call to SetOutputProps.  The next sample you receive for
    // this output will have these properties.  The contents of the
    // media type after calling SetOutputProps and before receiving
    // an OutputPropsChanged notification are undefined.
    //
    HRESULT OnOutputPropsChanged( [in] DWORD dwOutputNum,
                                  [in] WM_MEDIA_TYPE *pMediaType,
                                  [in] void *pvContext );

    //
    // If the user has registered to allocate buffers, this is where he must
    // do it.
    //
    HRESULT AllocateForStream( [in] WORD wStreamNum,
                               [in] DWORD cbBuffer,
                               [out] INSSBuffer **ppBuffer,
                               [in] void *pvContext );    
                               
    HRESULT AllocateForOutput( [in] DWORD dwOutputNum,
                               [in] DWORD cbBuffer,
                               [out] INSSBuffer **ppBuffer,
                               [in] void *pvContext );
};

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( D2827540-3EE7-432c-B14C-DC17F085D3B3 ),
    helpstring( "IWMDRMReader Interface"),
    pointer_default(unique),
    local
]
//
// Used to access advanced DRM functionality.
//
interface IWMDRMReader : IUnknown
{
    HRESULT AcquireLicense( [in]    DWORD   dwFlags );
    HRESULT CancelLicenseAcquisition();

    HRESULT Individualize( [in]     DWORD   dwFlags );
    HRESULT CancelIndividualization();

    HRESULT MonitorLicenseAcquisition();
    HRESULT CancelMonitorLicenseAcquisition();

    HRESULT SetDRMProperty( [in]    LPCWSTR pwstrName,  
                            [in]    WMT_ATTR_DATATYPE dwType, 
                            [in]    const BYTE *pValue,
                            [in]    WORD cbLength );
    HRESULT GetDRMProperty( [in]    LPCWSTR pwstrName,
                            [out]   WMT_ATTR_DATATYPE* pdwType,
                            [out]   BYTE *pValue, 
                            [out]   WORD *pcbLength );
};

///////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid( 96406BEC-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderNetworkConfig Interface"),
    pointer_default(unique),
    local
]
//
// Used to configure the network.  This interface is implemented by
// the IWMReader object.
//
interface IWMReaderNetworkConfig : IUnknown
{
    //
    // Get and set the amount of time the network source will buffer
    // data before rendering it.  
    //
    HRESULT GetBufferingTime( [out] QWORD *pcnsBufferingTime );
    HRESULT SetBufferingTime( [in] QWORD cnsBufferingTime );

    //
    // Returns the UDP port number ranges that will be used for receiving
    // data.  If no ranges are available, random UDP port numbers will be used.
    //
    HRESULT GetUDPPortRanges( [out] WM_PORT_NUMBER_RANGE *pRangeArray,
                              [in, out] DWORD *pcRanges );

    //
    // Sets the UDP port number ranges that can be used for receiving data.
    // If no ranges are specified, random UDP port numbers will be used.
    //
    HRESULT SetUDPPortRanges( [in] WM_PORT_NUMBER_RANGE *pRangeArray,
                              [in] DWORD cRanges );

   
    //
    // Proxy settings: Manual proxy, Autodetect, UseBrowser (only for HTTP), or No Proxy.
    //
    HRESULT GetProxySettings( LPCWSTR pwszProtocol, WMT_PROXY_SETTINGS *pProxySetting );
    HRESULT SetProxySettings( LPCWSTR pwszProtocol, WMT_PROXY_SETTINGS ProxySetting );
    
    //
    // The host to use as the proxy.
    //
    HRESULT GetProxyHostName( [in] LPCWSTR pwszProtocol, [out] WCHAR *pwszHostName, [in, out] DWORD *pcchHostName );
    HRESULT SetProxyHostName( [in] LPCWSTR pwszProtocol, [in] LPCWSTR pwszHostName );
    
    //
    // The port to use as the proxy.
    //
    HRESULT GetProxyPort( [in] LPCWSTR pwszProtocol, [out] DWORD *pdwPort );
    HRESULT SetProxyPort( [in] LPCWSTR pwszProtocol, [in] DWORD dwPort );

    //
    // Get and set the proxy exception list.
    //
    HRESULT GetProxyExceptionList( [in] LPCWSTR pwszProtocol, [out] WCHAR *pwszExceptionList, [in, out] DWORD *pcchExceptionList );
    HRESULT SetProxyExceptionList( [in] LPCWSTR pwszProtocol, [in] LPCWSTR pwszExceptionList );

    //
    // Whether or not to bypass proxy for local hosts
    //
    HRESULT GetProxyBypassForLocal( [in] LPCWSTR pwszProtocol, [out] BOOL *pfBypassForLocal );
    HRESULT SetProxyBypassForLocal( [in] LPCWSTR pwszProtocol, [in] BOOL fBypassForLocal );
    
    //
    // Whether to force a wpad discovery on the next run
    //
    HRESULT GetForceRerunAutoProxyDetection( [out] BOOL *pfForceRerunDetection );
    HRESULT SetForceRerunAutoProxyDetection( [in] BOOL fForceRerunDetection );
    
    //
    // Whether or not to use multicast, http, tcp, or udp
    //
    HRESULT GetEnableMulticast( [out] BOOL *pfEnableMulticast );
    HRESULT SetEnableMulticast( [in] BOOL fEnableMulticast );

    HRESULT GetEnableHTTP( [out] BOOL *pfEnableHTTP );
    HRESULT SetEnableHTTP( [in] BOOL fEnableHTTP );

    HRESULT GetEnableUDP( [out] BOOL *pfEnableUDP );
    HRESULT SetEnableUDP( [in] BOOL fEnableUDP );

    HRESULT GetEnableTCP( [out] BOOL *pfEnableTCP );
    HRESULT SetEnableTCP( [in] BOOL fEnableTCP );

    //
    // Forgets automatic protocol detection settings and redetects next time.
    //
    HRESULT ResetProtocolRollover( );

    //
    // Return or set the client's link bandwidth in bps.  This is an optional 
    // setting.  By default, the SDK will automatically detect its connection 
    // bandwidth to the streaming media server.
    //
    HRESULT GetConnectionBandwidth( [out] DWORD *pdwConnectionBandwidth );
    HRESULT SetConnectionBandwidth( [in] DWORD dwConnectionBandwidth );

    //
    // Iterate through the network protocols supported by this reader
    //
    HRESULT GetNumProtocolsSupported( [out] DWORD *pcProtocols );
    HRESULT GetSupportedProtocolName( [in]  DWORD dwProtocolNum, [out] WCHAR *pwszProtocolName, [in, out] DWORD *pcchProtocolName);


    //
    // Adds the specified pszUrl to the list of URL's to recieve logging data.  
    // This list is in addition to the origin server.
    //
    HRESULT AddLoggingUrl( [in] LPCWSTR pwszUrl );

    //
    // Fills the buffer with the URL corresponding to index dwIndex.
    //
    HRESULT GetLoggingUrl( [in] DWORD dwIndex, [out] LPWSTR pwszUrl, [in, out] DWORD *pcchUrl );

    //
    // Returns the number of URLs in the current list of logging URLs.
    //
    HRESULT GetLoggingUrlCount( [out] DWORD *pdwUrlCount );

    //
    // Clears the list of logging URLs
    //
    HRESULT ResetLoggingUrlList( );

}

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BED-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderStreamClock Interface"),
    pointer_default(unique),
    local
]
//
// Used to configure the network.  This interface is implemented by
// the IWMReader object.
//
interface IWMReaderStreamClock : IUnknown
{
    //
    // Get the current value of the stream clock
    //
    HRESULT GetTime( [in] QWORD *pcnsNow );
 
    //
    // Set or kill a timer.  All timers are automatically
    // killed whenever you stop the Reader.  When a timer
    // expires, you'll receive a WMT_TIMER OnStatus callback
    // with hr == S_OK, pValue = TimerId and pvContext == pvParam.
    // 
    //
    HRESULT SetTimer( [in] QWORD cnsWhen, [in]void *pvParam, [out] DWORD *pdwTimerId );
    HRESULT KillTimer( [in] DWORD dwTimerId );
}


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6d7cdc71-9888-11d3-8edc-00c04f6109cf ),
    helpstring( "IWMIndexer Interface"),
    pointer_default(unique),
    local
]
interface IWMIndexer : IUnknown
{
    //
    // Start is an asynchronous call; it returns almost immediately and the user 
    // should wait for appropriate OnStatus calls to be sent to the callback.
    //
    HRESULT StartIndexing( [in] const WCHAR *pwszURL,
                  [in] IWMStatusCallback *pCallback,
                  [in] void *pvContext );
    HRESULT Cancel();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8 ),
    helpstring( "IWMLicenseBackup Interface"),
    pointer_default(unique),
    local
]
interface IWMLicenseBackup : IUnknown
{

    HRESULT BackupLicenses( [in] DWORD dwFlags, 
                            [in] IWMStatusCallback *pCallback );
    HRESULT CancelLicenseBackup();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( C70B6334-0544-4efb-A245-15E65A004A13 ),
    helpstring( "IWMLicenseRestore Interface"),
    pointer_default(unique),
    local
]
interface IWMLicenseRestore : IUnknown
{
    HRESULT RestoreLicenses( [in] DWORD dwFlags, 
                             [in] IWMStatusCallback *pCallback );
    HRESULT CancelLicenseRestore();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E ),
    helpstring( "IWMBackupRestoreProps Interface"),
    pointer_default(unique),
    local
]
interface IWMBackupRestoreProps : IUnknown
{
    HRESULT GetPropCount( [out] WORD *pcProps );
    HRESULT GetPropByIndex( [in] WORD wIndex,
                       [out] WCHAR *pwszName,
                       [in,out] WORD *pcchNameLen,
                       [out] WMT_ATTR_DATATYPE *pType,
                       [out] BYTE *pValue,
                       [in,out] WORD *pcbLength );
    HRESULT GetPropByName( [in] LPCWSTR pszName,
                           [out] WMT_ATTR_DATATYPE *pType,
                           [out] BYTE *pValue,
                           [in,out] WORD *pcbLength );
    HRESULT SetProp( [in] LPCWSTR pszName,
                     [in] WMT_ATTR_DATATYPE Type,
                     [in] const BYTE *pValue,
                     [in] WORD cbLength );
    HRESULT RemoveProp( [in] LPCWSTR pcwszName );
    HRESULT RemoveAllProps();
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( A970F41E-34DE-4a98-B3BA-E4B3CA7528F0 ),
    helpstring( "IWMCodecInfo Interface"),
    pointer_default(unique),
    local
]
interface IWMCodecInfo : IUnknown
{
    HRESULT GetCodecInfoCount(   [in]      REFGUID guidType,
                                 [out]     DWORD *pcCodecs );

    HRESULT GetCodecFormatCount( [in]      REFGUID guidType,
                                 [in]      DWORD dwCodecIndex,
                                 [out]     DWORD *pcFormat );

    HRESULT GetCodecFormat(      [in]      REFGUID guidType,
                                 [in]      DWORD dwCodecIndex,
                                 [in]      DWORD dwFormatIndex,
                                 [out]     IWMStreamConfig **ppIStreamConfig );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( AA65E273-B686-4056-91EC-DD768D4DF710 ),
    helpstring( "IWMCodecInfo2 Interface"),
    pointer_default(unique),
    local
]
interface IWMCodecInfo2 : IWMCodecInfo
{
    HRESULT GetCodecName( [in]  REFGUID guidType,
                          [in]  DWORD dwCodecIndex,
                          [out] WCHAR *wszName,
                          [out] DWORD *pcchName );

    HRESULT GetCodecFormatDesc( [in]       REFGUID guidType,
                                [in]       DWORD dwCodecIndex,
                                [in]       DWORD dwFormatIndex,
                                [out]      IWMStreamConfig **ppIStreamConfig,
                                [out]      WCHAR *wszDesc,
                                [in, out]  DWORD *pcchDesc );
};
