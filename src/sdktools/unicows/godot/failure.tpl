;;/*++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;;  Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.
;;
;;  Module Name:
;;
;;    unicows.tpl
;;
;;  Abstract:
;;
;;      This file creates both failure.c and failure.h from the original 
;;      unicode API list (apilistw.lst). For custom EFuncs, see the
;;      comments below near BroadcastSystemMessageW
;;
;;  Revision History:
;;
;;    20 Feb 2001    v-michka    Created.
;;
;;-------------------------------------------------*/


; // This template is a [Code] template.  It is expanded by genthnk once
; // via the -cTemplateName command-line option.  Stuff inside the Begin=
; // End= section is C code or genthnk macros which are prefixed by an 'at' char.
[Code]
TemplateName=FailWrapperHeaders
Begin=
@NoFormat(
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    failure.h Header file for failure.c (failure functions for Godot

Abstract:

    Auto-generated file that contains the failure cases for
    the Godot hooks.

    WARNING: Do not edit! This file is auto-generated by genthnk.
    See failure.tpl if you want to make changes.

Revision History:

    19 Feb 2001    v-michka    Created.

--*/
#define SECURITY_WIN32
#include <windows.h>            // We always need a windows.h
#include <ras.h>                // for the RAS functions and constants
#include <raserror.h>           // for RAS errors
#include <ddeml.h>              // for HSZ, etc in DDEML calls.
#include <dbt.h>                // for RegisterDeviceNotification info
#include <Commdlg.h>            // for common dialogs
#include <shellapi.h>           // for shell API calls
#include <shlobj.h>             // for the rest of the shell APIs
#include <sensapi.h>            // for IsDestinationReachable defs
#include <oledlg.h>             // OLE UI definitions
#include <vfw.h>                // for capCreateCaptureWindow
#include <oleacc.h>             // Accessibility
#include <winspool.h>           // print spooler definitions
#include <ntsecapi.h>           // security API return types
#include <security.h>           // Used for security APIs

// include one special forward declare
FARPROC GetProcAddressInternal(HINSTANCE hDll, PCHAR szName);

#define FAIL_TEMPLATE_HEADER    // Let the world know we are in the header
@Template(FailHeaderTemplates)
End=

; // This template is a [Code] template.  It is expanded by genthnk once
; // via the -cTemplateName command-line option.  Stuff inside the Begin=
; // End= section is C code or genthnk macros which are prefixed by an 'at' char.
[Code]
TemplateName=FailWrappers
Begin=
@NoFormat(
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    failure.c (Windows 9x Unicode wrapper failure functions)

Abstract:

    Auto-generated file that contains the failure cases for
    the Godot hooks.

    WARNING: Do not edit! This file is auto-generated by genthnk.
    See failure.tpl if you want to make changes.

Revision History:

    19 Feb 2001    v-michka    Created.

--*/
#include "failure.h"        // forward declares for this file
#undef FAIL_TEMPLATE_HEADER // Let the world know we are not in the header

@Template(FailTemplates)
)
End=

[Macros]
MacroName=ExpandFailure
NumArgs=0
Begin=
SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return @IfApiRet(@RetType(Fail));
End=

; //
; // This template is an [IFunc] template.  It is expanded once for each API.
; //  Macros:
; //       ApiName     - the name of the API
; //       ArgList()   - expands the contents for each argument to the API
; //       ListCol     - text formatting - makes a nice column
; //       ArgMod      - type modifier like const/volatile
; //       ArgType     - type of the argument
; //       ArgName     - name of the argument (genthnk will assign a name if the prototype didn't name the arg)
; //       ArgMore()   - expands iff there are more args after the current one
; //       IfApiRet()  - expands iff the return type of the API is non-void
; //       ApiFnRet    - return type of the API
; //       Types()     - expands any applicable parts of [Types] templates
; //       IfApiCode() - expands any applicable parts of [EFunc] templates
; //
[IFunc]
TemplateName=FailTemplates
Begin=
@ApiFnRet @ApiFnMod
GodotFail@ApiName(@ArgList(@ListCol@ArgMod @ArgType @ArgName@ArgMore(,)))
{
    @ExpandFailure
}
End=

[IFunc]
TemplateName=FailHeaderTemplates
Begin=
@ApiFnRet @ApiFnMod
GodotFail@ApiName(@ArgList(@ListCol@ArgMod @ArgType @ArgName@ArgMore(,)));
End=

; // These templates are [Types] templates.  They are expanded whenever
; // an API argument type matches.
[Types]
TemplateName=BOOL
IndLevel=0
Fail=
FALSE 
End=

TemplateName=DWORD
Also=int
IndLevel=0
Fail=
0
End=

TemplateName=void
IndLevel=1
Fail=
NULL
End=

TemplateName=LPVOID
Also=LPCVOID
Also=PVOID
Also=LPWSTR
Also=HKL
Also=HMETAFILE
Also=HENHMETAFILE
IndLevel=0
Fail=
NULL
End=

TemplateName=RPC_STATUS
Fail=
STATUS_ACCESS_DENIED
End=

TemplateName=HCONVLIST
Also=HCONV
Also=HSZ
Also=HDDEDATA
Also=HIMCC
Also=HDRVR
Also=HWAVE
Also=HWAVEIN
Also=HWAVEOUT
Also=HMIDI
Also=HMIDIIN
Also=HMIDIOUT
Also=HMIDISTRM
Also=HMIXEROBJ
Also=HMIXER
Also=HMMIO
Also=HMONITOR
Also=HRASCONN
Also=HDROP
Also=HGDIOBJ
Also=HACCEL
Also=HBITMAP
Also=HBRUSH
Also=HCOLORSPACE
Also=HGLRC
Also=HDESK
IndLevel=0
Fail=
NULL
End=

TemplateName=HFONT
Also=HICON
Also=HMENU
Also=HINSTANCE
Also=HPALETTE
Also=HPEN
Also=HRGN
Also=HRSRC
Also=HSTR
Also=HTASK
Also=HWINSTA
Also=HWINEVENTHOOK
Also=HCURSOR
Also=HKEY
Also=HMODULE
Also=HGLOBAL
Also=HLOCAL
Also=HRSRC
ALSO=LPMMIOPROC
IndLevel=0
Fail=
NULL
End=

TemplateName=HRESULT
IndLevel=0
Fail=
E_NOTIMPL
End=

TemplateName=HANDLE
IndLevel=0
Fail=
INVALID_HANDLE_VALUE
End=

TemplateName=HWND
IndLevel=0
Fail=
(HWND)NULL
End=

TemplateName=FARPROC
IndLevel=0
Fail=
(FARPROC)NULL
End=

TemplateName=HHOOK
IndLevel=0
Fail=
(HHOOK)NULL
End=

TemplateName=HDC
IndLevel=0
Fail=
(HDC)NULL
End=

TemplateName=HFILE
IndLevel=0
Fail=
HFILE_ERROR
End=

TemplateName=ATOM
IndLevel=0
Fail=
INVALID_ATOM
End=

TemplateName=LPITEMIDLIST
IndLevel=0
Fail=
NULL
End=

TemplateName=SECURITY_STATUS
Fail=
SEC_E_UNSUPPORTED_FUNCTION
End=

TemplateName=PSecurityFunctionTableW
Fail=
NULL
End=

;// This is a typical override function. Note that in order to satisfy 
;// the genthnk requirement that always makes Begin=/End= override 
;// Fail=/End=, we have to use the hacky FAIL_TEMPLATE_HEADER ifdef.
;// The forward declare for failure.h should be placed in the #ifdef,
;// while the function itself should be placed in the #else. Not ideal,
;// but this is better than creating yet a third template file.
[EFunc]
TemplateName=BroadcastSystemMessageW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
long __stdcall GodotFailBroadcastSystemMessageW(DWORD _p1, LPDWORD _p2, UINT _p3, WPARAM _p4, LPARAM _p5);
#else
long __stdcall GodotFailBroadcastSystemMessageW(DWORD _p1, LPDWORD _p2, UINT _p3, WPARAM _p4, LPARAM _p5)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(-1);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=ChangeDisplaySettingsW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailChangeDisplaySettingsW(LPDEVMODEW _p1, DWORD _p2);
#else
LONG __stdcall GodotFailChangeDisplaySettingsW(LPDEVMODEW _p1, DWORD _p2)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DISP_CHANGE_FAILED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=ChangeDisplaySettingsExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailChangeDisplaySettingsExW(LPCWSTR _p1, LPDEVMODEW _p2, HWND _p3, DWORD _p4, LPVOID _p5);
#else
LONG __stdcall GodotFailChangeDisplaySettingsExW(LPCWSTR _p1, LPDEVMODEW _p2, HWND _p3, DWORD _p4, LPVOID _p5)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DISP_CHANGE_FAILED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=CharNextW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LPWSTR __stdcall GodotFailCharNextW(LPCWSTR _p1);
#else
LPWSTR __stdcall GodotFailCharNextW(LPCWSTR _p1)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(L"\0");
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=DdeConnect
Begin=
#ifdef FAIL_TEMPLATE_HEADER
HCONV __stdcall GodotFailDdeConnect(DWORD _p1, HSZ _p2, HSZ _p3, PCONVCONTEXT _p4);
#else
HCONV __stdcall GodotFailDdeConnect(DWORD _p1, HSZ _p2, HSZ _p3, PCONVCONTEXT _p4)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "DdeConnect");
    if(lpfn)
        return((HCONV)(* lpfn)(_p1, _p2, _p3, _p4));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0L);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=DdeConnectList
Begin=
#ifdef FAIL_TEMPLATE_HEADER
HCONVLIST __stdcall GodotFailDdeConnectList(DWORD _p1, HSZ _p2, HSZ _p3, HCONVLIST _p4, PCONVCONTEXT _p5);
#else
HCONVLIST __stdcall GodotFailDdeConnectList(DWORD _p1, HSZ _p2, HSZ _p3, HCONVLIST _p4, PCONVCONTEXT _p5)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "DdeConnectList");
    if(lpfn)
        return((HCONVLIST)(* lpfn)(_p1, _p2, _p3, _p4, _p5));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0L);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=DdeQueryConvInfo
Begin=
#ifdef FAIL_TEMPLATE_HEADER
UINT __stdcall GodotFailDdeQueryConvInfo(HCONV _p1, DWORD _p2, PCONVINFO _p3);
#else
UINT __stdcall GodotFailDdeQueryConvInfo(HCONV _p1, DWORD _p2, PCONVINFO _p3)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "DdeQueryConvInfo");
    if(lpfn)
        return((UINT)(* lpfn)(_p1, _p2, _p3));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=EnableWindow
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailEnableWindow(HWND _p1, BOOL _p2);
#else
BOOL __stdcall GodotFailEnableWindow(HWND _p1, BOOL _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "EnableWindow");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=EnumClipboardFormats
Begin=
#ifdef FAIL_TEMPLATE_HEADER
UINT __stdcall GodotFailEnumClipboardFormats(UINT _p1);
#else
UINT __stdcall GodotFailEnumClipboardFormats(UINT _p1)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "EnumClipboardFormats");
    if(lpfn)
        return((UINT)(* lpfn)(_p1));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=EnumPropsA
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFailEnumPropsA(HWND _p1, PROPENUMPROCA _p2);
#else
int __stdcall GodotFailEnumPropsA(HWND _p1, PROPENUMPROCA _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "EnumPropsA");
    if(lpfn)
        return((int)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(-1);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=EnumPropsExA
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFailEnumPropsExA(HWND _p1, PROPENUMPROCEXA _p2, LPARAM _p3);
#else
int __stdcall GodotFailEnumPropsExA(HWND _p1, PROPENUMPROCEXA _p2, LPARAM _p3)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "EnumPropsExA");
    if(lpfn)
        return((int)(* lpfn)(_p1, _p2, _p3));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(-1);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=ExtTextOutW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailExtTextOutW(HDC _p1, int _p2, int _p3, UINT _p4, const LPRECT _p5, 
                 LPCWSTR _p6, UINT _p7, const PINT _p8);
#else
BOOL __stdcall GodotFailExtTextOutW(HDC _p1, int _p2, int _p3, UINT _p4, const LPRECT _p5, 
                 LPCWSTR _p6, UINT _p7, const PINT _p8)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("gdi32.dll"), "ExtTextOutW");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=FindResourceW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
HRSRC __stdcall GodotFailFindResourceW(HMODULE _p1, LPCWSTR _p2, LPCWSTR _p3);
#else
HRSRC __stdcall GodotFailFindResourceW(HMODULE _p1, LPCWSTR _p2, LPCWSTR _p3)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "FindResourceW");
    if(lpfn)
        return((HRSRC)(* lpfn)(_p1, _p2, _p3));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=FindResourceExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
HRSRC __stdcall GodotFailFindResourceExW(HMODULE _p1, LPCWSTR _p2, LPCWSTR _p3, WORD _p4);
#else
HRSRC __stdcall GodotFailFindResourceExW(HMODULE _p1, LPCWSTR _p2, LPCWSTR _p3, WORD _p4)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "FindResourceExW");
    if(lpfn)
        return((HRSRC)(* lpfn)(_p1, _p2, _p3, _p4));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=FreeContextBuffer
Begin=
#ifdef FAIL_TEMPLATE_HEADER
SECURITY_STATUS __stdcall GodotFreeContextBuffer(void * _p1);
#else
SECURITY_STATUS __stdcall GodotFreeContextBuffer(void * _p1)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("secur32.dll"), "FreeContextBuffer");
    if(lpfn)
        return((SECURITY_STATUS)(* lpfn)(_p1));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}
#endif // FAIL_TEMPLATE_HEADER
End=


[EFunc]
TemplateName=GetCharWidthW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailGetCharWidthW(HDC _p1, UINT _p2, UINT _p3, LPINT _p4);
#else
BOOL __stdcall GodotFailGetCharWidthW(HDC _p1, UINT _p2, UINT _p3, LPINT _p4)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("gdi32.dll"), "GetCharWidthW");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2, _p3, _p4));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=GetClipboardData
Begin=
#ifdef FAIL_TEMPLATE_HEADER
HANDLE __stdcall GodotFailGetClipboardData(UINT _p1);
#else
HANDLE __stdcall GodotFailGetClipboardData(UINT _p1)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "GetClipboardData");
    if(lpfn)
        return((HANDLE)(* lpfn)(_p1));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=GetCPInfo
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailGetCPInfo(UINT _p1, LPCPINFO _p2);
#else
BOOL __stdcall GodotFailGetCPInfo(UINT _p1, LPCPINFO _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "GetCPInfo");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=GetProcAddress
Begin=
#ifdef FAIL_TEMPLATE_HEADER
FARPROC __stdcall GodotFailGetProcAddress(HMODULE _p1, LPCSTR _p2);
#else
FARPROC __stdcall GodotFailGetProcAddress(HMODULE _p1, LPCSTR _p2)
{
    return(GetProcAddressInternal(_p1, (LPSTR)_p2));
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=GetPropA
Begin=
#ifdef FAIL_TEMPLATE_HEADER
HANDLE __stdcall GodotFailGetPropA(HWND _p1, LPCSTR _p2);
#else
HANDLE __stdcall GodotFailGetPropA(HWND _p1, LPCSTR _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "GetPropA");
    if(lpfn)
        return((HANDLE)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(NULL);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=GetTextExtentPointW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailGetTextExtentPointW(HDC _p1, LPCWSTR _p2, int _p3, LPSIZE _p4);
#else
BOOL __stdcall GodotFailGetTextExtentPointW(HDC _p1, LPCWSTR _p2, int _p3, LPSIZE _p4)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("gdi32.dll"), "GetTextExtentPointW");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2, _p3, _p4));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=GetTextExtentPoint32W
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailGetTextExtentPoint32W(HDC _p1, LPCWSTR _p2, int _p3, LPSIZE _p4);
#else
BOOL __stdcall GodotFailGetTextExtentPoint32W(HDC _p1, LPCWSTR _p2, int _p3, LPSIZE _p4)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("gdi32.dll"), "GetTextExtentPoint32W");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2, _p3, _p4));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=GetWindowLongA
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailGetWindowLongA(HWND _p1, int _p2);
#else
LONG __stdcall GodotFailGetWindowLongA(HWND _p1, int _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "GetWindowLongA");
    if(lpfn)
        return((LONG)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=IsClipboardFormatAvailable
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailIsClipboardFormatAvailable(UINT _p1);
#else
BOOL __stdcall GodotFailIsClipboardFormatAvailable(UINT _p1)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "IsClipboardFormatAvailable");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=IsValidCodePage
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailIsValidCodePage(UINT _p1);
#else
BOOL __stdcall GodotFailIsValidCodePage(UINT _p1)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "IsValidCodePage");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=IsWindowUnicode
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailIsWindowUnicode(HWND _p1);
#else
BOOL __stdcall GodotFailIsWindowUnicode(HWND _p1)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "IsWindowUnicode");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=lstrcatW
Begin=
#ifdef FAIL_TEMPLATE_HEADER

LPWSTR __stdcall GodotFaillstrcatW(LPWSTR _p1, LPCWSTR _p2);
#else
LPWSTR __stdcall GodotFaillstrcatW(LPWSTR _p1, LPCWSTR _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "lstrcatW");
    if(lpfn)
        return((LPWSTR)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(NULL);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=lstrcpyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LPWSTR __stdcall GodotFaillstrcpyW(LPWSTR _p1, LPCWSTR _p2);
#else
LPWSTR __stdcall GodotFaillstrcpyW(LPWSTR _p1, LPCWSTR _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "lstrcpyW");
    if(lpfn)
        return((LPWSTR)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(NULL);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=lstrlenW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFaillstrlenW(LPCWSTR _p1);
#else
int __stdcall GodotFaillstrlenW(LPCWSTR _p1)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "lstrlenW");
    if(lpfn)
        return((int)(* lpfn)(_p1));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=MessageBoxW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFailMessageBoxW(HWND _p1, LPCWSTR _p2, LPCWSTR _p3, UINT _p4);
#else
int __stdcall GodotFailMessageBoxW(HWND _p1, LPCWSTR _p2, LPCWSTR _p3, UINT _p4)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "MessageBoxW");
    if(lpfn)
        return((int)(* lpfn)(_p1, _p2, _p3, _p4));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=MessageBoxExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFailMessageBoxExW(HWND _p1, LPCWSTR _p2, LPCWSTR _p3, UINT _p4, WORD _p5);
#else
int __stdcall GodotFailMessageBoxExW(HWND _p1, LPCWSTR _p2, LPCWSTR _p3, UINT _p4, WORD _p5)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "MessageBoxExW");
    if(lpfn)
        return((int)(* lpfn)(_p1, _p2, _p3, _p4, _p5));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=mmioInstallIOProcW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LPMMIOPROC __stdcall GodotFailmmioInstallIOProcW(FOURCC p1, LPMMIOPROC p2, DWORD p3);
#else
LPMMIOPROC __stdcall GodotFailmmioInstallIOProcW(FOURCC p1, LPMMIOPROC p2, DWORD p3)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(NULL);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=MultiByteToWideChar
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFailMultiByteToWideChar(UINT _p1, DWORD _p2, LPCSTR _p3, int _p4, LPWSTR _p5, int _p6);
#else
int __stdcall GodotFailMultiByteToWideChar(UINT _p1, DWORD _p2, LPCSTR _p3, int _p4, LPWSTR _p5, int _p6)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "MultiByteToWideChar");
    if(lpfn)
        return((int)(* lpfn)(_p1, _p2, _p3, _p4, _p5, _p6));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegConnectRegistryW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegConnectRegistryW(LPCWSTR _p1, HKEY _p2, PHKEY _p3);
#else
LONG __stdcall GodotFailRegConnectRegistryW(LPCWSTR _p1, HKEY _p2, PHKEY _p3)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegCreateKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegCreateKeyW(HKEY _p1, LPCWSTR _p2, PHKEY _p3);
#else
LONG __stdcall GodotFailRegCreateKeyW(HKEY _p1, LPCWSTR _p2, PHKEY _p3)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegCreateKeyExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegCreateKeyExW(HKEY _p1, LPCWSTR _p2, DWORD _p3, LPWSTR _p4, DWORD _p5, REGSAM _p6, LPSECURITY_ATTRIBUTES _p7, PHKEY _p8, LPDWORD _p9);
#else
LONG __stdcall GodotFailRegCreateKeyExW(HKEY _p1, LPCWSTR _p2, DWORD _p3, LPWSTR _p4, DWORD _p5, REGSAM _p6, LPSECURITY_ATTRIBUTES _p7, PHKEY _p8, LPDWORD _p9)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegDeleteKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegDeleteKeyW(HKEY _p1, LPCWSTR _p2);
#else
LONG __stdcall GodotFailRegDeleteKeyW(HKEY _p1, LPCWSTR _p2)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegDeleteValueW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegDeleteValueW(HKEY _p1, LPCWSTR _p2);
#else
LONG __stdcall GodotFailRegDeleteValueW(HKEY _p1, LPCWSTR _p2)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegEnumKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegEnumKeyW(HKEY _p1, DWORD _p2, LPWSTR _p3, DWORD _p4);
#else
LONG __stdcall GodotFailRegEnumKeyW(HKEY _p1, DWORD _p2, LPWSTR _p3, DWORD _p4)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegEnumKeyExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegEnumKeyExW(HKEY _p1, DWORD _p2, LPWSTR _p3, LPDWORD _p4, LPDWORD _p5, LPWSTR _p6, LPDWORD _p7, PFILETIME _p8);
#else
LONG __stdcall GodotFailRegEnumKeyExW(HKEY _p1, DWORD _p2, LPWSTR _p3, LPDWORD _p4, LPDWORD _p5, LPWSTR _p6, LPDWORD _p7, PFILETIME _p8)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegEnumValueW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegEnumValueW(HKEY _p1, DWORD _p2, LPWSTR _p3, LPDWORD _p4, LPDWORD _p5, LPDWORD _p6, LPBYTE _p7, LPDWORD _p8);
#else
LONG __stdcall GodotFailRegEnumValueW(HKEY _p1, DWORD _p2, LPWSTR _p3, LPDWORD _p4, LPDWORD _p5, LPDWORD _p6, LPBYTE _p7, LPDWORD _p8)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegLoadKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegLoadKeyW(HKEY _p1, LPCWSTR _p2, LPCWSTR _p3);
#else
LONG __stdcall GodotFailRegLoadKeyW(HKEY _p1, LPCWSTR _p2, LPCWSTR _p3)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegOpenKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegOpenKeyW(HKEY _p1, LPCWSTR _p2, PHKEY _p3);
#else
LONG __stdcall GodotFailRegOpenKeyW(HKEY _p1, LPCWSTR _p2, PHKEY _p3)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegOpenKeyExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegOpenKeyExW(HKEY _p1, LPCWSTR _p2, DWORD _p3, REGSAM _p4, PHKEY _p5);
#else
LONG __stdcall GodotFailRegOpenKeyExW(HKEY _p1, LPCWSTR _p2, DWORD _p3, REGSAM _p4, PHKEY _p5)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegQueryInfoKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegQueryInfoKeyW(HKEY _p1, LPWSTR _p2, LPDWORD _p3, LPDWORD _p4, LPDWORD _p5, LPDWORD _p6, LPDWORD _p7, LPDWORD _p8, LPDWORD _p9, LPDWORD _pA, LPDWORD _pB, PFILETIME _pC);
#else
LONG __stdcall GodotFailRegQueryInfoKeyW(HKEY _p1, LPWSTR _p2, LPDWORD _p3, LPDWORD _p4, LPDWORD _p5, LPDWORD _p6, LPDWORD _p7, LPDWORD _p8, LPDWORD _p9, LPDWORD _pA, LPDWORD _pB, PFILETIME _pC)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegQueryMultipleValuesW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegQueryMultipleValuesW(HKEY _p1, PVALENTW _p2, DWORD _p3, LPWSTR _p4, LPDWORD _p5);
#else
LONG __stdcall GodotFailRegQueryMultipleValuesW(HKEY _p1, PVALENTW _p2, DWORD _p3, LPWSTR _p4, LPDWORD _p5)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegQueryValueW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegQueryValueW(HKEY _p1, LPCWSTR _p2, LPWSTR _p3, PLONG _p4);
#else
LONG __stdcall GodotFailRegQueryValueW(HKEY _p1, LPCWSTR _p2, LPWSTR _p3, PLONG _p4)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegQueryValueExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegQueryValueExW(HKEY _p1, LPCWSTR _p2, LPDWORD _p3, LPDWORD _p4, LPBYTE _p5, LPDWORD _p6);
#else
LONG __stdcall GodotFailRegQueryValueExW(HKEY _p1, LPCWSTR _p2, LPDWORD _p3, LPDWORD _p4, LPBYTE _p5, LPDWORD _p6)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegReplaceKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegReplaceKeyW(HKEY _p1, LPCWSTR _p2, LPCWSTR _p3, LPCWSTR _p4);
#else
LONG __stdcall GodotFailRegReplaceKeyW(HKEY _p1, LPCWSTR _p2, LPCWSTR _p3, LPCWSTR _p4)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegSaveKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegSaveKeyW(HKEY _p1, LPCWSTR _p2, LPSECURITY_ATTRIBUTES _p3);
#else
LONG __stdcall GodotFailRegSaveKeyW(HKEY _p1, LPCWSTR _p2, LPSECURITY_ATTRIBUTES _p3)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegSetValueW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegSetValueW(HKEY _p1, LPCWSTR _p2, DWORD _p3, LPCWSTR _p4, DWORD _p5);
#else
LONG __stdcall GodotFailRegSetValueW(HKEY _p1, LPCWSTR _p2, DWORD _p3, LPCWSTR _p4, DWORD _p5)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegSetValueExW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegSetValueExW(HKEY _p1, LPCWSTR _p2, DWORD _p3, DWORD _p4, const BYTE * _p5, DWORD _p6);
#else
LONG __stdcall GodotFailRegSetValueExW(HKEY _p1, LPCWSTR _p2, DWORD _p3, DWORD _p4, const BYTE * _p5, DWORD _p6)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RegUnLoadKeyW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailRegUnLoadKeyW(HKEY _p1, LPCWSTR _p2);
#else
LONG __stdcall GodotFailRegUnLoadKeyW(HKEY _p1, LPCWSTR _p2)
{
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=RemovePropA
Begin=
#ifdef FAIL_TEMPLATE_HEADER
HANDLE __stdcall GodotFailRemovePropA(HWND _p1, LPCSTR _p2);
#else
HANDLE __stdcall GodotFailRemovePropA(HWND _p1, LPCSTR _p2)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "RemovePropA");
    if(lpfn)
        return((HANDLE)(* lpfn)(_p1, _p2));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(NULL);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=SetPropA
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailSetPropA(HWND _p1, LPCSTR _p2, HANDLE _p3);
#else
BOOL __stdcall GodotFailSetPropA(HWND _p1, LPCSTR _p2, HANDLE _p3)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "SetPropA");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2, _p3));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=SetWindowLongA
Begin=
#ifdef FAIL_TEMPLATE_HEADER
LONG __stdcall GodotFailSetWindowLongA(HWND _p1, int _p2, LONG _p3);
#else
LONG __stdcall GodotFailSetWindowLongA(HWND _p1, int _p2, LONG _p3)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("user32.dll"), "SetWindowLongA");
    if(lpfn)
        return((LONG)(* lpfn)(_p1, _p2, _p3));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=SHChangeNotify
Begin=
#ifdef FAIL_TEMPLATE_HEADER
void __stdcall GodotFailSHChangeNotify(LONG _p1, UINT _p2, LPCVOID _p3, LPCVOID _p4);
#else
void __stdcall GodotFailSHChangeNotify(LONG _p1, UINT _p2, LPCVOID _p3, LPCVOID _p4)
{
    // We had better hope the shell has been loaded by now!
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("shell32.dll"), "SHChangeNotify");
    if(lpfn)
        (* lpfn)(_p1, _p2, _p3, _p4);
    else
        SetLastError(ERROR_PROC_NOT_FOUND);

    return;
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=TextOutW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
BOOL __stdcall GodotFailTextOutW(HDC _p1, int _p2, int _p3, LPCWSTR _p4, int _p5);
#else
BOOL __stdcall GodotFailTextOutW(HDC _p1, int _p2, int _p3, LPCWSTR _p4, int _p5)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("gdi32.dll"), "TextOutW");
    if(lpfn)
        return((BOOL)(* lpfn)(_p1, _p2, _p3, _p4, _p5));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=wsprintfW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int _cdecl GodotFailwsprintfW(LPWSTR _p1, LPCWSTR _p2, ... );
#else
int _cdecl
GodotFailwsprintfW(LPWSTR _p1, LPCWSTR _p2, ... )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return -1;
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=wvsprintfW
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFailwvsprintfW(LPWSTR _p1, LPCWSTR _p2, va_list _p3);
#else
int __stdcall GodotFailwvsprintfW(LPWSTR _p1, LPCWSTR _p2, va_list _p3)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return -1;
}
#endif // FAIL_TEMPLATE_HEADER
End=

[EFunc]
TemplateName=WideCharToMultiByte
Begin=
#ifdef FAIL_TEMPLATE_HEADER
int __stdcall GodotFailWideCharToMultiByte(UINT _p1, DWORD _p2, LPCWSTR _p3, int _p4, 
                                           LPSTR _p5, int _p6, LPCSTR _p7, LPBOOL _p8);
#else
int __stdcall GodotFailWideCharToMultiByte(UINT _p1, DWORD _p2, LPCWSTR _p3, int _p4, 
                                           LPSTR _p5, int _p6, LPCSTR _p7, LPBOOL _p8)
{
    FARPROC lpfn = GetProcAddressInternal(GetModuleHandleA("kernel32.dll"), "WideCharToMultiByte");
    if(lpfn)
        return((int)(* lpfn)(_p1, _p2, _p3, _p4, _p5, _p6, _p7, _p8));

    SetLastError(ERROR_PROC_NOT_FOUND);
    return(0);
}
#endif // FAIL_TEMPLATE_HEADER
End=
