#include "ct.h"

#include <stdlib.h>

FILEMAP gfm;

char* g_pszInputFile;
char* g_pszCaller;
char* g_pszCallee;
int   g_nLevel = 1;
BOOL  g_bApplyUserRule = FALSE;

/*********************************************************************
* ParseCommandLine
*
*********************************************************************/
BOOL
ParseCommandLine(
    int           argc,
    LPSTR         argv[])
{
    char c, *p;
    int  argcParm = argc;

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p) {
                switch (toupper(c)) {
                    case 'I':
                        if (g_pszInputFile != NULL) {
                            LogMsg(LM_ERROR, "-i already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszInputFile = *argv;
                        break;

                    case 'R':
                        if (g_pszCaller != NULL) {
                            LogMsg(LM_ERROR, "-r already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszCaller = *argv;
                        break;

                    case 'U':
                        g_bApplyUserRule = TRUE;
                        break;

                    case 'E':
                        if (g_pszCallee != NULL) {
                            LogMsg(LM_ERROR, "-e already specified");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        g_pszCallee = *argv;
                        break;

                    case 'L':
                        {
                            char* pszLevel;

                            argc--, argv++;
                            pszLevel = *argv;

                            g_nLevel = atoi(pszLevel);

                            break;
                        }

                    default:
                        LogMsg(LM_ERROR, "Invalid parameter: %c", c);

                    case '?':
                        goto PrintHelp;
                }
            }
        }
    }

    if (g_pszInputFile == NULL) {
        g_pszInputFile = "calltree.out";
    }

    return TRUE;

PrintHelp:
    LogMsg(LM_PRINT, "\nCaller/Callee tree generator");
    LogMsg(LM_PRINT, "Version 2.0\n");
    LogMsg(LM_PRINT, "Usage: ct [-i input_file] -e function -r function -l level\n");
    LogMsg(LM_PRINT, "\t-i input_file - calltree.out generated by the linker");
    LogMsg(LM_PRINT, "\t-e function   - dump the callee tree for the function");
    LogMsg(LM_PRINT, "\t-r function   - dump the caller tree for the function");
    LogMsg(LM_PRINT, "\t-l level      - how deep to go on the tree");
    LogMsg(LM_PRINT, "\t-u            - allpy ntuser rule[s]");
    LogMsg(LM_PRINT, "\nExamples");
    LogMsg(LM_PRINT, "ct -e xxxMoveEvent -l 10");
    LogMsg(LM_PRINT, "ct -i userk.out -r xxxSwitchDesktop -l 2");
    LogMsg(LM_PRINT, "ct -i w32.out -e xxxMoveEvent -r xxxSwitchDesktop -l 2");
    return FALSE;
}

/*********************************************************************
* main
*
*********************************************************************/
int __cdecl
main(
    int argc,
    char *argv[])
{
    if (!InitMemManag()) {
        LogMsg(LM_ERROR, "Memory initialization failed");
        return 0;
    }

    if (!ParseCommandLine(argc, argv))
        return 0;
    
    if (!CtMapFile(g_pszInputFile, &gfm))
        return 0;

    ProcessInputFile(&gfm);

    if (g_pszCaller != NULL)
        ListCallerTree(g_pszCaller, g_nLevel, 1);
    
    if (g_pszCallee != NULL)
        ListCalleeTree(g_pszCallee, g_nLevel, 1);
    
    if (g_bApplyUserRule) {
        CheckUserRule();
        CheckUnnecessaryXXX();
    }
    
    CtUnmapFile(&gfm);

    FreeMemory();

    return 1;
}

