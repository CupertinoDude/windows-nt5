/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winsif.idl

Abstract:

    Contains the WINS Server Service API.
    Also contains the RPC specific data structures for these API.

Author:
	Pradeep Bahl		Apr, 1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

//
// Interface Attributes
//

//
// UUID for the winsif interface.  This was generated by uuidgen /i on
// pradeepb_486 at 10:22 am.
//

[

	uuid(45F52C28-7F9F-101A-B52B-08002B2EFABE),
    	version(1.0),
#ifdef __midl
	ms_union,
#endif // __midl
    	pointer_default(unique)
]

//
// Interface Keyword
//

interface winsif


//
// Interface Body
//

{

import   "winsimp.idl";

//
// ---------------------------------------------------------------//
//
// Note that there are two kinds of handles below. Originally, almost
// all RPC apis did not take explicit handle as an argument. WinsBind
// created an implicit handle and the same handle was used for making
// rpc calls. There were few APIs ( GetBroserName and WinsStatusWHdl)
// which tool explicit handle as an argument. This handle was a user
// defined type WINSINTF_BIND_DATA_T.
//
// However, this original scheme had fundamental problem that multiple
// threads could not call the apis simultaneously with binding to different
// wins servers. (coz there was only one implicit binding common for all
// the threads )
//
// To get around this problem, a new handle was created WINSIF2_HANDLE.
// The client stubs take this handle as an argument, but to keep the
// rpc backward compatible, the server apis are kept the same as before.
// i.e the server side stubs do not take handle as an argument. Since
// the WINSIF2_HANDLE is defined as handle_t (primitive), it is not
// passed on the wire and things work out ok. The makefil0 is modified
// so that the client stubs and the server stubs generate different
// signatures for the apis. DECLARE_WINS_HANDLE macro does the required
// trick here.
//
// In future, if new APIs need to be added, pls. always pass WINSIF2_HANDLE
// explicitly to both server and the client side.
//

typedef handle_t WINSIF2_HANDLE;
typedef [handle] PWINSINTF_BIND_DATA_T WINSIF_HANDLE;


//
// WINS Server APIs
//

#ifdef  WINS_CLIENT_APIS
#define DECLARE_WINS_HANDLE( _hdl )  [in] WINSIF2_HANDLE    _hdl,
#define DECLARE_WINS_HANDLE0( _hdl ) [in] WINSIF2_HANDLE    _hdl
#else
#define DECLARE_WINS_HANDLE( _hdl )
#define DECLARE_WINS_HANDLE0( _hdl )
#endif  WINS_CLIENT_APIS


//
// APIs to
//

DWORD
R_WinsRecordAction(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, out, ref] PWINSINTF_RECORD_ACTION_T *ppRecAction
    );

DWORD
R_WinsStatus(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in]	  WINSINTF_CMD_E      	   Cmd_e,
	[in, out, ref] PWINSINTF_RESULTS_T pResults
   );
DWORD
R_WinsTrigger(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, ref] PWINSINTF_ADD_T 	pWinsAdd,
	[in]	  WINSINTF_TRIG_TYPE_E  TrigType_e
   );

DWORD
R_WinsDoStaticInit(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, unique, string] LPWSTR pDataFilePath,
    [in]                  DWORD fDel
		);

DWORD
R_WinsDoScavenging(
        DECLARE_WINS_HANDLE0( ServerHdl )
);

DWORD
R_WinsGetDbRecs(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, ref] PWINSINTF_ADD_T	pWinsAdd,
	[in]	  WINSINTF_VERS_NO_T	MinVersNo,
	[in]	  WINSINTF_VERS_NO_T	MaxVersNo,
	[out]     PWINSINTF_RECS_T      pRecs
	);

DWORD
R_WinsTerm(
        [in] handle_t ServerHdl,
	[in] short	fAbruptTem
	);

DWORD
R_WinsBackup(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, string, ref] LPBYTE	pBackupPath,
	[in] short	fIncremental
	);
DWORD
R_WinsDelDbRecs(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, ref] PWINSINTF_ADD_T	pWinsAdd,
	[in]	  WINSINTF_VERS_NO_T	MinVersNo,
	[in]	  WINSINTF_VERS_NO_T	MaxVersNo
	);

DWORD
R_WinsPullRange(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, ref] PWINSINTF_ADD_T	pWinsAdd,
	[in, ref] PWINSINTF_ADD_T	pOwnerAdd,
	[in]	  WINSINTF_VERS_NO_T	MinVersNo,
	[in]	  WINSINTF_VERS_NO_T	MaxVersNo
	);
DWORD
R_WinsSetPriorityClass(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in]	  WINSINTF_PRIORITY_CLASS_E	PrCls_e
	);

DWORD
R_WinsResetCounters(
        DECLARE_WINS_HANDLE0( ServerHdl )
);


DWORD
R_WinsWorkerThdUpd(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in]	DWORD NewNoOfNbtThds
	 );

//
// Keep size_is value > MAX_COMPUTERNAME_LENGTH.  Somehow, the idl parser
// is not liking a symbol here.  No time to investigate this more at this
// time
//
DWORD
R_WinsGetNameAndAdd(
        DECLARE_WINS_HANDLE( ServerHdl )
	[out, ref]  PWINSINTF_ADD_T pWinsAdd,
	[out, string, size_is(80)] LPBYTE pUncName
	 );
DWORD
R_WinsGetBrowserNames_Old(
        DECLARE_WINS_HANDLE( ServerHdl )
	[out] PWINSINTF_BROWSER_NAMES_T	 pNames
	 );

DWORD
R_WinsDeleteWins(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, ref] PWINSINTF_ADD_T	pWinsAdd
	 );

DWORD
R_WinsSetFlags(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in] DWORD fFlags	
	 );

DWORD
R_WinsGetBrowserNames(
        [in, ref]  WINSIF_HANDLE             ServerHdl,
	[out] PWINSINTF_BROWSER_NAMES_T	 pNames
	 );
DWORD
R_WinsGetDbRecsByName(
        DECLARE_WINS_HANDLE( ServerHdl )
        [in, unique]                PWINSINTF_ADD_T	        pWinsAdd,
        [in]                        DWORD                   Location,
        [in, unique, size_is(NameLen + 1)]      LPBYTE          pName,
        [in]                        DWORD                   NameLen,
        [in]                        DWORD                   NoOfRecsDesired,
        [in]                        DWORD                   fOnlyStatic,
        [out]                       PWINSINTF_RECS_T        pRecs
	);

DWORD
R_WinsStatusNew(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in]	   WINSINTF_CMD_E      	   Cmd_e,
	[out]      PWINSINTF_RESULTS_NEW_T pResults
   );

DWORD
R_WinsStatusWHdl(
        [in, ref]    WINSIF_HANDLE             ServerHdl,
	[in]	  WINSINTF_CMD_E      	   Cmd_e,
	[in, out, ref] PWINSINTF_RESULTS_NEW_T pResults
   );

DWORD
R_WinsDoScavengingNew(
        DECLARE_WINS_HANDLE( ServerHdl )
	[in, ref] PWINSINTF_SCV_REQ_T	pScvReq
  );

}

