// ===========================================================================//	UAMDLOGUtils.c 				© 1997 Microsoft Corp. All rights reserved.// ===========================================================================// General dialog utilities used by the Microsoft User Authentication Method.//// ===========================================================================#include <Dialogs.h>#include <Events.h>#include <Controls.h>#include <Sound.h>#include <ControlDefinitions.h>#include <ctype.h>#include "UAMUtils.h"#include "UAMListBox.h"#include "UAMDLOGText.h"#include "UAMDLOGUtils.h"#include "UAMDebug.h"	// ---------------------------------------------------------------------------//		¥ UAM_GetScreenBounds()// ---------------------------------------------------------------------------Rect UAM_GetScreenBounds(){	GrafPtr		savePort,p;	Rect		screenBounds;		GetPort(&savePort);		p = (GrafPtr)NewPtr(sizeof(GrafPort));	OpenPort(p);		screenBounds = p->portBits.bounds;		ClosePort(p);	DisposePtr((Ptr)p);		return(screenBounds);}// ---------------------------------------------------------------------------//		¥ UAM_GetCHandle()// ---------------------------------------------------------------------------ControlHandle UAM_GetCHandle(DialogPtr inDialog, short item){	short	itype;	Rect	irect;	Handle	ihan;		GetDialogItem(inDialog, item, &itype, &ihan, &irect);	return((ControlHandle)ihan);}// ---------------------------------------------------------------------------//		¥ UAM_GetItemRect()// ---------------------------------------------------------------------------Rect UAM_GetItemRect(DialogPtr inDialog, short item){	short	itype;	Rect	irect;	Handle	ihan;		GetDialogItem(inDialog, item, &itype, &ihan, &irect);	return(irect);}// ---------------------------------------------------------------------------//		¥ UAM_ToggleControl()// ---------------------------------------------------------------------------void UAM_ToggleControl(DialogPtr inDialog, short item){	UAM_SetCValue(inDialog, item, UAM_GetCValue(inDialog, item) == 0);}// ---------------------------------------------------------------------------//		¥ UAM_GetText()// ---------------------------------------------------------------------------void UAM_GetText(DialogPtr inDialog, short item, Str255 *theText){	short	itype;	Handle	ihan;	Rect	irect;			GetDialogItem(inDialog, item, &itype, &ihan, &irect);		if ((itype == editText)||(itype == editText + itemDisable))		GetDialogItemText(ihan, *theText);}// ---------------------------------------------------------------------------//		¥ UAM_SetText()// ---------------------------------------------------------------------------void UAM_SetText(DialogPtr inDialog, short item, Str255 theText){	short	itype;	Handle	ihan;	Rect	irect;		GetDialogItem(inDialog, item, &itype, &ihan, &irect);	if ((itype == editText)		||(itype == editText+itemDisable)		||(itype == statText)		||(itype == statText+itemDisable))				SetDialogItemText(ihan, theText);}// ---------------------------------------------------------------------------//		¥ UAM_HiliteItem()// ---------------------------------------------------------------------------void UAM_HiliteItem(DialogPtr inDialog, short item, short value){	short	itype;	Handle	ihan;	Rect	irect;		GetDialogItem(inDialog, item, &itype, &ihan, &irect);	HiliteControl((ControlHandle)ihan, value);}// ---------------------------------------------------------------------------//		¥ UAM_IsActive()// ---------------------------------------------------------------------------Boolean UAM_IsActive(DialogPtr inDialog, short item){	ControlHandle	theHandle;		theHandle = UAM_GetCHandle(inDialog, item);	if (theHandle)	{		return(((*theHandle)->contrlHilite != 255));	}		return(false);}// ---------------------------------------------------------------------------//		¥ UAM_GetCValue()// ---------------------------------------------------------------------------short UAM_GetCValue(DialogPtr inDialog, short item){	short	itype;	Handle	ihan;	Rect	irect;	short	result;		GetDialogItem(inDialog, item, &itype, &ihan, &irect);	result = GetControlValue((ControlHandle)ihan);				return(result);}// ---------------------------------------------------------------------------//		¥ UAM_SetCValue()// ---------------------------------------------------------------------------void UAM_SetCValue(DialogPtr inDialog, short item, short value){	short	itype;	Handle	ihan;	Rect	irect;		GetDialogItem(inDialog, item, &itype, &ihan, &irect);	SetControlValue((ControlHandle)ihan, value);}// ---------------------------------------------------------------------------//		¥ UAM_PositionDialog()// ---------------------------------------------------------------------------void UAM_PositionDialog(ResType theType, short theID){	Rect	*theRect;	Rect	screenBounds;	Handle	theTemplate;	short	left,top;		screenBounds = UAM_GetScreenBounds();		theTemplate = GetResource(theType, theID);	theRect = (Rect *)*theTemplate;		left = (screenBounds.right - (theRect->right - theRect->left)) / 2;	top = (screenBounds.bottom - (theRect->bottom - theRect->top)) / 3;		if (top < LMGetMBarHeight())		top = LMGetMBarHeight() + 7;		theRect->right = theRect->right + left - theRect->left;	theRect->left = left;	theRect->bottom = theRect->bottom + top - theRect->top;	theRect->top = top;}// ---------------------------------------------------------------------------//		¥ UAM_GetItemType()// ---------------------------------------------------------------------------short UAM_GetItemType(DialogPtr inDialog, short item){	short	itype;	Handle	ihan;	Rect	irect;		GetDialogItem(inDialog, item, &itype, &ihan, &irect);				return(itype);}// ---------------------------------------------------------------------------//		¥ UAM_NewDialog()// ---------------------------------------------------------------------------DialogPtr UAM_NewDialog(short id, Boolean show){	Ptr			storage;	DialogPtr	dialog;	short		x;			storage = NewPtrClear(sizeof(UAMDialogRec));	if (storage == NULL) {		return(NULL);	}				dialog = GetNewDialog(id, storage, (WindowPtr) -1);	if (dialog == NULL) {		return(NULL);	}		SetPort(dialog);		if (UAM_GetItemType(dialog, kStdOkItemIndex) == kButtonDialogItem) {		SetDialogDefaultItem(dialog, kStdOkItemIndex);	}		if (UAM_GetItemType(dialog, kStdCancelItemIndex) == kButtonDialogItem) {		SetDialogCancelItem(dialog, kStdCancelItemIndex);	}	SetDialogTracksCursor(dialog, true);	if (show) {		ShowWindow(dialog);	}			UAM_DLOG(dialog).hasScrollBar 	= FALSE;	UAM_DLOG(dialog).supportCmdKeys	= TRUE;	UAM_DLOG(dialog).customFilter	= NULL;	UAM_DLOG(dialog).hasList		= false;		for (x = 0; x < kMaxGatedItems; x++)	{		UAM_DLOG(dialog).gateItems[x].controlID		= 0;		UAM_DLOG(dialog).gateItems[x].textID		= 0;	}		for (x = 0; x < kMaxBulletItems; x++)	{		UAM_DLOG(dialog).bulletItems[x].editID		= 0;		UAM_DLOG(dialog).bulletItems[x].maxLength	= 0;		UAM_DLOG(dialog).bulletItems[x].hTE			= NULL;	}		UAM_DLOG(dialog).scrollActionProc = NewControlActionProc(&UAM_ScrollText);			InitCursor();	return(dialog);}		// ---------------------------------------------------------------------------//		¥ UAM_Update()// ---------------------------------------------------------------------------void UAM_Update(DialogPtr inDialog){	GrafPtr	savePort;		GetPort(&savePort);	SetPort(inDialog);		BeginUpdate(inDialog);			if (UAM_DLOG(inDialog).hasScrollBar) {		UAM_UpdateText(inDialog);	}			if (UAM_DLOG(inDialog).hasList) {		UAM_ListUpdate(inDialog);	}			DrawDialog(inDialog);	DrawControls(inDialog);	EndUpdate(inDialog);		SetPort(savePort);}// ---------------------------------------------------------------------------//		¥ UAM_DialogFilter()// ---------------------------------------------------------------------------pascal Boolean UAM_DialogFilter(DialogPtr inDialog, EventRecord *e, short *itemHit){	Boolean 		result;	short			thePart, temp;	Point			pt;	ControlHandle	theControl;	ModalFilterUPP	theStdProc;				result = FALSE;		if (GetStdFilterProc(&theStdProc) == noErr)	{		if (CallModalFilterProc(theStdProc, inDialog, e, itemHit))		{			//			//The standard proc handled everything for us, so exit.			//			return(TRUE);		}	}		if (UAM_DLOG(inDialog).customFilter != NULL)	{		if (CallModalFilterProc(UAM_DLOG(inDialog).customFilter, inDialog, e, itemHit))		{			return(TRUE);		}	}		switch(e->what)	{		case updateEvt:			if ((DialogPtr)e->message == inDialog)				UAM_Update(inDialog);			break;					case mouseDown:			pt = e->where;			GlobalToLocal(&pt);						if (UAM_DLOG(inDialog).hasScrollBar)			{				thePart = FindControl(pt, inDialog, &theControl);				if (theControl == UAM_DLOG(inDialog).scrollBar)				{					if (thePart == kControlIndicatorPart)					{						temp = TrackControl(theControl, pt, 0L);						UAM_AdjustText(theControl);						result = TRUE;					}					else if (thePart >= kControlUpButtonPart)					{						temp = TrackControl(theControl, pt, UAM_DLOG(inDialog).scrollActionProc);						result = TRUE;					}				}			}						if ((!result) && (UAM_DLOG(inDialog).hasList)) {				result = UAM_ListDialogFilter(inDialog, e, itemHit);			}			break;					case keyDown:		case autoKey:			result = UAM_ProcessKeydown(inDialog, e, itemHit);			break;					default:			break;	}				return(result);}// ---------------------------------------------------------------------------//		¥ UAM_CheckGatedControls()// ---------------------------------------------------------------------------void UAM_CheckGatedControls(DialogPtr inDialog){	short			x,i;	Str255			s2;			//	//Flip through each of the gated controls and check to see if their associated	//text box has text of not.	//	for (x = 0; x < kMaxGatedItems; x++)	{		if (	(UAM_DLOG(inDialog).gateItems[x].controlID != 0)	&&				(UAM_DLOG(inDialog).gateItems[x].textID != 0)		)		{			UAM_GetText(					inDialog,					UAM_DLOG(inDialog).gateItems[x].textID,					(Str255 *)&s2			);						//			//Do we have text in the associated text box? And, is the first character			//a non-white space?			//			if ((s2[0] == 0) || (isspace(s2[1])))			{				if (UAM_DLOG(inDialog).gateItems[x].state != 255)				{					//					//No, so set the state of the box to 255 which grays it out.					//					UAM_DLOG(inDialog).gateItems[x].state = 255;										UAM_HiliteItem(							inDialog,							UAM_DLOG(inDialog).gateItems[x].controlID,							UAM_DLOG(inDialog).gateItems[x].state					);										//					//Now see if any other controls are gated to this text box. If so, then					//set the state to grayed also at this point.					//					for (i = 0; i < kMaxGatedItems; i++)					{						if ((i != x) && (UAM_DLOG(inDialog).gateItems[i].controlID != 0))						{							if (UAM_DLOG(inDialog).gateItems[i].textID == UAM_DLOG(inDialog).gateItems[x].textID)							{								UAM_DLOG(inDialog).gateItems[i].state = 255;																UAM_HiliteItem(										inDialog,										UAM_DLOG(inDialog).gateItems[i].controlID,										UAM_DLOG(inDialog).gateItems[i].state								);							}						}					}				}			}			else			{				UAM_DLOG(inDialog).gateItems[x].state = 0;								UAM_HiliteItem(						inDialog,						UAM_DLOG(inDialog).gateItems[x].controlID,						UAM_DLOG(inDialog).gateItems[x].state				);			}		}	}}	// ---------------------------------------------------------------------------//		¥ UAM_FrameItem()// ---------------------------------------------------------------------------pascal void UAM_FrameItem(DialogPtr inDialog, short i){	GrafPtr	savePort;	Rect	r;		GetPort(&savePort);	SetPort(inDialog);		r = UAM_GetItemRect( inDialog, i);	if ((r.bottom - r.top <= 1) || (r.right - r.left <= 1))	{		if (r.bottom - r.top <= 1) {			MoveTo(r.left, r.top);			LineTo(r.right, r.top);		} else {			MoveTo(r.left, r.top);			LineTo(r.left, r.bottom);		}	}	else		FrameRect(&r);		SetPort(savePort);}// ---------------------------------------------------------------------------//		¥ UAM_GetDRect()// ---------------------------------------------------------------------------Rect UAM_GetDRect( short id ){	DialogTHndl	dTh;	Rect		r;		dTh = (DialogTHndl)Get1Resource('DLOG', id);	r = (**dTh).boundsRect;		ReleaseResource((Handle)dTh);		return(r);}	// ---------------------------------------------------------------------------//		¥ UAM_SetUpUserItem()// ---------------------------------------------------------------------------void UAM_SetUpUserItem(DialogPtr inDialog, short i, UserItemUPP userProc, short type){	short	itype;	Handle	ihan;	Rect	irect;		GetDialogItem(inDialog, i, &itype, &ihan, &irect);	SetDialogItem(inDialog, i, type, (Handle)userProc, &irect);}// ---------------------------------------------------------------------------//		¥ UAM_DisposeDialog()// ---------------------------------------------------------------------------void UAM_DisposeDialog(DialogPtr inDialog){	SInt16	x;		if (UAM_DLOG(inDialog).hasScrollBar)	{		if (UAM_DLOG(inDialog).dialogTE)			TEDispose(UAM_DLOG(inDialog).dialogTE);		if (UAM_DLOG(inDialog).scrollBar)			DisposeControl(UAM_DLOG(inDialog).scrollBar);	}		DisposeRoutineDescriptor(UAM_DLOG(inDialog).scrollActionProc);		if (UAM_DLOG(inDialog).hasList) {		LDispose(UAM_DLOG(inDialog).dialogList);	}		for (x = 0; x < kMaxBulletItems; x++)	{		if (UAM_DLOG(inDialog).bulletItems[x].hTE != NULL)		{			TEDispose(UAM_DLOG(inDialog).bulletItems[x].hTE);			UAM_DLOG(inDialog).bulletItems[x].hTE = NULL;		}	}			DisposeDialog(inDialog);}// ---------------------------------------------------------------------------//		¥ UAM_GateControl()// ---------------------------------------------------------------------------void UAM_GateControl(DialogPtr inDialog, short controlID, short textID){	short	x;	Boolean	found = false;		//	//Find the next available gate slot.	//		for (x = 0; x < kMaxGatedItems; x++)	{		if (UAM_DLOG(inDialog).gateItems[x].controlID == 0)		{			found = true;			break;		}	}		if (found)	{		UAM_DLOG(inDialog).gateItems[x].controlID	= controlID;		UAM_DLOG(inDialog).gateItems[x].textID		= textID;	}}// ---------------------------------------------------------------------------//		¥ UAM_StopGate()// ---------------------------------------------------------------------------void UAM_StopGate(DialogPtr inDialog, short controlID){	SInt16	x;		for (x = 0; x < kMaxGatedItems; x++)	{		if (UAM_DLOG(inDialog).gateItems[x].controlID == controlID)		{			UAM_DLOG(inDialog).gateItems[x].controlID	= 0;			UAM_DLOG(inDialog).gateItems[x].textID		= 0;			UAM_DLOG(inDialog).gateItems[x].state		= 0;						UAM_HiliteItem(inDialog, controlID, 0);						break;		}	}}// ---------------------------------------------------------------------------//		¥ UAM_SetBulletItem()// ---------------------------------------------------------------------------void UAM_SetBulletItem(DialogPtr inDialog, short item, short maxLen){	short 		x;	Boolean		found = false;	Rect		rDest;		for (x = 0; x < kMaxBulletItems; x++)	{		if (UAM_DLOG(inDialog).bulletItems[x].editID == 0)		{			found = true;			break;		}	}		if (found)	{		UAM_DLOG(inDialog).bulletItems[x].editID	= item;		UAM_DLOG(inDialog).bulletItems[x].maxLength	= maxLen;				SetRect(&rDest, -1001, -1001, -1000, -1000);		UAM_DLOG(inDialog).bulletItems[x].hTE = TENew(&rDest, &rDest);	}}// ---------------------------------------------------------------------------//		¥ UAM_SetBulletText()// ---------------------------------------------------------------------------void UAM_SetBulletText(DialogPtr inDialog, short item, Str255 text){	short		x, i;	Str255		s;	TEHandle	hTE = NULL;			//	//Flip through all the bullet items till we find the one to set	//		for (x = 0; x < kMaxBulletItems; x++)	{		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)		{			SelectDialogItemText(inDialog, item, 0, 0);						s[0] = 0;							for (i = 1; i <= text[0]; i++) 			{				s[i] = kPasswordBulletText;				s[0]++;			}						UAM_SetText(inDialog, item, s);						TESetText(&text[1], text[0], UAM_DLOG(inDialog).bulletItems[x].hTE);		}	}}// ---------------------------------------------------------------------------//		¥ UAM_ClearBulletText()// ---------------------------------------------------------------------------void UAM_ClearBulletText(DialogPtr inDialog, short item){	short	x;	TEPtr	pTE;			//	//Flip through all the bullet items till we find the one to set	//		for (x = 0; x < kMaxBulletItems; x++)	{		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)		{			UAM_SetText(inDialog, item, "\p");						HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);						pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);			pTE->selStart	= 0;			pTE->selEnd		= pTE->teLength;						HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);						TEDelete(UAM_DLOG(inDialog).bulletItems[x].hTE);			break;		}	}}// ---------------------------------------------------------------------------//		¥ UAM_ProcessKeydown()// ---------------------------------------------------------------------------Boolean UAM_ProcessKeydown(DialogPtr inDialog, EventRecord *event, short *item){	Boolean		result 		= false;	short		chCode		= (event->message & charCodeMask);	Cell		theCell		= {0,0};	Cell		tempCell	= {0,0};	short		x;	TEHandle	hTE;	TEPtr		pTE;		//	//See if we want to support the edit command keys. If not, then	//kill the event and act like nothing happend. Also checkd for	//the unsupported Forward Delete key.	//		if (	((!UAM_DLOG(inDialog).supportCmdKeys) && (event->modifiers & cmdKey)) ||			(chCode == UAMKey_FwdDel)									)	{		event->what		= nullEvent;		event->message	= 0;				return(true);	}		//	//If we have a list box, then we want to process the arrow keys for up	//and down movement only. We can't process the keys directly here because	//we can't call LGetSelect() from this callback routine.	//		if (UAM_DLOG(inDialog).hasList)	{		switch(chCode)		{			case UAMKey_Up:			case UAMKey_Down:			case UAMKey_PageUp:			case UAMKey_PageDown:			case UAMKey_Home:			case UAMKey_End:				*item = DITEM_ListNavigationKey;								UAM_DLOG(inDialog).lastKeyCode	= chCode;				UAM_DLOG(inDialog).modifiers	= event->modifiers;								result = true;				break;							default:				*item = DITEM_ListMoveToKey;				UAM_DLOG(inDialog).lastKeyCode	= chCode;				UAM_DLOG(inDialog).modifiers	= event->modifiers;								GetDateTime(&UAM_DLOG(inDialog).lastKeyTime);								result = true;				break;		}	}		for (x = 0; x < kMaxBulletItems; x++)	{		if ((UAM_DLOG(inDialog).standardDialog.editField + 1) == UAM_DLOG(inDialog).bulletItems[x].editID)		{			switch(chCode)			{				case UAMKey_PageUp:				case UAMKey_PageDown:				case UAMKey_Home:				case UAMKey_End:				case UAMKey_Tab:				case UAMKey_Left:				case UAMKey_Right:				case UAMKey_Up:				case UAMKey_Down:					//					//We don't want to process these keys so just break here and continue.					//					break;								case UAMKey_FwdDel:					break;								default:					hTE = UAM_DLOG(inDialog).standardDialog.textH;					if (hTE == NULL) {						break;					}															if (chCode != UAMKey_BackDel)					{						event->message -= chCode;						event->message += kPasswordBulletText;					}										HLock((Handle)hTE);					HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);										pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);					pTE->selStart	= (*hTE)->selStart;					pTE->selEnd		= (*hTE)->selEnd;										if ((pTE->selStart == pTE->selEnd) && (chCode != UAMKey_BackDel))					{						if (pTE->teLength >= UAM_DLOG(inDialog).bulletItems[x].maxLength)						{							SysBeep(1);							HUnlock((Handle)hTE);							HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);														event->what		= nullEvent;							event->message	= 0;														break;						}					}										HUnlock((Handle)hTE);					HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);										TEKey(chCode, UAM_DLOG(inDialog).bulletItems[x].hTE);					break;			}						break;		}	}		return(result);}// ---------------------------------------------------------------------------//		¥ UAM_GetBulletBuffer()// ---------------------------------------------------------------------------void UAM_GetBulletBuffer(DialogPtr inDialog, short item, StringPtr outBuffer){	short 		x;	Boolean		found = false;	TEPtr		pTE;		for (x = 0; x < kMaxBulletItems; x++)	{		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)		{			found = true;			break;		}	}		if (found)	{		HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);						pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);		outBuffer[0] 	= pTE->teLength;				HLock(pTE->hText);				BlockMove(*pTE->hText, &outBuffer[1], pTE->teLength);				HUnlock(pTE->hText);		HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);	}}// ---------------------------------------------------------------------------//		¥ UAM_SupportCmdKeys()// ---------------------------------------------------------------------------void UAM_SupportCmdKeys(DialogPtr inDialog, Boolean support){	UAM_DLOG(inDialog).supportCmdKeys = support;}// ---------------------------------------------------------------------------//		¥ UAM_SetCustomFilterProc()// ---------------------------------------------------------------------------void UAM_SetCustomFilterProc(DialogPtr inDialog, ModalFilterUPP proc){	if (UAM_DLOG(inDialog).customFilter == NULL)	{		UAM_DLOG(inDialog).customFilter = proc;	}}