// ===========================================================================//	UAMDLOGText.c 				© 1997 Microsoft Corp. All rights reserved.// ===========================================================================// Utilities for maintaining a scrolling text field in a dialog.//// ===========================================================================#include <ControlDefinitions.h>#include "UAMDLOGUtils.h"#include "UAMDLOGText.h"// ---------------------------------------------------------------------------//		¥ UAM_AdjustText()// ---------------------------------------------------------------------------void UAM_AdjustText(ControlHandle theScrollBar){	DialogPtr	dialog;	TEHandle	dTE;	short		scrollValue;	char		saveState;		dialog = (*theScrollBar)->contrlOwner;	dTE = UAM_DLOG(dialog).dialogTE;	saveState = HGetState((Handle)dTE);	HLock((Handle)dTE);		scrollValue = GetControlValue( theScrollBar);	UAM_DLOG(dialog).deltaV = Abs(UAM_DLOG(dialog).vOffset) - scrollValue;	UAM_DLOG(dialog).vOffset = scrollValue;		if (UAM_DLOG(dialog).deltaV)		TEScroll(0, UAM_DLOG(dialog).deltaV, dTE);		UAM_DLOG(dialog).deltaV = 0;		HSetState((Handle)dTE, saveState);}// ---------------------------------------------------------------------------//		¥ UAM_ScrollText()// ---------------------------------------------------------------------------pascal void UAM_ScrollText(ControlHandle theControl, short thePart){	short		delta, newValue;	short		ctlMin, ctlMax;	UInt32		tix;	DialogPtr	dialog;	Rect		r;		dialog = (*theControl)->contrlOwner;	r = (*(UAM_DLOG(dialog).dialogTE))->viewRect;		switch(thePart)	{		case kControlUpButtonPart:			delta = -16;			break;		case kControlDownButtonPart:			delta = 16;			break;		case kControlPageUpPart:			delta = Min(-(r.bottom - r.top) / 2, -1);			Delay(10, &tix);			break;		case kControlPageDownPart:			delta = Max((r.bottom - r.top) / 2, 1);			Delay(10, &tix);			break;		default:			return;			break;	}		newValue = GetControlValue( theControl) + delta;		ctlMax = GetControlMaximum( theControl);	ctlMin = GetControlMinimum( theControl);		if (newValue > ctlMax)		newValue = ctlMax;	else if (newValue < ctlMin)		newValue = ctlMin;		SetControlValue( theControl, newValue);	UAM_AdjustText( theControl);}// ---------------------------------------------------------------------------//		¥ UAM_SetScrollBar()// ---------------------------------------------------------------------------void UAM_SetScrollBar(ControlHandle theScrollBar){	short		theHeight;	DialogPtr	dialog;	Rect		winRect;	TEHandle	dTE;			dialog = (*theScrollBar)->contrlOwner;	dTE = UAM_DLOG(dialog).dialogTE;	winRect = UAM_DLOG(dialog).dialogTERect;		theHeight = TEGetHeight( (*dTE)->nLines, 0, dTE);		if (theHeight > (winRect.bottom - winRect.top))		SetControlMaximum( theScrollBar, (theHeight - (winRect.bottom - winRect.top)));	else {		SetControlValue( theScrollBar, 0);		SetControlMaximum( theScrollBar, 0);	}}// ---------------------------------------------------------------------------//		¥ UAM_UpdateText()// ---------------------------------------------------------------------------void UAM_UpdateText(DialogPtr dialog){	Rect 		r;		r = UAM_DLOG(dialog).dialogTERect;	InsetRect(&r, textMargin, textMargin);	TEUpdate(&r, UAM_DLOG(dialog).dialogTE);	FrameRect(&UAM_DLOG(dialog).dialogTERect);}			// ---------------------------------------------------------------------------//		¥ UAM_FixText()// ---------------------------------------------------------------------------void UAM_FixText(DialogPtr dialog){	TEHandle	dTE;	char		saveState;		dTE = UAM_DLOG(dialog).dialogTE;		saveState = HGetState((Handle)dTE);	HLock((Handle)dTE);		(*dTE)->viewRect = UAM_DLOG(dialog).dialogTERect;		(*dTE)->viewRect.right = (*dTE)->viewRect.right;	(*dTE)->viewRect.bottom = (*dTE)->viewRect.bottom;		InsetRect( &((*dTE)->viewRect), textMargin, textMargin);	(*dTE)->destRect = (*dTE)->viewRect;		TECalText( dTE);	HSetState((Handle)dTE, saveState);}// ---------------------------------------------------------------------------//		¥ UAM_SetSText()// ---------------------------------------------------------------------------void UAM_SetSText(DialogPtr dialog, short textID){	Handle			textHndl;	Rect			r;	StScrpHandle	hST;		textHndl = Get1Resource('TEXT', textID);	if (textHndl != NULL)	{		HLock((Handle)UAM_DLOG(dialog).dialogTE);		HLock(textHndl);						r = UAM_DLOG(dialog).dialogTERect;		InsetRect(&r, textMargin, textMargin);		EraseRect(&r);		InvalRect(&r);			TESetText(*textHndl, GetHandleSize(textHndl), UAM_DLOG(dialog).dialogTE);				hST = (StScrpHandle)Get1Resource('styl', textID);		if (hST != NULL) {			HidePen();			TEUseStyleScrap( 0, 32767, hST, TRUE, UAM_DLOG(dialog).dialogTE);			ShowPen();		}		UAM_DLOG(dialog).vOffset = 0;		UAM_DLOG(dialog).deltaV  = 0;				SetControlValue(UAM_DLOG(dialog).scrollBar, 0);		UAM_FixText(dialog);		UAM_AdjustText(UAM_DLOG(dialog).scrollBar);				UAM_SetScrollBar( UAM_DLOG(dialog).scrollBar);				HUnlock((Handle)UAM_DLOG(dialog).dialogTE);		HUnlock(textHndl);				ReleaseResource(textHndl);		ReleaseResource((Handle)hST);	}}// ---------------------------------------------------------------------------//		¥ UAM_MakeText()// ---------------------------------------------------------------------------void UAM_MakeText(DialogPtr dialog, short textItem, short scrollItem, short textID){	Rect	textRect, r;			UAM_DLOG(dialog).dialogTERect = UAM_GetItemRect(dialog, textItem);	textRect = UAM_DLOG(dialog).dialogTERect;		UAM_DLOG(dialog).hasScrollBar = TRUE;		InsetRect(&textRect, textMargin, textMargin);	UAM_DLOG(dialog).dialogTE = TEStyleNew(&textRect, &textRect);		r = UAM_GetItemRect(dialog, scrollItem);	UAM_DLOG(dialog).scrollBar = NewControl(dialog, &r, "\p", TRUE, 0, 0, 0, 16, 0);	UAM_SetUpUserItem(dialog, scrollItem, (UserItemUPP)UAM_DLOG(dialog).scrollBar, ctrlItem);		UAM_SetSText(dialog, textID);}