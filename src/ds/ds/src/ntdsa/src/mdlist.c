//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdlist.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirList API.

    DSA_DirList() is the main function exported from this module.

*/



#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>			// schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>			// needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <ntdsctr.h>

// Logging headers.
#include "dsevent.h"			// header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"			// header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "permit.h"                     // RIGHT_DS_LIST_CONTENTS
#include "anchor.h"                     // For mdupdate.h
#include "debug.h"			// standard debugging header
#define DEBSUB "MDLIST:"                // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDLIST

/* Internal functions */

int LocalList(THSTATE *pTHS, LISTARG *pListArg, LISTRES *pListRes);

void ListBody(THSTATE *pTHS, LISTARG *pListArg, LISTRES *pListRes);

int GetNextListInf(THSTATE *pTHS,
                   CHILDLIST **ppChildList);

int GetListInf(THSTATE *pTHS,
               CHILDLIST *pChildList);


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/


ULONG
DirList(
	LISTARG * pListArg,
	LISTRES ** ppListRes
)
{
    THSTATE*        pTHS;
    LISTRES*        pListRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirList entered\n");

    /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
    is required on every API transaction.  First the state DS is initialized
    and then either a read or a write sync point is established.
    */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppListRes = pListRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppListRes = pListRes = THAllocEx(pTHS, sizeof(LISTRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if ((eServiceShutdown >= eSecuringDatabase) ||
                ((eServiceShutdown >= eRemovingClients) && !pTHS->fDSA)) {
                ErrorOnShutdown();
                __leave;
            }
        }

	SYNC_TRANS_READ();   /*Identify a reader trans*/
	__try {

	    pListRes->CommRes.aliasDeref = FALSE;   /*Initialize to Default*/

            // Assume no paged result
            memset(&pListRes->PagedResult,0,sizeof(PAGED_RESULT));

	    /* Call main List function*/

	    ListBody( pTHS, pListArg, pListRes );
	}
	__finally {
	    CLEAN_BEFORE_RETURN(pTHS->errCode);
	}
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
	HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pListRes) {
	pListRes->CommRes.errCode = pTHS->errCode;
	pListRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

}   /* DSA_DirList() */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if this is a restarted operation.

   The continued operation was either on this DSA or on a remote
   chained DSA.  This is determined using the isRemote flag.  Both the
   R_DirList remote DSA fns and the local LIST function
   can be continued.  On input, pRestart indicates if the function is a
   continuation.  On output it indicates if a continuation is necessary.
   These functions are responsible for setting this flag.  It should be
   TRUE only  when a good return is generated and a continuation is necessary.

   Different information is needed to restart a local from a remote operation.
   For a local call, we save the DN of the next object to be retrieved.
   For foreign call we save a pointer to the beginning of the user's RPC
   output Buf, a pointer to the next entInfList to be returned and the
   remote DSA handle.  Remote restarts are not yet implemented.

*/

void ListBody(THSTATE *pTHS, LISTARG *pListArg, LISTRES *pListRes)
{
   PRESTART       pRestart;

   pRestart = pListArg->CommArg.PagedResult.pRestart;    /* continuation? */

   if( pRestart != NULL ) {
       pListArg->pResObj = ResObjFromRestart(pTHS,
                                             pListArg->pObject,
                                             pRestart);
       LocalList(pTHS, pListArg, pListRes);
   }
   else  {
       // First transaction...Not a continuation.

       if (0 == DoNameRes(pTHS,
                          NAME_RES_QUERY_ONLY | NAME_RES_CHILDREN_NEEDED,
			  pListArg->pObject,
			  &pListArg->CommArg,
			  &pListRes->CommRes,
                          &pListArg->pResObj)) {
           LocalList(pTHS, pListArg, pListRes);
       }
   }

   return;

}/*ListBody*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Main body of local List function.  We get as many objects as will fit
   into the output buffer.  If more data is available, we use a non-null
   partialoutcomequalifier to indicate to the user that there is more data.

   The steps are as follows:

   1 - a - If this is a restarted transaction so we reposition on the next
           child to retrieve.

       b - otherwise, position on the first child.

   2 - a - Retrieve each child

       b - Try to retrieve its data into a child list structure.
           If we fail because we are out of space, we leave the partial
           outcome qualifier to indicate to the client that there is more
           data and we return the name of the current object that we were
           not able to return. We also indicate that a restart is needed.

   3 - If there are no more children, we NULL out the partial outcome
       qualifier and return.
*/

INT LocalList(THSTATE *pTHS, LISTARG *pListArg, LISTRES *pListRes)
{
    CHILDLIST  *pChildList,  /*Points to next output list info list*/
               *pLastChild;  /* ptr to ptr to last element in chain */
    INT        childRtn;
    COMMARG *  pCommArg;
    PRESTART   pArgRestart, pResRestart=NULL;
    CHILDLIST  ListRoot;
    DWORD      bufSize=0;
    PUCHAR     pVal=NULL;
    ATTCACHE   *pSortAC;
    ULONG      SearchFlags;
    POBJECT_TYPE_LIST pFilterSecurity;
    ULONG      FilterSecuritySize;
    DWORD      *pResults;
    BOOL       *pbSortSkip=NULL;

    PERFINC(pcTotalReads);
    INC_READS_BY_CALLERTYPE( pTHS->CallerType );

    pCommArg = &pListArg->CommArg;  /* only parts of listarg we use */
    pArgRestart = pCommArg->PagedResult.pRestart;
    SearchFlags = SEARCH_FLAGS(pListArg->CommArg);

    // Assert that we either don't have a restart structure OR we have said that
    // we are going to have one.  Note that it is legal to have fPresent == TRUE
    // and not actually have a pArgRestart
    Assert(!pArgRestart || pCommArg->PagedResult.fPresent);

    // Check access
    if(!IsAccessGrantedSimple(RIGHT_DS_LIST_CONTENTS, TRUE)) {
        // Might want to check for the RIGHT_DS_VIEW_OBJECT stuff if list_contents not
        //     allowed, but since this is a list operation for now only check the
        //     LIST_CONTENTS right.
        return pTHS->errCode;
    }


    // Set the base object name if an alias has been dereferenced
    if (pListRes->CommRes.aliasDeref) {
        DWORD len;
        DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                    0, 0,
                    &len, (PUCHAR *)&(pListRes->pBase));
    }
    else
        pListRes->pBase = NULL;

    // Set up the security check we need to do if they requested a sort.  If
    // this is not a sort, this is a NOP.
    GetFilterSecurity(pTHS,
                      NULL,
                      pListArg->CommArg.SortType,
                      pListArg->CommArg.SortAttr,
                      FALSE,
                      &pFilterSecurity,
                      &pbSortSkip,
                      &pResults,
                      &FilterSecuritySize);
    DBSetFilter(pTHS->pDB,
                NULL,
                pFilterSecurity,
                pResults,
                FilterSecuritySize,
                pbSortSkip);


    if( pArgRestart) {
        // A continuation
        childRtn = DBRepositionSearch(pTHS->pDB, pArgRestart,
                                      pCommArg->StartTick,
                                      pCommArg->DeltaTick,
                                      NULL,SearchFlags);
    }
    else {
        // Not a continuation, set up the search information.
	if (childRtn = DBSetSearchScope(pTHS->pDB,
                                        SE_CHOICE_IMMED_CHLDRN,
                                        FALSE,
                                        pListArg->pResObj))
            // Couldn't set the search scope.
	    return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 DIRERR_CANT_RETRIEVE_CHILD, childRtn);

        // Choose an index to walk.
        if(childRtn = DBChooseIndex(pTHS->pDB,
                               0, 0,
                               pCommArg->SortAttr,
                               pCommArg->SortType,
                               0,
                               pCommArg->MaxTempTableSize)) {

            // Got some error.
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 DIRERR_CANT_RETRIEVE_CHILD, childRtn);
        }

        // Get the first object.
        childRtn = DBGetNextSearchObject(pTHS->pDB,
                                         pCommArg->StartTick,
                                         pCommArg->DeltaTick,
                                         NULL, SearchFlags);
    }

    // Deal with errors from phase 1.
    switch(childRtn) {
    case 0:
    case DB_ERR_NEXTCHILD_NOTFOUND:
        // These are both OK, the code below handles them just fine.
        break;
    case DB_ERR_TIMELIMIT:
        // We hit a time limit, we need to build a restart structure.
        goto End;
        break;
    default:
        // Something unexpected happened.  Bail.
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_CANT_RETRIEVE_CHILD,
                             childRtn);
        break;
    }

    // Apply Delta.
    if(pCommArg->Delta) {
        BOOL fNegDelta = (pCommArg->Delta < 0);
        ULONG LocalSearchFlags;

        if(fNegDelta) {
            LocalSearchFlags = REVERSE_SEARCH_FLAGS(pListArg->CommArg);
        }
        else {
            LocalSearchFlags = SearchFlags;
        }

        switch(pCommArg->Delta) {
        case DB_MoveFirst:
            // Seek to the first object in the index (or last, if
            // !fForwardSeek, but callee handles that).  We set
            // fSearchInProgress to FALSE so that DBGetNextSearchObject resets
            // the index.
            pTHS->pDB->Key.fSearchInProgress = FALSE;
            childRtn = DBGetNextSearchObject(pTHS->pDB,
                                             pCommArg->StartTick,
                                             pCommArg->DeltaTick,
                                             NULL, SearchFlags);

            break;
        case DB_MoveLast:
            // Seek to the last object in the index (or first, if
            // !fForwardSeek, but callee handles that).  We set
            // fSearchInProgress to FALSE so that DBGetNextSearchObject resets
            // the index. Note our clever
            // reversal of fForwardSeek here to get the opposite behaviour from
            // DBGetNextSearchObject than we got in the prior if statement.
            // Then, move one past the object.
            pTHS->pDB->Key.fSearchInProgress = FALSE;
            childRtn =
                DBGetNextSearchObject(pTHS->pDB,
                                      pCommArg->StartTick,
                                      pCommArg->DeltaTick,
                                      NULL,
                                      REVERSE_SEARCH_FLAGS(pListArg->CommArg));
            if(!childRtn) {
                // Only do this if the previous call worked.  If it didn't we
                // are going to error out in a minute.
                DBMove(pTHS->pDB, FALSE,
                       (pCommArg->fForwardSeek?DB_MoveNext:DB_MovePrevious));
                childRtn =  DB_ERR_NEXTCHILD_NOTFOUND;
            }
            break;
        default:
            if(fNegDelta)
                pCommArg->Delta *= -1;

            Assert(!childRtn || childRtn == DB_ERR_NEXTCHILD_NOTFOUND);
            childRtn = 0;
            while(!childRtn && pCommArg->Delta) {
                childRtn = DBGetNextSearchObject(
                        pTHS->pDB,
                        pCommArg->StartTick,
                        pCommArg->DeltaTick,
                        NULL, LocalSearchFlags);
                pCommArg->Delta--;

            }

            if(childRtn==DB_ERR_NEXTCHILD_NOTFOUND && fNegDelta) {
                // We backed up past the beginning.  Set to the beginning.
                pTHS->pDB->Key.fSearchInProgress = FALSE;
                childRtn = DBGetNextSearchObject(
                        pTHS->pDB,
                        pCommArg->StartTick,
                        pCommArg->DeltaTick,
                        NULL, SearchFlags);

            }
        }
    }

    // init num of entries counter to 0
    pChildList = &(ListRoot);
    ListRoot.pNextChild = NULL;
    pListRes->count = 0;

    // Ok, we've  (probably) found an object, read it out for the list, then
    // move to the next object.
    while(childRtn == 0) {
        DPRINT(5,"DBGetNextSearchObj retrieved\n");

        // ptr to block we're about to create
        pLastChild = pChildList;

        if( GetNextListInf(pTHS,
                           &pChildList) ) {
            // Failed to get the next list inf object, even though we think we
            // are on a valid object.  Bail.
            DPRINT(3,"Bad return building list\n");
            return (pTHS->errCode);
        }

        if (pListRes->count >= pCommArg->ulSizeLimit) {
            // Reached a limit.

            DPRINT(4, "Size Limit reached\n");
            pListRes->pPartialOutcomeQualifier = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
            pListRes->pPartialOutcomeQualifier->problem =
                PA_PROBLEM_SIZE_LIMIT;
	        pListRes->pPartialOutcomeQualifier->pUnexploredDSAs = NULL;

            THFree( pChildList);    // discard last data block
            pLastChild->pNextChild = NULL;

            pListRes->Firstchild = *(ListRoot.pNextChild);

            if( pCommArg->PagedResult.fPresent) {
		        // Info from DB layer
		        DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_SIZE_LIMIT,
                                pListArg->pResObj);


                // Control info
                pListRes->PagedResult.fPresent = TRUE;
                pListRes->PagedResult.pRestart = pResRestart;
            }

            return 0;
        }
        else {
            // Got the next list inf object.  Add it to the list
            pListRes->count++;

            // Go to the next object.
            childRtn = DBGetNextSearchObject(pTHS->pDB,
                                             pCommArg->StartTick,
                                             pCommArg->DeltaTick,
                                             NULL, SearchFlags);
        }
    }

 End:
    switch( childRtn ) {
    case DB_ERR_TIMELIMIT:
        DPRINT(4, "Time Limit reached\n");
	pListRes->pPartialOutcomeQualifier = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
	pListRes->pPartialOutcomeQualifier->pUnexploredDSAs = NULL;
	pListRes->pPartialOutcomeQualifier->problem =
            PA_PROBLEM_TIME_LIMIT;
        if(pCommArg->PagedResult.fPresent) {
            // The caller has asked for paged results and we hit a time
            // limit.
	    DBCreateRestart(pTHS->pDB,
                            &pResRestart,
                            SearchFlags,
                            PA_PROBLEM_TIME_LIMIT,
                            pListArg->pResObj);

            // Control info
            pListRes->PagedResult.fPresent = TRUE;
            pListRes->PagedResult.pRestart = pResRestart;
        }
        return 0;
        break;

    case DB_ERR_NEXTCHILD_NOTFOUND:

        Assert(pListRes->pPartialOutcomeQualifier == NULL);
        Assert(!pListRes->PagedResult.fPresent);
        Assert(!pListRes->PagedResult.pRestart);

        if(!pListRes->count) {
            // Nothing found.
            return 0;
        }

        pListRes->Firstchild = *(ListRoot.pNextChild);

        DPRINT1(4,"No more children so return <%u> children\n",
                pListRes->count);
        return (0);
        break;

    case DB_ERR_SYSERROR:
    default:
        DPRINT(4, "Bad error returned from DBGetNextSearchObject\n");
        return (SetSvcError(SV_PROBLEM_DIR_ERROR,
                            DIRERR_CANT_RETRIEVE_CHILD));
    }

    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Build the ChildList datastructure for the current object and add to
   the linked list.  If we run out of RPC space, we throw away the partial
   object and sucessfully return.
*/

int GetNextListInf(THSTATE *pTHS,
                   CHILDLIST **ppChildList)
{
    CHILDLIST *pNewChildList;

    DPRINT(3, "GetNextListInf entered\n");

    (*ppChildList)->pNextChild = THAllocEx(pTHS, sizeof(CHILDLIST));
    pNewChildList = (*ppChildList)->pNextChild;

    if (GetListInf(pTHS,
                   pNewChildList)) {
        DPRINT(4,"Error in getting object info\n");
        return pTHS->errCode;
    }
    else {
        DPRINT(5, "Object retrieved\n");
        *ppChildList = pNewChildList;
        return 0;
    }
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Build-up a CHILDLIST element by interrogating the current object.  The
   pChildList handed in is a pointer to an allocated, but not yet filled
   in, last member of the chain.
*/

INT GetListInf (THSTATE *pTHS,
                CHILDLIST *pChildList)
{
    ULONG           len;
    SYNTAX_INTEGER  iType;
    ATTCACHE        *pAC;
    ATTR            *pAttr;
    WCHAR           rdnbuf[MAX_RDN_SIZE];
    ATTRTYP         atype;
    DWORD           rtn;

    /* Determine if this is an alias entry by checking the object class
       inheritance list for the alias class.
       */

    pChildList->aliasEntry = IsAlias(pTHS->pDB);

    /* Determine if this is a master or a replica object by interrogating
       the InstanceType attribute.
       */
    if(rtn = DBGetSingleValue(pTHS->pDB,
                        ATT_INSTANCE_TYPE, &iType, sizeof(iType), &len)) {

        DPRINT(4,"Problem retrieving Instance Type\n");
        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_RETRIEVE_INSTANCE,
                 szInsertSz(GetExtDN(pTHS, pTHS->pDB)),
                 NULL,
                 NULL);

        return (SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              DIRERR_CANT_RETRIEVE_INSTANCE, rtn));
    }

    if(iType & IT_WRITE) {
        DPRINT(5,"The object is writable (i.e. from  a master)\n");
        pChildList->fromMaster = TRUE;
    }
    else {
        DPRINT(5,"The object is not writable (i.e. from full or partial replica\n");
        pChildList->fromMaster = FALSE;
    }

    if(!(pAC = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME)) ||
       (rtn = DBGetMultipleAtts(pTHS->pDB, 1, &pAC, NULL, NULL, &len, &pAttr,
                                DBGETMULTIPLEATTS_fEXTERNAL, 0))) {
        DPRINT(4,"Problem retrieving DN attribute\n");
        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_RETRIEVE_DN,
                 szInsertSz(""),
                 NULL,
                 NULL);

        return (SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              DIRERR_CANT_RETRIEVE_DN,rtn));
    }

    if (rtn = GetRDNInfo(pTHS,
               (DSNAME *)pAttr->AttrVal.pAVal->pVal,
               rdnbuf,
               &len,
               &atype)) {
        // We should never get here.  This code is only for Prefix's benefit.
        Assert(FALSE);
        return (SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              DIRERR_CANT_RETRIEVE_DN,rtn));
    }

    pAttr->attrTyp = atype;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal->valLen = len * sizeof(WCHAR);

    THFree(pAttr->AttrVal.pAVal->pVal);
    pAttr->AttrVal.pAVal->pVal = THAllocEx(pTHS, len*sizeof(WCHAR));
    memcpy(pAttr->AttrVal.pAVal->pVal, rdnbuf, len*sizeof(WCHAR));
    pChildList->pChildName = pAttr;

    return 0;
}
