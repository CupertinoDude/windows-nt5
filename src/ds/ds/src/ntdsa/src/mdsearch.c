//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdsearch.c
//
//--------------------------------------------------------------------------


/*
Description:

    Implements the DirSearch API.

    DSA_DirSearch() is the main function exported from this module.

*/
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <ntdsctr.h>            // Perf Hook

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "permit.h"
#include "filtypes.h"                   // For FI_CHOICE...
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "MDSEARCH:"              // define the subsystem for debugging

// LDAP errors
#include <winldap.h>

#include <fileno.h>
#define  FILENO FILENO_MDSEARCH

#include <dstrace.h>
#include "dsutil.h"



// Search Logging
ULONG gcTotalSearchesInLastPeriod = 0;
ULONG gcSearchInefficientThreshold = 10000;
ULONG gcSearchExpensiveThreshold = 5;
ULONG gcSearchInefficient_count = 0;
ULONG gcSearchExpensive_count = 0;
BOOL  isSearchPerformanceLoggingFirstTime = TRUE;
DSTIME timeLastSearchLoggingPerformed;

/* Internal functions */

int
GetNextEntInf (
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pRange,
    IN ENTINFLIST **ppEntInfList,
    IN RANGEINFLIST **ppRangeInfList,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN PCACHED_AC CachedAC
    );

DWORD
FindFirstSearchObject(
        DBPOS *pDB,
        SEARCHARG *pSearchArg,
        PRESTART pArgRestart,
        PSECURITY_DESCRIPTOR *ppSecurity
        );

void
GeneratePOQ(THSTATE *pTHS,
            const SEARCHARG *pSearchArg,
            PARTIALOUTCOME **ppPOQ);
void
GenerateASQ_POQ(THSTATE *pTHS,
                const SEARCHARG *pSearchArg,
                PARTIALOUTCOME **ppPOQ,
                DWORD cASQRefCount,
                DWORD *pASQReferrals);
void
AddCurrentObjectToAsqReferrals (THSTATE *pTHS,
                                DWORD *pcASQRefCount,
                                DWORD *pcASQRefAlloced,
                                DWORD **ppASQReferrals);
VOID
SimpleBaseSearch (
        THSTATE   *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags
        );

BOOL
IsBaseOnlyAttPresent(
        SEARCHARG *pSearchArg
        );

void
SearchPerformanceLogFilter (DBPOS *pDB, SEARCHARG *pSearchArg);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirSearch(
          SEARCHARG*  pSearchArg,
          SEARCHRES **ppSearchRes
          )
{
    THSTATE*     pTHS;
    SEARCHRES *pSearchRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT1(1,"DirSearch(%ws) entered\n",pSearchArg->pObject->StringName);

   /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
      is required on every API transaction.  First the state DS is initialized
      and then either a read or a write sync point is established.
   */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppSearchRes = pSearchRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppSearchRes = pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if (   (eServiceShutdown >= eSecuringDatabase)
                || (   (eServiceShutdown >= eRemovingClients)
                    && (   !(pTHS->fDSA)
                        || (pTHS->fSAM)))) {
                ErrorOnShutdown();
                __leave;
            }
        }

        SYNC_TRANS_READ();   /*Identify a reader trans*/
        __try {

            pSearchRes->CommRes.aliasDeref = FALSE;   /*Initialize to Default*/

            pSearchRes->PagedResult = pSearchArg->CommArg.PagedResult;

            // Assume no paged result
            memset(&pSearchRes->PagedResult,0,sizeof(PAGED_RESULT));

            /* Call main search function*/

            SearchBody(pTHS, pSearchArg, pSearchRes,0);

        } __finally {
            CLEAN_BEFORE_RETURN( pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pSearchRes) {
        pSearchRes->CommRes.errCode = pTHS->errCode;
        pSearchRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;
} // DirSearch


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if this is a restarted operation.

   The continued operation was either on this DSA or this DSA or on a remote
   chained DSA.  This is determined using the isRemote flag.  Both the
   R_DirSearch remote DSA fns and the LocalSearch  function
   can be continued.  On input, pRestart indicates if the function is a
   continuation.  On output it indicates if a continuation is necessary.
   These functions are responsible for setting this flag.  It should be
   TRUE only  when a good return is generated and a continuation is necessary.

   Different information is needed to restart a local search from a remote
   one.  For a local call, we save the DN of the next object to be  returned.
   For foreign call we save a pointer to the beginning of the user's RPC
   output Buf, a pointer to the next entInfList to be returned and the
   remote DSA handle.

*/

void
SearchBody (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags)
{
    PRESTART       pRestart;
    DWORD          dwNameResFlags = NAME_RES_QUERY_ONLY;

   pRestart = pSearchArg->CommArg.PagedResult.pRestart;    /* continuation? */

   if( pRestart != NULL ) {
       // all the data we need should be in PRESTART struct
       pSearchArg->pResObj = ResObjFromRestart(pTHS,
                                               pSearchArg->pObject,
                                               pRestart);
       LocalSearch(pTHS, pSearchArg, pSearchRes,flags);
       // Search may have opened a sort table.  Some callers require that it be
       // closed.
       DBCloseSortTable(pTHS->pDB);
   }
   else          /* First transaction...Not a continuation.  */
   {
       /* We perform name resolution. Set the children needed flag
          according to if the search includes child objects.
          */

       if(pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
           dwNameResFlags |= NAME_RES_CHILDREN_NEEDED;
           if(!pSearchArg->bOneNC) {
               // We are on a GC, thus it is OK to root a search from a phantom
               // as long as the search wasn't a base-only one.
               // Set the flags to show this.
               dwNameResFlags |= NAME_RES_PHANTOMS_ALLOWED;
           }
       }
       // If we're on a GC port we need to pass this flag to DoNameRes, so
       // we'll get referrals to all objects in NDNCs.
       dwNameResFlags |= (pSearchArg->bOneNC) ? 0 : NAME_RES_GC_SEMANTICS;

       if( 0 == DoNameRes(pTHS,
                          dwNameResFlags,
                          pSearchArg->pObject,
                          &pSearchArg->CommArg,
                          &pSearchRes->CommRes,
                          &pSearchArg->pResObj)) {
            LocalSearch(pTHS, pSearchArg, pSearchRes,flags);
           // Search may have opened a sort table.  Some callers require that it
           // be closed.
           DBCloseSortTable(pTHS->pDB);
       }
   }
   return;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Main body of local search function.  We get as many objects as will fit
   into the output buffer.  If more data is available, we use a non-null
   partialoutcomequalifier to indicate to the user that there is more data.

   The steps are as follows:

   1 - Set the client filter.

   2 - a - If this is not a restarted transaction, we retrieve and test the
           filter against the base of the subtree or

       b - This is a restarted transaction so we reposition on the next
           entry to retrieve.  (Note that we assume that we have been called
           with the same exact filter ( this is expected)

   3 - We determine the scope of the call, this indicates if the client
       requested the base object only or the base and the immediate children.
       If it is base only we return.

   4 - a - Retrieve each child that passes the filter test.  (Note that the
           filter test is implicit in the DBGetNextSearchObj database call.)

       b - Try to retrieve its data into an entry info structure.
           If we failulSearchStatus because we are out of space, we leave the partial
           outcome qualifier to indicate to the client that there is more
           data and we return the name of the current object that we were
           not able to return. We also indicate that a restart is needed.

   5 - If there are no more children, we NULL out the partial outcome
       qualifier and return.
*/

#if DBG
DWORD gulInefficientSearchTrigger = 5000;
BOOL fBreakOnInefficientSearchTrigger = FALSE;
#endif

INT
LocalSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags)
{
    ENTINFLIST *pEntInfList; /*Points to next output Entry info list*/
    RANGEINFLIST *pRangeInfList;
    ULONG        dwSearchStatus;
    COMMARG *  pCommArg;
    BOOL       fExitLoop = FALSE;
    BOOL       fFirstTime = TRUE;
    DWORD      cbSecurity;
    PSECURITY_DESCRIPTOR pSecurity=NULL;
    PRESTART   pArgRestart, pResRestart=NULL;
    POBJECT_TYPE_LIST pFilterSecurity;
    DWORD      *pResults;
    ULONG      FilterSecuritySize;
    ULONG      SearchFlags=0;
    PFILTER    pInternalFilter = NULL;
    INT        numAtts = 0; // holds total number of attributes found
                            // across all entries.  error if it stays == 0
    BOOL       *pbSortSkip=NULL;
    BOOL        bSkipEntInf = FALSE;
    DWORD       cASQRefCount = 0;
    DWORD       cASQRefAlloced = 0;
    DWORD       *pASQReferrals = NULL;

    CACHED_AC   cachedAC;
    DWORD       getEntInfFlags = 0;
    DWORD       err;
    BOOL        fVLVPresent, fASQPresent;
    ATTCACHE    *pSortAC = NULL;
    ATTCACHE    *pASQAC, *pACSD;
    VLV_REQUEST *pVLVRequest;
    ASQ_REQUEST *pASQRequest;
    PDSNAME     pParent = NULL;
    CLASSCACHE  *pCC;
    ULONG       cAtts;

    DPRINT1(1,"LocalSearch(%ws) entered\n",pSearchArg->pObject->StringName);

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_SEARCH,
                     EVENT_TRACE_TYPE_START,
                     DsGuidSearch,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertSz(SEARCHTYPE_STRING(pSearchArg->choice)),
                     szInsertDN(pSearchArg->pObject),
                     NULL, NULL, NULL, NULL, NULL);

    Assert(pSearchArg->pResObj);

    PERFINC(pcTotalSearches);
    INC_SEARCHES_BY_CALLERTYPE( pTHS->CallerType );
    gcTotalSearchesInLastPeriod++;

    pCommArg = &pSearchArg->CommArg;
    pArgRestart = pCommArg->PagedResult.pRestart;

    // Assert that we either don't have a restart structure OR we have said
    // that we are going to have one.  Note that it is legal to have
    // fPresent == TRUE and not actually have a pArgRestart
    Assert(!pArgRestart || pCommArg->PagedResult.fPresent);



    // check that they ask for a sort on an attribute that we know how to sort
    //
    if (pSearchArg->CommArg.SortType != SORT_NEVER) {

        pSortAC = SCGetAttById(pTHS, pSearchArg->CommArg.SortAttr);
        if (!pSortAC) {
            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
            goto exit;
        }

        // check whether we support sorting on this syntax.
        // all the operators that support >, support >=, <, <= are ok for sorting
        //
        if (!FLegalOperator (pSortAC->syntax, FI_CHOICE_GREATER)) {
            pSearchRes->SortResultCode = LDAP_INAPPROPRIATE_MATCHING;
            if (pSearchArg->CommArg.SortType == SORT_OPTIONAL) {
                pSearchArg->CommArg.SortType = SORT_NEVER;
            }
            else {
                SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED_SORT_ORDER);
                goto exit;
            }
        }
    }


    // Check for VLV presence
    //
    pVLVRequest = &pCommArg->VLVRequest;
    fVLVPresent = pVLVRequest->fPresent;
    Assert(!pVLVRequest->pVLVRestart || fVLVPresent);
    if (fVLVPresent) {

        DPRINT5 (1, "VLV: before:%d after:%d cnt:%d target:%d res: 0x%x\n",
                                pVLVRequest->beforeCount,
                                pVLVRequest->afterCount,
                                pVLVRequest->contentCount,
                                pVLVRequest->targetPosition,
                                pVLVRequest->pVLVRestart);

        if (pVLVRequest->fseekToValue) {
            DPRINT1 (1, "VLV: seekToValue  seekVal: %ws\n",
                            pVLVRequest->seekValue.pVal);
        }

        // we don't support VLV without a sort request
        //
        if (pSearchArg->CommArg.SortType == SORT_NEVER) {

            // set this so to exit with VLV specific errors
            DBSetVLVArgs (pTHS->pDB, pVLVRequest, pCommArg->SortAttr);
            pTHS->pDB->Key.pVLV->Err = LDAP_SORT_CONTROL_MISSING;
            DBSetVLVResult (pTHS->pDB, &pSearchRes->VLVRequest, NULL);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
            goto exit;
        }

        // we don't support VLV on base searches, unless we are also doing an ASQ
        //
        if (pSearchArg->choice == SE_CHOICE_BASE_ONLY &&
            !pSearchArg->CommArg.ASQRequest.fPresent) {

                // set this so to exit with VLV specific errors
                //
                DBSetVLVArgs (pTHS->pDB, pVLVRequest, pCommArg->SortAttr);
                pTHS->pDB->Key.pVLV->Err = LDAP_UNWILLING_TO_PERFORM;
                DBSetVLVResult (pTHS->pDB, &pSearchRes->VLVRequest, NULL);

                SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
                goto exit;
        }
    }

    // check for ASQ presence
    pASQRequest = &pCommArg->ASQRequest;

    if (fASQPresent = pASQRequest->fPresent) {

	//
	// The client should be able to see this object
	// before we continue.
	//
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            goto exit;
        }

        // we support ASQ only on base searches
        //
        if (pSearchArg->choice != SE_CHOICE_BASE_ONLY) {

            pTHS->pDB->Key.asqRequest.Err = LDAP_UNWILLING_TO_PERFORM;
            DBSetASQResult (pTHS->pDB, &pSearchRes->ASQRequest);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
            goto exit;
        }

        if (!(pASQAC = SCGetAttById (pTHS, pASQRequest->attrType))) {
            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            goto exit;
        }

        DPRINT3 (1, "ASQ Scoped Query on %s(0x%x) linkID:0x%x\n",
                        pASQAC->name, pASQAC->id, pASQAC->ulLinkID);

        // we only support ASQ on certain attribute syntaxes
        //
        if (pASQAC->syntax != SYNTAX_DISTNAME_TYPE) {
            DPRINT1 (1, "Invalid Syntax on ASQ Attribute: %d\n", pASQAC->syntax);

            // set this so as to exit with ASQ specific errors
            //
            pTHS->pDB->Key.asqRequest.Err = LDAP_INVALID_SYNTAX;
            DBSetASQResult (pTHS->pDB, &pSearchRes->ASQRequest);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_BAD_ATT_SCHEMA_SYNTAX);
            goto exit;
        }

        //
	// Client should have read permission on the attribute.
	//
	if (!(pCC = SCGetClassById(pTHS, pSearchArg->pResObj->MostSpecificObjClass))) {
	    SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_OBJECT_CLASS_REQUIRED);
	    goto exit;
	}
	// First, get the security descriptor for this object.
	pACSD = SCGetAttById(pTHS, ATT_NT_SECURITY_DESCRIPTOR);
	if (err = DBGetAttVal_AC(pTHS->pDB, 1, pACSD,
			   0, 0,
			   &cbSecurity, (PUCHAR *)&pSecurity))
	    {
	    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
			 ERROR_DS_CANT_RETRIEVE_SD,
			 err);
	    goto exit;  
	}

	cAtts = 1;
	CheckReadSecurity(pTHS, 0, pSecurity, pSearchArg->pResObj->pObj, &cAtts, pCC, &pASQAC);
	THFreeEx(pTHS, pSecurity); pSecurity = NULL; 
	if (!pASQAC) {
	    //
	    // The client can't see this attribute.  Act as if the attribute simply 
	    // doesn't exist on this object.
	    //
	    goto exit;
	}

	// if we are a GC, possibly we have local copies of objects
        // without all the requested attributes.
        // check whether the requested attributes are all replicated to the GC
        if (gAnchor.fAmGC && !pSearchArg->bOneNC) {

            if (!pSearchArg->pSelection) {
                DPRINT(1, "ASQ Setting missing attrs to TRUE\n");
                pASQRequest->fMissingAttributesOnGC = TRUE;
            }
            else {
                DPRINT1(1, "ASQ Setting missing attrs to %s\n",
                        pCommArg->Svccntl.fMissingAttributesOnGC ? "TRUE" : "FALSE");
                pASQRequest->fMissingAttributesOnGC = pCommArg->Svccntl.fMissingAttributesOnGC;
            }
        }
    }

    // Assume not sorted
    pSearchRes->bSorted = FALSE;

    //Set the base object name if an alias has been dereferenced
    if (pSearchRes->CommRes.aliasDeref) {
        DWORD len;
        pSearchRes->baseProvided = TRUE;
        DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                    0, 0,
                    &len, (PUCHAR *)&(pSearchRes->pBase)) ;
    }
    else {
        pSearchRes->baseProvided = FALSE;
    }

    if (pSearchArg->pSelection)
    {
        DPRINT2(4,"Attribute selection is <%c>, infotypes <%c>\n",
            (pSearchArg->pSelection->attSel),
            (pSearchArg->pSelection->infoTypes));

        // We allow certain constructed attributes to be asked for
        // only if it is a base search.
        if (IsBaseOnlyAttPresent(pSearchArg)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_NON_BASE_SEARCH, 0);
            goto exit;
        }
    } else{
        DPRINT(4,"No selection specified.\n");
    }

    // internalize and register the filter with the DBlayer
    // and check to see if the filter is valid

    if ((err = DBMakeFilterInternal(pTHS->pDB,
                         pSearchArg->pFilter,
                         &pInternalFilter)) != ERROR_SUCCESS ) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, err, 0);
        goto exit;
    }

    // initialize results
    pRangeInfList = &(pSearchRes->FirstRangeInf);
    pEntInfList = &(pSearchRes->FirstEntInf);
    pSearchRes->count = 0;     /* init num of entries counter to 0 */

    // Check for simplest case
    if(pInternalFilter &&
       !pInternalFilter->pNextFilter &&
       pInternalFilter->choice == FILTER_CHOICE_ITEM &&
       pInternalFilter->FilterTypes.Item.choice == FI_CHOICE_TRUE &&
       pSearchArg->choice == SE_CHOICE_BASE_ONLY && !fASQPresent) {
        // This is a base object read, no filter.  Verify the parent, then do a
        // getentinf.
        SimpleBaseSearch(pTHS, pSearchArg,pSearchRes,flags);

        goto exit;
    }

    GetFilterSecurity(pTHS,
                      pInternalFilter,
                      pCommArg->SortType,
                      pCommArg->SortAttr,
                      (flags & SEARCH_AB_FILTER),
                      &pFilterSecurity,
                      &pbSortSkip,
                      &pResults,
                      &FilterSecuritySize);

    DBSetFilter(pTHS->pDB,
                pInternalFilter,
                pFilterSecurity,
                pResults,
                FilterSecuritySize,
                pbSortSkip
                );

    //
    // if this is not the first page and we are paging and the
    // size is 0, abort at this point.
    //      We need to generate referrals with the first page.
    //      If page size is 0, then the client is signalling us
    //      to abort the paging sequence. We do this check way
    //      down in the core and not on the ldap head so we
    //      can check the validity of client parameters
    //

    if ( (pArgRestart != NULL) &&
         (pCommArg->ulSizeLimit == 0) &&
         pCommArg->PagedResult.fPresent ) {

        // exit to avoid generating referrals on succeeding pages
        goto exit;
    }

    if (fVLVPresent) {
        DBSetVLVArgs (pTHS->pDB, pVLVRequest, pCommArg->SortAttr);
    }

    if (fASQPresent) {
        DBSetASQArgs (pTHS->pDB, pASQRequest, pCommArg);
    }

    // position on the first record that qualifies.
    SearchFlags = SEARCH_FLAGS((*pCommArg));

    dwSearchStatus = FindFirstSearchObject(pTHS->pDB,
                                           pSearchArg,
                                           pArgRestart,
                                           &pSecurity);


    if (DB_ERR_NEXTCHILD_NOTFOUND == dwSearchStatus) {
	//
	// There were no entries visible to the client.  If the 
	// base of the search is not visible to the client, then
	// make sure not to reveal it's existence.
	//
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            goto exit;
        }
    }

    if(dwSearchStatus == DB_ERR_CANT_SORT) {
        // A mandatory sort order was unavailable.  Other errors fall through
        // and are dealt with below.
        SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, DIRERR_UNKNOWN_ERROR);
        goto exit;
    }
    else if ( dwSearchStatus == DB_ERR_NOT_AN_OBJECT) {
        AddCurrentObjectToAsqReferrals (pTHS,
                                        &cASQRefCount,
                                        &cASQRefAlloced,
                                        &pASQReferrals);
        bSkipEntInf = TRUE;
        dwSearchStatus = 0;
    }

    // Did we find a sort order?
    pSearchRes->bSorted = (pTHS->pDB->Key.ulSorted != SORT_NEVER);

    // we might be directed to leave the results in the
    // sort table and don't create the ENTINF in-memory list
    if (pSearchArg->fPutResultsInSortedTable) {
        pSearchRes->count = pTHS->pDB->Key.ulEntriesInTempTable;
    }

    ZeroMemory(&cachedAC, sizeof(cachedAC));

    SvccntlFlagsToGetEntInfFlags(&pCommArg->Svccntl,&getEntInfFlags);

    if(flags & SEARCH_UNSECURE_SELECT) {
        getEntInfFlags |= GETENTINF_NO_SECURITY;
    }

    while (   !dwSearchStatus
           && !fExitLoop
           && ((eServiceShutdown == eRunning)
               || ((eServiceShutdown == eRemovingClients)
                   && (pTHS->fDSA
                       && !pTHS->fSAM)))) {

        if((pSearchRes->count + cASQRefCount) >= pCommArg->ulSizeLimit) {

            DPRINT(4, "Size Limit reached\n");
            if (!pSearchRes->pPartialOutcomeQualifier) {
                pSearchRes->pPartialOutcomeQualifier =
                    THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
            }
            pSearchRes->pPartialOutcomeQualifier->problem =
                PA_PROBLEM_SIZE_LIMIT;

            if( pCommArg->PagedResult.fPresent) {
                // Info from DB layer
                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_SIZE_LIMIT,
                                pSearchArg->pResObj);

                // Control info
                pSearchRes->PagedResult.fPresent = TRUE;
                pSearchRes->PagedResult.pRestart = pResRestart;
            }

            fExitLoop = TRUE;
            continue;
        }
        else if (pTHS->pDB->Key.pVLV &&
                 (pSearchRes->count >= pTHS->pDB->Key.pVLV->requestedEntries) ) {

            DBCreateRestart(pTHS->pDB,
                            &pResRestart,
                            SearchFlags,
                            PA_PROBLEM_SIZE_LIMIT,
                            pSearchArg->pResObj);

            DBSetVLVResult (pTHS->pDB,
                            &pSearchRes->VLVRequest,
                            pResRestart);

            fExitLoop = TRUE;
            continue;
        }

        if (!bSkipEntInf) {
            if ((fFirstTime &&
                 GetEntInf(pTHS->pDB,
                           pSearchArg->pSelection,
                           pSearchArg->pSelectionRange,
                           &pEntInfList->Entinf,
                           &pRangeInfList->RangeInf,
                           pCommArg->Svccntl.SecurityDescriptorFlags,
                           pSecurity,
                           getEntInfFlags,
                           &cachedAC,
                           NULL)) ||
                (!fFirstTime &&
                    GetNextEntInf(pTHS->pDB,
                               pSearchArg->pSelection,
                               pSearchArg->pSelectionRange,
                               &pEntInfList,
                               &pRangeInfList,
                               pCommArg->Svccntl.SecurityDescriptorFlags,
                               pSecurity,
                               getEntInfFlags,
                               &cachedAC))){
                DPRINT(0,"Bad return building ENT\n");
                goto exit;
            }

            numAtts += pEntInfList->Entinf.AttrBlock.attrCount;
            fFirstTime = FALSE;
            pSearchRes->count++;
        }
        bSkipEntInf = FALSE;

        if (pSearchArg->choice == SE_CHOICE_BASE_ONLY && !fASQPresent) {
            dwSearchStatus = DB_ERR_NEXTCHILD_NOTFOUND;
        } else {

            do {
                dwSearchStatus = DBGetNextSearchObject(pTHS->pDB,
                                                       pCommArg->StartTick,
                                                       pCommArg->DeltaTick,
                                                       &pSecurity,
                                                       SearchFlags);

                if ( dwSearchStatus == DB_ERR_NOT_AN_OBJECT) {
                    AddCurrentObjectToAsqReferrals (pTHS,
                                                    &cASQRefCount,
                                                    &cASQRefAlloced,
                                                    &pASQReferrals);
                    bSkipEntInf = TRUE;
                    dwSearchStatus = 0;
                    break;
                }


                if (!dwSearchStatus) {
                    // Check if the parent is one we don't have rights to list contents of.

                    // we already checked security for this
                    if(pTHS->pDB->Key.ulSorted && pTHS->pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
                        break;
                    }
                    // check security
                    else if (IsObjVisibleBySecurity(pTHS, TRUE)) {
                        break;
                    }
                }

            } while ( !dwSearchStatus );
        }
    }

    if (eServiceShutdown
        && ((eServiceShutdown >= eSecuringDatabase)
            || (!pTHS->fDSA || pTHS->fSAM))) {
        SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN);
    } else {

        switch (dwSearchStatus) {

        case DB_ERR_TIMELIMIT:
            DPRINT(4, "Time Limit reached\n");
            if (!pSearchRes->pPartialOutcomeQualifier) {
                pSearchRes->pPartialOutcomeQualifier =
                    THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
            }
            pSearchRes->pPartialOutcomeQualifier->problem =
                PA_PROBLEM_TIME_LIMIT;

            if(pCommArg->PagedResult.fPresent) {
                // We were asked for paged results and we hit a time limit.
                // Build a paged results.  Note that we explicitly DO NOT come
                // through here if we hit a size limit.  In that case, we
                // already built the paged result above as soon as we found that
                // we hit the size limit.
                //

                // Info from DB layer
                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_TIME_LIMIT,
                                pSearchArg->pResObj);

                // Control info
                pSearchRes->PagedResult.fPresent = TRUE;
                pSearchRes->PagedResult.pRestart = pResRestart;
            }
            else if (fVLVPresent) {
                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_TIME_LIMIT,
                                pSearchArg->pResObj);

                DBSetVLVResult (pTHS->pDB,
                                &pSearchRes->VLVRequest,
                                pResRestart);
            }

            // Fall through to see if we failed to read any attributes, since
            // that is an error.

        case DB_ERR_NEXTCHILD_NOTFOUND:
            // This is the case of a complete search (i.e. no more objects to be
            // returned, even if paging was requested.


            if (fVLVPresent) {

                DBCreateRestart(pTHS->pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_SIZE_LIMIT,
                                pSearchArg->pResObj);

                DBSetVLVResult (pTHS->pDB,
                                &pSearchRes->VLVRequest,
                                pResRestart);
            }

            // Fall through to see if we failed to read any attributes, since
            // that is an error.

        case 0:
            // This is the case of a sizeLimit reached.

            //
            // This is #if 0 instead of removed to allow for our bosses to
            // change their minds on the issue of whether we should be returning
            // an error or not
            //

#if 0
            if ((numAtts == 0) &&
                (pSearchRes->count != 0) &&
                (pSearchArg->pSelection) &&
                ((pSearchArg->choice != SE_CHOICE_BASE_ONLY) ||
                (pInternalFilter)                            ) &&
                (pSearchArg->pSelection->AttrTypBlock.attrCount != 0)) {

                // it is an error if the user requested a list of
                // attributes and none were found on any objects.

                SetAttError(pSearchArg->pObject, 0L,
                            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                            DIRERR_NO_REQUESTED_ATTS_FOUND);
            }
#endif
            break;

        case DB_ERR_VLV_CONTROL:
            Assert (fVLVPresent);

            // we got a VLV related error. more info for this error
            // is found on the VLV_SEARCH on the pDB
            // we don't want to fail the call, just the specific part (VLV)
            DBSetVLVResult (pTHS->pDB,
                            &pSearchRes->VLVRequest,
                            NULL);
            break;

        default:
            DPRINT(1, "Bad error returned from DBGetNextSearchObj\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_CHILD,
                     szInsertWC(pSearchArg->pObject->StringName),
                     NULL,
                     NULL);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_CHILD,
                          dwSearchStatus);

        }
    }

    if (fASQPresent) {
        DBSetASQResult (pTHS->pDB, &pSearchRes->ASQRequest);
    }

    /* Generate a Partial Outcome Qualifier, if needed */
    if (!pArgRestart &&         /* only do this on first packet */
        !pTHS->errCode &&       /* only do if nothing has gone wrong */
        pSearchArg->choice != SE_CHOICE_BASE_ONLY && /* unnecessary */
        !fVLVPresent && /* if VLV we don't want this */
        !pSearchArg->CommArg.Svccntl.localScope) { /* don't if local only */

        GeneratePOQ(pTHS,
                    pSearchArg,
                    &pSearchRes->pPartialOutcomeQualifier);
    }

    if (cASQRefCount) {
        GenerateASQ_POQ (pTHS,
                         pSearchArg,
                         &pSearchRes->pPartialOutcomeQualifier,
                         cASQRefCount,
                         pASQReferrals);

        THFreeEx (pTHS, pASQReferrals);
    }

exit:

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_SEARCH,
                     EVENT_TRACE_TYPE_END,
                     DsGuidSearch,
                     szInsertUL(pTHS->errCode),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertSz (pTHS->searchLogging.pszFilter)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertSz (pTHS->searchLogging.pszIndexes)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertUL (pTHS->searchLogging.SearchEntriesVisited)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertUL (pTHS->pDB->SearchEntriesReturned)
                        : NULL),
                     NULL, NULL, NULL);

#if DBG

    //
    // Used to trackdown callers doing inefficient searches
    //

    if ( pTHS->searchLogging.SearchEntriesVisited > gulInefficientSearchTrigger ) {

        if ( pTHS->CallerType != CALLERTYPE_LDAP ) {

            KdPrint(("Search Entries Visited == %d\n",pTHS->searchLogging.SearchEntriesVisited));
            KdPrint(("Caller %s SearchArg %x\n",
                     GetCallerTypeString(pTHS),
                     pSearchArg));
            if ( fBreakOnInefficientSearchTrigger ) {
                DebugBreak();
            }
        }
    }
#endif

    // if we were asked for paged results, and we didn't hit any limit (size, time)
    // this means that we finished with searching, so we can account for it
    if ( (pCommArg->PagedResult.fPresent && !pSearchRes->pPartialOutcomeQualifier) ||
         (!pCommArg->PagedResult.fPresent) ) {

        DWORD searchExpensiveInefficient = 0;

        pTHS->searchLogging.SearchEntriesReturned = pTHS->pDB->SearchEntriesReturned;
        pTHS->searchLogging.SearchEntriesVisited = pTHS->pDB->SearchEntriesVisited;

        if (pTHS->pDB->SearchEntriesVisited >= gcSearchExpensiveThreshold) {
            gcSearchExpensive_count += 1;
            searchExpensiveInefficient |= 1;
        }

        if (pTHS->pDB->SearchEntriesVisited >= gcSearchInefficientThreshold) {
            if (pTHS->pDB->SearchEntriesVisited >= (10 * pTHS->pDB->SearchEntriesReturned) ) {
                gcSearchInefficient_count += 1;
                searchExpensiveInefficient |= 2;
            }
        }

        // check if we are asked to log all inefficient / expensive searches
        if ( searchExpensiveInefficient &&
             (DS_EVENT_SEV_INTERNAL <=
              gpDsEventConfig->rgEventCategories[DS_EVENT_CAT_FIELD_ENGINEERING].ulLevel) ) {

            SearchPerformanceLogFilter (pTHS->pDB, pSearchArg);
        }
    }

    if(pSecurity) {
        THFreeEx(pTHS, pSecurity);
    }

    DPRINT2 (2, "Objects Visited: %d   Returned: %d\n",
                    pTHS->pDB->SearchEntriesVisited,
                    pTHS->pDB->SearchEntriesReturned);

    return pTHS->errCode;

} // LocalSearch



// -------------------------------------------------------------------------
//  performs logging of the various search operations that took place the
//  last period. this function is invoked from within the garbage collector
//  so they share the same invocation interval.
// -------------------------------------------------------------------------
void
SearchPerformanceLogging (void)
{
    DSTIME timeNow = DBTime();
    DSTIME timeElapsed;
    DWORD hours;

    // We are not interested in the first time this function is called,
    // which happens 15 minutes after starting the DS, since we are bundled
    // together with GarbageCollection
    if (isSearchPerformanceLoggingFirstTime) {
        isSearchPerformanceLoggingFirstTime = FALSE;
        timeLastSearchLoggingPerformed = timeNow;
        return;
    }

    timeElapsed = timeNow - timeLastSearchLoggingPerformed;

    hours = (DWORD)timeElapsed / 3600;

    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_SEARCH_OPERATIONS,
             szInsertUL(hours),
             szInsertUL(gcTotalSearchesInLastPeriod),
             szInsertUL(gcSearchExpensive_count),
             szInsertUL(gcSearchInefficient_count),
             NULL, NULL, NULL, NULL);

    DPRINT4 (0, "SearchPerformanceLogging: %d total searches in %d hours, %d expensive, %d inefficient\n",
            gcTotalSearchesInLastPeriod, hours, gcSearchExpensive_count, gcSearchInefficient_count);

    // reset period loging variables
    gcSearchExpensive_count = gcSearchInefficient_count = gcTotalSearchesInLastPeriod = 0;
    timeLastSearchLoggingPerformed = timeNow;
}


void
SearchPerformanceLogFilter (DBPOS *pDB, SEARCHARG *pSearchArg)
{
    LPSTR buff = THAllocEx(pDB->pTHS, DBFILTER_DUMP_SIZE);

    buff[0] = '\0';

    DBCreateSearchPerfLogFilter (pDB, pSearchArg->pFilter, buff, DBFILTER_DUMP_SIZE);

    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
             DS_EVENT_SEV_INTERNAL,
             DIRLOG_SEARCH_FILTER_LOGGING,
             szInsertWC (!pSearchArg->pObject->NameLen ? L"RootDSE" : pSearchArg->pObject->StringName),
             szInsertSz (buff),
             szInsertUL(pDB->SearchEntriesVisited),
             szInsertUL(pDB->SearchEntriesReturned),
             szInsertSz(GetCallerTypeString(pDB->pTHS)),
             NULL, NULL, NULL );

    DPRINT3 (1, "Filter %s\n Returned %d Visited %d\n",
                    buff,
                    pDB->SearchEntriesReturned,
                    pDB->SearchEntriesVisited);

    THFreeEx (pDB->pTHS, buff);
}



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Build the Ent Inf datastructure for the current object and add to
   the linked-list.  If we run out of RPC space, we throw away the partial
   object and sucessfully return.  Note however, that atleast 1 object must
   be able to fit in RPC space.
*/

int
GetNextEntInf (
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pRange,
    IN ENTINFLIST **ppEntInfList,
    IN RANGEINFLIST **ppRangeInfList,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN PCACHED_AC CachedAC
    )
{
    THSTATE *pTHS = pDB->pTHS;
    ENTINFLIST *pNewEntList;
    RANGEINFLIST *pNewRangeList = NULL;     //initialized to avoid C4701
    RANGEINF *pRangeInf = NULL;
    DPRINT(3, "GetNextEntInf entered\n");

    if(pRange) {
        // A range was specified, so we need to allocate a range list
        (*ppRangeInfList)->pNext = THAllocEx(pTHS, sizeof(RANGEINFLIST));
        pNewRangeList = (*ppRangeInfList)->pNext;
        pRangeInf = &(pNewRangeList->RangeInf);
    }
    (*ppEntInfList)->pNextEntInf = THAllocEx(pTHS, sizeof(ENTINFLIST));

    pNewEntList = (*ppEntInfList)->pNextEntInf;

    if (GetEntInf(pDB,
                  pSel,
                  pRange,
                  &(pNewEntList->Entinf),
                  pRangeInf,
                  SecurityDescriptorFlags,
                  pSecurity,
                  Flags,
                  CachedAC,
                  NULL)) {

        DPRINT(2,"Error in getting object info\n");
        return pTHS->errCode;
    }
    else {
         DPRINT1(5, "Object retrieved: %S\n", pNewEntList->Entinf.pName);
         *ppEntInfList = pNewEntList;
         if(pRange) {
             *ppRangeInfList = pNewRangeList;
         }
         return 0;
    }
}


/*-------------------------------------------------------------------------*/
/*
   Check if this is a continued operation (paged results).  Regardless, find
   the first object which matches the search.
*/

DWORD
FindFirstSearchObject (
        DBPOS *pDB,
        SEARCHARG *pSearchArg,
        PRESTART pArgRestart,
        PSECURITY_DESCRIPTOR *ppSecurity
        )
{
    ULONG dwSearchStatus;
    BOOL fNegDelta=FALSE;
    ULONG LocalSearchFlags;
    ULONG SearchFlags;
    BOOL  fVLVSearch = FALSE;
    PRESTART pArgVLVRestart = NULL;

    if (pDB->Key.pVLV) {
        fVLVSearch = TRUE;
        pArgVLVRestart = pDB->Key.pVLV->pVLVRequest->pVLVRestart;
    }

    // we don't want Delta usage with VLV, since VLV imposes
    // its own delta usage
    Assert ( (pSearchArg->CommArg.Delta && !fVLVSearch) ||
             (!pSearchArg->CommArg.Delta) );

    // Set up the search flags we'll use to find the first object based on
    // restarting or simply going to the first element of the index, ignoring
    // deltas and security.
    SearchFlags = SEARCH_FLAGS(pSearchArg->CommArg);

    // Set up the search flags we'll use to move away from that object to the
    // object which is the real first object after we take into account security
    // and deltas.
    LocalSearchFlags = SearchFlags;

    switch(pSearchArg->CommArg.Delta) {
    case DB_MoveFirst:
        // Fall through
    case DB_MoveLast:
        // Fall through
    case 0:
        // No Delta anyway.

        // In all these cases, we don't need to change anything about direction
        // and we aren't backing up.
        break;
    default:
        if(pSearchArg->CommArg.Delta < 0) {
            fNegDelta = TRUE;
            pSearchArg->CommArg.Delta *= -1;
            // Switch the DB_SEARCH_FORWARD flag in the local search flags.
            LocalSearchFlags = REVERSE_SEARCH_FLAGS(pSearchArg->CommArg);
        }
        break;
    }

    if (pArgRestart) {
        // restarted operation
        dwSearchStatus = DBRepositionSearch(pDB,
                                            pArgRestart,
                                            pSearchArg->CommArg.StartTick,
                                            pSearchArg->CommArg.DeltaTick,
                                            ppSecurity,
                                            SearchFlags
                                            );
    }
    else if (pArgVLVRestart) {
        // VLV operation
        dwSearchStatus = DBRepositionSearch(pDB,
                                            pArgVLVRestart,
                                            pSearchArg->CommArg.StartTick,
                                            pSearchArg->CommArg.DeltaTick,
                                            ppSecurity,
                                            SearchFlags
                                            );
    }
    else {
        DWORD dwIndexFlags = (pSearchArg->choice == SE_CHOICE_BASE_ONLY)
                                ? 0 : DBCHOOSEINDEX_fUSEFILTER;

        if(!(pSearchArg->CommArg.fForwardSeek)) {
            dwIndexFlags |= DBCHOOSEINDEX_fREVERSE_SORT;
        }

        if (pSearchArg->CommArg.PagedResult.fPresent) {
            dwIndexFlags |= DBCHOOSEINDEX_fPAGED_SEARCH;
        }

        if (fVLVSearch) {
            dwIndexFlags |= DBCHOOSEINDEX_fVLV_SEARCH;
        }

        if (SearchFlags & DB_SEARCH_DELETIONS_VISIBLE) {
            dwIndexFlags |= DBCHOOSEINDEX_fDELETIONS_VISIBLE;
        }

        // if the client asks to leave the results in a sorted table,
        // then we do that since we sort at the same time
        // otherwise we use the default mechanism,
        // which is creating a list of the returned entries in memory

        if (pSearchArg->fPutResultsInSortedTable) {
            dwIndexFlags |= DBCHOOSEINDEX_fUSETEMPSORTEDTABLE;
        }

        if ((dwSearchStatus = DBSetSearchScope(
                pDB,
                pSearchArg->choice,
                pSearchArg->bOneNC,
                pSearchArg->pResObj)) ||
            (dwSearchStatus = DBChooseIndex(
                    pDB,
                    pSearchArg->CommArg.StartTick,
                    pSearchArg->CommArg.DeltaTick,
                    pSearchArg->CommArg.SortAttr,
                    pSearchArg->CommArg.SortType,
                    dwIndexFlags,
                    pSearchArg->CommArg.MaxTempTableSize))) {
            return dwSearchStatus;
        }

#if DBG
        {
           KEY_INDEX *tmp_index;

           for (tmp_index = pDB->Key.pIndex; tmp_index; tmp_index = tmp_index->pNext) {
               DPRINT3 (2, "Cantidate Idx: %s(%d) %d\n", tmp_index->szIndexName, tmp_index->bIsIntersection, tmp_index->ulEstimatedRecsInRange);
           }
        }
#endif

        // check to see what kind of search operation control we are passed
        //
        if (pSearchArg->CommArg.Svccntl.DontPerformSearchOp) {

            DBGenerateLogOfSearchOperation (pDB);

            // if we are told not to find any object, but just optimize the filter,
            // return an error so as to finish searching.
            //
            if (pSearchArg->CommArg.Svccntl.DontPerformSearchOp & SO_ONLY_OPTIMIZE) {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
        // if we are tracing, and we already don't have created the logfilter
        // we do this now
        else if (gpDsEventConfig->fTraceEvents) {
            DBGenerateLogOfSearchOperation (pDB);
        }

        if (pSearchArg->fPutResultsInSortedTable) {
            return DB_ERR_NEXTCHILD_NOTFOUND;
        }

        // we don't want to find the first object here if we are doing VLV
        if (!fVLVSearch) {
            dwSearchStatus= DBGetNextSearchObject(pDB,
                                                  pSearchArg->CommArg.StartTick,
                                                  pSearchArg->CommArg.DeltaTick,
                                                  ppSecurity,
                                                  SearchFlags);
        }
    }


    // if we are doing a VLV search, then use special positioning for this
    if (fVLVSearch) {
        // if we are doing container based VLV, we have to check for
        // access rights on the container.
        if (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) {

            // look up the container object.
            if(DBTryToFindDNT(pDB, pDB->Key.ulSearchRootDnt)) {
                // The container couldn't be found, hence it is empty.
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }

            // Check access
            if(!IsAccessGrantedSimple(RIGHT_DS_LIST_CONTENTS, FALSE)) {
                DPRINT(1, "Access Denied Listing Contents of VLV search.\n");

                // set count to zero, since we don't allow you to see any entries
                pDB->Key.pVLV->contentCount = 0;

                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }

        // At this point, we need to position ourselves correctly
        // on the specified entry.

        dwSearchStatus = DBPositionVLVSearch (pDB, pSearchArg, ppSecurity);

        return dwSearchStatus;
    }
    // if we are doing ASQ, we are already positioned. bail
    // we are not doing delta adjustements for ASQ
    else if (pDB->Key.asqRequest.fPresent) {
        return dwSearchStatus;
    }
    else if(dwSearchStatus && dwSearchStatus != DB_ERR_NEXTCHILD_NOTFOUND) {
        // Oops, we've already failed.  Other failures are handled below.
        return dwSearchStatus;
    }

    // Delta position adjustments
    if (pSearchArg->CommArg.Delta) {
        if(pSearchArg->CommArg.Delta == DB_MoveFirst) {
            pDB->Key.fSearchInProgress = FALSE;
            dwSearchStatus =
                DBGetNextSearchObject(pDB,
                                      pSearchArg->CommArg.StartTick,
                                      pSearchArg->CommArg.DeltaTick,
                                      ppSecurity,
                                      SearchFlags);
            pSearchArg->CommArg.Delta = 0;
        }
        else if(pSearchArg->CommArg.Delta == DB_MoveLast) {
            // Drop any positioning we currently have, switch the forward bit in the
            // flags, and reposition.  We switch the forward bit so that we will go
            // to the end of the index instead of the beginning.
            pDB->Key.fSearchInProgress = FALSE;
            dwSearchStatus =
                DBGetNextSearchObject(pDB,
                                      pSearchArg->CommArg.StartTick,
                                      pSearchArg->CommArg.DeltaTick,
                                      ppSecurity,
                                      REVERSE_SEARCH_FLAGS(pSearchArg->CommArg));
            if(dwSearchStatus == DB_ERR_TIMELIMIT) {
                // We bail out if we get this error.
                return dwSearchStatus;
            }
            DBMove(pDB, FALSE,
                   (pSearchArg->CommArg.fForwardSeek?DB_MoveNext:DB_MovePrevious));
            dwSearchStatus =  DB_ERR_NEXTCHILD_NOTFOUND;
            pSearchArg->CommArg.Delta = 0;
        }
        else if(dwSearchStatus && pSearchArg->CommArg.Delta && fNegDelta) {
            // We aren't on an object (so we are logically past the end of the
            // list), but we need to apply a delta backwards.  Force the code path
            // to back up.
            dwSearchStatus = 0;
        }
    }

    // At this point, we are on the beginning object of the search (that is,
    // we are either at the beginning of the index if DB_MoveFirst was
    // specified, the end if DB_MoveLast was specified, or somewhere in the
    // middle if we did a restart. Now, walk away
    // from that object applying security and the delta we were given to arrive
    // at the "real" first object.

    while(!dwSearchStatus) {
        // Found something, apply list rights.
        if(IsObjVisibleBySecurity(pDB->pTHS, TRUE)) {
            // List rights OK
            if(pSearchArg->CommArg.Delta) {
                // But we need to skip some.
                pSearchArg->CommArg.Delta--;
            }
            else {
                // And we don't need to skip any
                break;
            }
        }

        dwSearchStatus = DBGetNextSearchObject(
                pDB,
                pSearchArg->CommArg.StartTick,
                pSearchArg->CommArg.DeltaTick,
                ppSecurity,
                LocalSearchFlags );
    }

    if((dwSearchStatus == DB_ERR_NEXTCHILD_NOTFOUND) && fNegDelta) {
        // Not on a valid object, and we were backing up.  That means we should
        // find the first object.  Call recursively to avoid duplicate code, but
        // recursion depth will never be greater than 1.
        pSearchArg->CommArg.Delta = DB_MoveFirst;
        return FindFirstSearchObject (pDB,
                                      pSearchArg,
                                      pArgRestart,
                                      ppSecurity);
    }

    return dwSearchStatus;
}


void
AddCurrentObjectToAsqReferrals (THSTATE *pTHS,
                                DWORD *pcASQRefCount,
                                DWORD *pcASQRefAlloced,
                                DWORD **ppASQReferrals)
{
    DWORD DNT, actualRead;
    DWORD err;

    if (*ppASQReferrals == NULL) {
        *pcASQRefAlloced = 32;
        *ppASQReferrals = THAllocEx (pTHS, sizeof (DWORD) * (*pcASQRefAlloced));
    }
    else if (*pcASQRefCount >= *pcASQRefAlloced) {
        *pcASQRefAlloced = *pcASQRefAlloced * 2;
        *ppASQReferrals = THReAllocEx (pTHS, *ppASQReferrals, sizeof (DWORD) * (*pcASQRefAlloced));
    }

    if (err = DBGetSingleValue (pTHS->pDB, FIXED_ATT_DNT, &DNT, sizeof (DNT), &actualRead)) {
        DPRINT1 (0, "Error reading DNT: 0x%x\n", err);
        return;
    }

    (*ppASQReferrals)[*pcASQRefCount] = DNT;

    *pcASQRefCount = *pcASQRefCount + 1;

    DPRINT1 (1, "ASQREF for DNT: 0x%x\n", DNT);

    return;
}

void
GenerateASQ_POQ(THSTATE *pTHS,
                const SEARCHARG *pSearchArg,
                PARTIALOUTCOME **ppPOQ,
                DWORD cASQRefCount,
                DWORD *pASQReferrals)
{
    DBPOS * pDB = pTHS->pDB;
    DSNAME *pObject;
    ATTRBLOCK *pObjB = NULL;
    PARTIALOUTCOME * pPOQ;
    CONTREF *pContRef, **ppContRef;
    DWORD DNT, actualRead;
    DWORD err, i;


    DPRINT1 (0, "GENERATING %d refferral(s) for ASQ\n", cASQRefCount);

    pPOQ = *ppPOQ;

    if (pPOQ == NULL) {
        // no POQ allocated yet
        pPOQ = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
        pPOQ->problem = PA_PROBLEM_ADMIN_LIMIT;
    }

    pContRef = pPOQ->pUnexploredDSAs;
    ppContRef = &pPOQ->pUnexploredDSAs;


    for (i=0; i<cASQRefCount; i++) {
        DNT = pASQReferrals[i];

        pObject = DBGetDSNameFromDnt (pDB, DNT);
        if (!pObject) {
            DPRINT (0, "Error getting DSNAME\n");
            return;
        }
        DPRINT1 (0, "ASQREF: %ws\n", pObject->StringName);

        err = DSNameToBlockName(pTHS, pObject, &pObjB, DN2BN_PRESERVE_CASE);
        if (err) {
            DPRINT (0, "Bad Name\n");
            return;
        }

        // Alloc and stitch in the Contref
        pContRef = THAllocEx(pTHS, sizeof(CONTREF));
        pContRef->pNextContRef = pPOQ->pUnexploredDSAs;
        pPOQ->pUnexploredDSAs = pContRef;
        pPOQ->count++;

        pContRef->pTarget = pObject;

        pContRef->pNewFilter = pSearchArg->pFilter;

        // Ok, now we need to aim the search at the DC
        pContRef->pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
        pContRef->pDAL->pNextAddress = NULL; // one address per target
        GenSupRef(pTHS,
                  pContRef->pTarget,
                  pObjB,
                  &pSearchArg->CommArg,
                  &pContRef->pDAL->Address);

        FreeBlockName(pObjB);
    }

    // Did we find anything worth returning?  If so, return it.  If we
    // entered with an existing POQ this step is unnecessary, but if
    // we created the POQ here then it's needed.  Why make it conditional?
    // To handle the case where no unexplored DSAs were found, and no
    // POQ should be returned.
    if (pPOQ->pUnexploredDSAs) {
        *ppPOQ = pPOQ;
    }
}


void
GeneratePOQ(THSTATE *pTHS,
            const SEARCHARG *pSearchArg,
            PARTIALOUTCOME **ppPOQ)
{
    const DSNAME * const pObject = pSearchArg->pObject;
    const UCHAR choice = pSearchArg->choice;
    PARTIALOUTCOME * pPOQ;
    DBPOS * pDB = pTHS->pDB;
    ULONG it;
    ULONG len, iVal;
    DWORD err;
    ATTCACHE * pAC;
    DSNAME *pSRName = NULL;
    CONTREF *pContRef, **ppContRef;
    DSNAME *pName = NULL;
    WCHAR * pDNS;
    CROSS_REF *pCrossRef;
    ATTRTYP ObjClass;
    PSUBREF_LIST pDomainSubref;
    BOOL fDomainSubrefHit;
    DWORD i, nVal;
    DSA_ADDRESS_LIST *pDAL;

    pPOQ = *ppPOQ;

    if (!pSearchArg->bOneNC &&
        pSearchArg->choice != SE_CHOICE_IMMED_CHLDRN) {
        // The only time we issue referrals on a GC search should be
        // for the special ABView referrals, which we only issue for
        // one level searches.
        return;
    }
    if (pPOQ == NULL) {

        // no POQ allocated yet
        pPOQ = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
        pPOQ->problem = PA_PROBLEM_ADMIN_LIMIT;

        // WHy an admin limit?  Because the only case where we
        // generate a brand-new POQ here is from encountering NC
        // boundaries.  If we've already encountered a size or time
        // limit, we'll let that POQ code stand as is, and just return
        // the contrefs as a bonus.  Note the special handling of pPOQ
        // at the end of this routine for the other half of this logic.
    }
    pPOQ->count = 0;

    ObjClass = pSearchArg->pResObj->MostSpecificObjClass;
    it = pSearchArg->pResObj->InstanceType;

    if (pSearchArg->bOneNC) {
        // We need to go to the NC head to get the subref information. The
        // assert swears that if the search root is an NC head, then our resobj
        // NCDNT matches our DNT, meaning that we're going to the right place.
        Assert(   !!(it & IT_NC_HEAD)
               == !!(pSearchArg->pResObj->NCDNT == pSearchArg->pResObj->DNT));

        Assert(pPOQ->pUnexploredDSAs == 0);
        ppContRef = &pPOQ->pUnexploredDSAs;

        // Check the cache of ATT_SUB_REFS in gAnchor
        if (pSearchArg->pResObj->NCDNT == gAnchor.ulDNTDomain &&
            gAnchor.fDomainSubrefList) {

            // For each cached ATT_SUB_REFS
            for (pDomainSubref = gAnchor.pDomainSubrefList;
                 pDomainSubref;
                 pDomainSubref = pDomainSubref->pNextSubref) {

                fDomainSubrefHit = FALSE;

                // Is the subref subordinate to this object?
                if (choice == SE_CHOICE_WHOLE_SUBTREE) {
                    for (i = 0; i < pDomainSubref->cAncestors; ++i) {
                        if (*(pDomainSubref->pAncestors + i) == pSearchArg->pResObj->DNT) {
                            fDomainSubrefHit = TRUE;
                            break; // out of inner for
                        }
                    }
                }
                // Is the subref an immediate child of this object?
                else if (   (choice == SE_CHOICE_IMMED_CHLDRN)
                           && (pDomainSubref->cAncestors > 1)
                           && (*(pDomainSubref->pAncestors + 1) == pSearchArg->pResObj->DNT)) {
                    fDomainSubrefHit = TRUE;
                }
                // HIT. save a copy of the DSName
                if (fDomainSubrefHit) {
                    *ppContRef = pContRef = THAllocEx(pTHS, sizeof(CONTREF));
                    ppContRef = &pContRef->pNextContRef;
                    pContRef->pTarget = THAllocEx(pTHS,
                                                  pDomainSubref->pDSName->structLen);
                    CopyMemory(pContRef->pTarget,
                               pDomainSubref->pDSName,
                               pDomainSubref->pDSName->structLen);
                    pPOQ->count++;
                }
            }
        }
        // Read the subrefs because the cache isn't valid for this search.
        else {
            err = DBFindDNT(pDB, pSearchArg->pResObj->NCDNT);
            if (err) {
                LogUnhandledError(err);
                return;
            }

            iVal = 1;
            pAC = SCGetAttById(pTHS, ATT_SUB_REFS);
            //
            // PREFIX: PREFIX complains that pAC hasn't been checked to
            // make sure that it is not NULL.  This is not a bug.  Since
            // a predefined constant was passed to SCGetAttById, pAC will
            // never be NULL.
            //

            Assert(pAC);

            while (0 == DBGetAttVal_AC(pDB,
                                       iVal,
                                       pAC,
                                       0,
                                       0,
                                       &len,
                                       (UCHAR**)&pSRName)) {
                pName = (DSNAME *)THAllocEx(pTHS, pSRName->structLen);
                if (((choice == SE_CHOICE_IMMED_CHLDRN) &&
                     (0 == TrimDSNameBy(pSRName, 1, pName)) &&
                     NameMatched(pObject, pName))
                    ||
                    ((choice == SE_CHOICE_WHOLE_SUBTREE) &&
                     NamePrefix(pObject, pSRName))) {

                    *ppContRef = pContRef = THAllocEx(pTHS, sizeof(CONTREF));
                    ppContRef = &pContRef->pNextContRef;
                    pContRef->pTarget = pSRName;
                    pSRName = NULL;
                    pPOQ->count++;
                }
                else {
                    THFreeEx(pTHS, pSRName);
                }
                ++iVal;
                // Free memory allocated in this iteration of while
                THFreeEx(pTHS, pName);
            }
        }
    }

    pContRef = pPOQ->pUnexploredDSAs;
    ppContRef = &pPOQ->pUnexploredDSAs;
    while (pContRef) {
        // Find the in memory CrossRef structure corresponding to this NC
        pCrossRef = FindExactCrossRef(pContRef->pTarget,
                                      &pSearchArg->CommArg);
        if (!pCrossRef) {
            /*
             * Once replication has quiesced, we should have a cross-ref
             * for every sub-ref.  While replication is still going on,
             * though, we could easily have replicated in a sub-ref with
             * one naming context before we have fully synched the config
             * NC, meaning that the cross-ref would not have replicated in
             * yet.  This means that we can't make a blanket assertion that
             * we should have a cross ref.  Instead we can only assert that
             * this should be the case if replication is complete.
             */
            DPRINT1(0, "Can't find cross-ref for %ls\n",
                        pContRef->pTarget->StringName);
            LooseAssert(!"Can't find cross-ref object!", SubrefReplicationDelay);

            goto SkipIt;
        }

        if(!pCrossRef->bEnabled){
            // We don't generate referrals of any kind for disabled
            // crossRefs.  As far as the directory is concerned we this
            // part of the directory does not exist yet.
            goto SkipIt;
        }

        // No referrals?
        if (0 == pCrossRef->DnsReferral.valCount) {
            goto SkipIt;
        }

        // Add each dns name
        pContRef->pDAL = NULL; // just in case
        for (nVal = 0; nVal < pCrossRef->DnsReferral.valCount; ++nVal) {
            len = pCrossRef->DnsReferral.pAVal[nVal].valLen;
            pDNS = THAllocEx(pTHS, len);
            memcpy(pDNS, pCrossRef->DnsReferral.pAVal[nVal].pVal, len);

            Assert(len < 64*1024);

            len = AdjustDNSPort(pDNS, len, (pTHS->CipherStrength == 0));

            // Copy the address information into the Continuation
            pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
            pDAL->pNextAddress = pContRef->pDAL;
            pDAL->Address.Length = (unsigned short) len;
            pDAL->Address.MaximumLength = (unsigned short) len;
            pDAL->Address.Buffer = pDNS;
            pContRef->pDAL = pDAL;
        }
        if (choice == SE_CHOICE_IMMED_CHLDRN) {
            pContRef->bNewChoice = TRUE;
            pContRef->choice = SE_CHOICE_BASE_ONLY;
        }

        /* Since we have successfully processed this entry, step to the
         * next entry in the list.
         */
        ppContRef = &pContRef->pNextContRef;
        pContRef = pContRef->pNextContRef;
        continue;

        /* this line is not reached */
SkipIt:
        /* This contref was messed up for some reason, so we want to snip
         * it out of the list, so that all contrefs in our output list
         * are valid
         */
        pPOQ->count--;             // decrement the count of contrefs
        *ppContRef = pContRef->pNextContRef; // step around the element
        THFreeEx(pTHS, pContRef->pTarget); // free a sub part
        THFreeEx(pTHS, pContRef);          // free the contref
        pContRef = *ppContRef;     // reset our loop pointer
    }

    if ((ObjClass == CLASS_ADDRESS_BOOK_CONTAINER) &&
        (pSearchArg->choice == SE_CHOICE_IMMED_CHLDRN)) {
        // Ok, this was a one-level search under an ABView, which means
        // that we get to construct a magic search continuation.  The
        // search described will have be to a GC (always), have a base
        // object of root, be whole subtree, and have a filter that is
        // an AND of the input filter, a special Show-In this View filter,
        // and DISPLAY_NAME present (the index we maintain over Show-In is
        // compound over show-in and display-name, and is defined
        // ignore_any_null, so we can only use it in the display-name present
        // case.
        FILTER * pFilterTemp;

        // Alloc and stitch in the Contref
        pContRef = THAllocEx(pTHS, sizeof(CONTREF));
        pContRef->pNextContRef = pPOQ->pUnexploredDSAs;
        pPOQ->pUnexploredDSAs = pContRef;
        pPOQ->count++;

        // re-base the search to the root
        pContRef->pTarget = THAllocEx(pTHS, DSNameSizeFromLen(0));
        pContRef->pTarget->structLen = DSNameSizeFromLen(0);

        // re-scope the search
        pContRef->bNewChoice = TRUE;
        pContRef->choice = SE_CHOICE_WHOLE_SUBTREE;

        // re-filter the search
        pContRef->pNewFilter = THAllocEx(pTHS, sizeof(FILTER));
        pContRef->pNewFilter->choice = FILTER_CHOICE_AND;
        pContRef->pNewFilter->FilterTypes.And.count = 3;
        pContRef->pNewFilter->FilterTypes.And.pFirstFilter =
            pFilterTemp = THAllocEx(pTHS, 2 * sizeof(FILTER));

        // First clause: Show-In is the address book in question
        pFilterTemp->choice = FILTER_CHOICE_ITEM;
        pFilterTemp->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.type =
          ATT_SHOW_IN_ADDRESS_BOOK;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.valLen =
          pSearchArg->pObject->structLen;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.pVal =
          (UCHAR*)(pSearchArg->pObject);
        pFilterTemp->pNextFilter = &pFilterTemp[1];
        pFilterTemp++;

        // Second clause: Display-name present
        pFilterTemp->choice = FILTER_CHOICE_ITEM;
        pFilterTemp->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.type =
            ATT_DISPLAY_NAME;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.valLen = 0;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.pVal = NULL;

        // Third clause: Pick up the filter they gave us.
        pFilterTemp->pNextFilter = pSearchArg->pFilter;

        // Ok, now we need to aim the search at a GC
        pContRef->pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
        pContRef->pDAL->pNextAddress = NULL; // one address per target
        GenSupRef(pTHS,
                  pContRef->pTarget,
                  gpRootDNB,
                  &pSearchArg->CommArg,
                  &pContRef->pDAL->Address);

    }

    // Did we find anything worth returning?  If so, return it.  If we
    // entered with an existing POQ this step is unnecessary, but if
    // we created the POQ here then it's needed.  Why make it conditional?
    // To handle the case where no unexplored DSAs were found, and no
    // POQ should be returned.
    if (pPOQ->pUnexploredDSAs) {
        *ppPOQ = pPOQ;
    }
}


VOID
SimpleBaseSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags
        )
{
    ULONG                ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD               getEntInfFlags = 0;
    RESOBJ              *pResObjArg;
    PDSNAME             pParent = NULL;

    // Before we start, mark that we are as sorted as we were requested to be.
    pTHS->pDB->Key.ulSorted = pSearchArg->CommArg.SortType;
    pSearchRes->bSorted = (pTHS->pDB->Key.ulSorted != SORT_NEVER);

    // PERFINC(pcSearchSubOperations);
    pTHS->pDB->SearchEntriesVisited += 1;
    
    // First, make sure we have list content rights on the parent.
    if (!(pTHS->fDSA || pTHS->fDRA)) {
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            return;
        }

        // Now, get the security descriptor for this object.
        if(!(flags & SEARCH_UNSECURE_SELECT)) {
            DBPOS* pDB = pTHS->pDB;
            char objFlag;
            DWORD err;
            err = DBGetObjectSecurityInfo(
                    pDB,
                    pDB->DNT,
                    &ulLen,
                    &pSec,
                    NULL,
                    NULL,
                    &objFlag,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE
                );
            if (err) {
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }
            // Every object should have an SD.
            Assert(objFlag == 0 || ulLen > 0);
        }
    }

    SvccntlFlagsToGetEntInfFlags(&pSearchArg->CommArg.Svccntl,&getEntInfFlags);

    if(flags & SEARCH_UNSECURE_SELECT) {
        getEntInfFlags |= GETENTINF_NO_SECURITY;
    }

    if ((pSearchArg->pResObj->pObj->NameLen)
        || (pSearchArg->pSelection->infoTypes  == EN_INFOTYPES_SHORTNAMES)) {
        // If we already have a good enough object name, don't fetch another
        pResObjArg = pSearchArg->pResObj;
    }
    else {
        pResObjArg = NULL;
    }

    // Do the GetEntInf
    if(!GetEntInf(pTHS->pDB,
                  pSearchArg->pSelection,
                  pSearchArg->pSelectionRange,
                  &pSearchRes->FirstEntInf.Entinf,
                  &pSearchRes->FirstRangeInf.RangeInf,
                  pSearchArg->CommArg.Svccntl.SecurityDescriptorFlags,
                  pSec,
                  getEntInfFlags,
                  NULL,
                  pResObjArg)) {

#if 0
        //
        // This is #if 0 instead of removed to allow for our bosses to
        // change their minds on the issue of whether we should be returning
        // an error or not
        //

        if ((pSearchRes->FirstEntInf.Entinf.AttrBlock.attrCount == 0) &&
            (pSearchArg->pSelection) &&
            (pSearchArg->pSelection->AttrTypBlock.attrCount != 0)) {

            // it is an error if the user requested a list of
            // attributes and none were found on any objects.

            SetAttError(pSearchArg->pObject, 0L,
                        PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                        DIRERR_NO_REQUESTED_ATTS_FOUND);
        }
#endif
        // success, set the count.
        pSearchRes->count = 1;
    }

    if(pSec) {
        THFreeEx(pTHS, pSec);
    }

    return;
} // SimpleBaseSearch

BOOL
IsBaseOnlyAttPresent(
    SEARCHARG *pSearchArg
)
{
   ULONG i;
   ENTINFSEL *pSel = pSearchArg->pSelection;

   if (!pSel) {
      // no selection to check
      // return false, since constructed atts are returned
      // only when explicitly asked for, that is, there is
      // a selection
      return FALSE;
   }

   for (i=0; i<pSel->AttrTypBlock.attrCount; i++) {
       switch(pSel->AttrTypBlock.pAttr[i].attrTyp) {
          case ATT_TOKEN_GROUPS:
          case ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE:
              if (pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
                 // non-base search
                 return TRUE;
              }
              break;
          default:
             // more attributes may need to be added later
             ;
       }
   }

   return FALSE;
}

