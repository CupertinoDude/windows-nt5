//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mddel.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirRemoveEntry API.

    DirRemoveEntry() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <ntdsctr.h>                    // Perf Hook
#include <ntdsa.h>
#include <cracknam.h>

// SAM interoperability headers
#include <mappings.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"
#include "dstaskq.h"
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include "permit.h"
#include "debug.h"                      // standard debugging header
#include "drameta.h"
#define DEBSUB "MDDEL:"                 // define the subsystem for debugging

#define _AVOID_REPL_API
#include "nlrepl.h"

#include <fileno.h>
#define  FILENO FILENO_MDDEL

#include <dnsapi.h>                     // DnsValidateDnsName
#include <dsgetdc.h>                    // DsValidateSubnetNameW

int
PrivateLocalRemoveTree (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        );

/* Internal functions */
int
MakeNameForDeleted(
        THSTATE *pTHS,
        DSNAME *pObject,
        DSNAME *pDeletedName,
        ULONG  cbDeletedBuf,
        ATTR *pNewRDN
        );

DWORD
PossiblyMoveDeletedObject (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        );

int NoDelCriticalSystemObjects(REMOVEARG *pRemoveArg);
int SetDelAtt(RESOBJ *pObj, ATTRTYP rdnType);
int CheckCatalogd(THSTATE *pTHS, DSNAME *pDN);

extern DWORD GetConfigParam(char * parameter, void * value, DWORD dwSize);

typedef struct _DSA_DEL_INFO {
    LPWSTR  pDnsDomainName;
    GUID    DomainGuid;
    GUID    DsaGuid;
    LPWSTR  pDnsHostName;
} DSA_DEL_INFO;

DSA_DEL_INFO *GatherDsaDelInfo(THSTATE *pTHS,
                               RESOBJ  *pResObj);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirRemoveEntry(
    REMOVEARG  * pRemoveArg,     /* RemoveEntry  argument */
    REMOVERES ** ppRemoveRes
){

    THSTATE*     pTHS;
    REMOVERES * pRemoveRes;
    BOOL           fContinue;
    BOOL           fDidPrivateLocalRemoveTree = FALSE;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirRemoveEntry entered\n");


    // This operation should not be performed on read-only objects.
    pRemoveArg->CommArg.Svccntl.dontUseCopy = TRUE;

    /* Initialize the THSTATE anchor and set a write sync-point.  This sequence
       is required on every API transaction.  First the state DS is initialized
       and then either a read or a write sync point is established.
       */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    pTHS->fLazyCommit |=  pRemoveArg->CommArg.fLazyCommit;
    *ppRemoveRes = pRemoveRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppRemoveRes = pRemoveRes = THAllocEx(pTHS, sizeof(REMOVERES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            ErrorOnShutdown();
            __leave;
        }

        if( pRemoveArg->fTreeDelete ) {

            if (  (TRANSACT_BEGIN_END != pTHS->transControl)
               || (NULL != pTHS->pSamLoopback) )
            {
                //
                // N.B. Due to the transaction scheme used for
                // our tree delete, clients cannot expect thier current
                // transaction to live beyond this call, hence the
                // "dont_end" restriction.  Furthermore, the tree delete
                // routine ends the transaction independent of success
                // hence allowing dont_begin_end would be misleading.
                // Thus, there is only one kind of transControl allowed.
                //
                // Since SAM controls its own transactioning, this should
                // not be used during loopback either.
                //
                // This is an internal error, since the system controls how DirXxx
                // api are called and should never program this combination.
                //
                Assert( TRANSACT_BEGIN_END == pTHS->transControl );
                Assert( NULL == pTHS->pSamLoopback );
                SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM, DS_ERR_INTERNAL_FAILURE );
                __leave;
            }

            // This is a legal operation

            SYNC_TRANS_READ();
        }
        else {
            SYNC_TRANS_WRITE();       /* Set Sync point*/
        }
        __try {
            /* Inhibit update operations if the schema hasen't been loaded yet
               or if we had a problem loading.
               */

            if (!gUpdatesEnabled){
                DPRINT(2, "Returning BUSY because updates are not enabled yet\n");
                SetSvcError(SV_PROBLEM_BUSY, DIRERR_SCHEMA_NOT_LOADED);
                __leave;
            }

            // Perform name resolution to locate object.  If it fails,
            // just return an error, which may be a referral. Note that
            // we must demand a writable copy of the object.
            pRemoveArg->CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               NAME_RES_IMPROVE_STRING_NAME,
                               pRemoveArg->pObject,
                               &pRemoveArg->CommArg,
                               &pRemoveRes->CommRes,
                               &pRemoveArg->pResObj)){

                if(pRemoveArg->fTreeDelete) {
                    // Local Remove Tree operation
                    pRemoveArg->fTreeDelete = FALSE;
                    pRemoveArg->fDontDelCriticalObj = TRUE;
                    fDidPrivateLocalRemoveTree = TRUE;
                    PrivateLocalRemoveTree(pTHS, pRemoveArg);
                }
                else {
                    /* Local Remove operation */

                    if (!SampRemoveLoopbackCheck(pRemoveArg, &fContinue) &&
                        fContinue ) {
                        LocalRemove(pTHS, pRemoveArg);
                    }
                }
            }
        }
        __finally {
            // Security errors are logged separately
            if (pTHS->errCode != securityError) {
                BOOL fFailed = (BOOL)(pTHS->errCode || AbnormalTermination());

                LogEventWithFileNo(
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         fFailed ?
                            DS_EVENT_SEV_VERBOSE :
                            DS_EVENT_SEV_INTERNAL,
                         fFailed ?
                            DIRLOG_PRIVILEGED_OPERATION_FAILED :
                            DIRLOG_PRIVILEGED_OPERATION_PERFORMED,
                         szInsertSz(""),
                         szInsertDN(pRemoveArg->pObject),
                         NULL,
                         FILENO);
            }

            if(!fDidPrivateLocalRemoveTree) {
                // If we didn't do a localremovetree, then we have yet to do
                // this. PrivateLocalRemoveTree does this for itself.
                CLEAN_BEFORE_RETURN (pTHS->errCode);
            }
            else {
                // If we did do a localremovetree, then we need to reset the
                // flag in the remove arg.  This is just to be consistent to our
                // callers.
                pRemoveArg->fTreeDelete = TRUE;
            }

        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pRemoveRes) {
        pRemoveRes->CommRes.errCode = pTHS->errCode;
        pRemoveRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;
}                               /*S_DirRemoveEntry*/

int
GetRdnTypeForDeleteOrRename (
    IN THSTATE      *pTHS,
    IN DSNAME       *pObj,
    OUT ATTRTYP     *pRdnType
    )
/*++
Routine Description:
    Retrieve the rdnType (msDS-IntId) needed for checks in
    LocalRemove and LocalModifyDn. The rdnType is read from the object.
    If no value for rdnType is present (what?), the rdnType
    is found from the most-specific component of the object's DN.

Arguments:
    pTHS - thread state
    pObj - object to be removed (pRemoveArg->pResObj->pObj)
    pRdnType - returned rdnType

Return Value:
    0 if all went well and *pRdnType will be set, an error otherwise and
    *pRdnType will be unchanged. If an error is returned, a Set???Error
    will already have been called.
--*/
{
    ULONG   dwErr;

    // Use the object's rdnType, not the rdnattid from its class definition
    // A superceding class may have a different rdnattid than the
    // the superceded class in effect when this object was created.
    if(dwErr = DBGetSingleValue(pTHS->pDB,
                              FIXED_ATT_RDN_TYPE,
                              pRdnType,
                              sizeof(*pRdnType),
                              NULL)) {
        if (DB_ERR_NO_VALUE == dwErr) {
            // Hmmm... the object doesn't have an rdnType? No matter. Simply
            // retrieve the RDN type of the old name.  Note that this value may be
            // different from that specified in the CLASSCACHE for this object's
            // object class; specifically, they will likely differ if we're deleting
            // an auto-generated subref, in which case the class is CLASS_TOP, the
            // class-specific RDN type for CLASS_TOP is ATT_COMMON_NAME, but the subref
            // likely corresponds to, e.g., DC=Child,DC=Root,DC=Microsoft,....
            // In this case the RDN type in the DSNAME must be "DC", not "CN".
            if ( !pObj->StringName || !pObj->NameLen) {
                dwErr = DIRERR_NAME_TYPE_UNKNOWN;
            } else {
                dwErr = GetRDNInfo(pTHS, pObj, NULL, NULL, pRdnType);
            }
            if (dwErr) {
                return SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pObj, DIRERR_BAD_NAME_SYNTAX);
            }
        } else {
            // We shouldn't be here.  Assume a temporary problem.
            // (record locks, etc.)
            return SetSvcErrorEx(SV_PROBLEM_BUSY,
                                 DIRERR_DATABASE_ERROR, dwErr);
        }
    }
    return 0;
}

/*++
Routine Description
    Remove an object from the directory.  Actually, mark object as deleted, but
    leave row in database alone (needed for tombstone replication)

    Unless fPreserveRDN is set in the REMOVEARG, this routine will delete-mangle
    both the "true" RDN (ATT_RDN) and the class-specific RDN, changing them to
    the stringized object GUID plus an invalid character.  This avoids name
    conflicts between deleted objects and new objects with the same RDN.

Arguments
   pTHS - Threadstate pointer

   pRemoveArg - REMOVEARG structure containing the name of the object to remove.

 --*/

int
LocalRemove (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        )
{
    CLASSCACHE *pClassSch = NULL;
    ATTR       NewRDN;
    ATTRVAL    NewRDNAV;
    DSNAME    *pDeletedName = NULL;
    ULONG      cbDeletedBuf = 0;
    ULONG      iClass, LsaClass;
    DSNAME     *pObjToRemove;
    ULONG      len;
    DWORD      err;
    DSA_DEL_INFO *pDsaDelInfo = NULL;
    ATTRTYP    AttLsaLikes = ATT_USER_ACCOUNT_CONTROL;
    DWORD      ActiveContainerID;

    extern BOOL gfRunningAsMkdit;       //from dsamain.c

    DPRINT(1,"LocalRemove entered\n");

    PERFINC(pcTotalWrites);
    INC_WRITES_BY_CALLERTYPE( pTHS->CallerType );

    Assert(pRemoveArg->pResObj);

    //
    // Trace event
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_REMOVE,
                     EVENT_TRACE_TYPE_START,
                     DsGuidDelete,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertDN(pRemoveArg->pObject),
                     NULL, NULL, NULL, NULL, NULL, NULL);

    // We should be positioned on the object by now.  Since the client
    // might have passed in a GUID or SID only name, use the fully prepped
    // name in the resobj
    pObjToRemove = pRemoveArg->pResObj->pObj;
    Assert(pObjToRemove->NameLen);

    pClassSch = SCGetClassById(pTHS,
                               pRemoveArg->pResObj->MostSpecificObjClass);
    Assert(pClassSch);

    if (!pClassSch) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        goto exit;
    }

    //
    // Check Remove Security
    //

    if (CheckRemoveSecurity(
            FALSE,
            pClassSch,
            pRemoveArg->pResObj))
    {
        goto exit;
    }
    
    // Don't allow re-deletions of tombstones, except if caller is the
    // replicator.
    if (pRemoveArg->pResObj->IsDeleted && !pTHS->fDRA) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);

        goto exit;
    }

    // Check to see if this is an update in an active container
    CheckActiveContainer(pRemoveArg->pResObj->PDNT, &ActiveContainerID);
    if(ActiveContainerID) {
        if(PreProcessActiveContainer(pTHS,
                                     ACTIVE_CONTAINER_FROM_DEL,
                                     pObjToRemove,
                                     pClassSch,
                                     ActiveContainerID)) {
            goto exit;
        }
    }

    cbDeletedBuf = pObjToRemove->structLen + MAX_RDN_SIZE * sizeof(WCHAR);
    pDeletedName= THAllocEx(pTHS, cbDeletedBuf);

    // RDNs should be preserved only when the DRA is tearing down a
    // read-only NC, or if the DSA really wants to
    Assert( !pRemoveArg->fPreserveRDN || pTHS->fDRA || pTHS->fDSA);

    // lock the DN against someone adding children to this object.

    err = DBLockDN(pTHS->pDB, DB_LOCK_DN_WHOLE_TREE, pObjToRemove);
    if(err && !(err & DB_LOCK_DN_CONFLICT_TREE_ABOVE) &&
       !(err & DB_LOCK_DN_STICKY))

    if (    err
            // and not the tree delete case
         && (    !(err & DB_LOCK_DN_CONFLICT_TREE_ABOVE)
              && !(err & DB_LOCK_DN_STICKY) )
            // and not the CreateProxyObject case - three flags required
         && (    !(err & DB_LOCK_DN_CONFLICT_NODE)
              && !(err & DB_LOCK_DN_CONFLICT_TREE_BELOW)
              && !pTHS->fCrossDomainMove ) )
    {
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
        goto exit;
    }

    NewRDN.AttrVal.pAVal = &NewRDNAV;
    // Null this, since we might have to free it later, and we'd rather not free
    // stack noise.
    NewRDN.AttrVal.pAVal->pVal = NULL;

    if (pClassSch->ClassId == CLASS_NTDS_DSA) {
        // If someone's deleting a DSA, we need to gather some info from
        // the object before it gets stripped, so that we can later tell
        // NetLogon about the deletion, but only if this is an originating
        // write.
        if (!pTHS->fDRA) {
            pDsaDelInfo = GatherDsaDelInfo(pTHS, pRemoveArg->pResObj);
        }
    }

    // Retrieve the rdnType (msDS-IntId) needed for the checks below.
    // Don't bother if none of the functions requiring rdnType will be
    // called. The rdnType is read from the object. If no value for
    // rdnType is present, the rdnType is found from the most-specific
    // component of the object's DN.
    //
    // The rdnattid in the object's class cannot be used because
    // a superceding class may have a different rdnattid than the
    // superceded class in effect when the object was created.
    NewRDN.attrTyp = INVALID_ATT;
    if (!pRemoveArg->fPreserveRDN || !pRemoveArg->fGarbCollectASAP) {
        if (GetRdnTypeForDeleteOrRename(pTHS, pObjToRemove, &NewRDN.attrTyp)) {
            goto exit;
        }
    }

    /* The order of these validations are important */

    // Note that we don't go through SetDelAtt() when we're going to try to
    // garbage collect this object ASAP.  SetDelAtt() simply sets the
    // is-deleted attribute and removes a bunch of attributes.  We need not
    // set is-deleted since we're going to immediately remove it in DBPhysDel()
    // along with most of the other attributes, EXCLUDING backlinks.  Backlinks
    // should be maintained, as presumably fGarbCollectASAP is only set when
    // we're tearing down a read-only NC, in which case we don't want to remove
    // forward links to this object from objects in other NCs.


    if (   (   pRemoveArg->fPreserveRDN
             ? (memcpy(pDeletedName,
                       pObjToRemove,
                       pObjToRemove->structLen), 0)
             : MakeNameForDeleted(pTHS,
                                  pObjToRemove,
                                  pDeletedName,
                                  cbDeletedBuf,
                                  &NewRDN)
           )
        || NoDelCriticalObjects(pRemoveArg->pResObj->pObj, pRemoveArg->pResObj->DNT)
        || NoDelCriticalSystemObjects(pRemoveArg)
        || (pTHS->fDRA      // if not DRA, make sure there are no children
            ? 0
            : NoChildrenExist(pRemoveArg->pResObj))
        || (pRemoveArg->fGarbCollectASAP
            ? 0
            : SetDelAtt(pRemoveArg->pResObj, NewRDN.attrTyp))
        || (  pRemoveArg->fPreserveRDN
            ? 0
            : ReSetNamingAtts(pTHS,
                              pRemoveArg->pResObj,
                              NULL,
                              &NewRDN,
                              FALSE,
                              FALSE,
                              pClassSch)
            )
        || PossiblyMoveDeletedObject(pTHS, pRemoveArg)
        || InsertObj(pTHS, pObjToRemove, pRemoveArg->pMetaDataVecRemote, TRUE,
                    META_STANDARD_PROCESSING)
        ){

        // Clean up some memory we might have allocated.
        THFreeEx(pTHS,NewRDN.AttrVal.pAVal->pVal);
        goto exit;
    }

    // Clean up some memory we might have allocated.
    THFreeEx(pTHS,NewRDN.AttrVal.pAVal->pVal);

    if (pTHS->SchemaUpdate!=eNotSchemaOp) {
        //
        // On Schema updates we want to resolve conflicts, and we want to
        // do so without losing database currency, which would cause operations
        // a few lines below to fail.

        ULONG dntSave = pTHS->pDB->DNT;

        if (!pTHS->fDRA) {
            if(WriteSchemaObject()) {
                goto exit;
            }
        }

        //  A schema object cannot be deleted except for through schupgr.exe,
        if (     !pTHS->fDSA
              && !pTHS->fDRA
              && !gAnchor.fSchemaUpgradeInProgress
              && !gfRunningAsMkdit
              && !DsaIsInstalling()
              && (   pTHS->SchemaUpdate==eSchemaAttDel
                  || pTHS->SchemaUpdate==eSchemaClsDel ) ) {

            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_CANT_DELETE );
            goto exit;
        }


        if (ValidSchemaUpdate()) {
            goto exit;
        }

        // Now restore currency
        DBFindDNT(pTHS->pDB, dntSave);
    }

    if (
        //    The original data record is replaced by the new record
        //    with the Logical Flag set. This new record is the one
        //    to be entered into the deletion index. So the data record
        //    pos to be used should be the one setup by InsertObj.

           DBAddDelIndex(pTHS->pDB, pRemoveArg->fGarbCollectASAP)
        || CheckCatalogd(pTHS, pRemoveArg->pResObj->pObj)
        || DelObjCaching(pTHS, pClassSch, pRemoveArg->pResObj, TRUE)){

        if (0 == pTHS->errCode) {
            // Only case where this could happen is if DBAddDelIndex() failed,
            // in which case the failure is the inability to find either the
            // metadata vector or an entry in the vector for ATT_IS_DELETED
            // (which _should_ never happen).

            SetAttError(
                pObjToRemove,
                ATT_IS_DELETED,
                PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                NULL,
                DIRERR_MISSING_REQUIRED_ATT
                );
        }

        goto exit;
    }



    if (pRemoveArg->fGarbCollectASAP) {
        // Go ahead and try to physically delete this object.
        // At minimum this will strip the remaining attributes from the object
        // (most importantly all those that reference other objects) and
        // demote the object to a phantom.

        DBPhysDel(pTHS->pDB, TRUE, NULL);
    }
    else
    {
        if (!pTHS->fDRA) {

            // Only notify replicas if this is not the DRA thread. If it is,
            // then we will notify replicas near the end of DRA_replicasync.
            // We can't do it now as NC prefix is in inconsistent state

            // Currency of DBPOS must be at the target object
            DBNotifyReplicasCurrDbObj(pTHS->pDB,
                         pRemoveArg->CommArg.Svccntl.fUrgentReplication );
        }


        //
        // We need to inform SAM and NetLogon of
        // changes to SAM objects to support downlevel replication
        //

        if (SampSamClassReferenced(pClassSch,&iClass)) {
                if ( SampAddToDownLevelNotificationList(
                               pObjToRemove,
                               iClass,
                               0,
                               SecurityDbDelete,
                               FALSE,
                               FALSE,
                               DomainServerRoleBackup // Place holder value
                                                      // for server role. Will
                                                      // not be used as the
                                                      // Role transfer parameter
                                                      // is set to FALSE
                              ) )
                {
                    //
                    // the above routine failed
                    //
                    goto exit;
                }
        }

        //
        // We want to notify Lsa
        //

        if (SampIsClassIdLsaClassId(pTHS,
                                    pClassSch->ClassId,
                                    1,
                                    &AttLsaLikes,
                                    &LsaClass)) {

             if ( SampAddToDownLevelNotificationList(
                     pObjToRemove,
                     iClass,
                     LsaClass,
                     SecurityDbDelete,
                     FALSE,
                     FALSE,
                     DomainServerRoleBackup) )
             {
                 //
                 // the above routine failed.
                 //
                 goto exit;
             }
        }
    }

    if (pDsaDelInfo) {
        // We need to tell NetLogon if we deleted a DSA
        if (0 == pTHS->errCode) {
            __try {
                // If we don't have a DnsDomainName, we also don't have
                // a DomainGuid. I_NNNDD wants a null pointer to a guid
                // rather than a pointer to a null guid, though, so
                // we get the funky second argument to the call.
                I_NetNotifyNtdsDsaDeletion(pDsaDelInfo->pDnsDomainName,
                                           (pDsaDelInfo->pDnsDomainName
                                            ? &(pDsaDelInfo->DomainGuid)
                                            : NULL),
                                           &(pDsaDelInfo->DsaGuid),
                                           pDsaDelInfo->pDnsHostName);
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                // Ignore errors
                ;
            }
        }
        THFreeEx(pTHS, pDsaDelInfo->pDnsDomainName);
        THFreeEx(pTHS, pDsaDelInfo->pDnsHostName);
        THFreeEx(pTHS, pDsaDelInfo);
    }

    // Cheaper to free stuff here than later.
    THFreeEx(pTHS, pDeletedName);

exit:
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_REMOVE,
                     EVENT_TRACE_TYPE_END,
                     DsGuidDelete,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL,
                     NULL, NULL, NULL, NULL, NULL);

    return (pTHS->errCode);  /*incase we have an attribute error*/

}/*LocalRemove*/

/* fDNTInProtectedList - Checks to see if the supplied DNT exists in the list
*       of DNTs whose deletion we should not allow.
*
*  Returns:
*       TRUE if DNT in list.
*
*  Note: Any changes in logic here should be mirrored in NoDelCriticalObjects
*        in src\mddel.c
*/
BOOL
fDNTInProtectedList(
    ULONG DNT,
    BOOL *pfNtdsaAncestorWasProtected
    )
{
    ULONG uli;

    if (pfNtdsaAncestorWasProtected) {
        *pfNtdsaAncestorWasProtected = FALSE;
    }

    // Can't delete NTDS-DSA object for this machine. Note that pAncestors is
    // ordered from the bottom of the tree toward the top, and we protect things
    // at the level of the Config container and above using other mechanisms
    for (uli=0;
         (uli<gAnchor.AncestorsNum &&
          gAnchor.pAncestors[uli] != gAnchor.ulDNTConfig); uli++) {
        if (DNT == gAnchor.pAncestors[uli]) {
            if (pfNtdsaAncestorWasProtected) {
                *pfNtdsaAncestorWasProtected = TRUE;
            }
            return TRUE;
        }
    }
    // Can't delete protected objects
    for (uli=0; uli < gAnchor.UnDeletableNum; uli++) {
        if (DNT == gAnchor.pUnDeletableDNTs[uli]) {
            return TRUE;
        }
    }
    // Can't delete protected objects ancestors
    for (uli=0; uli<gAnchor.UnDelAncNum; uli++) {
        if (DNT == gAnchor.pUnDelAncDNTs[uli]) {
            return TRUE;
        }
    }

    return FALSE;
}


/*++ NoDelCriticalObjects
 *
 * Set an error if the object is one of those this DSA refuses to delete.
 *
 *  Note that there are two separate definitions of "critical objects" floating
 *  around.  One is that list of objects marked in the Anchor as being
 *  ancestors of the DSA or otherwise undeletable, and these objects are
 *  not deletable by anyone.  These objects are protected by
 *  NoDelCriticalObjects.  The second definition is those objects stamped
 *  with the attribute criticalSystemObject.  Those objects can normally be
 *  deleted, except if the removearg explicitly asks to avoid stomping on
 *  them, which is usually the case only during tree deletes.  These objects
 *  are protected by NoDelCriticalSystemObjects
 */
int NoDelCriticalObjects(DSNAME *pObj,
                         ULONG  DNT)
{
    unsigned i;
    BOOL fNtdsaAncestorWasProtected;

    DPRINT(1,"NoDelCriticalObjects entered\n");

    if (fDNTInProtectedList( DNT, &fNtdsaAncestorWasProtected )) {

        if (fNtdsaAncestorWasProtected) {
            DPRINT(2,"Can't delete the DSA object for this service\n");
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_CANT_DELETE_DSA_OBJ);
        } else {
            DPRINT(2,"Can't delete protected objects\n");
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_CANT_DELETE);
        }
    }

    // Can't delete Cross-Ref objects corresponding to local master
    // config/schem/domain NCs.
    if (IsCrossRefProtectedFromDeletion(pObj)) {

        DPRINT(2,"Can't delete master cross-refs\n");
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_CANT_DEL_MASTER_CROSSREF);
    }

    return 0;    /*Not a critical object*/

}/*NoDelCriticalObjects*/

/*++ NoDelCriticalSystemObjects
 *
 * Set an error if the object is one of those this DSA refuses to delete,
 * unless you want to.
 *
 *  Note that there are two separate definitions of "critical objects" floating
 *  around.  One is that list of objects marked in the Anchor as being
 *  ancestors of the DSA or otherwise undeletable, and these objects are
 *  not deletable by anyone.  These objects are protected by
 *  NoDelCriticalObjects.  The second definition is those objects stamped
 *  with the attribute criticalSystemObject.  Those objects can normally be
 *  deleted, except if the removearg explicitly asks to avoid stomping on
 *  them, which is usually the case only during tree deletes.  These objects
 *  are protected by NoDelCriticalSystemObjects.
 */
int NoDelCriticalSystemObjects(REMOVEARG *pRemoveArg)
{
    ULONG IsCritical;

    if (pRemoveArg->fDontDelCriticalObj) {

        if ((0 == DBGetSingleValue(pTHStls->pDB,
                                   ATT_IS_CRITICAL_SYSTEM_OBJECT,
                                   &IsCritical,
                                   sizeof(IsCritical),
                                   NULL))
            && IsCritical) {
            // This object is marked as critical.  Fail the delete.
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ);
        }
    }

    return 0;    /*Not a critical object*/

}/*NoDelCriticalSystemObjects*/

/*++ GatherDsaDelInfo
 *
 * This routine gathers enough information about a DSA object to notify
 * NetLogon about the DSA's deletion.  This consists of GUIDs and DNS
 * addresses, which are scattered all over the place.  The GUID of the DSA
 * is embedded in the DSNAME of the DSA object.  The DNS address of the
 * host is on the DSA's parent (the server), stored as an attribute.  From
 * the DSA object we can also get a list of its master NCs, one of which
 * will be domain.  From the DSNAME of the domain we can extract both the
 * GUID of the domain and (separately) the DNS name of the domain.
 *
 * INPUT:
 *   pResObj - resolved object of the DSA being deleted
 * RETURN VALUE:
 *   pointer to information block
 */
DSA_DEL_INFO *
GatherDsaDelInfo(THSTATE *pTHS,
                 RESOBJ * pResObj)
{
    DSA_DEL_INFO *pInfo;
    unsigned cbCur, cbMax;
    DSNAME *pNC;
    unsigned err;
    unsigned iTagSequence;
    ATTCACHE *pAC;
    PDS_NAME_RESULTW pResults=NULL;
    WCHAR * apwc[1];
    UCHAR * pBuf;

    pInfo = THAllocEx(pTHS, sizeof(DSA_DEL_INFO));

    pInfo->DsaGuid = pResObj->pObj->Guid;

    cbMax = 0;
    cbCur = 0;
    iTagSequence = 0;
    pAC = SCGetAttById(pTHS, ATT_HAS_MASTER_NCS);
    Assert(pAC != NULL);

    do {
        ++iTagSequence;
        cbMax = max(cbMax, cbCur);

        //
        // PREFIX: PREFIX complains that pAC hasn't been checked to
        // make sure that it is not NULL.  This is not a bug.  Since
        // a predefined constant was passed to SCGetAttById, pAC will
        // never be NULL.
        //
        err = DBGetAttVal_AC(pTHS->pDB,
                             iTagSequence,
                             pAC,
                             DBGETATTVAL_fREALLOC,
                             cbMax,
                             &cbCur,
                             (UCHAR**)&pNC);
    } while (!err &&
             NamePrefix(gAnchor.pConfigDN,
                        pNC));

    if (0 == err) {
        pInfo->DomainGuid = pNC->Guid;

        // Convert the name into a DNS address.
        apwc[0] = pNC->StringName;
        err = DsCrackNamesW((HANDLE) -1,
                            (DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC |
                             DS_NAME_FLAG_SYNTACTICAL_ONLY),
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            1,
                            apwc,
                            &pResults);
        if ( err                                // error from the call
            || !(pResults->cItems)            // no items returned
            || (pResults->rItems[0].status)   // DS_NAME_ERROR returned
            || !(pResults->rItems[0].pDomain) // No domain returned
            || !(pInfo->pDnsDomainName = THAlloc(
               (cbCur= (sizeof(WCHAR)*(1+wcslen(pResults->rItems[0].pDomain))))))
            ) {
            // We couldn't crack the name?  Bad.  Assert for debugging and
            // continue for production.
            Assert(err == 0);
            THFreeEx(pTHS, pInfo);
            THFreeEx(pTHS, pNC);
            return NULL;
        }
        THFreeEx(pTHS, pNC);

        memcpy(pInfo->pDnsDomainName,
               pResults->rItems[0].pDomain,
               cbCur);

    }
    else {
        // We ran out of NCs held by the DSA before we found one that wasn't
        // a child of the config container, i.e., before we found a domain NC.
        // That's unexpected, as every DSA should have a domain NC.  Assert
        // for debugging, and return nothing (so that NetLogon won't be
        // notified) for production.

        // DonH 7/9/98 - Due to a recent change in link attribute behavior,
        // we can now end up with NTDS-DSA objects with no domain listed (if
        // the domain is deleted before the NTDS-DSA object is).  In that case
        // we leave the DEL_INFO partially populated, with a NULL domain DNS
        // address and GUID.
        pInfo->pDnsDomainName = NULL;
    }

    DBFindDNT(pTHS->pDB, pResObj->PDNT);
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_DNS_HOST_NAME,
                      0,
                      0,
                      &cbCur,
                      &pBuf);

    if (err) {
        // Dang.  Something must have failed.
        THFreeEx(pTHS, pInfo->pDnsDomainName);
        THFreeEx(pTHS, pInfo);
        pInfo = NULL;
    }
    else {
        // Now have to NULL terminate the host name
        pInfo->pDnsHostName = THAllocEx(pTHS, cbCur + sizeof(WCHAR));
        memcpy(pInfo->pDnsHostName, pBuf, cbCur);
        THFreeEx(pTHS, pBuf);
    }

    // Have to reposition where we were
    DBFindDNT(pTHS->pDB, pResObj->DNT);

    return pInfo;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int
SetDelAtt (RESOBJ *pResObj, ATTRTYP rdnType)
{
    SYNTAX_BOOLEAN         true = TRUE;
    DWORD                  rtn = 0;
    THSTATE *              pTHS = pTHStls;
    ATTR *                 pAttr;
    unsigned               count, i, j;
    CLASSCACHE            *pCC;
    ATTCACHE              *pAC;
    DSNAME                *pLastKnownParent;

    DPRINT(1,"SetDelAtt entered\n");

    // Remove all attributes that aren't marked as vital to keep.
    if (0 ==  DBGetMultipleAtts(pTHS->pDB,
                                0,
                                NULL,
                                NULL,
                                NULL,
                                &count,
                                &pAttr,
                                0,
                                0)) {

        for(i=0;i<count;i++) {
            switch (pAttr[i].attrTyp) {
              case ATT_ATTRIBUTE_ID:
              case ATT_ATTRIBUTE_SYNTAX:
              case ATT_DN_REFERENCE_UPDATE:
              case ATT_FLAT_NAME:               // For trust relationships
              case ATT_GOVERNS_ID:
              case ATT_GROUP_TYPE:              // downlevel BDC sync
              case ATT_INSTANCE_TYPE:
              case ATT_LDAP_DISPLAY_NAME:
              case ATT_LEGACY_EXCHANGE_DN:
              case ATT_MSMQ_OWNER_ID:           // for MSMQ NT4/NT5 sync
              case ATT_NC_NAME:
              case ATT_NT_SECURITY_DESCRIPTOR:
              case ATT_OBJECT_CLASS:
              case ATT_OBJ_DIST_NAME:
              case ATT_OBJECT_GUID:
              case ATT_OBJECT_SID:
              case ATT_OM_SYNTAX:
              case ATT_PROXIED_OBJECT_NAME:     // cross domain move
              case ATT_RDN:
              case ATT_REPL_PROPERTY_META_DATA:
              case ATT_SAM_ACCOUNT_NAME:        // downlevel BDC sync
              case ATT_SECURITY_IDENTIFIER:     // For trust relationships
              case ATT_SUB_CLASS_OF:
              case ATT_SYSTEM_FLAGS:
              case ATT_TRUST_PARTNER:           // For trust relationships
              case ATT_TRUST_DIRECTION:         // For trust relationships
              case ATT_TRUST_TYPE:              // For trust relationships
              case ATT_TRUST_ATTRIBUTES:        // For trust relationships
              case ATT_USER_ACCOUNT_CONTROL:    // downlevel BDC sync
              case ATT_USN_CHANGED:
              case ATT_USN_CREATED:
              case ATT_WHEN_CREATED:
              case ATT_MS_DS_CREATOR_SID:

                // Preserve these attributes no matter what.  Please keep
                // the list ordered, it's hard enough to find things as is.
                break;

              default:
                // preserve the att if the schema says to, or if it's the RDN,
                // or if it's a link or backlink attribute, which are handled
                // separately below
                pAC = SCGetAttById(pTHS, pAttr[i].attrTyp);
                Assert(pAC != NULL);
                if (   (pAttr[i].attrTyp == rdnType)
                    || (pAC->fSearchFlags & fPRESERVEONDELETE)
                    || (0 != pAC->ulLinkID)) {
                    break;
                }
                // Didn't make the test? Fall through to the delete case

              case ATT_IS_DELETED:
              case ATT_OBJECT_CATEGORY:
              case ATT_SAM_ACCOUNT_TYPE:
              case ATT_LAST_KNOWN_PARENT: // forcibly removed and reset below
                // These atts (and others who failed the test) get removed
                DBRemAtt(pTHS->pDB, pAttr[i].attrTyp);
            }

            // No values were actually fetched, so we don't have to free them

        }
        THFreeEx(pTHS, pAttr);
    }

    if ( (rtn = DBAddAtt(pTHS->pDB, ATT_IS_DELETED, SYNTAX_BOOLEAN_TYPE))
       || (rtn =DBAddAttVal(pTHS->pDB, ATT_IS_DELETED,
                            sizeof(SYNTAX_BOOLEAN),(UCHAR *) &true))) {
        DPRINT(1, "Couldn't add deletion flag\n");

        Assert(DB_ERR_VALUE_EXISTS != rtn);

        // All problems are assumed to be temporary (record locks, etc.)
        return SetSvcErrorEx(SV_PROBLEM_BUSY,
                             DIRERR_DATABASE_ERROR, rtn);
    }

    // Delete the member/is member attributes. We handle these differently
    // than other attributes so that we can remove backlinks, which are
    // not normally writable on objects.
    if (DBRemoveLinks(pTHS->pDB) == DB_ERR_SYSERROR)
    {
        DPRINT(1,"Error removing links\n");
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,
                             DB_ERR_SYSERROR);
    }

    // Help folks find the original location of a deleted object
    // by setting ATT_LAST_KNOWN_PARENT. Forcibly removed above.
    // RAID 261208 in Windows Bugs.
    pLastKnownParent = THAllocEx(pTHS, pResObj->pObj->structLen);
    if (TrimDSNameBy(pResObj->pObj, 1, pLastKnownParent)
        || DBAddAtt(pTHS->pDB, ATT_LAST_KNOWN_PARENT, SYNTAX_DISTNAME_TYPE)
        || DBAddAttVal(pTHS->pDB, ATT_LAST_KNOWN_PARENT,
                       pLastKnownParent->structLen, pLastKnownParent)) {
        DPRINT(0,"Error while adding lastKnownParent (ignored)\n");
    }
    THFreeEx(pTHS, pLastKnownParent);
    pLastKnownParent = NULL;

    return 0;

}/*SetDelAtt*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function removes any possible entries from the system catalog,  It
   also validates that no children exist for this object.
*/

int CheckCatalogd(THSTATE *pTHS,
                  DSNAME *pDN)
{

   SYNTAX_INTEGER instance;

   DPRINT(1,"CheckCatalogd entered\n");

   /* Position on the attribute instance.  */

   if (GetExistingAtt(pTHS->pDB, ATT_INSTANCE_TYPE, (void *) &instance,
                      sizeof(instance))){
          DPRINT(2,"Couldn't retrieve INSTANCE type error already set\n");
          return pTHS->errCode;
   }

   DPRINT1(2,"Instance type is <%lu>.\n", instance);


   if (DelCatalogInfo(pTHS, pDN, instance)){
      DPRINT(2,"Error while deleting global object info\n");
      return pTHS->errCode;
   }

   return 0;

}/*CheckCatalogd*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/


int
ReSetNamingAtts (
        THSTATE *pTHS,
        RESOBJ *pResObj,
        DSNAME *pNewParent,
        ATTR *pNewRDN,
        BOOL fCheckRDNConstraints,
        BOOL fAllowPhantomParent,
        CLASSCACHE *pClassSch
        )
{
    ULONG         code;
    ATTCACHE      *pAC;
    WCHAR         *pwszRDN;
    DWORD         cb;
    DWORD         dnsErr;
    HVERIFY_ATTS  hVerifyAtts;

    // Use the new RDNs attrTyp and not the object's class rdnattid
    // because a superceding class may have a different rdnattid
    // than the superceded class in effect when this object was
    // created.
    pAC = SCGetAttById(pTHS, pNewRDN->attrTyp);
    if (!pAC) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_MISSING_REQUIRED_ATT);
    }

    // Replace the current RDN attribute with the new one.  Except, of
    // course, for auto-generated subrefs, which don't have their
    // class-specific RDN column set.  Auto-generated subrefs are
    // most easily detected by their object class:
    if (pResObj->MostSpecificObjClass != CLASS_TOP) {
        // not an auto-generated subref
        hVerifyAtts = VerifyAttsBegin(pTHS, pResObj->pObj, pResObj->NCDNT, NULL);

        __try {
            if (code = ReplaceAtt(pTHS,
                                  hVerifyAtts,
                                  pAC,
                                  &(pNewRDN->AttrVal),
                                  fCheckRDNConstraints)) {
                Assert(pTHS->errCode);
                return code;
            }
        } __finally {
            VerifyAttsEnd(pTHS, &hVerifyAtts);
        }
    }
    else {
        // We think this is a auto-gen subref, so it had better look like one.
        Assert(IT_NC_HEAD & pResObj->InstanceType || pTHS->fSingleUserModeThread );
    }

    // Reset the true RDN column (ATT_RDN)
    if(code = DBResetRDN(pTHS->pDB, pNewRDN->AttrVal.pAVal)) {
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             DIRERR_ILLEGAL_MOD_OPERATION,
                             code);
    }

    if(pNewParent) {
        // Drat, gotta change the parentage
        if(code = DBResetParent(pTHS->pDB, pNewParent, fAllowPhantomParent ? DBRESETPARENT_CreatePhantomParent : 0)) {
            return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                 DIRERR_ILLEGAL_MOD_OPERATION,
                                 code);
        }
    }

    // Validate site names - RAID 145341.
    // Validate subnet names - RAID 200090.
    Assert(pNewRDN->AttrVal.valCount < 2);
    if (    !pTHS->fDRA
         && fCheckRDNConstraints
         && (    (CLASS_SITE == pClassSch->ClassId)
              || (CLASS_SUBNET == pClassSch->ClassId) ) )
    {
        cb = pNewRDN->AttrVal.pAVal[0].valLen + sizeof(WCHAR);
        pwszRDN = (WCHAR *) THAllocEx(pTHS,cb);
        memcpy(pwszRDN,
               pNewRDN->AttrVal.pAVal[0].pVal,
               pNewRDN->AttrVal.pAVal[0].valLen);

        if (    (    (CLASS_SITE == pClassSch->ClassId)
                  && (    // Check for legal characters
                          (    (dnsErr = DnsValidateName_W(pwszRDN, DnsNameDomainLabel))
                            && (DNS_ERROR_NON_RFC_NAME != dnsErr) ) ) )
             || (    (CLASS_SUBNET == pClassSch->ClassId)
                  && (NO_ERROR != DsValidateSubnetNameW(pwszRDN)) ) )
        {
            THFreeEx(pTHS,pwszRDN);
            return SetNamError(NA_PROBLEM_BAD_NAME,
                               NULL,
                               DIRERR_BAD_NAME_SYNTAX);
        }
        THFreeEx(pTHS,pwszRDN);
    }

    // We are not allowed to change the name of any naming context,
    // so we don't need to worry about updating the NC name cache
    // in the anchor.

    return 0;
}

/*++
Description:
    Creates a new name for a deleted object based on the undeleted name.  This
    new name is unique among all objects.  We do this by creating a GUID,
    stringizing it, and adding a "bad" unicode character after it.  We also make
    sure that the name is unique by looking up the name in the directory and
    making sure it is not there.

    Locks the newly deleted name.

    Moves DB currency, but puts it back.

    Assumes that position is on pObject, and that pObject is a valid,
    'DBFindDSName'able object.

Arguments

    pObject - the undeleted name

    pDeletedName - space for the deleted name, must be big enough to hold an
       arbitrary DSNAME.

    pNewRDn - An allocated ATTR and ATTRVALBLOCK for holding the new RDN.  The
        val pointer will be THAlloc()'ed.

Return Vals:
    0 if all went well, an error otherwise.  If an error is returned, a
    Set???Error will already have been called.

--*/
int
MakeNameForDeleted(
        THSTATE *pTHS,
        DSNAME *pObject,
        DSNAME *pDeletedName,
        ULONG cbDeletedBuf,
        ATTR *pNewRDN
        )
{
    BOOL       fOK;
    unsigned   len = 0;
    GUID       guid;
    ULONG      dbError;
    ULONG      ReasonForLock;
    WCHAR      *pNewRDNVal;
    ATTRTYP     IgnoreRdnType;
    DSNAME     *pParentName = (DSNAME *) THAllocEx(pTHS, pObject->structLen);

    // Set up some values for the new RDN
    pNewRDN->AttrVal.valCount = 1;
    pNewRDN->AttrVal.pAVal->pVal = THAllocEx(pTHS, sizeof(WCHAR)*MAX_RDN_SIZE);
    pNewRDNVal = (WCHAR *) pNewRDN->AttrVal.pAVal->pVal;
    len = 0;

    fOK=FALSE;

    // Start setting up the new DN by copying all but the RDN of the
    // original object.
    TrimDSNameBy(pObject, 1, pParentName);

    // Retrieve the RDN of the old name. Ignore the rdnType returned
    // by GetRDNInfo. The rdnType stored in ATT_FIXED_RDN_TYPE is
    // used instead (set by the caller in pNewRDN->attrtyp).
    GetRDNInfo(pTHS, pObject, pNewRDNVal, &len, &IgnoreRdnType);

    // Get the object GUID.
    dbError = DBGetSingleValue(
                    pTHS->pDB,
                    ATT_OBJECT_GUID,
                    &guid,
                    sizeof( guid ),
                    NULL
                    );

    Assert(DB_ERR_NO_VALUE != dbError);

    if ( 0 != dbError ) {
        LogUnhandledError( DIRERR_MISSING_REQUIRED_ATT );
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_NO_DELETED_NAME, dbError );
    }

    // Mangle the RDN into the appropriate tombstone name.
    MangleRDN(MANGLE_OBJECT_RDN_FOR_DELETION, &guid, pNewRDNVal, &len);

    pNewRDN->AttrVal.pAVal->valLen = len * sizeof(WCHAR);

    // Now append the new RDN.
    if (AppendRDN(pParentName,
                  pDeletedName,
                  cbDeletedBuf,
                  pNewRDNVal,
                  len,
                  pNewRDN->attrTyp)) {
        LogUnhandledError(DIRERR_NO_DELETED_NAME);
        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_NO_DELETED_NAME);
    }

    // See if we can lock this new name and if we fail to find it already in
    // the dit.  Note that we don't attempt to lock the deleted name if it's
    // the same as the object name (as occurs during replication of a
    // tombstone), as the object name has already been locked by LocalRemove().
    // Also we don't lock the dn if the tree above is locked, since it will be
    // locked during tree delete
    if ( NameMatched(pObject, pDeletedName) )
    {
        fOK = TRUE;
    }
    else
    {
        ReasonForLock = DBLockDN(pTHS->pDB, 0, pDeletedName);
        if (  (ReasonForLock == 0)
           || (ReasonForLock & DB_LOCK_DN_CONFLICT_TREE_ABOVE) )
        {
            if ( DIRERR_OBJ_NOT_FOUND == DBFindDSName(pTHS->pDB, pDeletedName) )
            {
                fOK = TRUE;
            }
        }
    }

    THFreeEx(pTHS,pParentName);

    if(!fOK) {
        // Couldn't come up with a decent name.
        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_NO_DELETED_NAME);
    }

    // Copy over GUID for DN comparisons.
    memcpy(&pDeletedName->Guid, &guid, sizeof(GUID));

    // Ok, set currency back to the correct object
    DBFindDSName(pTHS->pDB, pObject);

    return 0;
}

/*++ DelAutoSubRef
 *
 * If appropriate, removes an automatically generated subref object
 *
 * INPUT
 *   pCR - name of cross ref object being deleted
 * RETURN VALUE
 *   non-zero on error
 */
int DelAutoSubRef(DSNAME *pCR)
{
    THSTATE *pTHS = pTHStls;
    int err;
    DSNAME *pNC = 0;
    int it = 0;
    DBPOS *pDB, *pDBSave;
    ULONG len;
    REMOVEARG removeArg;
    BOOL fDSASave;
    BOOL fCommit = FALSE;

    memset( &removeArg, 0, sizeof( removeArg ) );

    fDSASave = pTHS->fDSA;
    pDBSave = pTHS->pDB;
    DBOpen(&pDB);
    pTHS->pDB = pDB;
    __try {
        if (err = DBFindDSName(pDB, pCR)) {
            /* couldn't find the CR?  bogus  It's got to be there */
            SetSvcErrorEx(SV_PROBLEM_UNABLE_TO_PROCEED,
                          DIRERR_OBJ_NOT_FOUND,
                          err);
            __leave;
        }
        if (DBGetAttVal(pDB, 1, ATT_NC_NAME, 0, 0, &len, (UCHAR**)&pNC)) {
            /* we don't care */
            __leave;
        }

        if (err = DBFindDSName(pDB, pNC)) {
            if (err == DIRERR_NOT_AN_OBJECT) {
                GUID phantomGuid;
                // ncName reference is a phantom.
                // We are about to delete the cross ref which references this phantom
                // as an NC.  Normally we wouldn't have to mangle this name now since
                // phantom name conflict will handle this if a new reference to this name
                // comes in. However, we mangle it now to facilitate the check for nc
                // name ownership, which assumes that there are no current users of the
                // name. This is similar to the cases of removing a cross ref to a
                // real nc head or a cross ref to a subref, both of which get mangled as
                // a side effect of cross ref removal.
                err = DBGetSingleValue(pDB, ATT_OBJECT_GUID, &phantomGuid,
                                       sizeof(phantomGuid), NULL);
                if (err == DB_ERR_NO_VALUE) {
                    DsUuidCreate(&phantomGuid);
                } else if (err) {
                    SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
                    __leave;
                }

                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_DEL_AUTO_SUBREF,
                         szInsertDN(pCR),
                         szInsertDN(pNC),
                         szInsertUUID( &phantomGuid) );


                if ((err = DBMangleRDN(pDB, &phantomGuid)) ||
                    (err = DBUpdateRec(pDB))) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
                    __leave;
                }
                CheckNCRootNameOwnership( pTHS, pNC );
                fCommit = TRUE;
            }
            /* not there? nothing to delete! */
            __leave;
        }
        removeArg.pResObj = CreateResObj(pDB, pNC);
        if (!removeArg.pResObj) {
            /*Couldn't create a resobj when we're on the object? Bogus */
            err = 1;
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        DIRERR_OBJ_NOT_FOUND);
            __leave;
        }
        it = removeArg.pResObj->InstanceType;


        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DEL_AUTO_SUBREF,
                 szInsertDN(pCR),
                 szInsertDN(pNC),
                 szInsertUL( it ) );

        if (it == SUBREF) {
            removeArg.pObject = pNC;
            Assert( !fNullUuid(&pNC->Guid) ); // SUBREFs now always have GUIDS
            removeArg.fPreserveRDN = FALSE;
            pTHS->fDSA = TRUE;

            err = LocalRemove(pTHS, &removeArg);
            if (!err) {
                // ncName reference is a subref.
                CheckNCRootNameOwnership( pTHS, pNC );
            }
        }
        else if (it & IT_NC_ABOVE) {
            // We're removing a cross-ref for which we locally have an
            // instantiated NC with an NC above it.  This typically happens
            // when a domain is removed from the enterprise and this is a GC.
            //
            // In this case we want to remove the NC from the parent NC's
            // SUBREF list to prevent referrals from being generated for the
            // NC whose cross-ref is being deleted.  (A live cross-ref is
            // required to generate a referral.)  The KCC will come along later
            // to remove the NC.

            DelSubFromNC(pTHS, pNC, DSID(FILENO,__LINE__));
        }
        fCommit = (0 == err);
    }
    __finally {
        DBClose(pDB, fCommit);
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASave;
    }
    if (pNC)
      THFreeEx(pTHS, pNC);
    if (removeArg.pResObj)
      THFreeEx(pTHS, removeArg.pResObj);

    return err;
}

/*++
  IMPORTANT NOTE!!!!! This routine violates the normal transaction rules of the
  various LocalFoo routines, hence the name "Private".  It expects to be called
  inside a SYNC_TRANS_READ.  Furthermore, IT DOES THE CLEAN_BEFORE_RETURN
  itself!! Don't call this routine unless you can handle that!!!  After closing
  the transaction it was in when it was called, it may call DirRemove, which
  opens and closes transactions that are completely separate.  No matter what,
  when you leave this routine, you are one transaction level lower than you were
  when you called.

Routine Description
    Remove a sub tree from the directory.  Finds all children of the root of the
    delete first (or as many as will fit in memory) via DBLayer call, the calls
    DirRemoveEntry on them.

    NOTE that if not all children fit in memory, we will delete children from
    the bottom up, but we make no guarantees about which children are reoved.

    NOTE that we return an error if we didn't finish the whole tree, even though
    we may have committed deletions.  Yes, this does somewhat violate the normal
    transaction model.

    Passes the pRemoveArg on to DirRemoveEntry, but turns off the TreeDelete
    flag.

Arguments
   pTHS - Threadstate pointer

   pRemoveArg - REMOVEARG structure containing the name of the object to remove.

 --*/

int
PrivateLocalRemoveTree (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        )
{
    ULONG       cNamesMax, iLastName, i;
    PDSNAME     *pNames;
    REMOVEARG   SingleRemoveArg;
    REMOVERES  *pSingleRemoveRes;
    BOOL        bWholeTree;
    BOOL        fWrapped;
    CLASSCACHE *pClassSch = NULL;
    BOOL        fLockedDN = FALSE;
    ATTRBLOCK  *pObjB=NULL;
    DWORD       rtn;
    PDSNAME     pParent;
    BOOL        fPassedSec = FALSE;

    DPRINT(1,"LocalRemove entered\n");

    __try {
        // Now, do a security check.
        pClassSch = SCGetClassById(pTHS,
                                   pRemoveArg->pResObj->MostSpecificObjClass);
        Assert(pClassSch);
        
        if (CheckRemoveSecurity(
                TRUE,
                pClassSch,
                pRemoveArg->pResObj)) {

            __leave;
        }

        // We are located on the root of the deletion.  The first step is to
        // lock the tree.
        if (rtn = DBLockDN(pTHS->pDB,
                           (DB_LOCK_DN_WHOLE_TREE | DB_LOCK_DN_STICKY),
                           pRemoveArg->pResObj->pObj)) {
            // Someone's trying to muck with this object (primarily adding
            // children)
            SetSvcErrorEx(SV_PROBLEM_BUSY,
                          ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE,
                          rtn);
            __leave;
        }

        fLockedDN = TRUE;

        // Final preliminary: make sure there are no NC's beneath us.
        if(DSNameToBlockName(pTHS,
                             pRemoveArg->pResObj->pObj,
                             &pObjB,
                             DN2BN_LOWER_CASE)) {
            SetNamError(NA_PROBLEM_BAD_NAME,
                        pRemoveArg->pObject,
                        DIRERR_BAD_NAME_SYNTAX);
            __leave;
        }
        if (fHasDescendantNC(pTHS, pObjB, &pRemoveArg->CommArg)) {
            // Whoops, there is an NC beneath us. Bail
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_NO_TREE_DELETE_ABOVE_NC);
            FreeBlockName(pObjB);
            __leave;
        }

        // we don't need this anymore...
        FreeBlockName(pObjB);

        // OK, now build an array of objects to delete.  The array holds objects
        // in depth first traversal order.
        if(rtn = DBGetDepthFirstChildren(pTHS->pDB, &pNames, &iLastName,
                                         &cNamesMax, &fWrapped, FALSE)) {
            // Failed to get the children.
            SetSvcErrorEx(SV_PROBLEM_UNABLE_TO_PROCEED,
                          ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE,
                          rtn);
            __leave;
        }
    }
    __finally {

	// This routine needs to leave it's transaction, as DirRemoveTree
	// expects it.
	CLEAN_BEFORE_RETURN (pTHS->errCode);
    }

    __try {
        if(!pTHS->errCode) {
            // Before we start, see if the first dsname in the list is the root
            // of the delete.  If it is AND we successfully delete all the
            // objects in the list, then we succeeded in deleting the tree.
            if(NameMatched(pRemoveArg->pObject, pNames[0])) {
                bWholeTree = TRUE;
            }
            else {
                bWholeTree = FALSE;
            }

            // set deleting tree flag so that only audits are generated (no actual security checks)
            pTHS->fDeletingTree = TRUE;
            __try {
                memset(&SingleRemoveArg, 0, sizeof(REMOVEARG));
                SingleRemoveArg.CommArg = pRemoveArg->CommArg;
                SingleRemoveArg.fDontDelCriticalObj = TRUE;
                i = iLastName;
                while(!pTHS->errCode) {
                    i--;
                    // OK, loop through the objects, calling DirRemove on them
                    SingleRemoveArg.pObject = pNames[i];
                    DirRemoveEntry(&SingleRemoveArg, &pSingleRemoveRes );

                    THFreeEx(pTHS, pNames[i]);
                    THFreeEx(pTHS, pSingleRemoveRes);
                    THFreeEx(pTHS, SingleRemoveArg.pResObj);
                    pSingleRemoveRes = NULL;

                    if (fWrapped) {
                        if (i == iLastName) {
                            // ok, last entry was deleted, done.
                            break;
                        }
                        else if (i == 0) {
                            // need to wrap around
                            i = cNamesMax;
                        }
                    }
                    else {
                        // not wrapped
                        if (i == 0) {
                            // last entry (first in the array) was deleted, done.
                            break;
                        }
                    }
                }
            }
            __finally {
                pTHS->fDeletingTree = FALSE;
            }
        }
    }
    __finally {
        if(fLockedDN) {
            DBUnlockStickyDN (pRemoveArg->pResObj->pObj);
        }
    }

    if(!pTHS->errCode && !bWholeTree) {
        // We finished off the deletions we knew about, but we didn't delete the
        // root of the tree.
        SetSvcErrorEx(SV_PROBLEM_ADMIN_LIMIT_EXCEEDED,
                      DIRERR_TREE_DELETE_NOT_FINISHED,
                      pTHS->errCode);
    }

    return pTHS->errCode;
}

/*++ DirProtectEntry
 *
 * This routine, callable only by in-process clients, registers an object as
 * being undeletable on this DSA.  The registration lasts only for the current
 * boot cycle (i.e., it must be renewed each time the DSA starts), and is
 * effective only on this DSA.  That is, these objects can still be deleted
 * on other DSAs in the enterprise, but when that deletion replicates to this
 * server it will be rejected and the object re-animated.
 *
 * Note that the ancestors of the protected object are also protected. The ancestors
 * are automatically recalculated if the protected object is moved.
 *
 * INPUT:
 *   pObj - name of object to be protected from deletion
 * RETURN VALUE:
 *   0 on success, error in pTHS->errCode if the object could not be found
 */
ULONG
DirProtectEntry(DSNAME *pObj)
{
    THSTATE *pTHS;
    COMMARG CommArg;
    COMMRES CommRes;
    RESOBJ  *pResObj;
    ULONG   *pDNTs, *pOld;
    unsigned i;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    ULONG UnDelAncNum, *pUnDelAncDNTs, *pOldUnDelAncDNTs = NULL;

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));

    __try {
        __try {
            if (eServiceShutdown) {
                ErrorOnShutdown();
                __leave;
            }

            SYNC_TRANS_READ();

            InitCommarg(&CommArg);
            // We can't protect what we can't write, so no copies allowed
            CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               0,
                               pObj,
                               &CommArg,
                               &CommRes,
                               &pResObj)) {
                // Got the object, so add it
                pOld = NULL;
                EnterCriticalSection(&gAnchor.CSUpdate);
                __try {
                    pDNTs = malloc((gAnchor.UnDeletableNum + 1) * sizeof(ULONG));
                    if (!pDNTs) {
                        SetSysError(ENOMEM, ERROR_NOT_ENOUGH_MEMORY);
                        __leave;
                    }
                    for (i=0; i< gAnchor.UnDeletableNum; i++) {
                        if (gAnchor.pUnDeletableDNTs[i] == pResObj->DNT) {
                            // Already present
                            pOld = pDNTs;
                            __leave;
                        }
                        else {
                            pDNTs[i] = gAnchor.pUnDeletableDNTs[i];
                        }
                    }
                    pDNTs[gAnchor.UnDeletableNum] = pResObj->DNT;

                    // Update anchor atomically
                    pOld = gAnchor.pUnDeletableDNTs;
                    gAnchor.pUnDeletableDNTs = pDNTs;
                    gAnchor.UnDeletableNum++;

                    // Update undeletable ancestors
                    if (ERROR_SUCCESS ==
                        MakeProtectedAncList( gAnchor.pUnDeletableDNTs,
                                              gAnchor.UnDeletableNum,
                                              &pUnDelAncDNTs,
                                              &UnDelAncNum )) {

                        pOldUnDelAncDNTs = gAnchor.pUnDelAncDNTs;

                        // Order updates against other readers
                        if (gAnchor.UnDelAncNum <= UnDelAncNum) {
                            gAnchor.pUnDelAncDNTs = pUnDelAncDNTs;
                            gAnchor.UnDelAncNum = UnDelAncNum;
                        }
                        else {
                            gAnchor.UnDelAncNum = UnDelAncNum;
                            gAnchor.pUnDelAncDNTs = pUnDelAncDNTs;
                        }
                        pUnDelAncDNTs = NULL;
                    }
                }
                __finally {
                    LeaveCriticalSection(&gAnchor.CSUpdate);
                }
                if (pOld) {
                    DELAYED_FREE(pOld);
                }
                if (pOldUnDelAncDNTs) {
                    DELAYED_FREE(pOldUnDelAncDNTs);
                }
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    return pTHS->errCode;
}

DWORD
PossiblyMoveDeletedObject (
        THSTATE *pTHS,
        REMOVEARG *pRemoveArg
        )
/*++
  Description:
      Check to see if any of the exceptions to moving are found.  If not,
      move a deleted object to the deleted object container for the NC it's in.
      Note that if no deleted container is found, this is a no-op.  Further, the
      dblayer routine we call here DOES NOT QUEUE an SD propagation.  This is OK
      since we've already verified that this object has no children, and we've
      already written the default SD.  The dblayer routine fixes the ancestry,
      though.

    NOTE: in the case where we decide not to move the object, or no deleted
    objects container is found, we simply return 0 and do nothing.  We are just
    not moving the object and not returning an error.  We only return an error
    in the case where we decide to move the object, but the move fails.

--*/
{
    NAMING_CONTEXT_LIST *pNCL;
    DWORD dwDeletedContainerDNT;
    ULONG ulSysFlags;
    DWORD err;

    // First, check for the reasons we don't move based on the thread state.
    if(
       // Don't move objects if we're just replicating this deletion.  Only
       // originating deletions move objects
       pTHS->fDRA
       ) {
        return 0;
    }

    // Now, the reasons that we can check in the remove arg.
    if(
        // Don't move objects we're not renaming
          pRemoveArg->fPreserveRDN
        // Don't move NC heads.
       || (IT_NC_HEAD & pRemoveArg->pResObj->InstanceType)) {
        return 0;
    }


    // Finally, check the system flags.
    err = DBGetSingleValue(pTHS->pDB,
                           ATT_SYSTEM_FLAGS,
                           &ulSysFlags,
                           sizeof(ulSysFlags),
                           NULL);
    switch(err) {
    case 0:
        if (ulSysFlags & FLAG_DISALLOW_MOVE_ON_DELETE) {
            // Don't move this one.
            return 0;
        }
        break;

    case DB_ERR_NO_VALUE:
        // No system flags.  Allow the move.
        break;

    default:
        // Something wrong in getting the system flags.  Don't allow the move.
        return 0;
    }

    // OK, we think we can move this object.  See if we can find a destination
    // for the move. Find the deleted objects container for the NC this object
    // is in

    // We shouldn't be deleting things that move during cross domain move.
    // Assert this.
    Assert(!pTHS->fCrossDomainMove );

    pNCL = FindNCLFromNCDNT(pTHS->pDB->NCDNT, TRUE);
    if(pNCL) {
        dwDeletedContainerDNT = pNCL->DelContDNT;
    }
    else {
        dwDeletedContainerDNT = INVALIDDNT;
    }

    if(dwDeletedContainerDNT == INVALIDDNT) {
        // Couldn't find a deleted objects container.  Oh, well, we just don't
        // move this object.  No big deal.
        return 0;
    }

    if(err = DBResetParentByDNT(pTHS->pDB, dwDeletedContainerDNT, FALSE)) {
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             DIRERR_ILLEGAL_MOD_OPERATION,
                             err);
    }
    return 0;
}


/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_LinkVals(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount
    )
{
    DBPOS           *pDB;
    ULONG           ulCurrentTag  = 0; // initial key values or state information
    ULONG           ulCurrentValueTag  = 0; // initial key values or state information
    DSTIME          tCurrentTime = 0; // for  DBGetNextDelRecord
    ULONG           err;
    ULONG           dwException, ulErrorCode, dsid;
    PVOID           dwEA;

    DBOpen(&pDB);
    __try {

        //
        // Garbage collect absent values that have expired
        //

        tCurrentTime = 0;
        ulCurrentTag = 0;
        ulCurrentValueTag = 0;

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        while ((!DBGetNextDelLinkVal(pDB,
                                     AgeOutDate,
                                     &tCurrentTime,
                                     &ulCurrentTag,
                                     &ulCurrentValueTag )) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE))
        {
            err = 1;               // in case of exception

            if (err = DBPhysDelLinkVal(pDB, ulCurrentTag, ulCurrentValueTag)) {
                DPRINT( 1, "Failed physically removing value.\n" );

                dsid = 0;
            }

            // TODO: Flush the transaction every 100 values instead of each time
            __try {
                DBTransOut(pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = ulErrorCode;
                Assert(err);
            }

            if (0 == err) {
                DPRINT(4,"Physically removed value successfully\n");

                // If we have succesfully removed an object, update
                // the success count

                (*pulSuccessCount)++;

                LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_GC_REMOVED_OBJECT_VALUE,
                         szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentValueTag ) ),
                         szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentTag ) ),
                         NULL);
            }
            else {
                (*pulFailureCount)++;

                LogEvent8(DS_EVENT_CAT_GARBAGE_COLLECTION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_GC_FAILED_TO_REMOVE_OBJECT_VALUE,
                          szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentValueTag ) ),
                          szInsertSz( DBGetExtDnFromDnt( pDB, ulCurrentTag ) ),
                          szInsertInt(err),
                          szInsertUL(dsid),
                          NULL, NULL, NULL, NULL);
            }
            DBTransIn(pDB);
        }
    }
    __finally
    {
        DBClose( pDB, TRUE);
    }
}

/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_EntryTTL(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount,
    IN OUT ULONG    *pulNextSecs
    )
{
    DSNAME          *pDelObj = NULL;
    DBPOS           *pDB = NULL;
    ULONG           err;
    BOOL            fObject;
    ULONG           dwException, ulErrorCode, dsid = 0;
    PVOID           dwEA;
    ATTCACHE        *pAC;
    ULONG           ulNoDelDnt = INVALIDDNT;
    DSTIME          tNoDelTime;
    ULONG           Dnt;
    DSTIME          tCurrentTime = 0;

    DBOpen(&pDB);
    __try {
        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        pAC = SCGetAttById(pDB->pTHS, ATT_MS_DS_ENTRY_TIME_TO_DIE);
        if (!pAC) {
            DPRINT1(0, "SCGetAttById(msDS-Entry-Time-To-Die(= %08x); not found\n",
                    ATT_MS_DS_ENTRY_TIME_TO_DIE);
            __leave;
        }

        // Loop over all DNs of records to be removed; allow for service
        // shutdown and for undeletable records (ulNoDelDnt). Undeletable
        // records are skipped.

        while ((!DBGetNextEntryTTLRecord(pDB,
                                         AgeOutDate,
                                         pAC,
                                         ulNoDelDnt,
                                         &pDelObj,
                                         &tCurrentTime,
                                         &fObject,
                                         pulNextSecs)) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE)) {

            // Dnt of record (in case pDB->DNT is altered by subsequent calls)
            Dnt = pDB->DNT;

            // Assume no problems
            err = 0;

            // Critical object, skip it
            if (fObject && NoDelCriticalObjects(pDelObj, pDB->DNT)) {
                DPRINT( 1, "Failed removing critical object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Can't lock, skip it. Unlocked by DBTransOut
            else if (fObject && DBLockDN(pDB, DB_LOCK_DN_WHOLE_TREE, pDelObj)) {
                DPRINT( 1, "Failed locking object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Can't delete; skip it
            // Keep in mind that a successful return doesn't mean it was
            // actually deleted. If it has children, its time is simply
            // adjusted to its child's time + 1 so that it can be
            // successfully deleted later. However, DBPhysDel returns TRUE
            // in this case so that the transaction will be committed.
            else if (DBPhysDel(pDB, FALSE, pAC)) {
                DPRINT( 1, "Failed physically removing object.\n" );
                ulNoDelDnt = Dnt;
                tNoDelTime = tCurrentTime;
                err = 1;
            }
            // Are we skipping a previously undeletable record?
            else if (ulNoDelDnt != INVALIDDNT) {
                // If so, stop if we have moved past its expiration time
                if (tNoDelTime != tCurrentTime) {
                    ulNoDelDnt = INVALIDDNT;
                }
            }

            __try {
                DBTransOut(pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = (ulErrorCode) ? ulErrorCode : 1;
            }

            if (0 == err) {
                DPRINT(4,"Physically removed object successfully\n");
                if (fObject) {
                    (*pulSuccessCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_GC_REMOVED_OBJECT,
                             szInsertDN( pDelObj ),
                             NULL,
                             NULL);
                }
            }
            else {
                if (fObject) {
                    (*pulFailureCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_BASIC,
                             DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                             szInsertDN( pDelObj ),
                             szInsertInt(err),
                             szInsertUL(dsid));
                }
            }
            THFreeEx(pDB->pTHS, pDelObj);
            DBTransIn(pDB);
        }
    } __finally {
        DBClose( pDB, TRUE);
    }
}

/*-------------------------------------------------------------------------*/
VOID
Garb_Collect_DelTime(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount
    )
{
    DSNAME              *pDelObj = NULL;
    THSTATE             *pTHS = pTHStls;
    ULONG               ulCurrentTag  = 0; // initial key values or state information
    DSTIME              tCurrentTime = 0; // for  DBGetNextDelRecord
    ULONG               err;
    BOOL                fObject;
    ULONG               dwException, ulErrorCode, dsid;
    PVOID               dwEA;

    // The reason we use pTHS->pDB here is that some of our called routines expect it
    Assert( !pTHS->pDB );
    DBOpen(&pTHS->pDB);
    __try {

        // Loop over all DNs of records to be removed; allow for service
        // shutdown

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        while ((!DBGetNextDelRecord(pTHS->pDB,
                                    AgeOutDate,
                                    &pDelObj,
                                    &tCurrentTime,
                                    &ulCurrentTag,
                                    &fObject)) &&
               (!eServiceShutdown) &&
               (*pulSuccessCount + *pulFailureCount < MAX_DUMPSTER_SIZE)) {

            err = 1;               // in case of exception
            dsid = 0;

            err = DBPhysDel(pTHS->pDB, FALSE, NULL);
            if (err == ERROR_DS_CHILDREN_EXIST) {

                // Move children to lost and found prior to object removal
                // DBMakeCurrent is needed because pDB->NCDNT not set
                if ( (err = DBMakeCurrent(pTHS->pDB)) ||
                     (err = PrePhantomizeChildCleanup(pTHS, TRUE /*fChildrenAllowed*/)) )
                {
                    DPRINT(0,"Garbage Collection child cleanup failed\n" );
                    DbgPrintErrorInfo();
                    THClearErrors();
                }
            } else if (err) {
                DPRINT( 1, "Failed physically removing object.\n" );
            }

            __try {
                DBTransOut(pTHS->pDB, (err == 0), TRUE);
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {
                err = ulErrorCode;
                Assert(err);
            }

            if (0 == err) {
                DPRINT(4,"Physically removed object successfully\n");

                // If we have succesfully removed an object, update
                // the success count

                if (fObject) {
                    (*pulSuccessCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_GC_REMOVED_OBJECT,
                             szInsertDN( pDelObj ),
                             NULL,
                             NULL);
                }
            }
            else {
                if (fObject) {
                    (*pulFailureCount)++;

                    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                             DS_EVENT_SEV_BASIC,
                             DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                             szInsertDN( pDelObj ),
                             szInsertInt(err),
                             szInsertUL(dsid));
                }
            }
            THFreeEx(pTHS, pDelObj);
            DBTransIn(pTHS->pDB);
        }
    }
    __finally
    {
        DBClose( pTHS->pDB, TRUE );
    }
}

/*-------------------------------------------------------------------------*/
USHORT
Garb_Collect(
             DSTIME    AgeOutDate )
{
    ULONG   ulSuccessCount = 0;
    ULONG   ulFailureCount = 0;
    ULONG   ulNextSecs = 0;
    DBPOS   *pDB;
    ULONG   dwException, ulErrorCode, dsid;
    PVOID   dwEA;

    DPRINT( 1, "Garbage Collector entered\n" );

    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_GC_STARTED,
             NULL,
             NULL,
             NULL);

    __try {
        // collect deleted objects
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_DelTime(AgeOutDate,
                                 &ulSuccessCount,
                                 &ulFailureCount);
        }

        // collect link vals
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_LinkVals(AgeOutDate,
                                 &ulSuccessCount,
                                 &ulFailureCount);
        }

        // collect expired dynamic objects (EntryTTL)
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            Garb_Collect_EntryTTL(DBTime(),
                                  &ulSuccessCount,
                                  &ulFailureCount,
                                  &ulNextSecs);
        }

        // Defrag
        if (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) {
            DBOpen(&pDB);
            __try {
                if (!eServiceShutdown) {
                    DBDefrag(pDB);
                }
            } __finally {
                DBClose( pDB, TRUE);
            }
        }
    } __except(GetExceptionData(GetExceptionInformation(),
                                &dwException,
                                &dwEA,
                                &ulErrorCode,
                                &dsid)) {
        DPRINT3(0, "Garb_Collect() EXCEPTION: %08x (%d) ulErrorCode; %08x dsid\n",
               ulErrorCode, ulErrorCode, dsid);
    }

    LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_GC_COMPLETED,
             szInsertUL(ulSuccessCount),
             szInsertUL(ulFailureCount),
             NULL);

    DPRINT( 1, "Garbage Collector returning.\n");
    return (ulSuccessCount + ulFailureCount < MAX_DUMPSTER_SIZE) ? 0 : 1;
}
