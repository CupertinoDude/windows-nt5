//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdread.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirRead API.

    DSA_DirRead() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <anchor.h>
#include <ntdsctr.h>

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"         // Defines for selected classes and atts
#include "debug.h"          // standard debugging header
#define DEBSUB     "MDREAD:"            // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDREAD

// Internal functions

int LocalRead(THSTATE *pTHS, READARG *pReadArg, READRES *pReadRes);

VOID
RemoveDuplicatesFromAttCache(
    IN ATTCACHE **AttCache,
    IN DWORD nAtts
    );



ULONG
DirRead(
        READARG*    pReadArg,
    READRES **  ppReadRes
        )
/*++
  pReadArg is the read argument
  ppOutBuf is the Result or Error output buffer addr.
--*/
{
    THSTATE*     pTHS;
    READRES *pReadRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirRead entered\n");

    /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
    is required on every API transaction.  First the state DS is initialized
    and then either a read or a write sync point is established.
    */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppReadRes = pReadRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppReadRes = pReadRes = THAllocEx(pTHS, sizeof(READRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if ((eServiceShutdown >= eSecuringDatabase) ||
                ((eServiceShutdown >= eRemovingClients) && !pTHS->fDSA)) {
                ErrorOnShutdown();
                __leave;
            }
        }
    SYNC_TRANS_READ();   /*Identify a reader trans*/
    __try {
        /* Perform name resolution to locate object.  If it fails,
         * just return an error, which may be a referral.
         */

        if (0 == DoNameRes(pTHS,
                               NAME_RES_QUERY_ONLY,
                   pReadArg->pObject,
                   &pReadArg->CommArg,
                   &pReadRes->CommRes,
                               &pReadArg->pResObj)){

        /* Local read operation */

        LocalRead(pTHS, pReadArg, pReadRes);
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN (pTHS->errCode);
    }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                  &dwEA, &ulErrorCode, &dsid)) {
    HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pReadRes) {
    pReadRes->CommRes.errCode = pTHS->errCode;
    pReadRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }
    return pTHS->errCode;
}  // DSA_DirRead


/*++ CmpACByAttType
 *
 * A simple function to be used with qsort and bsearch.  Compares ATTCACHE's
 * base on attrtyp.
 *
 ++*/
int __cdecl
CmpACByAttType(const void * keyval, const void * datum)
{
    ATTCACHE **ppACkey = (ATTCACHE **)keyval;
    ATTCACHE **ppACdatum = (ATTCACHE **)datum;

    return ((*ppACkey)->id - (*ppACdatum)->id);
}

/*++ CmpIndexedACByAttType
 *
 * A simple helper function for use in qsorting arrays of Indexed pACs by their
 * attrtyp's.  We do this so that we can remove duplicates from a user supplied
 * list of attributes without changing the ordering of the returned att's.
 */
int __cdecl
CmpIndexedACByAttType(const void * keyval, const void * datum)
{
    PINDEXED_AC pACkey = (PINDEXED_AC)keyval;
    PINDEXED_AC pACdatum = (PINDEXED_AC)datum;

    return (pACkey->AttCache->id - pACdatum->AttCache->id);
}


INT
GetAttrFromSel(
    IN THSTATE *pTHS,
    IN ENTINFSEL *Sel,
    IN ENTINF *Ent,
    IN ATTCACHE **AttCache,
    IN PDWORD pnAtts,
    IN BOOL fIgnoreError
    )
/*++

Function Description:
       Convert ENTINFSEL entries into ATTCACHE entries.

Arguments:
       Sel - describes what attributes to read.
       Ent - returns the read attributes.
       AttCache - where to put the converted entries
       fIgnoreError - ignore conversion error.  used for the ALL with List
        case.

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{

    DWORD i;
    DWORD nNext = 0;

    for(i=0 ; i < Sel->AttrTypBlock.attrCount ; i++) {

        if(Sel->AttrTypBlock.pAttr[i].attrTyp == INVALID_ATT) {

            continue;

        } else if (!(AttCache[nNext] =
                     SCGetAttById(pTHS,
                                  Sel->AttrTypBlock.pAttr[i].attrTyp))) {

            if ( !fIgnoreError ) {
                return SetAttError(Ent->pName,
                    Sel->AttrTypBlock.pAttr[i].attrTyp,
                    PR_PROBLEM_UNDEFINED_ATT_TYPE,
                    NULL,
                    DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }

            continue;

        } else {

            nNext++;
        }
    }

    *pnAtts = nNext;
    return 0;
} // GetAttrFromSel


INT
AppendAttrFromSel(
    IN THSTATE *pTHS,
    IN ENTINFSEL *Sel,
    IN ENTINF *Ent,
    IN ATTCACHE **AttCache,
    IN DWORD cAttCache,
    IN BOOL fIgnoreError,
    IN BOOL fIgnoreDups
    )
/*++

Function Description:
       Convert ENTINFSEL entries into ATTCACHE entries and append to an array
       of attcache's if there will be no duplicates after.

Arguments:
       Sel - describes what attributes to read.
       Ent - returns the read attributes.
       AttCache - where to put the converted entries
       fIgnoreError - ignore conversion error.  used for the ALL with List
        case.
       pCC - the CLASSCACHE these entries belong to

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{

    unsigned i,k;
    unsigned j = cAttCache;
    unsigned cNewAtts, ListLength;
    BOOL     fFound;
    ATTCACHE *pAC;


    for(i=0 ; i < Sel->AttrTypBlock.attrCount ; i++) {

        if(Sel->AttrTypBlock.pAttr[i].attrTyp == INVALID_ATT) {

            continue;

        } else if (!(pAC = SCGetAttById(pTHS,
                                  Sel->AttrTypBlock.pAttr[i].attrTyp))) {

            if ( !fIgnoreError ) {
                return SetAttError(Ent->pName,
                    Sel->AttrTypBlock.pAttr[i].attrTyp,
                    PR_PROBLEM_UNDEFINED_ATT_TYPE,
                    NULL,
                    DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }

            continue;

        } else if (!fIgnoreDups) {
            // append attribute if it's not already in the list
            if (j < 6) {
                // not worth doing bsearch
                for (k = 0; k < j; k++) {
                    if (pAC->id == AttCache[k]->id) {
                        fFound = TRUE;
                    }
                }
                if (!fFound) {
                    AttCache[j++] = pAC;
                } else {
                    fFound = FALSE;
                }
            } else {
                if (!bsearch(pAC, AttCache, cAttCache, sizeof(AttCache[0]), CmpACByAttType)) {
                    AttCache[j++] = pAC;
                }
            }
        } else {
            AttCache[j++] = pAC;
        }
    }

    if (j > (cAttCache + 1) && !fIgnoreDups) {
        //
        // We know that none of the atts that came in the EntInfSel are dups of atts
        // already in the attcache list, now make certain there were no dupes in the
        // EntInfSel.  Just sort the newly added atts and remove the duplicates.
        //
        cNewAtts = j - cAttCache;
        if (!IsACListSorted(&AttCache[cAttCache], cNewAtts)) {
            qsort(&AttCache[cAttCache], cNewAtts, sizeof(AttCache[0]), CmpACByAttType);
        }

        RemoveDuplicatesFromAttCache(&AttCache[cAttCache], cNewAtts);

    }

    return 0;
} // InsertAttrFromSel


VOID
RemoveDuplicatesFromAttCache(
    IN ATTCACHE **AttCache,
    IN DWORD nAtts
    )
/*++

    Function Description:
       Remove duplicate attributes

    Arguments:
       AttCache - Array of ATTCACHE pointers
       nAtts - number of items in array

    Return Value.
       None

--*/
{
    DWORD i, j;
    BOOL  fGaps = FALSE;

    //
    // Do a linear search and NULL out all duplicates
    //

    for ( i=0; i < nAtts - 1; i++ ) {
        if (AttCache[i] == AttCache[i+1]) {
            AttCache[i] = NULL;
            fGaps = TRUE;
        }
    }

    //
    // Now remove any gaps left behind.
    //
    if (fGaps) {
        for (i=0;i<nAtts && AttCache[i]; i++) {
            ; // Still looking for first NULL
        }
        j = i + 1;
        while (j<nAtts) {
            if (NULL != AttCache[j]) {
                AttCache[i++] = AttCache[j];
            }
            j++;
        }
    }
} // RemoveDuplicatesFromAttCache


INT
GetEntInf(
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pSelRange,
    IN ENTINF *pEnt,
    IN RANGEINF *pRange,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN OUT PCACHED_AC CachedAC OPTIONAL,
    IN OPTIONAL RESOBJ *pResObj
    )
/*++

Function Description:
       Retrieve attribute data from the positioned object.  First some object
       header information is retrieved (DN and master or copy flag), then either
       some or all of the attributes are visited and data is returned.

Arguments:
       pDB - Database position to be used. Note that pDB != pDB->pTHS->pDB.
             We may be passing in a temporary pDB so that the primary pDB
             is not disturbed.
       pSel - describes what attributes to read.
       pEnt - returns the read attributes.
       CachedAC - Enables the caller to request and send a preformatted/sorted
            ATTCACHE array.
            if NULL, caller does not wish the array to be returned
            if not NULL and CacheAC->AC is NULL, caller is requesting that the array
                be returned
            if not NULL and CacheAC->AC is not NULL, caller is supplying the array
       pResObj - if present, used instead of fetching the object name

       pSecurity - the security descriptor of the object we are positioned on
                   this will be used to check read security of the object.
                   NOTE: it is required that this security descriptor is
                   the one of the object that we are positioned on.
                
       Flags - One of the following:
               GETENTINF_FLAG_CAN_REORDER    - Don't need to preserve the order
                                               of the attributes specified by 
                                               the caller.
               GETENTINF_FLAG_DONT_OPTIMIZE  - ?
               GETENTINF_GC_ATTRS_ONLY       - Return only GC attributes.
               GETENTINF_IGNORE_DUPS         - Don't waste time removing duplicates
                                               attributes.
               GETENTINF_NO_SECURITY         - Don't apply security.

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{
    THSTATE             *pTHS = pDB->pTHS;
    ATTRBLOCK           AttrBlock;
    ULONG               i, k, cInAtts, attrCount, cOut;
    ATTCACHE            **rgpAC = NULL, **fullACList = NULL, **attList = NULL;
    ATTCACHE            **rgpACTemp = NULL;
    DWORD               fFlags, fNameFlags;
    DWORD               iType;
    DWORD               *piType=&iType;
    ATTR                *pAttr;
    CLASSCACHE          *pCC = NULL;
    ATTCACHE            *pObjclassAC = NULL;
    ATTRTYP             *pObjClasses = NULL;
    CLASSCACHE          **ppObjClassesCC = NULL, *pTempCC;
    DWORD               cObjClasses, cObjClasses_alloced;
    BOOL                fDoSecCheck;
    DWORD               nSelAttrs = 0;
    BOOL                fGetAll = FALSE;
    BOOL                fGetAllWithList = FALSE;
    BOOL                fMaintainOrder = FALSE;
    BOOL                fGcAttsOnly = FALSE;
    BOOL                fHaveAuxClass = FALSE;
    BOOL                fIgnoreDups;
    PDWORD              pOrderIndex = NULL;
    DWORD               classid = INVALID_ATT;
    DWORD               err;
    DSTIME              TimeToDie;

    if(pTHS->fDSA ||
       pTHS->fDRA ||
       Flags & GETENTINF_NO_SECURITY) {
        fDoSecCheck = FALSE;
    }
    else {
        fDoSecCheck = TRUE;
    }

    //
    // See if we should ignore nonGC attributes
    //

    fGcAttsOnly = (BOOL)(Flags & GETENTINF_GC_ATTRS_ONLY);
    fIgnoreDups = (BOOL)(Flags & GETENTINF_IGNORE_DUPS);

    // First, decide what form of values we want.
    fNameFlags = DBGETMULTIPLEATTS_fEXTERNAL;

    if( pSel == NULL ) {
        fFlags = DBGETMULTIPLEATTS_fEXTERNAL;
        fGetAll = TRUE;

    } else {
        switch(pSel->infoTypes) {
          case EN_INFOTYPES_TYPES_MAPI:
            // Return no values, just type information, and return the obj name
            // in MAPI format
            fNameFlags |= DBGETMULTIPLEATTS_fMAPINAMES;
            fFlags = 0;
            break;

          case EN_INFOTYPES_TYPES_ONLY:
            // Return no values, just type information
            fFlags = 0;
            break;

          case EN_INFOTYPES_SHORTNAMES:
            // Return values in internal format.
            fFlags = DBGETMULTIPLEATTS_fSHORTNAMES | DBGETMULTIPLEATTS_fEXTERNAL;
            fNameFlags |= DBGETMULTIPLEATTS_fSHORTNAMES;
            break;

          case EN_INFOTYPES_MAPINAMES:
            // Return values in internal format.
            fFlags = DBGETMULTIPLEATTS_fMAPINAMES | DBGETMULTIPLEATTS_fEXTERNAL;
            fNameFlags |= DBGETMULTIPLEATTS_fMAPINAMES;
            break;

          default:
            // Return values in normal external format.
            fFlags = DBGETMULTIPLEATTS_fEXTERNAL;
        }

        // If we are the DRA and we are asking for certain selections, we need to
        // tell the DBLayer that we dont want to get all ATTS.  The DBLayer knows
        // which ones to trim.

        switch ( pSel->attSel ) {

        case EN_ATTSET_ALL:
            fGetAll = TRUE;
            break;
        case EN_ATTSET_ALL_WITH_LIST:
            fGetAll = TRUE;
            fGetAllWithList = TRUE;
            nSelAttrs = pSel->AttrTypBlock.attrCount;
            break;

        case EN_ATTSET_ALL_DRA:     // fall through
        case EN_ATTSET_ALL_DRA_EXT:     // fall through
            fGetAll = TRUE;

        case EN_ATTSET_LIST_DRA:
        case EN_ATTSET_LIST_DRA_EXT:
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION;
            break;

        case EN_ATTSET_ALL_DRA_PUBLIC:     // fall through
            fGetAll = TRUE;

        case EN_ATTSET_LIST_DRA_PUBLIC:
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION;
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION_PUBLIC;
            break;

        case EN_ATTSET_LIST:
            // intentionally do nothing
            break;

        default:
            Assert (!"Passed wrong value for pSel->attSel");
            break;
        }
    }

    if (NULL == pResObj) {
        // Get and set the DN
        ATTCACHE *pAC = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);
        if (i=DBGetMultipleAtts(pDB,
                                1,
                                &pAC,
                                NULL,
                                NULL,
                                &cOut,
                                &pAttr,
                                fNameFlags,
                                0)) {
            DPRINT(2,"Problem retrieving DN attribute\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_DN,
                     szInsertSz(""),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_DN);
        }

        pEnt->pName = (PDSNAME)pAttr[0].AttrVal.pAVal[0].pVal;

        if (pAttr) {
            THFreeEx (pTHS, pAttr->AttrVal.pAVal);
            THFreeEx (pTHS, pAttr);
            pAttr = NULL;
        }

        // instance type
        if(DBGetSingleValue(pDB,
                            ATT_INSTANCE_TYPE,
                            &iType,
                            sizeof(iType),
                            NULL)) {
            DPRINT(2, "Can't retrieve instance type\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_INSTANCE,
                     szInsertDN(pEnt->pName),
                     NULL,
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_CANT_RETRIEVE_INSTANCE);
        }
    }
    else {
        pEnt->pName = THAllocEx(pTHS, pResObj->pObj->structLen);
        memcpy(pEnt->pName,
               pResObj->pObj,
               pResObj->pObj->structLen);
        iType = pResObj->InstanceType;
    }

    pEnt->ulFlags = 0;
    if(iType & IT_WRITE) {
        pEnt->ulFlags |= ENTINF_FROM_MASTER;
    }
    // For performance, this feature only available to the replicator.
    // You can remove the fDRA check when you need this flag.
    if ( (pTHS->fDRA) &&
         (DBGetSingleValue(pDB,
                           ATT_MS_DS_ENTRY_TIME_TO_DIE,
                           &TimeToDie,
                           sizeof(TimeToDie),
                           NULL) == 0) ) {
        pEnt->ulFlags |= ENTINF_DYNAMIC_OBJECT;
    }

    if (fGetAll) { // also fGetAllWithList

        // we have to read all the attributes available on the object
        // this might include attributes contributed by the possible
        // auxClasses attached to the object
        // we will propably use these attributes later to do a security check
        // if fDoSecCheck is set

        // get the needed information for the objectClass on this object
        if (! (pObjclassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS)) ) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get auxClass .
        }

        cObjClasses_alloced = 0;

        if (ReadClassInfoAttribute (pDB,
                                    pObjclassAC,
                                    &pObjClasses,
                                    &cObjClasses_alloced,
                                    &cObjClasses,
                                    &ppObjClassesCC) ) {
            return pTHS->errCode;
        }

        if (!cObjClasses) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get class data.
        }

        classid = pObjClasses[0];
        pCC = ppObjClassesCC[0];

        // we had an auxClass. leave only the most specific classes
        if (cObjClasses > pCC->SubClassCount) {

            fHaveAuxClass = TRUE;

            for (i=pCC->SubClassCount; i<cObjClasses-1; i++) {

                if (ppObjClassesCC[i]==NULL)
                    continue;

                for (k=pCC->SubClassCount; k<cObjClasses-1; k++) {
                    if ((i==k) || (ppObjClassesCC[k]==NULL)) {
                        continue;
                    }

                    if (pTempCC = FindMoreSpecificClass(ppObjClassesCC[i], ppObjClassesCC[k])) {
                        if (pTempCC == ppObjClassesCC[i]) {
                            ppObjClassesCC[k] = NULL;
                        }
                        else {
                            ppObjClassesCC[i] = NULL;
                            break;
                        }
                    }
                }
            }

            // we might have gaps in the ppAuxClassesCC, but we don't care

            // we are not interested in preserving the cache
            // since we are using auxClasses
            CachedAC = NULL;
        }
    }
    else if ( fDoSecCheck ) {

        // They are applying a security check (without specifying all, all+list) 
        // We don't have to generate the full list of attributes contributed 
        // by auxClasses and the list of attributes from the structural class
        // is enough.  So we need to get the class of  the object we are on.

        if(DBGetSingleValue(pDB,
                            ATT_OBJECT_CLASS,
                            &classid, sizeof(classid),
                            NULL) ||
           !(pCC = SCGetClassById(pTHS, classid))) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get class data.
        }
    }

    // Do this now, since we might bail out in the next if statement.
    pEnt->AttrBlock.attrCount = 0;

    //
    // If the caller passed us an attribute array, use it. Copy the saved copy to
    // the scratch copy.  The scratch copy may be changed by CheckReadSecurity()
    //

    if ( (CachedAC != NULL) && (CachedAC->AC != NULL) ) {

        if ( CachedAC->classId == classid ) {

            cInAtts = CachedAC->nAtts;
            rgpAC = (ATTCACHE**)((PCHAR)CachedAC->AC + cInAtts * sizeof(ATTCACHE*));

            CopyMemory(rgpAC, CachedAC->AC, cInAtts * sizeof(ATTCACHE*));

            pOrderIndex = CachedAC->pOrderIndex;
            goto have_array;
        } else {

            THFreeEx(pTHS,CachedAC->AC);
            CachedAC->AC = NULL;
        }
    }

    // Set up the the pInCols based on the pSel
    // first determine if we need to retrieve all attributes or a selection

    if ( fGetAll ) {

        DWORD ourCount;
        DWORD sizeAlloc;
        DWORD auxCount = 0;

        // Client did not provide an entifsel with explicitly listed atts.
        // or provided a list in addition to specifying all

        // Retrieve all attributes

        if ( fDoSecCheck || fGetAllWithList ) {

            ULONG j=0;

            Assert(pCC != NULL);

            // We need to apply security, so instead of sending a null list
            // of attcache pointers to DBGetMultipleAtts, read the class of the
            // current object, get the classcache object describing it, then
            // build the attcache array for all possible attributes.

            if (fHaveAuxClass) {

                for (i=pCC->SubClassCount; i<cObjClasses-1; i++) {
                    if (ppObjClassesCC[i]) {
                        auxCount += ppObjClassesCC[i]->MayCount + ppObjClassesCC[i]->MustCount;
                        DPRINT2 (1, "AuxClasses[%d]: %s\n", i, ppObjClassesCC[i]->name);
                    }
                }
            }

            sizeAlloc = (pCC->MayCount + pCC->MustCount + nSelAttrs + auxCount) * sizeof(ATTCACHE *);

            if ( CachedAC != NULL ) {
                //
                // Allocate a scratch and a copy buffer.
                //

                sizeAlloc *= 2;
            }

            rgpAC = (ATTCACHE **) THAllocEx(pTHS,sizeAlloc);
            
            // Do we have an auxClass ?
            //

            if (!fHaveAuxClass) {

                attList = SCGetTypeOrderedList (pTHS, pCC);

                if (!attList) {
                    return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR);
                }

                // maximum count of attributes for this class
                ourCount = pCC->MayCount + pCC->MustCount;

                j = 0;

                for(i=0;i<ourCount;i++) {

                    // defunct attributes are not returned
                    if (!attList[i]) {
                        continue;
                    }

                    if(attList[i]->bIsOperational) {
                        // These attributes are not returned unless explicitly asked
                        // for.  In this branch of the code, we know that an
                        // explicit list was not supplied.
                        continue;
                    }

                    // Check:
                    // If request came in through GC port make sure
                    // this is in the GC partial attribute list.
                    // Since j is already incremented, the attcache of
                    // of interest is pointed to by j-1

                    else if ( (attList[i]->bIsConstructed ) ||
                         (fGcAttsOnly && !IS_GC_ATTRIBUTE(attList[i])) ) {
                        
                        // GCport and not GC attribute. 
                        // Should not be passed down

                        continue;
                    }

                    else {
                        rgpAC[j] = attList[i];
                        j++;
                    }
                }

                cInAtts = j;

                //
                // Did the caller piggy backed a list?
                //

                if (nSelAttrs != 0) {

                    DWORD ret;

                    Assert(nSelAttrs == pSel->AttrTypBlock.attrCount);

                    if ( (ret = AppendAttrFromSel(pTHS,
                                                  pSel,
                                                  pEnt,
                                                  rgpAC,
                                                  cInAtts,
                                                  TRUE,
                                                  fIgnoreDups)) != 0 ) {

                        THFreeEx(pTHS,rgpAC);
                        return ret;
                    }

                    // Count up the atts
                    for (j = 0; rgpAC[j] != NULL; j++);

                    cInAtts = j;
                }

                Assert(cInAtts <= (pCC->MayCount + pCC->MustCount + nSelAttrs));
            }
            else {
                //
                // Did the caller piggy backed a list?
                //

                if (nSelAttrs != 0) {
                    // Populate the ATTCACHE list from the Sel list
                    //
                    cInAtts = pSel->AttrTypBlock.attrCount;

                    if ( (err = GetAttrFromSel(pTHS, pSel, pEnt, rgpAC, &cInAtts, FALSE)) != 0 ) {

                        THFreeEx(pTHS,rgpAC);
                        return err;
                    }

                    if (!IsACListSorted(rgpAC, cInAtts)) {
                        qsort(rgpAC, cInAtts, sizeof(rgpAC[0]), CmpACByAttType);
                    }
                }
                else {
                    cInAtts = 0;
                }

                // start the loop with using the current class
                pTempCC = pCC;
                k = pCC->SubClassCount;    // loop counter for auxClasses

                rgpACTemp = THAllocEx(pTHS, sizeAlloc);

                while (pTempCC != NULL) {
                    j = cInAtts;

                    attList = SCGetTypeOrderedList (pTHS, pTempCC);

                    if (!attList) {
                        THFreeEx(pTHS,rgpAC);
                        return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR);
                    }

                    // maximum count of attributes for this class
                    ourCount = pTempCC->MayCount + pTempCC->MustCount;

                    for(i=0;i<ourCount;i++) {

                        // defunct attributes are not returned
                        if (!attList[i]) {
                            continue;
                        }

                        if(attList[i]->bIsOperational) {
                            // These attributes are not returned unless explicitly asked
                            // for.  In this branch of the code, we know that an
                            // explicit list was not supplied.
                            continue;
                        }

                        // Check:
                        // If request came in through GC port make sure
                        // this is in the GC partial attribute list.
                        // Since j is already incremented, the attcache of
                        // of interest is pointed to by j-1

                        else if ( (attList[i]->bIsConstructed ) ||
                             (fGcAttsOnly && !IS_GC_ATTRIBUTE(attList[i])) ) {

                            // GCport and not GC attribute. 
                            // Should not be passed down

                            continue;
                        }

                        else {
                            // if client has piggy backed a list, we are goint to insert them
                            // to this array later, otherwise we can finish up now.
                            rgpAC[j] = attList[i];
                            j++;
                        }
                    }

                    if (cInAtts == 0) {
                        cInAtts = j;
                    }
                    if (!fIgnoreDups && (0 != (j - cInAtts))) {
                        ATTCACHE **tmp;
                        MergeSortedACLists(pTHS,
                                           rgpAC,
                                           cInAtts,
                                           rgpAC + cInAtts,
                                           j - cInAtts,
                                           rgpACTemp,
                                           &cInAtts
                                           );
                        //
                        // swap the temp and the working copy of the AC list.
                        //
                        tmp = rgpAC; rgpAC = rgpACTemp; rgpACTemp = tmp;
                    }
                    
                    // find the next auxClass to use
                    if (k < cObjClasses-1) {
                        while (k<cObjClasses-1) {
                            if (pTempCC = ppObjClassesCC[k++]) {
                                break;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }


                if (!fIgnoreDups) {
                    RemoveDuplicatesFromAttCache(rgpAC, cInAtts);
                }
                THFreeEx(pTHS, rgpACTemp); rgpACTemp = NULL;
            }
        }
        else {
            // We are not applying any security, just send a null list of
            // attcache pointers.
            cInAtts = 0;
        }
    }
    else {
        // Client provided an entifsel with explicitly listed atts.

        // allocate ATTCACHE structures for all selected attributes  and
        // get schema cache entry for attribute

        DWORD ret;
        DWORD sizeAlloc = pSel->AttrTypBlock.attrCount * sizeof(ATTCACHE*);
        PVOID buffer;

        if ( CachedAC != NULL ) {
            //
            // Allocate for the saved and scratch
            //

            sizeAlloc *= 2;
        }

        rgpAC = (ATTCACHE**)THAllocEx(pTHS,sizeAlloc);
        
        cInAtts = pSel->AttrTypBlock.attrCount;

        //
        // Populate the ATTCACHE list from the Sel list
        //

        if ( (ret = GetAttrFromSel(pTHS, pSel, pEnt, rgpAC, &cInAtts, FALSE)) != 0 ) {
            THFreeEx(pTHS,rgpAC);
            return ret;
        }

        if(cInAtts == 0) {
            // We're not looking for anything, we might as well bail out.
            THFreeEx(pTHS,rgpAC);
            return 0;
        }
        //
        // Sort it
        //

        if ( cInAtts > 1 && !fIgnoreDups) {

            //
            // if CAN_REORDER flag is set, then forget about creating an index.
            //

            if (Flags & GETENTINF_FLAG_CAN_REORDER) {

                qsort(rgpAC, cInAtts, sizeof(rgpAC[0]), CmpACByAttType);
            } else if ( (Flags & GETENTINF_FLAG_DONT_OPTIMIZE) == 0) {

                PINDEXED_AC pIndexAC;

                //
                // The caller wants the index preserved, we need to allocate an
                // index array that will help us reorder the results back.
                //

                pIndexAC = (PINDEXED_AC)THAllocEx(pTHS,
                        cInAtts * (sizeof(DWORD) + sizeof(INDEXED_AC)));

                pOrderIndex =
                    (PDWORD)((PCHAR)pIndexAC + cInAtts * sizeof(INDEXED_AC));

                //
                // Copy the attcache array to a temp buffer for sorting. This
                // enables us to sort both array and index at the same time.
                // we use the index to reorder the result to the original order.
                //

                for (i=0;i < cInAtts; i++) {

                    pIndexAC[i].Index = i;
                    pIndexAC[i].AttCache = rgpAC[i];
                }

                qsort(pIndexAC, cInAtts, sizeof(INDEXED_AC), CmpIndexedACByAttType);

                //
                // ok, copy the index to return to the user
                //

                for (i=0;i < cInAtts; i++) {
                    pOrderIndex[i] = pIndexAC[i].Index;
                    rgpAC[i] = pIndexAC[i].AttCache;
                }

                // we return pOrderIndex as a pointer to somewhere in the block of pIndexAC
                // but we cannot free it, since it is in the middle of the block.
                // we need to add one more field to CACHED_AC for the whole pIndexAC
            }
            RemoveDuplicatesFromAttCache(rgpAC, cInAtts);
        }
    }

    //
    // Send this back to the caller so they can use it to call us again
    // Make a saved copy since CheckReadSecurity() might modify the array.
    //

    if ( (CachedAC != NULL) && (cInAtts > 0) ) {
        Assert(CachedAC->AC == NULL);
        CachedAC->AC = rgpAC;
        CachedAC->classId = classid;
        rgpAC = (ATTCACHE**)((PCHAR)CachedAC->AC + cInAtts * sizeof(ATTCACHE*));
        CopyMemory(rgpAC, CachedAC->AC, cInAtts * sizeof(ATTCACHE*));
        CachedAC->nAtts = cInAtts;
        CachedAC->pOrderIndex = pOrderIndex;
    }

have_array:

    // now read all the relevant columns from the record

    if ( fDoSecCheck ) {
        // We need to trim the atts we are asking for based on security
        CheckReadSecurity(pTHS,
                          SecurityDescriptorFlags,
                          pSecurity,
                          pEnt->pName,
                          &cInAtts,
                          pCC,
                          rgpAC);
    }

    if (i=DBGetMultipleAtts(pDB,
                            cInAtts,
                            rgpAC,
                            pSelRange,
                            pRange,
                            &AttrBlock.attrCount,
                            &AttrBlock.pAttr,
                            fFlags,
                            SecurityDescriptorFlags)) {

        DPRINT(1,"GetEntInf: Error in GetMultipleAtts\n");
        if (!CachedAC) THFreeEx(pTHS,rgpAC);
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_CANT_RETRIEVE_ATTS, i);
    }

    //
    // Do we need to reorder the result?
    //

    if ( (pOrderIndex != NULL) &&
         (AttrBlock.attrCount > 1) ) {

        DWORD i,j;
        ATTR * pTmpAttr = THAllocEx(pTHS,cInAtts * sizeof(ATTR));

        Assert(AttrBlock.attrCount <= cInAtts);
        FillMemory(pTmpAttr, cInAtts * sizeof(ATTR), 0xFF);

        for (i=0, j=0; (i < cInAtts) && (j < AttrBlock.attrCount) ; i++) {

            if ( (rgpAC[i] != NULL) &&
                 (rgpAC[i]->id == AttrBlock.pAttr[j].attrTyp) ) {

                CopyMemory(&pTmpAttr[pOrderIndex[i]],
                           &AttrBlock.pAttr[j],
                           sizeof(ATTR));

                j++;
            }
        }

        //
        // ok, copy the entries from the tmp array back to the AttrBlock buffer
        //

        for (i=0,j=0;i<cInAtts;i++) {

            if ( pTmpAttr[i].attrTyp != 0xFFFFFFFF ) {
                CopyMemory(
                       &AttrBlock.pAttr[j],
                       &pTmpAttr[i],
                       sizeof(ATTR));

                Assert(j < AttrBlock.attrCount);
                j++;
            }
        }
        Assert(j == AttrBlock.attrCount);
        THFreeEx(pTHS,pTmpAttr);
    }

    // initialize the entinf
    pEnt->AttrBlock = AttrBlock;
    if (!CachedAC) THFreeEx(pTHS,rgpAC);
    return 0;
} /*GetIntInf*/

int
LocalRead (
        THSTATE *pTHS,
        READARG *pReadArg,
        READRES *pReadRes
        )
     /*++
       Get the selected attributes and optionally, their values from the current
       object.  If no attributes were found, return an error.
       --*/
{
    ULONG ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD       getEntInfFlags = 0;
    RESOBJ      *pResObj;
    DWORD err;

    PERFINC( pcTotalReads );
    INC_READS_BY_CALLERTYPE( pTHS->CallerType );

    // First, get the security descriptor for this object.
    // Don't bother if this is an internal read
    if (!(pTHS->fDSA || pTHS->fDRA)) {
        DBPOS* pDB = pTHS->pDB;
        char objFlag;
        err = DBGetObjectSecurityInfo(
                pDB,
                pDB->DNT,
                &ulLen,
                &pSec,
                NULL,
                NULL,
                &objFlag,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE
            );

        if (err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        // Every object should have an SD.
        Assert(objFlag == 0 || ulLen > 0);
    }

    //
    // Can we reorder entries
    //

    SvccntlFlagsToGetEntInfFlags(&pReadArg->CommArg.Svccntl,&getEntInfFlags);

    if ((pReadArg->pResObj->pObj->NameLen)
        || (pReadArg->pSel->infoTypes  == EN_INFOTYPES_SHORTNAMES)) {
        // If we already have a good enough object name, don't fetch another
        pResObj = pReadArg->pResObj;
    }
    else {
        pResObj = NULL;
    }

    if (GetEntInf(pTHS->pDB,
                  pReadArg->pSel,
                  pReadArg->pSelRange,
                  &pReadRes->entry,
                  &pReadRes->range,
                  pReadArg->CommArg.Svccntl.SecurityDescriptorFlags,
                  pSec,
                  getEntInfFlags,
                  NULL,
                  pResObj)) {
        return (pTHS->errCode);
    }

    // it is an error if the user requested a list of attributes and none
    // where found. If a 0 list was requested, this is an O.K. existance test

    if (pReadRes->entry.AttrBlock.attrCount == 0 && pReadArg->pSel &&
        pReadArg->pSel->AttrTypBlock.attrCount > 0){
    ULONG u;

        DPRINT(2,"No user sel atts found .PR_PROBLEM_NO_ATTRIBUTE_OR_VAL\n");

    for (u = 0; u < pReadArg->pSel->AttrTypBlock.attrCount; u++) {
        SetAttError(pReadArg->pObject,
            pReadArg->pSel->AttrTypBlock.pAttr[u].attrTyp,
            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
            NULL,
            DIRERR_NO_REQUESTED_ATTS_FOUND);
    }
    }

    return pTHS->errCode;

}/*LocalRead*/


VOID
SvccntlFlagsToGetEntInfFlags(
    IN  SVCCNTL* Svccntl,
    OUT PDWORD Flags
    )
{
    if ( !Svccntl->fMaintainSelOrder ) {
        *Flags = GETENTINF_FLAG_CAN_REORDER;
    } else if (Svccntl->fDontOptimizeSel) {
        *Flags = GETENTINF_FLAG_DONT_OPTIMIZE;
    }

    //
    // if request came in through GC port, get only GC attributes
    //

    if (Svccntl->fGcAttsOnly) {
        *Flags |= GETENTINF_GC_ATTRS_ONLY;
    }

    return;
} // SvccntlFlagsToGetEntInfFlags


BOOL
IsACListSorted(
    IN ATTCACHE  **rgpAC,
    IN DWORD       cAtts
    )
/*++

Function Description:
       Checks a list of ATTCACHE pointers to see if it is already sorted.
       
Arguments:
       rgpAC - The list of ATTCACHE pointers to be checked.
       
       cAtts - A count of the ATTCACHE pointers in rgpAC
       
Return Value.
       Returns TRUE if the list is sorted, FALSE if not.
       
--*/
{
    unsigned i;

    for (i = 0; i<cAtts - 1; i++) {
        if (rgpAC[i]->id > rgpAC[i+1]->id) {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
MergeSortedACLists(
    IN  THSTATE    *pTHS,
    IN  ATTCACHE  **rgpAC1,
    IN  DWORD       cAtts1,
    IN  ATTCACHE  **rgpAC2,
    IN  DWORD       cAtts2,
    IN OUT ATTCACHE **rgpACOut,
    OUT DWORD      *pcAttsOut
    )
/*++

Function Description:
       Merges to sorted lists of ATTCACHE arrays.
              
Arguments:
       rgpAC1, rgpAC2 - The lists of ATTCACHE pointers to be merged.
       
       cAtts1, cAtts2 - A count of the ATTCACHE pointers in the respective list.
       
       rgpACOut - A buffer that must be larger enough to hold both input lists.
                  This is where the merged list will be placed.
                  
       pcOutAtts - Where the size of the merged list is returned.
       
Return Value.

       n/a       
--*/
{
    ATTCACHE   **rgpACIndirect = NULL;
    unsigned   pos1 = 0, pos2 = 0, outPos = 0;
    int        cmp;

    *pcAttsOut = 0;

    for (;;) {
        cmp = CmpACByAttType(&rgpAC1[pos1], &rgpAC2[pos2]);
        if (cmp > 0) {
            rgpACOut[outPos++] = rgpAC2[pos2++];
            if (pos2 == cAtts2) {
                break;
            }
        } else if (cmp < 0) {
            rgpACOut[outPos++] = rgpAC1[pos1++];
            if (pos1 == cAtts1) {
                break;
            }
        } else {
            rgpACOut[outPos++] = rgpAC2[pos2++];
            pos1++;
            if (pos1 == cAtts1 || pos2 == cAtts2) {
                break;
            }
        }
    }

    //
    // One of the input lists has run out of elements.  Copy the rest
    // of the other list over.
    //
    if (pos1 == cAtts1) {
        rgpACIndirect = rgpAC2;
        pos1 = pos2;
        cAtts1 = cAtts2;
    } else {
        rgpACIndirect = rgpAC1;
    }
    while (pos1 < cAtts1) {
        rgpACOut[outPos++] = rgpACIndirect[pos1++];
    }

    *pcAttsOut = outPos;

    return;
}
