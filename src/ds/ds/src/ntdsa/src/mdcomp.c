//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdcomp.c
//
//--------------------------------------------------------------------------

/*

Description:
    
    Implements the DirCompare API.
    
    DSA_DirCompare() is the main function exported from this module.
    
*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h> 
#include <scache.h>			// schema cache 
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header 
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>			// needed for output allocation 
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"			// header Audit\Alert logging 
#include "dsexcept.h"
#include "mdcodes.h"			// header for error codes 

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include <filtypes.h>                   // Def for FI_CHOICE_???
#include "debug.h"			// standard debugging header 
#define DEBSUB "MDCOMPARE:"             // define the subsystem for debugging 

#include <fileno.h>
#define  FILENO FILENO_MDCOMP


/* Internal functions */

int LocalCompare(THSTATE *pTHS, COMPAREARG *pCompareArg,
		 COMPARERES *pCompareRes);


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirCompare(
    COMPAREARG* pCompareArg,    /* Compare  argument */
    COMPARERES **ppCompareRes
    ){
      
    THSTATE*     pTHS;
    COMPARERES *pCompareRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirCompare entered\n");

    /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
       is required on every API transaction.  First the state DS is initialized
       and then either a read or a write sync point is established.
       */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppCompareRes = pCompareRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppCompareRes = pCompareRes = THAllocEx(pTHS, sizeof(COMPARERES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if ((eServiceShutdown >= eSecuringDatabase) ||
                ((eServiceShutdown >= eRemovingClients) && !pTHS->fDSA)) {
                ErrorOnShutdown();
                __leave;
            }
        }
        SYNC_TRANS_READ();   /*Identify a reader trans*/
        __try {

            /* Perform name resolution to locate object.  If it fails, just 
            * return an error, which may be a referral.
            */

            if (0 == DoNameRes(pTHS,
                               NAME_RES_QUERY_ONLY,
                               pCompareArg->pObject,
                               &pCompareArg->CommArg,
                               &pCompareRes->CommRes,
                               &pCompareArg->pResObj)){

               /* Local compare operation */
	   
                LocalCompare(pTHS, pCompareArg, pCompareRes);
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pCompareRes) {
        pCompareRes->CommRes.errCode = pTHS->errCode;
        pCompareRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;
}/*DirCompare*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the Distname if an alias was dereferenced.  Determine if the object
   is a master or replica.  Match the user attribute and value against the
   object.  If a match is found return TRUE, if not return FALSE.

   NOTE that we use the attribute type to determine the type of
   comparison, via the DBEval call (the same call is used in evaluating
   filter items in a ds_search call.)
*/

int LocalCompare(THSTATE *pTHS,
		 COMPAREARG *pCompareArg,
		 COMPARERES *pCompareRes)
{

    DWORD   err;
    SYNTAX_INTEGER       iType;
    ATTCACHE             *pAC;
    ULONG                ulLen;
    PSECURITY_DESCRIPTOR pSecurity = NULL;
    DSNAME TempDN;
    CLASSCACHE *pCC=NULL;
    BOOL                 fNoAtt = FALSE;
    DWORD       cInAtts = 1;
    DWORD classP;
    PUCHAR pVal=(PUCHAR)&classP;
    TRIBOOL     retfil;
    
    //
    // Log Event for tracing
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_COMPARE,
                     EVENT_TRACE_TYPE_START,
                     DsGuidCompare,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertUL(pCompareArg->Assertion.type),
                     szInsertDN(pCompareArg->pObject),
                     NULL, NULL, NULL, NULL, NULL);

    /*Get and set the DN if an alias was dereferenced*/

    //
    // check to see if the object is visible at all
    //
    if (CheckObjDisclosure(pTHS, pCompareArg->pResObj, FALSE)) {
        goto exit;
    }

    if (pCompareRes->CommRes.aliasDeref){

        if (err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                            0,
                            0,
                            &ulLen, (UCHAR **)&pCompareRes->pObject)){
          
            DPRINT(2,"Problem retrieving DN attribute\n");
          
          
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                   DS_EVENT_SEV_MINIMAL,
                   DIRLOG_CANT_RETRIEVE_DN,
                   szInsertDN(pCompareArg->pObject),
                   NULL,
                   NULL);

            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_DN,
                                err);
            goto exit;
        }
    }
    else {
        pCompareRes->pObject = NULL;
    }

    /* Determine of the object is a master or a replica */
    if(err = DBGetSingleValue(pTHS->pDB, ATT_INSTANCE_TYPE, &iType,
                       sizeof(iType), NULL)) {
        DPRINT(2, "Can't retrieve instance type\n");
        LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_RETRIEVE_INSTANCE,
                szInsertDN(GetExtDSName(pTHS->pDB)),
                NULL,
                NULL);
       
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                      DIRERR_CANT_RETRIEVE_INSTANCE, err);
        goto exit;
    }
   
    DPRINT1(2,"Instance type is <%lx>\n",iType);

    if ( iType & IT_WRITE ) {
        pCompareRes->fromMaster = TRUE;
    } else {
        pCompareRes->fromMaster = FALSE;
    }

    pAC = SCGetAttById(pTHS, pCompareArg->Assertion.type);
    Assert(pAC != NULL);

    /* Check if the attribute type and value exists on this object*/

    if(!(pAC && DBHasValues_AC(pTHS->pDB, pAC))) {
       
        DPRINT1(2,"No Att, No match%lu\n", pCompareArg->Assertion.type);
        fNoAtt = TRUE;
    }
   
    if (!fNoAtt) {

        if (pCompareArg->Assertion.Value.valLen == 0){

            DPRINT1(2,"No Att value provided, No match%lu\n", pCompareArg->Assertion.type); 

            pCompareRes->matched = FALSE;
            goto exit;
        }

        //
        // See whether the client has read access to the attribute.
        //

        // Get the SD
        err = DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                          0, 0,
                          &ulLen, (PUCHAR *)&pSecurity);
        if(err) {
            // Every object should have an SD.
            Assert(!err);
            ulLen = 0;
            pSecurity = NULL;
        }

        // Now, an abbreviated form the the DSNAME.
        TempDN.structLen = DSNameSizeFromLen(0);
        TempDN.NameLen = 0;
        DBFillGuidAndSid(pTHS->pDB, &TempDN);

        // Finally, get the class cache pointer.
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_CLASS,
                          DBGETATTVAL_fINTERNAL | DBGETATTVAL_fCONSTANT,
                          sizeof(classP),
                          &ulLen, &pVal);
        // Every object should have ATT_OBJECT_CLASS.
        Assert(!err);

        pCC = SCGetClassById(pTHS, classP);

        // Finally do the security check.  If the check fails then pAC will
        // be NULL'ed out.
        CheckReadSecurity(pTHS,
                          0,               // no SD flags
                          pSecurity,
                          &TempDN,
                          &cInAtts,
                          pCC,
                          &pAC); 

        if (!pAC) {
            //
            // Failed the access check
            //
            fNoAtt = TRUE;
        }
    }
    
    if (fNoAtt) {
        //
        // Set this error here so that the case where the att doesn't exist, and
        // the case where the user doesn't have permission to see that att can't
        // be distuinguished by DSID
        //
        pCompareRes->matched = FALSE;
        SetAttError(pCompareArg->pObject,
                          pCompareArg->Assertion.type,
                          PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                          DIRERR_CANT_ADD_ATT_VALUES);
        goto exit;
    }

    //
    // Finally do the comparison.
    //
    if(!FLegalOperator(pAC->syntax,FI_CHOICE_EQUALITY)) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_GENERIC_ERROR);
        goto exit;
    }
   
    retfil = DBEval(pTHS->pDB, FI_CHOICE_EQUALITY, 
                                  pAC,
                                  pCompareArg->Assertion.Value.valLen,
                                  pCompareArg->Assertion.Value.pVal);
    Assert(VALID_TRIBOOL(retfil));
    pCompareRes->matched = (eTRUE == retfil);

    if(pCompareRes->matched) {
        DPRINT1(2,"Att value matched %lu\n", pCompareArg->Assertion.type);
    } else {
        DPRINT1(2,"No Att value match,%lu\n", pCompareArg->Assertion.type);
    }


exit:
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_COMPARE,
                     EVENT_TRACE_TYPE_END,
                     DsGuidCompare,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL,
                     NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;
   
}/*LocalCompare*/
