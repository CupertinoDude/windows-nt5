//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdfind.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirGetDomainHandle and DirFindEntry APIs.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                   // schema cache
#include <prefix.h>                   // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                 // MD global definition header
#include <mdlocal.h>                  // MD local definition header
#include <dsatools.h>                 // needed for output allocation
#include <samsrvp.h>                  // to support CLEAN_FOR_RETURN()
#include <sdprop.h>                   // Critical section for adds.
#include <gcverify.h>                 // GC DSNAME verification

// SAM interoperability headers
#include <mappings.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                  // header Audit\Alert logging
#include "mdcodes.h"                  // header for error codes

// Assorted DSA headers.
#include "objids.h"                   // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "drautil.h"
#include "debug.h"                    // standard debugging header
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#include "filtypes.h"
#define DEBSUB "MDFIND:"              // define the subsystem for debugging

// MD layer headers.
#include "drserr.h"

#include <fileno.h>
#define  FILENO FILENO_MDFIND

BOOL
dbEvalInt (
        DBPOS FAR *pDB,
        BOOL fUseSearchTbl,
        UCHAR Operation,
        ATTRTYP type,
        ULONG valLenFilter,
        UCHAR *pValFilter,
        BOOL *pbSkip
        );
DWORD
LocalFind(FINDARG *pFindArg,
          FINDRES *pFindRes);
DWORD
CheckAndReturnObject(
    FINDARG *pFindArg,
    FINDRES *pFindRes,
    BOOL     fCheckValue,
    ATTRVAL *pIntVal,        
    DWORD   *pFoundDNT
    );



/*++
 *  Given an attribute value and a domain handle (i.e., an NCDNT), this
 *  routine returns the DSNAME of the one object in that domain for which
 *  that AVA is true.  Returns a simple error code if no such object exists
 *  or if multiple such objects do.
 *
 *  NOTE: This routine does not enforce security in any way, shape, or form,
 *        and is not to be called by any out-of-process callers.
 */
ULONG
DirFindEntry(FINDARG  * pFindArg,
             FINDRES ** ppFindRes)
{
    THSTATE*        pTHS;
    FINDRES *       pFindRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(2,"DirFindEntry entered\n");

    // Initialize the THSTATE anchor and set a read sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppFindRes = pFindRes = NULL;

    Assert(pTHS->fDSA || pTHS->fSAM || pTHS->fDRA);
    
    if (eServiceShutdown) {
        ErrorOnShutdown();
        return pTHS->errCode;
    }

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppFindRes = pFindRes = THAllocEx(pTHS, sizeof(FINDRES));
        if (pTHS->errCode) {
            __leave;
        }
        SYNC_TRANS_READ();       /* Set Sync point*/
	__try {
            LocalFind(pFindArg, pFindRes);
	}
	__finally {
	
	    CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction

	}
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
	HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pFindRes) {
	pFindRes->CommRes.errCode = pTHS->errCode;
	pFindRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

} /*DirFindEntry*/

/*++ 
 *  Given an attribute value and a domain handle (i.e., an NCDNT), this
 *  routine returns the DSNAME of the one object in that domain for which
 *  that AVA is true.  Returns a simple error code if no such object exists
 *  or if multiple such objects do.
 *
 *  NOTE: This routine does not enforce security in any way, shape, or form,
 *        and is not to be called by any out-of-process callers.
 */
DWORD
LocalFind(FINDARG *pFindArg,
          FINDRES *pFindRes)
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE *pAC;
    DWORD err=0;
    INDEX_VALUE IV;
    ULONG len;
    DWORD FoundDNT = INVALIDDNT;
    ATTRVAL IntVal;
    BOOL     fCheckValue;
    DWORD    cbKey=0;

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_FIND,
                     EVENT_TRACE_TYPE_START,
                     DsGuidFind,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertHex(pFindArg->AttId),
                     NULL, NULL, NULL, NULL, NULL, NULL);
    
    pAC = SCGetAttById(pTHS, pFindArg->AttId);
    if (!pAC || !(pAC->fSearchFlags & fATTINDEX)) {
        SetAttError(gpRootDN,
                    pFindArg->AttId,
                    (USHORT)(pAC
                             ? PR_PROBLEM_WRONG_MATCH_OPER
                             : PR_PROBLEM_UNDEFINED_ATT_TYPE),
                    NULL,
                    DIRERR_GENERIC_ERROR);
        goto exit;
    }

    // Convert the given arg to internal value

    err = MakeInternalValue(pTHS->pDB,
                      pAC->syntax,
                      &pFindArg->AttrVal,
                      &IntVal);

    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }

    err = DBSetCurrentIndex(pTHS->pDB,
                            0,
                            pAC,
                            FALSE);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }

    IV.pvData = IntVal.pVal;
    IV.cbData = IntVal.valLen;
    err = DBSeek(pTHS->pDB,
                 &IV,
                 1,
                 DB_SeekEQ);
    if (err) {
        // No matches
        SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                      NULL,
                      DIRERR_UNKNOWN_ERROR,
                      err); 
        goto exit;
    }
    
    //
    // See if the key was too long.  If it was, then check and return objects
    // must also verify the value of the attribute we're searching on, in
    // addition to the rest of the checks it does.
    //
    
    DBGetKeyFromObjTable(pTHS->pDB, NULL, &cbKey);
    fCheckValue = (cbKey >= DB_CB_MAX_KEY);


    // Set an index range over the given value as we might need to
    // either iterate over the object or move one step further to
    // check for duplicates.

    err = DBSetIndexRange(pTHS->pDB,
                          &IV,
                          1);
    if (err) {
        SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                      NULL,
                      DIRERR_UNKNOWN_ERROR,
                      err);
        goto exit;
    }



    while (0==err) {


        err = CheckAndReturnObject(pFindArg,
                                   pFindRes,
                                   fCheckValue,
                                   &IntVal,
                                   &FoundDNT);

        if (err)
        {
            // Some other error occured. 
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
            goto exit;
        }

        err = DBMove(pTHS->pDB, 
                     FALSE,
                     1);
    }

    if (FoundDNT == INVALIDDNT) {
       // Uh, oh.  We're out of candidates.
       SetNamErrorEx(NA_PROBLEM_NO_OBJECT,
                     NULL,
                     DIRERR_UNKNOWN_ERROR,
                     err);
       goto exit;
    }

    Assert(pTHS->errCode == 0);

exit:
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_FIND,
                     EVENT_TRACE_TYPE_END,
                     DsGuidFind,
                     szInsertUL(pTHS->errCode), 
                     NULL, NULL, NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;
}

/*++
 *  This routine will perform the following operations
 *  1. Check if the currently positioned object is in the right NC
 *  2. Check if the currently positioned object is not deleted
 *     If any of the above fail, return success without setting pFoundDNT
 *  3. Check if no other object has been found before, if so fail
 *  4. If told to, check that the value looked up is equal to the value found.
 *     This solves problems with truncated jet keys.
 *  5. If all is well, retrieve the DSName of the object, set pFoundDNT to the
 *     DNT we found. return a success 
 *  This routine is called by LocalFind, after LocalFind thinks that
 *  it has positioned on an object. 
--*/
DWORD
CheckAndReturnObject(
    FINDARG *pFindArg,
    FINDRES *pFindRes,
    BOOL     fCheckValue,
    ATTRVAL *pIntVal,        
    DWORD   *pFoundDNT
    )
{
    THSTATE *pTHS=pTHStls;
    ULONG   isdel;
    ULONG   len;
    ULONG   err=0;
    DWORD   DNT;

    // We are positioned on an object at this time

    // Is it in the right NC ?
    if (pTHS->pDB->NCDNT != pFindArg->hDomain) {

        //Nope, do not touch the state of pFoundDNT
        return 0;
    }

    // Check wether it is deleted
    err = DBGetSingleValue(pTHS->pDB,
                   ATT_IS_DELETED,
                   &isdel,
                   sizeof(isdel),
                   NULL);
    if (err) {
        if (DB_ERR_NO_VALUE == err) {
            // Treat having no value the same as being false.
            isdel = 0;
            err = 0;
        }
        else {
            // I don't know what happened, but it isn't good.
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
            return pTHS->errCode;
        }
    }

    if (0!=isdel) {
       // object is deleted. Return without touch pFoundDNT
       return 0;
    }

    // Good! object is not deleted.  Get it's DNT
    DBGetSingleValue(pTHS->pDB,
                     FIXED_ATT_DNT,
                     &DNT,
                     sizeof(DNT),
                     NULL);

    
    if(fCheckValue && (DNT != *pFoundDNT)) {
        // Need to check that the value is actually a match.
        if(!dbEvalInt(pTHS->pDB,
                      FALSE,
                      FI_CHOICE_EQUALITY,
                      pFindArg->AttId,
                      pIntVal->valLen,
                      pIntVal->pVal,
                      NULL)) {
            // Not really a match
            return 0;
        }
    }


    // Have we found an object before ?
    if ((*pFoundDNT != INVALIDDNT) && (*pFoundDNT != DNT)) {
        // this is a duplicate !
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        return pTHS->errCode;
    }
    
    // O.K get the DSNAME and set pFoundDNT to the DNT we've found.
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_OBJ_DIST_NAME,
                      pFindArg->fShortNames?DBGETATTVAL_fSHORTNAME:0,
                      0,
                      &len,
                      (UCHAR**)&pFindRes->pObject);
    if (err) {
        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR,
                      err);
        return pTHS->errCode;
    }

    *pFoundDNT=DNT;

    return(0);
}



/*++
 *  This routine returns a "domain handle" for the specified domain, as needed
 *  by clients of DirFindEntry.  The domain handle is actually just the DNT 
 *  of the NC head, which is therefore the NCDNT of objects in that domain/NC.
 *  We verify that the name passed in is indeed the name of an NC head, but
 *  not that it is the name of a domain (as opposed to being the name of a
 *  non-domain NC, such as the schema NC).
 *
 *  INPUT:
 *     pDomainDN  - pointer to DSNAME of domain for which handle is desired
 *  RETURN VALUE
 *     non-0      - domain handle
 *     0          - name was not that of a domain
 */
DWORD DirGetDomainHandle(DSNAME *pDomainDN)
{
    THSTATE*        pTHS;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    DWORD err, it;
    DWORD handle = 0;


    // Initialize the THSTATE anchor and set a read sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));

    __try {
        SYNC_TRANS_READ();       /* Set Sync point*/
	__try {
            err = DBFindDSName(pTHS->pDB,
                               pDomainDN);
            if (err) {
                __leave;
            }
            err = DBGetSingleValue(pTHS->pDB,
                                   ATT_INSTANCE_TYPE,
                                   &it,
                                   sizeof(it),
                                   NULL);
            if (!err &&
                (it & IT_NC_HEAD)) {
                handle = pTHS->pDB->DNT;
            }
	}
	__finally {
	
	    CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction

	}
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
			      &dwEA, &ulErrorCode, &dsid)) {
	HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    return handle;
}

