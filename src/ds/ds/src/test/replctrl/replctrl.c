/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replctrl.c

Abstract:

    Callable api to the ldap replication control

    Use the dirsync replication control to get changes from a
    source and nc given a usn and utd

    This code derived from
    \nt\private\dirsync\dsserver\adread\read.cpp:
        GetMoreDataFromDS()

    The source is essentially stateless for change positioning. The caller
    (destination) records where he was last.  A change position is represented
    by a opaque data structure called a cookie.

    The is no support at the moment to explode and construct cookies, so that
    one could build an arbitrary one.  Instead, you may either duplicate a cookie
    from a reps-from, or you can start with no cookie, and iterate sequentially 
    through all the changes, and then proceeding incrementally from there.

Author:

    Will Lees (wlees) 30-Apr-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <ismapi.h>
#include <schedule.h>
#include <ntldap.h>
#include <winber.h>

#define CHK_LD_STATUS( x )                        \
{                                                 \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        err = LdapMapErrorToWin32(x);             \
        printf( "[%s, %d] LDAP error %d (%ls) win32 %d.\n", \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ),            \
                err );                            \
       goto error;                                \
    }                                             \
}

#define MemAlloc( x ) malloc( x )
#define MemFree( x ) free( x )

#define BAIL() \
printf( "Fatal error at line %d, file %s\n", __LINE__, __FILE__ ); \
goto error;
#define BAIL_ON_NULL(x) if (!(x)) { \
printf( "%s had unexpected null value at line %d, file %s\n", #x,__LINE__, __FILE__ ); \
err = ERROR_NOT_ENOUGH_MEMORY; \
goto error; \
}
#define BAIL_ON_FAILURE(x) if (x) { \
printf( "%s had unexpected failure value at line %d, file %s\n", #x,__LINE__, __FILE__ ); \
goto error; \
}
#define ERR(parenarglist) \
printf parenarglist; \
goto error;

// Read 100 objects at a time
#define DIRSYNC_SIZE_LIMIT 100
// Maximum attrs to return
// sic
#define MAX_ATTIBUTES        1048576

// The following is from  dsamain/ldap/const.hxx

//
// version of the repl dirsync control cookie structure
//
// structure for v1
//   REPL VERSION
//   vector To
//   UTD Vector
//
// structure for v2
//   REPL VERSION
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//
// structure for v3
//   REPL_SIGNATURE
//   REPL_VERSION
//   TIMESTAMP
//   RESERVED
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//

#define REPL_VERSION        3
#define REPL_SIGNATURE      'SDSM'
#define LDAP_VALID_DIRSYNC_CONTROL_FLAGS    (DRS_GET_ANC)

//
// minimum size of a repl control cookie
//

#define MIN_REPL_CONTROL_BLOB_LENGTH    (sizeof(DWORD) + sizeof(DWORD) + sizeof(FILETIME) + \
                                        sizeof(LARGE_INTEGER) + sizeof(DWORD) + \
                                        sizeof(USN_VECTOR) + sizeof(UUID))

#define ASCII_TO_INT(x)    ((x)<='9' ? (x)-'0' : ((x) <='F' ? (x)-'A' + 10 : (x)-'a' + 10))
#define ASCII_TO_INTW(x)    ((x)<=L'9' ? (x)-L'0' : ((x) <=L'F' ? (x)-L'A' + 10 : (x)-L'a' + 10))

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon May 03 15:25:45 1999 */

DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    );

DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    );

void
displayResults(
    LDAP *pLdap,
    LDAPMessage *pSearchResult,
    BOOL fVerbose
    );

void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    );

DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );

/* End Forward */


DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

A Cookie represents a position in the changes stream for a particular source.

Build a cookie from neighbor and cursor information representing the
position of a destination with respect to some source

Cookie is output on success, otherwise not returned.

Arguments:

    pNeighbor - 
    pCursors - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD err, i;
    USN_VECTOR usnVec;
    UPTODATE_VECTOR *pUTD = NULL;
    DWORD cbUTD = 0;

    // Initialize out parameters
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    // Construct USN VECTOR
    ZeroMemory( &usnVec, sizeof( USN_VECTOR ) );
    usnVec.usnHighObjUpdate = pNeighbor->usnLastObjChangeSynced;
    usnVec.usnHighPropUpdate = pNeighbor->usnAttributeFilter;

    // Construct UPTODATE VECTOR
    cbUTD = UpToDateVecV1SizeFromLen( pCursors->cNumCursors );
    pUTD = malloc( cbUTD );
    if (pUTD == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    ZeroMemory( pUTD, cbUTD );
    pUTD->dwVersion = 1;
    pUTD->V1.cNumCursors = pCursors->cNumCursors;
    for( i = 0; i < pCursors->cNumCursors; i++ ) {
        pUTD->V1.rgCursors[i].uuidDsa = pCursors->rgCursor[i].uuidSourceDsaInvocationID;
        pUTD->V1.rgCursors[i].usnHighPropUpdate = pCursors->rgCursor[i].usnAttributeFilter;
    }

    // Build the initial cookie
    err = packCookie(
        &usnVec,
        &(pNeighbor->uuidSourceDsaInvocationID),
        pUTD,
        ppCookieNext,
        pdwCookieLenNext
        );
    if (err != ERROR_SUCCESS) {
        goto error;
    }

    err = ERROR_SUCCESS;
error:

    if (pUTD) {
        free(pUTD);
    }

    return err;
} /* DsMakeReplCookieForDest */


DWORD
DsFreeReplCookie(
    PBYTE pCookie
    )

/*++

Routine Description:

Free a cookie returned by DsMakeReplCookie

Arguments:

    pCookie - pointer to cookie

Return Value:

    DWORD - errors if cookie not valid

--*/

{
    DWORD dwSignature;

    if (pCookie == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)pCookie);

    if (dwSignature != REPL_SIGNATURE) {
        return ERROR_INVALID_PARAMETER;
    }

    MemFree( pCookie );

    return ERROR_SUCCESS;
} /* DsFreeReplCookie */


DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    )

/*++

Return a packet of changes given position information in "current cookie".

If successful, an updated position will be returned in "next cookie".

Cookies are self describing and position independent: they may be saved to long
term storage and retrieved later as a kind of bookmark.  Cookies are specific to
the source server and naming context they were created for.

The caller is responsible for deallocating the cookies himself.  The "next
cookie" in particular must be deallocated using DsFreeReplCookie.  The current
cookie may come from a file or other long term storage.

The changes are returned as an LDAP message of entries, attributes and values.
Secret data will have been supressed.

Arguments:

The out parameters are initialized to null at the start.

    m_pLdap - ldap handle to source server.
    m_pSearchBase - The dn of the nc head to search
    pszSourceFilter - Ldap search filter, if any
    dwReplFlags - Replication flags, DRS_GET_ANC, etc
    pCookieCurr - null, or cookie previously returned by DsGetSourceChanges.
          The cookie must have come from a call with the same source server and
          same naming context.
    dwCookieLenCurr - cookie length, or zero
    ppSearchResult - pointer to pointer, to receive ldap message
    pfMoreData - Indication whether there is more data and this call should be made
        again with the updated cookie.  This is independent of whether the current
        call returned data.
    ppCookieNext - Newly allocated cookie for the updated position
    pdwCookieLenNext - Length of new cookie
    ppAttListArray - A Null terminated list of pointers to attributes to return

The out parameters are not allocated on error.

Even if there are no changes (entries in result are zero), the cookie may
have been updated with the latest positioning information.

Return Value:

    DWORD - 

--*/

{
    PBERVAL pBerVal = NULL;
    LDAPControlW replControl;
    LDAPControlW extDNControl;
    PLDAPControlW controlArray[3];
    int lderr, err;
    LDAP_TIMEVAL TimeVal;

    // Initialize out parameters
    *ppSearchResult = NULL;
    *pfMoreData = FALSE;
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    //
    // The replication control has the USN that specifies where to
    // continue from. This can be treated as opaque information by us.
    //

    err = BerEncodeReplicationControl(dwReplFlags,
                                      pCookieCurr, dwCookieLenCurr,
                                      &pBerVal);
    BAIL_ON_FAILURE( err );

    replControl.ldctl_oid = LDAP_SERVER_DIRSYNC_OID_W;
    replControl.ldctl_iscritical = TRUE;
    replControl.ldctl_value.bv_len = pBerVal->bv_len;
    replControl.ldctl_value.bv_val = (PCHAR)(pBerVal->bv_val);
    extDNControl.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    extDNControl.ldctl_iscritical = TRUE;
    extDNControl.ldctl_value.bv_len = 0;
    extDNControl.ldctl_value.bv_val = NULL;

    controlArray[0] = &replControl;
    controlArray[1] = &extDNControl;
    controlArray[2] = NULL;

    //
    // Adding in timeout so that we can recover if the server do not respond
    //
    TimeVal.tv_usec = 0;
    TimeVal.tv_sec = LDAP_TIMEOUT;

//    dumpCookie( *ppCookieNext, *pdwCookieLenNext );

    lderr = ldap_search_ext_sW(m_pLdap,
                               m_pSearchBase,
                               LDAP_SCOPE_SUBTREE, // m_pSessionData->SourceScope
                               pszSourceFilter,
                               ppAttListArray,
                               0,
                               (PLDAPControlW *) &controlArray,
                               NULL,
                               &TimeVal,
                               DIRSYNC_SIZE_LIMIT,
                               ppSearchResult);

    CHK_LD_STATUS( lderr );

    if ( (*ppSearchResult) == NULL )
    {
        // Let caller know there is no search result or cookie
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }

    //
    // Save the returned cookie value
    //

    err = BerDecodeReplicationCookie(
        m_pLdap,
        *ppSearchResult,
        ppCookieNext,
        pdwCookieLenNext,
        pfMoreData
        );
    BAIL_ON_FAILURE( err );

    err = ERROR_SUCCESS;

error:

    // On error, return the same cookie that came in

    // Release results on error
    if ( (err != ERROR_SUCCESS) && (*ppSearchResult) )
    {
        ldap_msgfree(*ppSearchResult);
        *ppSearchResult = NULL;
    }

    if (pBerVal)
        ber_bvfree(pBerVal);

    return err;

} /* DsGetSourceChanges */


DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    )

/*++

Routine Description:

    This encodes the replication cookie into a BERVAL that can be put in
    an LDAP control.

Arguments:

    dwReplFlags - Replication flags
    pCookie - Pointer to replication cookie
    dwLen - Length of cookie
    ppBerVal - Pointer that received the BERVAL structure. Called needs to
               free this using ber_bvfree().

Return Value:

    S_OK on success, error code otherwise

--*/

{
    DWORD err = ERROR_INVALID_PARAMETER;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    BAIL_ON_NULL(pBer);

    //
    // flag - set to zero, so order of parent & child objects is not important
    //

    if (ber_printf(pBer, "{iio}", dwReplFlags, MAX_ATTIBUTES, pCookie, dwLen) == -1)
    {
        err = ERROR_INTERNAL_ERROR;
        ERR(("Error in ber_printf\n"));
        BAIL();
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0)
    {
        err = ERROR_INTERNAL_ERROR;
        ERR(("Error in ber_flatten\n"));
        BAIL();
    }

    err = ERROR_SUCCESS;

error:
    if (pBer)
    {
        ber_free(pBer,1);
    }

    return err;

}



DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    )

/*++

Routine Description:

    This saves the replication cookie that came back from the server so that
    it can be used for the next call

Arguments:

    m_pLdap - 
    m_pSearchResult - 
    ppCookieNext - 
    pdwCookieLenNext - 
    pfMoreData - 

Return Value:

    DWORD - 

--*/

{
    PLDAPControlW *ppServerControl = NULL;
    BERVAL berVal;
    DWORD err = ERROR_INVALID_PARAMETER;
    ULONG lderr;
    BerElement *pBer = NULL;
    PBERVAL pbv = NULL;
    DWORD size;
    DWORD i;

    lderr = ldap_parse_resultW(m_pLdap,
                               m_pSearchResult,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               &ppServerControl,
                               FALSE);
    CHK_LD_STATUS( lderr );

    //
    // Find the replication control
    //

    i = 0;
    while (ppServerControl[i] &&
           wcscmp(ppServerControl[i]->ldctl_oid,LDAP_SERVER_DIRSYNC_OID_W) != 0)
    {
        i++;
    }

    if (!ppServerControl[i])
    {
        err = ERROR_NOT_FOUND;
        ERR(("Did not get a replication server control back\n"));
        BAIL();
    }

    berVal.bv_len = ppServerControl[i]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControl[i]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    ber_scanf(pBer, "{iiO}", pfMoreData, &size, &pbv);

    *pdwCookieLenNext = pbv->bv_len;
    *ppCookieNext = (PBYTE)MemAlloc(pbv->bv_len);
    BAIL_ON_NULL(*ppCookieNext);

    memcpy(*ppCookieNext, pbv->bv_val, *pdwCookieLenNext);

    err = ERROR_SUCCESS;

error:
    if (pbv)
        ber_bvfree(pbv);
    if (pBer)
        ber_free(pBer, 1);
    if (ppServerControl)
        ldap_controls_freeW(ppServerControl);

    return err;
} /* BerDecodeReplicationCookie */


#if DBG


void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    )

/*++

Routine Description:

    //
    // If the cookie is available, this debug code will dump out the cookie
    // value to the debugger
    //

Arguments:

    None

Return Value:

    None

--*/

{
    PUCHAR p;
    DWORD dwVersion, dwSignature;
    DWORD cbVecSize;
    USN_VECTOR usnVec;

    if (!pCookieNext)  {
        printf( "Cookie: null\n" );
    }

    p = pCookieNext;

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)p);
    p += sizeof(DWORD);

    //
    // Get the Version.
    //
    dwVersion = *((PDWORD)p);
    p += sizeof(DWORD);

    // Skip filetime
    p += sizeof(FILETIME);

    // Skip reserved
    p += sizeof(LARGE_INTEGER);

    //
    // Get the size of the up to date vector
    //
    cbVecSize = *((PDWORD)p);
    p += sizeof(DWORD);

    // Usnvec
    memcpy(&usnVec,p,sizeof(USN_VECTOR));

    // todo: invocation uuid
    // todo: uptodatevec

    printf("Cookie: ver %d,\nHighObjUpdate: %I64d,\nHighPropUpdate: %I64d\n",
           dwVersion, usnVec.usnHighObjUpdate, usnVec.usnHighPropUpdate);
}
#endif


DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

The following logic is taken from
    dsamain\ldap\ldapconv.cxx:LDAP_PackReplControl

Arguments:

    pUsnVec - 
    puuidInvocationId - 
    pUtdvecV1 - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD cbCookie = MIN_REPL_CONTROL_BLOB_LENGTH;
    DWORD cbVecSize = 0;
    PBYTE p, pbCookie = NULL;

    // todo: deal with not having a utd

    Assert( pUtdvecV1 != NULL );
    Assert(IS_VALID_UPTODATE_VECTOR(pUtdvecV1));

    if (pUtdvecV1->V1.cNumCursors > 0) {      
        cbVecSize = UpToDateVecV1Size(pUtdvecV1);
        cbCookie += cbVecSize;
    }

    pbCookie = MemAlloc( cbCookie );
    if (pbCookie == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pbCookie, cbCookie );

    p = pbCookie;

    //
    // Pack the signature
    //

    *((PDWORD)p) = REPL_SIGNATURE;
    p += sizeof(DWORD);

    //
    // Pack the Version. 
    //

    *((PDWORD)p) = REPL_VERSION;    
    p += sizeof(DWORD);

    //
    // Set the current time
    //

    GetSystemTimeAsFileTime((PFILETIME)p);
    p += sizeof(FILETIME);

    //
    // reserved for now
    //

    p += sizeof(LARGE_INTEGER);

    //
    // Pack the size of the up to date vector
    //

    *((PDWORD)p) = cbVecSize;
    p += sizeof(DWORD);

    //
    // Copy the usnvecTo. 
    //

    CopyMemory( p,pUsnVec, sizeof(USN_VECTOR));
    p += sizeof(USN_VECTOR);

    //
    // Copy the invocation UUID
    //

    CopyMemory( p, puuidInvocationId, sizeof(UUID));

    p += sizeof(UUID);

    //
    // Copy the UPTODATE_VECTOR if it exists
    //

    if( cbVecSize > 0 ) {
        CopyMemory( p,
                    pUtdvecV1, 
                    cbVecSize);
    }

    *pdwCookieLenNext = cbCookie;
    *ppCookieNext = pbCookie;

    return ERROR_SUCCESS;
} /* packCookie */

/* end dirsync.c */
