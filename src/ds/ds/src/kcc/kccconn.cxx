/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccconn.cxx

ABSTRACT:

    KCC_CONNECTION and KCC_CONNECTION_LIST classes.

DETAILS:

    These classes represent a single NTDS-Connection DS object and a
    collection thereof, resp.

    NTDS-Connection objects represent a uni-directional replication link,
    with the parent server object being the destination and the From-Server
    attribute holding the source.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <sddl.h>
#include "kcc.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kcclink.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kcccref.hxx"
#include "kccstale.hxx"
#include "kccsite.hxx"
#include <dsutil.h>
#include <winsock.h>                    // host <--> net long conversions

extern "C"
{
#include "permit.h"
}


#define FILENO FILENO_KCC_KCCCONN


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_CONNECTION methods
//

ATTR KCC_CONNECTION::AttrList[7] = {
    { ATT_ENABLED_CONNECTION,           { 0, NULL } },
    { ATT_FROM_SERVER,                  { 0, NULL } },
    { ATT_OPTIONS,                      { 0, NULL } },
    { ATT_SCHEDULE,                     { 0, NULL } },
    { ATT_WHEN_CREATED,                 { 0, NULL } },
    { ATT_TRANSPORT_TYPE,               { 0, NULL } },
    { ATT_MS_DS_REPLICATES_NC_REASON,   { 0, NULL } }
    // If adding or removing entries from this list, be sure to update array
    // size in kccconn.hxx.
};

DSNAME *
KCC_CONNECTION::GetConnectionDN()
//
// Retrieve the DN of the corresponding NTDS-Connection DS object.
//
{
    ASSERT_VALID( this );
    return m_pdnConnection;
}

DSNAME *
KCC_CONNECTION::GetSourceDSADN()
//
// Retrieve the DN of the source DSA's NTDS-DSA DS object.
//
{
    ASSERT_VALID( this );
    return m_pSourceDSA->GetDsName();
}

KCC_DSA *
KCC_CONNECTION::GetSourceDSA()
//
// Retrieve the source DSA's NTDS-DSA DS object.
//
{
    ASSERT_VALID( this );
    return m_pSourceDSA;
}

DSNAME *
KCC_CONNECTION::GetSourceSiteDN()
//
// Retrieve the DN of the source DSA's site object.
//
{
    ASSERT_VALID(this);

    return m_pSourceDSA->GetSiteDN();
}

DSNAME *
KCC_CONNECTION::GetDestinationDSADN()
//
// Retrieve the DN of the destination DSA's NTDS-DSA DS object.
//
{
    KCC_DSA *pDsa;
    
    ASSERT_VALID(this);
    
    if (NULL == m_pdnDestinationDSA) {
        Assert(m_pdnConnection && "Can't currently call this if obj not yet added!");
    
        // Destination ntdsDsa is the parent of the ntdsConnection object.
        m_pdnDestinationDSA = (DSNAME *) new BYTE[m_pdnConnection->structLen];
        TrimDSNameBy(m_pdnConnection, 1, m_pdnDestinationDSA);

        // Need to find the GUID for the destination DSA DN. Try to find an
        // in-memory KCC_DSA object for this DSA.

        // We can quickly find the KCC_DSA object in our global list of DSAs.
        pDsa = gpDSCache->GetGlobalDSAListByString()
                        ->GetDsa( m_pdnDestinationDSA, NULL );
        if( pDsa ) {
            memcpy( &m_pdnDestinationDSA->Guid,
                    &pDsa->GetDsName()->Guid,
                    sizeof(UUID) );
        } else {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_DESTINATION_DSA_NOT_FOUND,
                szInsertDN( m_pdnConnection ),
                0,
                0
                );
            KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
        }

    }

    return m_pdnDestinationDSA;
}

BOOL
KCC_CONNECTION::IsEnabled()
//
// Is the connection enabled?
//
{
    ASSERT_VALID( this );
    return !!m_fIsEnabled;
}

BOOL
KCC_CONNECTION::IsIntrasite()
//
// Is this an intra-site connection?
// This is determined by checking if the source DSA is in the local site.
//
{
    // Note that we implicitly assume here that all connections loaded have their
    // destination DSA in the local site. In the future, we may load connections
    // from other sites as well.
    return NamePrefix( gpDSCache->GetLocalSite()->GetObjectDN(), GetSourceDSADN() );
}

BOOL
KCC_CONNECTION::IsGenerated()
//
// Was the connection generated by the KCC (as opposed to being created by
// an administrator)?
//
{
    ASSERT_VALID( this );
    return !!( m_dwOptions & NTDSCONN_OPT_IS_GENERATED );
}

BOOL
KCC_CONNECTION::IsTwoWaySynced()
//
// Does completion of a sync of this NC trigger a sync in the opposite
// direction?
//
{
    ASSERT_VALID(this);
    return !!(m_dwOptions & NTDSCONN_OPT_TWOWAY_SYNC);
}

BOOL
KCC_CONNECTION::IsCompressionEnabled()
//
// Is compression enabled over this connection? 
// For intra-site connections, compression is never enabled.
// For inter-site connections, compression is enabled unless the option
// has been set to disable it.
//
{
    ASSERT_VALID(this);
    if( IsIntrasite() ) {
        return FALSE;
    } else {
        return !(m_dwOptions & NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION);
    }
}

BOOL
KCC_CONNECTION::UsesNotification()
//
// Override the default notification based on intra/inter site.
// Force the notification to be as specified
//
{
    BOOL fUsesNotification;
    ASSERT_VALID(this);

    if (m_dwOptions & NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) {
        fUsesNotification = !!(m_dwOptions & NTDSCONN_OPT_USE_NOTIFY);
    } else {
        // True if in same site
        fUsesNotification = IsIntrasite();
    }

    return fUsesNotification;
}

TOPL_SCHEDULE
KCC_CONNECTION::GetSchedule()
//
// Retrieve the periodic replication schedule.
//
{
    ASSERT_VALID( this );
    return m_toplSchedule;
}

KCC_CONNECTION &
KCC_CONNECTION::SetConnectionDN(
    IN  DSNAME *    pdn
    )
//
// Set the DN of the corresponding NTDS-Connection DS object.
//
{
    m_pdnConnection = (DSNAME *) new BYTE[ pdn->structLen ];
    memcpy( m_pdnConnection, pdn, pdn->structLen );

    return *this;
}
    
KCC_CONNECTION &
KCC_CONNECTION::SetSourceDSA(
    IN KCC_DSA *pDsa
    )
//
// Set the DN of the source DSA's NTDS-DSA DS object.
//
{
    m_pSourceDSA = pDsa;

    return *this;
}
    
KCC_CONNECTION &
KCC_CONNECTION::SetEnabled(
    IN  BOOL    fIsEnabled
    )
//
// Set the is-enabled flag to the given value.
//
{
    m_fIsEnabled = !!fIsEnabled;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetGenerated(
    IN  BOOL    fIsGenerated
    )
//
// Set the is-generated flag to the given value.
//
{
    if ( fIsGenerated )
    {
        m_dwOptions |= NTDSCONN_OPT_IS_GENERATED;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_IS_GENERATED;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetOverrideNotification(
    IN  BOOL    fUsesNotification
    )
//
// Override the default notification of the connection
//
{
    m_dwOptions |= NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT;
    if ( fUsesNotification )
    {
        m_dwOptions |= NTDSCONN_OPT_USE_NOTIFY;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_USE_NOTIFY;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetTwoWaySync(
    IN  BOOL    fIsTwoWaySync
    )
//
// Set the TwoWaySync'd state of the connection
//
{
    if ( fIsTwoWaySync )
    {
        m_dwOptions |= NTDSCONN_OPT_TWOWAY_SYNC;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_TWOWAY_SYNC;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetDisableIntersiteCompression(
    IN  BOOL    fDisableCompression
    )
//
// If this flag is set, compression of replication traffic across
// this connection is disabled. This function may only be called
// for inter-site connections.
//
{
    if ( fDisableCompression )
    {
        m_dwOptions |= NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetSchedule(
    IN  TOPL_SCHEDULE toplSchedule
    )
//
// Set the periodic replication schedule.
//
{
    Assert( ToplScheduleValid(toplSchedule) );
    m_toplSchedule = toplSchedule;
    m_fUpdatedSchedule = TRUE;
    return *this;
}

BOOL
KCC_CONNECTION::IsValid()
//
// Is this object internally consistent?
//
{
    return ( NULL != m_pSourceDSA );
}

BOOL
KCC_CONNECTION::Init(
    IN  ENTINF *    pEntInf
    )
//
// Initialize the internal object from an ENTINF describing a corresponding
// NTDS-Connection DS object.
//
{
    DWORD   iAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;
    DSNAME *pdnSourceDSA = NULL;

    Reset();

    m_pdnConnection = (DSNAME *) new BYTE[ pEntInf->pName->structLen ];
    memcpy( m_pdnConnection, pEntInf->pName, pEntInf->pName->structLen );
    DPRINT1( 5, "Parsing connection %ls.\n", m_pdnConnection->StringName );

    for ( iAttr = 0; iAttr < pEntInf->AttrBlock.attrCount; iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        switch ( pAttr->attrTyp )
        {
        case ATT_ENABLED_CONNECTION:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_fIsEnabled ) );
            memcpy( &m_fIsEnabled, pbVal, sizeof( m_fIsEnabled ) );
            break;

        case ATT_FROM_SERVER:
            Assert( 1 == pAttr->AttrVal.valCount );
            pdnSourceDSA = (DSNAME*) pbVal;
            break;

        case ATT_OPTIONS:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_dwOptions ) );
            memcpy( &m_dwOptions, pbVal, sizeof( m_dwOptions ) );
            break;

        case ATT_SCHEDULE:
            Assert( 1 == pAttr->AttrVal.valCount );
            if( IS_VALID_SCHEDULE((PSCHEDULE) pbVal) ) {

                // Schedule is okay. Load it into the cache and store it in
                // this connection object.
                m_toplSchedule = ToplScheduleImport(
                    gpDSCache->GetScheduleCache(),
                    (PSCHEDULE) pbVal );

            } else {
                // improper schedule format - default schedule used; complain 
                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_CHK_BAD_SCHEDULE,
                    szInsertDN( m_pdnConnection ),
                    0,
                    0
                    );

                DPRINT1(
                    0,
                    "The value of the schedule attribute on the connection "
                        "object %ls is invalid.  A default schedule will be "
                        "substituted.\n",
                    m_pdnConnection->StringName
                    );

                m_toplSchedule = NULL;
            }
            break;

        case ATT_WHEN_CREATED:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_timeCreated ) );
            memcpy( &m_timeCreated, pbVal, sizeof( m_timeCreated ) );
            break;

        case ATT_TRANSPORT_TYPE:
            Assert( 1 == pAttr->AttrVal.valCount );
            m_pdnTransport = (DSNAME*) new BYTE[ cbVal ];
            memcpy( m_pdnTransport, pbVal, cbVal );
            break;

        case ATT_MS_DS_REPLICATES_NC_REASON:
            m_pOldNCs = new DN_AND_REASON[ pAttr->AttrVal.valCount ];
            m_cOldNCs = pAttr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cOldNCs; iAttrVal++ )
            {
                SYNTAX_DISTNAME_BINARY *pdnb;
                DSNAME *pdn;
                SYNTAX_ADDRESS *psa;
                DWORD  dwTemp;

                pdnb = (SYNTAX_DISTNAME_BINARY *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;

                // Retrieve the dsname part.
                pdn = NAMEPTR(pdnb);
                m_pOldNCs[ iAttrVal ].dn = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_pOldNCs[ iAttrVal ].dn, pdn, pdn->structLen );

                // Extract the binary blob part                
                psa = DATAPTR(pdnb);
                
                // Check that the binary blob is at least as long as we expect.
                Assert(psa->structLen >= 2*sizeof(DWORD)); // Length + Data DWORD
                if( psa->structLen < 2*sizeof(DWORD) ) {
                    KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
                }
                
                // Copy the data to a temp variable to avoid alignment problems,
                // then convert to 'host' byte-ordering.
                memcpy(&dwTemp, &psa->byteVal[0], sizeof(DWORD));
                m_pOldNCs[ iAttrVal ].reason = (DWORD) ntohl(dwTemp);
            }
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    // Initialize the DSA. We have the guidded DSA name. The problem is that
    // the DSA lists are site specific, and we don't have a pSite, so we
    // have to compute one.

    // Defense against deleted DSA's. We look up the DSA by guid in the cache.
    // The DSA should not be in the cache if it is deleted, since the
    // cache is populated using a search of the site servers container, and a
    // deleted DSA would reside in the deleted objects container.

    if (pdnSourceDSA) {
        KCC_SITE *pSite;
        DSNAME *pdnSourceSite;

        // Allocate a DSNAME for the site name
        pdnSourceSite = (DSNAME *) new BYTE[ pdnSourceDSA->structLen ];

        // Syntactically convert the DSA DN to a Site DN without a guid
        TrimDSNameBy(pdnSourceDSA, 3, pdnSourceSite);

        // Guid-less name lookup is ok here
        pSite = gpDSCache->GetSiteList()->GetSite( pdnSourceSite );
        // pSite may be NULL if site renamed concurrently

        delete [] pdnSourceSite;

        if (pSite) {
            m_pSourceDSA = pSite->GetDsaList()->GetDsa( pdnSourceDSA );
            // m_pSourceDSA may be null if DSA not found, deleted, etc.
        }
    }

    if ( IsValid() )
    {
        // A connection object must store the DN of its destination DSA,
        // (including the GUID). In order to find the DN+GUID, we trim the name and
        // read the directory. This presents a race condition, since the connection
        // object and the destination DSA are read from the directory in two
        // transations. If we postpone construction of the destination DSA DN until
        // it is needed (i.e. read on demand) then we increase the severity of the
        // race condition. We mitigate the severity by reading it as soon as possible.
        GetDestinationDSADN();

        // We don't want to permit KCC-Generated connection with the NEVER
        // schedule. If we see this, we set it to the Always schedule.
        if( IsGenerated() && ToplScheduleDuration(m_toplSchedule)==0 ) {
            m_toplSchedule = ToplGetAlwaysSchedule( gpDSCache->GetScheduleCache() );
        }

        return TRUE;
    }
    else
    {
        // WARNING: A FALSE return implies the KCC_CONNECTION_LIST::Init()
        // routine should delete this NTDS-Connection object from the DIT.
        DPRINT1( 4, "Connection %ls is invalid.\n", m_pdnConnection->StringName );
        return FALSE;
    }
}

DWORD
KCC_CONNECTION::Add(
    DSNAME *    pdnDestinationDSA
    )
//
// Convert to an NTDS-Connection DS object and write it to the DS.
// If the connection object DN has not been set, it will be constructed
// from the pdnDSA argument and a unique RDN.
//
{
    ULONG           dirError;
    DWORD           WinError;
    DWORD           dwConnectionClass = CLASS_NTDS_CONNECTION;
    ATTRBLOCK       AttrBlock;
    ATTR            rgAttr[ 6 ];
    ATTRVALBLOCK    rgAttrValBlock[ 6 ];
    ATTRVAL         rgAttrVal[ 6 ];
    DSNAME *        pdnSourceDSA;

    ASSERT_VALID( this );

    Assert( NTDSCONN_OPT_IS_GENERATED & m_dwOptions );

    if ( NULL == m_pdnConnection )
    {
        //
        // Generate unique RDN.
        //

        RPC_STATUS      rpcStatus;
        UUID            uuid;
        UCHAR *         pszUuid;
        WCHAR           rgchRdn[ MAX_RDN_SIZE ];
        DWORD           cchRdn;

        rpcStatus = UuidCreate( &uuid );
        
        // Note: Global uniqueness is not really critical here -- we only seek
        // to make sure the RDN is unique in its container.  Thus, "local only"
        // UUIDs are okay.  (If a collision occurs, the add will fail, and we'll
        // try again next time -- with a different UUID.)

        if (    ( RPC_S_OK              != rpcStatus )
             && ( RPC_S_UUID_LOCAL_ONLY != rpcStatus )
           )
        {
            KCC_EXCEPT( rpcStatus, 0 );
        }

        rpcStatus = UuidToString( &uuid, &pszUuid );
        if ( RPC_S_OK != rpcStatus )
        {
            KCC_EXCEPT( rpcStatus, 0 );
        }

        cchRdn = MultiByteToWideChar(
                    CP_TELETEX,
                    0,
                    (char *) pszUuid,
                    -1,
                    rgchRdn,
                    sizeof( rgchRdn ) / sizeof( rgchRdn[ 0 ] )
                    );
        if ( 0 == cchRdn )
        {
            KCC_EXCEPT( GetLastError(), 0 );
        }
        DWORD cbConnectionDN =  pdnDestinationDSA->structLen +
                      ( MAX_RDN_SIZE+MAX_RDN_KEY_SIZE )*sizeof(WCHAR);
        m_pdnConnection = (DSNAME *) new BYTE[ cbConnectionDN ];
        AppendRDN( pdnDestinationDSA,
                  m_pdnConnection,
                  cbConnectionDN,
                  rgchRdn,
                  cchRdn - 1,
                  ATT_COMMON_NAME );
    }

    //
    // Add NTDS-Connection object to the DS.
    //
    ULONG cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
    PSCHEDULE pSchedule;
    Assert( scheduleCache );
    pSchedule = ToplScheduleExportReadonly( scheduleCache, m_toplSchedule );
    Assert( pSchedule );

    pdnSourceDSA = m_pSourceDSA->GetDsName();

    AttrBlock.attrCount = 6;
    AttrBlock.pAttr     = new ATTR [AttrBlock.attrCount];

    AttrBlock.pAttr[ 0 ].attrTyp          = ATT_ENABLED_CONNECTION;
    AttrBlock.pAttr[ 0 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 0 ].AttrVal.pAVal    = &rgAttrVal[ 0 ];
    rgAttrVal[ 0 ].valLen                 = sizeof( m_fIsEnabled );
    rgAttrVal[ 0 ].pVal                   = (BYTE *) &m_fIsEnabled;

    AttrBlock.pAttr[ 1 ].attrTyp          = ATT_FROM_SERVER;
    AttrBlock.pAttr[ 1 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 1 ].AttrVal.pAVal    = &rgAttrVal[ 1 ];
    rgAttrVal[ 1 ].valLen                 = pdnSourceDSA->structLen;
    rgAttrVal[ 1 ].pVal                   = (BYTE *) pdnSourceDSA;

    AttrBlock.pAttr[ 2 ].attrTyp          = ATT_OPTIONS;
    AttrBlock.pAttr[ 2 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 2 ].AttrVal.pAVal    = &rgAttrVal[ 2 ];
    rgAttrVal[ 2 ].valLen                 = sizeof( m_dwOptions );
    rgAttrVal[ 2 ].pVal                   = (BYTE *) &m_dwOptions;

    AttrBlock.pAttr[ 3 ].attrTyp          = ATT_SCHEDULE;
    AttrBlock.pAttr[ 3 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 3 ].AttrVal.pAVal    = &rgAttrVal[ 3 ];
    rgAttrVal[ 3 ].valLen                 = cbSchedule;
    rgAttrVal[ 3 ].pVal                   = (BYTE *) pSchedule;

    AttrBlock.pAttr[ 4 ].attrTyp          = ATT_OBJECT_CLASS;
    AttrBlock.pAttr[ 4 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 4 ].AttrVal.pAVal    = &rgAttrVal[ 4 ];
    rgAttrVal[ 4 ].valLen                 = sizeof( dwConnectionClass );
    rgAttrVal[ 4 ].pVal                   = (BYTE *) &dwConnectionClass;

    if ( m_pdnTransport )
    {
        AttrBlock.pAttr[ 5 ].attrTyp          = ATT_TRANSPORT_TYPE;
        AttrBlock.pAttr[ 5 ].AttrVal.valCount = 1;
        AttrBlock.pAttr[ 5 ].AttrVal.pAVal    = &rgAttrVal[ 5 ];
        rgAttrVal[ 5 ].valLen                 = m_pdnTransport->structLen;
        rgAttrVal[ 5 ].pVal                   = (BYTE *) m_pdnTransport;
    }
    else
    {
        //
        // No transport type attribute to add
        //
        AttrBlock.attrCount--;
    }


    dirError = KccAddEntry( m_pdnConnection, &AttrBlock );
    if (dirError != 0 ) {
        KCC_LOG_ADDENTRY_FAILURE( m_pdnConnection, dirError );
    }
    
    return dirError;
}


DWORD
KCC_CONNECTION::UpdateDS()
//
// Update the ntdsConnection object in the DS with recent changes made to the
// in-memory KCC_CONNECTION representation.
//
{
    ATTRMODLIST rgMods[3] = {0};
    ATTRVAL     rgAttrVals[3] = {0};
    DWORD       dirError;
    USHORT      cNumMods = 0;
    const DWORD cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    PSCHEDULE   pSchedule;


    Assert(m_fUpdatedOptions
           || m_fUpdatedSchedule 
           || m_fUpdatedTransport);

    if (m_fUpdatedOptions) {
        rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
        rgMods[cNumMods].AttrInf.attrTyp          = ATT_OPTIONS;
        rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
        rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
        
        rgAttrVals[cNumMods].valLen = sizeof(m_dwOptions);
        rgAttrVals[cNumMods].pVal   = (BYTE *) &m_dwOptions;

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }
    
    if (m_fUpdatedSchedule) {
        TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
        Assert( scheduleCache );
        pSchedule = ToplScheduleExportReadonly( scheduleCache, m_toplSchedule );
        Assert( pSchedule );
        
        rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
        rgMods[cNumMods].AttrInf.attrTyp          = ATT_SCHEDULE;
        rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
        rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
        
        rgAttrVals[cNumMods].valLen = cbSchedule;
        rgAttrVals[cNumMods].pVal   = (BYTE *) pSchedule;

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }

    if (m_fUpdatedTransport) {
        if (NULL == m_pdnTransport) {
            // Transport removed (i.e., changed from inter-site to intra-site).
            rgMods[cNumMods].choice          = AT_CHOICE_REMOVE_ATT;
            rgMods[cNumMods].AttrInf.attrTyp = ATT_TRANSPORT_TYPE;
        } else {
            // Transport added/updated.
            rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
            rgMods[cNumMods].AttrInf.attrTyp          = ATT_TRANSPORT_TYPE;
            rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
            rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
            
            rgAttrVals[cNumMods].valLen = m_pdnTransport->structLen;
            rgAttrVals[cNumMods].pVal   = (BYTE *) m_pdnTransport;
        }

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }
        
    Assert(cNumMods <= ARRAY_SIZE(rgMods));
    Assert(cNumMods <= ARRAY_SIZE(rgAttrVals));

    dirError = KccModifyEntry(GetConnectionDN(), cNumMods, rgMods);

    if (0 == dirError) {
        // Success.
        DPRINT1(0, "Updated connection object %ws.\n",
                GetConnectionDN()->StringName);
        m_fUpdatedOptions = m_fUpdatedSchedule = m_fUpdatedTransport = FALSE;
    } else {
        // Failure.
        KCC_LOG_MODIFYENTRY_FAILURE(GetConnectionDN(), dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    return dirError;
}


KCC_CONNECTION &
KCC_CONNECTION::SetTransport(
        IN DSNAME *pdn
        )
// Set transport associated with this connection.
{
    m_pdnTransport = pdn;

    m_fUpdatedTransport = TRUE;
    
    return *this;
}

DSNAME*
KCC_CONNECTION::GetTransportDN()
// Get the transport associated with this connection.
{
    return m_pdnTransport;
}

DWORD
KCC_CONNECTION::Remove(
        VOID
        )
//
// Remove the connection object from the ds. Note that the in memory copy of the
// object remains.
//
{
    ULONG dirError;

    ASSERT_VALID( this );

    dirError = KccRemoveEntry( m_pdnConnection );
    if (0 == dirError) {
        // Success.
        DPRINT1(0, "Deleted connection object %ls from the database.\n",
                GetConnectionDN()->StringName);
        
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CONNECTION_OBJECT_DELETED,
                 szInsertDN(GetSourceDSADN()),
                 szInsertDN(GetDestinationDSADN()),
                 0);
    }
    else {
        // Failure.
        KCC_LOG_REMOVEENTRY_FAILURE( m_pdnConnection, dirError );

        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CONNECTION_OBJECT_DELETION_FAILED,
                 szInsertDN(GetSourceDSADN()),
                 szInsertDN(GetDestinationDSADN()),
                 0);
    }

    return dirError;
}

void
KCC_CONNECTION::UpdateLink(
    IN  KCC_LINK *              plink,
    IN  KCC_CROSSREF *          pCrossRef,
    IN  DSNAME *                pdnLocalSite,
    IN  KCC_TRANSPORT_LIST *    pTransportList
    )
//
// Update pre-existing repsFrom link to reflect the state of this connection
// object.
//
{
    BOOL fUpdateLink = FALSE;
    BOOL fIsDSRPCReplica;
    BOOL fInSameSite;
    DWORD cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    SCHEDULE *pSchedule = (SCHEDULE *) alloca(cbSchedule);
    DSNAME *pdnNC = pCrossRef->GetNCDN();
    TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
    
    ASSERT_VALID( this );
    Assert( scheduleCache );
    Assert(0 == memcmp(plink->GetDSAUUID(), &GetSourceDSADN()->Guid, sizeof(GUID)));

    if (IsGenerated() && IsIntrasite()) {
        // Auto-generated, intra-site connection.
        
        Assert( gfIntrasiteSchedInited );
        if (!ToplScheduleIsEqual(scheduleCache,
                                 m_toplSchedule,
                                 gpIntrasiteSchedule))
        {
            // The auto-generated, intra-site connection object has the wrong
            // schedule.  Update it.
            ATTRMODLIST rgMods[1] = {0};
            ATTRVAL     AttrVal;
            ULONG       dirError;
        
            Assert( gfIntrasiteSchedInited );
            SetSchedule(gpIntrasiteSchedule);

            UpdateDS();

            DPRINT1(0, "Updated intra-site schedule on %ls.\n",
                    GetConnectionDN()->StringName);

            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_UPDATED_SCHEDULE,
                     szInsertDN(GetConnectionDN()),
                     szInsertDN(GetSourceDSADN()),
                     szInsertDN(GetDestinationDSADN()));
        }
    }

    REPLTIMES *linkRT, *connRT;

    linkRT = plink->GetSchedule();
    connRT = KccConvertToplScheduleToReplTimes( m_toplSchedule );

    if ( 0 != memcmp( linkRT, connRT, sizeof(REPLTIMES) ) )
    {
        // update schedule
        DPRINT2(
            0,
            "Updating schedule in Reps-From %hs on %ls.\n",
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetSchedule( connRT );
        fUpdateLink = TRUE;
    }

    // Free the REPLTIMES structure that was allocated
    delete[] connRT;

    if ( plink->IsEnabled() != IsEnabled() )
    {
        // update enabled flag
        DPRINT3(
            0,
            "Changing Enabled flag to 0x%x in Reps-From %hs on %ls.\n",
            IsEnabled(),
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetEnabled( IsEnabled() );
        fUpdateLink = TRUE;
    }

    if ( IsIntrasite() )
    {
        // DSAs in the same site always replicate via DS RPC
        fIsDSRPCReplica = TRUE;
        fInSameSite = TRUE;
    }
    else
    {
        // DSAs in different sites can replicate via RPC or mail.
        // Intersite IP connections send/receive using DS RPC,
        // though we still use the ISM IP plug-in for topology
        // queries.
        fIsDSRPCReplica = (NULL == GetTransportDN())
                          || IsOverIntersiteIP();
        fInSameSite = FALSE;
    }

    if ( fIsDSRPCReplica != plink->IsDSRPCReplica() )
    {
        // update mail replica flag
        DPRINT3(
            0,
            "Changing Is-DS-RPC-Replica flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsDSRPCReplica,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetDSRPCReplica( fIsDSRPCReplica );
        fUpdateLink = TRUE;
    }

    DSNAME * pdnTransport = NULL;

    if (fIsDSRPCReplica) {
        // fIsDSRPCReplica trumps GetTransportDN()
        Assert( pdnTransport == NULL );

        // Note that the call to UpdateRepsFromRef in ReplicateNC expects that
        // the transport uuid is fNullUuid for RPC-based links
        if (!fNullUuid( plink->GetTransportUUID() )) {
            // update transport
            DPRINT2(
                0,
                "Changing transport in Reps-From %hs on %ls to NULL for RPC link.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName
                );
            plink->SetTransportUUID( &gNullUuid );
            fUpdateLink = TRUE;
        }
    } else {
        pdnTransport = GetTransportDN();
        Assert( pdnTransport != NULL );
        if ( (pdnTransport != NULL) &&
             (0 != memcmp(&pdnTransport->Guid,
                          plink->GetTransportUUID(),
                          sizeof(UUID)))) {
            // update transport
            DPRINT3(
                0,
                "Changing transport in Reps-From %hs on %ls to %ls.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName,
                pdnTransport->StringName
                );
            plink->SetTransportUUID( &pdnTransport->Guid );
            fUpdateLink = TRUE;
        }
    }

    BOOL fIsPeriodic = ( 0 != ToplScheduleDuration(m_toplSchedule) );
    if ( fIsPeriodic != plink->IsPeriodicSynced() )
    {
        // update periodic flag
        DPRINT3(
            0,
            "Changing Periodic-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsPeriodic,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetPeriodicSync( fIsPeriodic );
        fUpdateLink = TRUE;
    }

    BOOL fUseCompression=IsCompressionEnabled();
    if ( fUseCompression != plink->UsesCompression() )
    {
        // update compression flag
        DPRINT3(
            0,
            "Changing Use-Compression flag to 0x%x in Reps-From %hs on %ls.\n",
            fUseCompression,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetCompression( fUseCompression );
        fUpdateLink = TRUE;
    }

    BOOL fIsNeverNotified = !UsesNotification();

    if ( fIsNeverNotified != plink->IsNeverNotified() )
    {
        // update is-never-notified flag
        DPRINT3(
            0,
            "Changing Is-Never-Notified flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsNeverNotified,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetNeverNotified( fIsNeverNotified );
        fUpdateLink = TRUE;
    }

    BOOL fIsInitSync = fInSameSite;

    if ( fIsInitSync != plink->IsInitSynced() )
    {
        // update init-sync flag
        DPRINT3(
            0,
            "Changing Init-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsInitSync,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetInitSync( fIsInitSync );
        fUpdateLink = TRUE;
    }

    if (IsTwoWaySynced() != plink->IsTwoWaySynced()) {
        // update two-way-synced flag
        DPRINT3(0,
                "Changing Two-Way-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
                IsTwoWaySynced(),
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName);
        plink->SetTwoWaySync(IsTwoWaySynced());
        fUpdateLink = TRUE;
    }

    KCC_TRANSPORT * pTransport
        = (NULL == pdnTransport)
            ? NULL
            : pTransportList->GetTransport(pdnTransport);

    MTX_ADDR *pmtx = m_pSourceDSA->GetMtxAddr(pTransport);

    if (    ( NULL != pmtx )
         && !MtxSame( plink->GetDSAAddr(), pmtx )
       )
    {
        // update source dsa address
        DPRINT3(
            0,
            "Changing Mtx-Addr flag to %hs in Reps-From %hs on %ls.\n",
            pmtx->mtx_name,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetDSAAddr( pmtx );
        fUpdateLink = TRUE;
    }

    if ( fUpdateLink )
    {
        DWORD draError = plink->Update( pdnNC, ATT_REPS_FROM );

        if ( DRAERR_Success == draError )
        {
            DPRINT2(
                0,
                "Successfully updated link to %hs in Reps-From on %ls.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName
                );
        }
        else
        {
            DPRINT3(
                0,
                "Failed to update link to %hs in Reps-From on %ls, DRA error %d.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName,
                draError
                );
        }
    }
}

BOOL
KCC_CONNECTION::ShouldSkipDraAdd(
    KCC_DSA *pRemoteDSA,
    DWORD   *pdwDraError OPTIONAL
    )
//
// Check the connection failure cache for any failures communicating with
// pRemoteDSA. If an error has already occurred during this run of the KCC,
// then we decide to skip the DirReplicaAdd() since it is quite likely we will
// hit the same error again (and thus have to wait for the DirReplicaAdd() call
// to timeout).
// 
{
    DWORD draError;
    BOOL  fErrorOccurredThisRun;

    if( ! gConnectionFailureCache.Get( pRemoteDSA->GetDsName(),
                                       NULL, /* TimeSinceFirstAttempt */
                                       NULL, /* NumberOfFailures */
                                       NULL, /* fUserNotifiedOfStaleness */
                                       &draError,
                                       &fErrorOccurredThisRun ) )
    {
        // No error in the cache, so we shouldn't skip DirReplicaAdd()
        return FALSE;
    }

    if( !fErrorOccurredThisRun ) {
        // The error in the cache didn't happen during this run of the KCC
        // so we don't want to skip the DirReplicaAdd().
        return FALSE;
    }

    switch( draError ) {
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_S_SERVER_TOO_BUSY:
        case ERROR_DS_DNS_LOOKUP_FAILURE:
            // These transient errors might cause DirReplicaAdd() to take
            // a long time.
            if( pdwDraError ) {
                *pdwDraError = draError;
            }
            return TRUE;
        default:
            return FALSE;
    }

    return FALSE;
}


void
KCC_CONNECTION::AddLink(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  BOOL                    fIsLocalMaster,
    IN  DSNAME *                pdnLocalSite,
    IN  KCC_DSA *               pLocalDSA,
    IN  KCC_DSA *               pRemoteDSA,
    IN  KCC_TRANSPORT_LIST *    pTransportList
    )
//
// Derive new repsFrom link from this connection object.
//
{
    DSNAME *pdnNC = pCrossRef->GetNCDN();
    BOOL fInSameSite = IsIntrasite();
    BOOL fIsDSRPCReplica;

    DPRINT3( 3, "AddLink: nc %ws isLocMaster:%d remote:%ws\n",
             pdnNC->StringName,
             fIsLocalMaster,
             pRemoteDSA->GetDsName()->StringName );

    if ( fInSameSite )
    {
        // DSAs in the same site always replicate via DS RPC
        fIsDSRPCReplica = TRUE;
        fInSameSite = TRUE;
    }
    else
    {
        // DSAs in different sites can replicate via RPC or mail.
        // Intersite IP connections send/receive using DS RPC,
        // though we still use the ISM IP plug-in for topology
        // queries.
        fIsDSRPCReplica = (NULL == GetTransportDN())
                          || IsOverIntersiteIP();
        fInSameSite = FALSE;
    }

    DSNAME * pdnTransport = GetTransportDN();
    KCC_TRANSPORT * pTransport
        = (NULL == pdnTransport)
            ? NULL
            : pTransportList->GetTransport(pdnTransport);
    LPWSTR pszTransportAddr = pRemoteDSA->GetTransportAddr(pTransport);
    LPWSTR pszLocalTransportAddr = pLocalDSA->GetTransportAddr(pTransport);
    
    if ( (NULL != pszTransportAddr) &&
         (NULL != pszLocalTransportAddr) ) {
        BOOL            fIsPeriodic;
        DWORD           dwOptions = DRS_ASYNC_REP;

        // See comments in UpdateLink regarding periodic sync criteria
        fIsPeriodic = ( 0 != ToplScheduleDuration(m_toplSchedule) );
        if ( fIsPeriodic )
        {
            // connection has a non-empty schedule, so we periodically sync
            dwOptions |= DRS_PER_SYNC;
        }

        if ( !fInSameSite )
        {
            if(IsCompressionEnabled()) {
                dwOptions |= DRS_USE_COMPRESSION;
            }
            if (!fIsDSRPCReplica) {
                dwOptions |= DRS_MAIL_REP;
            }
        }
        else
        {
            // sync RPC-based replicas on startup, too
            dwOptions |= DRS_INIT_SYNC;
        }

        if ( fIsLocalMaster )
        {
            dwOptions |= DRS_WRIT_REP;
        }

        if (IsTwoWaySynced()) {
            dwOptions |= DRS_TWOWAY_SYNC;
        }
    
        if (!UsesNotification()) {
            dwOptions |= DRS_NEVER_NOTIFY;
        }
    
        
        // Don't try to add the replica link if we have previously encountered
        // a transient error while contacting this DSA.
        DWORD draError;
        if( ShouldSkipDraAdd(pRemoteDSA, &draError) )
        {          
            DPRINT3(
                1,
                "Didn't try to add link for %ls from %ls due to previous error %d.\n",
                pdnNC->StringName,
                pszTransportAddr,
                draError
                );

            LogEvent8WithData(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_KCC_SKIPPED_DIRREPLICAADD,
                szInsertDN( pdnNC ),
                szInsertWC( pszTransportAddr ),
                szInsertWin32Msg( draError ),
                szInsertDN( pRemoteDSA->GetDsName() ),
                pdnTransport ? szInsertDN(pdnTransport) : szInsertSz(""),
                NULL,
                NULL,
                NULL,
                sizeof( draError ),
                &draError );
        
        } else {
            
            // DirReplicaAdd takes its schedules as REPLTIMES.
            // We convert our TOPL_SCHEDULE here.
            REPLTIMES* pRT;
            pRT = KccConvertToplScheduleToReplTimes(m_toplSchedule);
            Assert( NULL!=pRT );

            draError = DirReplicaAdd(
                            pdnNC,
                            pRemoteDSA->GetDsName(),
                            pdnTransport,
                            pszTransportAddr,
                            NULL,
                            pRT,
                            dwOptions
#ifdef KCC_PERF_TEST
                                // When doing KCC testing, don't want DirReplicaAdd to block
                                // when adding IP links. So we initially make them as SMTP
                                // links, // then they will get repaired on the second run. This
                                // is just a temporary workaround.
                                | DRS_ASYNC_REP | DRS_MAIL_REP
#endif
                            );

            // Free the REPLTIMES structure that was allocated.
            delete[] pRT;

            if ( DRAERR_Success == draError )
            {
                DPRINT3(
                    0,
                    "Added link for %ls from %ls with options 0x%x.\n",
                    pdnNC->StringName,
                    pszTransportAddr,
                    dwOptions
                    );

                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    fIsLocalMaster
                      ? DIRLOG_CHK_LINK_ADD_MASTER_SUCCESS
                      : DIRLOG_CHK_LINK_ADD_REPLICA_SUCCESS,
                    szInsertDN( pdnNC ),
                    szInsertDN( pRemoteDSA->GetDsName() ),
                    NULL);

                //
                // Remove this server from the list of servers that have
                // failed in the past
                //
                gConnectionFailureCache.Remove( pRemoteDSA->GetDsName() );

            }
            else
            {
                DPRINT4(
                    0,
                    "Failed to add link for %ls from %ls with options 0x%x, error %d.\n",
                    pdnNC->StringName,
                    pszTransportAddr,
                    dwOptions,
                    draError
                    );

                LogEvent8WithData(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    fIsLocalMaster
                      ? DIRLOG_CHK_LINK_ADD_MASTER_FAILURE
                      : DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE,
                    szInsertDN( pdnNC ),
                    szInsertWC( pszTransportAddr ),
                    szInsertWin32Msg( draError ),
                    szInsertDN( pRemoteDSA->GetDsName() ),
                    pdnTransport ? szInsertDN(pdnTransport) : szInsertSz(""),
                    NULL,
                    NULL,
                    NULL,
                    sizeof( draError ),
                    &draError );

                //
                // Add this server from the list of servers with whom
                // we have failed to initiate a link with
                //
                if ( !gConnectionFailureCache.Add(pRemoteDSA->GetDsName(), draError, FALSE) )
                {
                    DPRINT1(
                        3,
                        "Failed to add %ws in gConnectionFailureCache\n",
                        pszTransportAddr
                        );

                }
            }       // End DirReplicaAdd() failed
        }       // End No Cached RPC Failure

    } else {
        // We've committed to a certain connection and transport, but one
        // of the dsas is not configured for it. Error out.
        // If we could back out and try another connection, we should.
        // It would be better if we didn't get to this point, and instead
        // decided earlier on not to use this transport.
        // Do we need a way to tell the user that we could use a given transprt
        // if he would only configure it on the dsas?

        // JeffParh 03-19-99: This should never happen for auto-generated
        // connections.  We should have verified that the source and destination
        // bridgeheads supported the transport in KccGetNcBridgeheadForTransport.

        DPRINT3( 0, "Failed to add link for %ws from %ws, transport %ws because transport-specific address is missing!\n",
                 pdnNC->StringName,
                 pRemoteDSA->GetDsName()->StringName,
                 pdnTransport->StringName );
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_TRANSPORT_ADDRESS_MISSING,
            szInsertDN( pdnNC ),
            szInsertDN( pRemoteDSA->GetDsName() ),
            szInsertDN( pdnTransport ) );
    }
}

// Register an NC as being replicated over this connection.
void
KCC_CONNECTION::AddReplicatedNC(
    IN  DSNAME * pNC,
    IN  BOOL     fGCTopology
    )
{
    KCC_REPLICATED_NC * pReplNC;

    pReplNC = m_ReplicatedNCArray.Find(pNC);

    if (NULL == pReplNC) {
        // No entry yet exists.
        pReplNC = new KCC_REPLICATED_NC;
    
        pReplNC->pNC = pNC;
        pReplNC->fReadOnly = fGCTopology;

        m_ReplicatedNCArray.Add(pReplNC);
    }
    else {
        // Entry already exists -- update it if necessary.
        if (!fGCTopology && pReplNC->fReadOnly) {
            // This connection used to replicate both writeable and read-only.
            pReplNC->fReadOnly = FALSE;
        }
    }
}

// Enumerate the NCs replicated over this connection (as previously
// registered via AddReplicatedNC()).
DSNAME *
KCC_CONNECTION::GetReplicatedNC(
    IN  DWORD    iNC,
    OUT BOOL *   pfGCTopology
    )
{
    DSNAME * pNC = NULL;

    if (iNC < m_ReplicatedNCArray.GetCount()) {
        KCC_REPLICATED_NC * pReplNC = m_ReplicatedNCArray[iNC];
        pNC = pReplNC->pNC;
        *pfGCTopology = pReplNC->fReadOnly;
    }

    return pNC;
}

// Return the number of replicated NCs that are writeable.
DWORD
KCC_CONNECTION::GetReplicatedWriteableNCCount()
{
    DWORD cReplNCCount = m_ReplicatedNCArray.GetCount();
    DWORD cWriteable = 0;
    DWORD i;

    for (i = 0; i < cReplNCCount; i++) {
        if (!m_ReplicatedNCArray[i]->fReadOnly) {
            cWriteable++;
        }
    }

    return cWriteable;
}

// Is the connection used by the given naming context?
//
// There are two special cases:
// 1. Schema does not appear specifically. It is assumed that if Config
//    is replicated, schema is also
// 2. Admin generated connections are assumed to carry all common ncs
//
// Note that you should not use this to filter which which replica links
// should be created on behalf of which connections. Applications make
// assumptions that each connection may replicate all common NC's.
//
BOOL
KCC_CONNECTION::ReplicatesNC(
    IN KCC_CROSSREF *pCrossRef
    )
{
    if (!IsGenerated()) {
        // Admin generated connections carry all common, compatible nc's
        return TRUE;
    } else {
        DSNAME *pNC;

        // If they ask for Schema, use Config since they share the same topology
        if (pCrossRef->GetNCType() == KCC_NC_TYPE_SCHEMA) {
            pNC = gpDSCache->GetConfigNC();
        } else {
            pNC = pCrossRef->GetNCDN();
        }

        return (m_ReplicatedNCArray.IsElementOf( pNC ));
    }
}

// Determine whether the info replicated by this connection is a subset of that
// replicated by the specified connection.
BOOL
KCC_CONNECTION::ReplicatesSubsetOf(
    IN KCC_CONNECTION * pcn2
    )
{
    DWORD cNumReplNCs1 = m_ReplicatedNCArray.GetCount();
    DWORD cNumReplNCs2 = pcn2->m_ReplicatedNCArray.GetCount();
    BOOL fIsSubset;

    if (cNumReplNCs1 > cNumReplNCs2) {
        // *this replicates more NCs, so it can't be a subset.
        fIsSubset = FALSE;
    }
    else {
        DWORD iReplNC1, iReplNC2;

        m_ReplicatedNCArray.Sort();
        pcn2->m_ReplicatedNCArray.Sort();

        fIsSubset = TRUE;
        iReplNC2 = 0;
        for (iReplNC1 = 0; iReplNC1 < cNumReplNCs1; iReplNC1++) {
            KCC_REPLICATED_NC * pReplNC1 = m_ReplicatedNCArray[iReplNC1];
            KCC_REPLICATED_NC * pReplNC2;
            int nDiff;

            if (iReplNC2 >= cNumReplNCs2) {
                // Remaining NC(s) replicated by 1 are not replicated by 2.
                // 1 is not a subset of 2.
                fIsSubset = FALSE;
                break;
            }

            // Skip over NCs replicated by 2 that are not replicated by 1 --
            // they're irrelevant.

            do {
                pReplNC2 = pcn2->m_ReplicatedNCArray[iReplNC2++];
            } while (((nDiff = CompareDsName(&pReplNC2->pNC, &pReplNC1->pNC))
                      < 0)
                     && (iReplNC2 < cNumReplNCs2));

            if (nDiff) {
                // NC replicated by 1 not replicated by 2 -- not a subset.
                fIsSubset = FALSE;
                break;
            }

            Assert(NameMatched(pReplNC1->pNC, pReplNC2->pNC));
            
            if (!pReplNC1->fReadOnly && pReplNC2->fReadOnly) {
                // 1 supports writeable replication of this NC; 2 solely
                // supports read-only -- not a subset.
                fIsSubset = FALSE;
                break;
            }
        }
    }

    return fIsSubset;
}


BOOL
KCC_CONNECTION::IsSourceSiteUnreachable()
/*++

Routine Description:

    This function should only be called after the spanning-tree algorithm has
    completed. If the source site was found to be unreachable from the local
    site for any NC, this function will return TRUE.

Parameters:

    None.

Return value:

    TRUE  - The source site is unreachable.
    FALSE - Otherwise.

--*/
{
    KCC_SITE_LIST   *pSiteList;
    DSNAME          *pdnSourceSite;
    KCC_SITE        *pSourceSite;

    pSiteList = gpDSCache->GetSiteList();
    ASSERT_VALID( pSiteList );

    pdnSourceSite = GetSourceSiteDN();
    Assert( pdnSourceSite );

    pSourceSite = pSiteList->GetSite(pdnSourceSite);
    ASSERT_VALID( pSourceSite );

    return pSourceSite->IsUnreachable();
}


BOOL
KCC_CONNECTION::OnProbation()
/*++

Routine Description:

    When a connection has been newly created, we cannot immediately
    determine if replication is succeeding over this connection.
    
    For example, an ISTG may create a connection inbound to another
    bridgehead server. In order to determine if replication is succeeding
    over this connection, the following steps must occur:

      - The connection must replicate to the bridgehead server
      - The KCC on the bridgehead server must run and fail to create the
        repsFrom more than gcIntersiteLinkFailuresAllowed times.
      - At least gcSecsUntilIntersiteLinkFailure seconds must elapse.
      - The KCC must run on the ISTG and retrieve the staleness entries
        from the bridgehead server.

    Thus, it takes a fair amount of time before we can assert that
    replication is succeeding over a connection.

    When a connection is newly created, it goes 'on probation' for a
    certain period of time. The intention is that, by the time the connection
    is no longer 'on probation', we will have had sufficient time to determined
    whether or not replication is succeeding over that connection.
    
    This function determines if this connection is it its 'probation period'.

Parameters:

    None

Return value:

    TRUE  - Connection is on probation
    FALSE - Connection is not on probation

--*/
{
    DSTIME timeNow, timeCreated, cSecsCalculatedProbation;
    const DWORD MINS_IN_SECS=60;
    
    timeNow = GetSecondsSince1601();
    timeCreated = GetWhenCreated();
    
    // If 'timeCreated' is 0, this connection was created during this run of
    // the KCC and is therefore still in its probation period.
    if( timeCreated==0 ) {
        return TRUE;
    }

    // If the connection was created in the future, we consider it to be _not_
    // on probation. Otherwise, if the administrator set the clocks far into the
    // future, created some connections, and then set the clocks back to normal,
    // the connections would be on probation for a very long time.
    if(timeCreated > timeNow) {
        return FALSE;
    }

    // If this connection was created less than gcConnectionProbationSecs ago,
    // it is therefore still in its probation period.
    if(timeNow-timeCreated < (DSTIME) gcConnectionProbationSecs) {
        return TRUE;
    }

    // At the bare minimum, the KCC must run at least
    // (gcIntersiteLinkFailuresAllowed+1) times plus a fudge factor of 1 hour
    // to determine that a connection is stale.
    cSecsCalculatedProbation = (DSTIME) (60 * MINS_IN_SECS)
        + ((gcIntersiteLinkFailuresAllowed+1) * gcSecsBetweenTopologyUpdates);
    
    // If this connection was created less than cSecsCalculatedProbation ago,
    // it is therefore still in its probation period.
    if(timeNow-timeCreated < cSecsCalculatedProbation ) {
        return TRUE;
    }
    
    return FALSE;
}


BOOL
KCC_CONNECTION::Supercedes(
    IN  KCC_CONNECTION *pcn
    )
/*++

Routine Description:

    Determine if this connection 'supercedes' pcn. The requirements are
    that this connection is not stale and that this connection replicates a
    superset of the NCs that pcn does.

Parameters:

    pcn - The connection to compare against.

Return value:

    TRUE  - this supercedes pcn
    FALSE - Otherwise

--*/
{
    BOOL fOnProbation, fReplicatesSubset, fShouldSupercede;

    fOnProbation = this->OnProbation();
    fReplicatesSubset = pcn->ReplicatesSubsetOf(this);
    fShouldSupercede = ( !this->IsStale() && fReplicatesSubset );

    if( fShouldSupercede ) {

        if( fOnProbation ) {
            // this should supercede pcn but it can't because it's
            // on probation.
            DPRINT2(2,"Connection %ls would supercede %ls but did not "
                      "because it is on probation.\n",
                    this->GetConnectionDN()->StringName,
                    pcn->GetConnectionDN()->StringName);
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_KCC_CONN_ON_PROBATION,
                     szInsertDN(this->GetConnectionDN()),
                     szInsertDN(pcn->GetConnectionDN()),
                     0);
            return FALSE;
        } else {
            // this supercedes pcn and this is not on probation
            return TRUE;
        }

    } else {
        // Does not supercede
        return FALSE;
    }
}


int __cdecl
KCC_CONNECTION::CompareDNAndReason(
    const void *elem1,
    const void *elem2
    )
//
// Compare two DN_AND_REASON elements by their DN.
//
{
    DN_AND_REASON *p1 = (DN_AND_REASON *) elem1;
    DN_AND_REASON *p2 = (DN_AND_REASON *) elem2;
    int nDiff;

    Assert(!fNullUuid(&p1->dn->Guid));
    Assert(!fNullUuid(&p2->dn->Guid));

    nDiff = CompareDsName(&p1->dn, &p2->dn);
    
    return nDiff;
}

BOOL
KCC_CONNECTION::NewNCsSameAsOld(
    void
    )
//
// Determine if the new set of replicated NCs and their reasons are
// identical to the old set of replicated NCs and their reasons.
// To do this, we sort the lists and compare the corresponding elements.
//
{
    DSNAME      *dnOld, *dnNew;
    DWORD       iNC;

    // If the two arrays differ in size, they are obviously not the same.
    if( m_cOldNCs != m_ReplicatedNCArray.GetCount() ) {
        return FALSE;
    }

    // Sort both arrays by the NC DNs
    qsort( m_pOldNCs, m_cOldNCs, sizeof(DN_AND_REASON), CompareDNAndReason );
    m_ReplicatedNCArray.Sort();

    // Now that the arrays are sorted, we can compare their contents one-by-one.
    for( iNC=0; iNC<m_cOldNCs; iNC++ ) {
    
        dnOld = m_pOldNCs[iNC].dn;
        dnNew = m_ReplicatedNCArray[iNC]->pNC;

        // Check that the same NC is in both lists
        if( 0!=CompareDsName(&dnOld,&dnNew) ) {
            return FALSE;
        }

        // Check that the reason has not changed
        if( m_pOldNCs[iNC].reason != m_ReasonForConnection ) {
            return FALSE;
        }
    }

    return TRUE;
}


// The binary data in the replicatesNCReason distname-binary
// Note that each DWORD is encoded in network byte order.
// Another example of distname-binary values is dsamain\src\xdommove.c

#define REASON_BINARY_DATA_SIZE (STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(DWORD)))

void
KCC_CONNECTION::UpdateReason(
    void
    )
//
// Update reason fields in object
//
{
    ATTRMODLIST rgMods[1];
    ULONG       dirError;
    DWORD       cReplNCCount = m_ReplicatedNCArray.GetCount();
    ATTRVAL    *pAttrValNC;
    DWORD       iNC;
    SYNTAX_ADDRESS *pBinaryData = (SYNTAX_ADDRESS *) alloca(REASON_BINARY_DATA_SIZE);
    SYNTAX_DISTNAME_BINARY *pReason;

    
    // We want to avoid updating the reason fields in the DB if the new reasons
    // are identical to the old reasons.
    if( NewNCsSameAsOld() ) {
        DPRINT1(1,
            "Not updating NC reasons for connection %ls because they haven't changed.\n",
            m_pdnConnection->StringName );
        return;
    }
    
    DPRINT3(1,
        "Updated connection %ls with rep nc count %d, reason flags 0x%x.\n",
        m_pdnConnection->StringName,
        cReplNCCount,
        m_ReasonForConnection );
    
    // Fill out binary data
    pBinaryData->structLen = REASON_BINARY_DATA_SIZE;
    // Someday make this reason NC specific. Move inside loop.
    Assert( (((ULONG_PTR)pBinaryData) & 0x3) == 0 );  // DWORD alignment
    *((LPDWORD) &(pBinaryData->byteVal)) = htonl(m_ReasonForConnection);

    memset(rgMods, 0, sizeof(rgMods));

    rgMods[0].choice = ( (0 == cReplNCCount) ? AT_CHOICE_REMOVE_ATT
                                             : AT_CHOICE_REPLACE_ATT );        
    rgMods[0].AttrInf.attrTyp          = ATT_MS_DS_REPLICATES_NC_REASON;
    rgMods[0].AttrInf.AttrVal.valCount = cReplNCCount;
    if (cReplNCCount) {
        pAttrValNC = new ATTRVAL [cReplNCCount];
        rgMods[0].AttrInf.AttrVal.pAVal= pAttrValNC;

        for( iNC = 0; iNC < cReplNCCount; iNC++ ) {
            BOOL fGCTopology;
            DSNAME *pNC = GetReplicatedNC( iNC, &fGCTopology );
            DWORD cbDistNameBinary = DERIVE_NAME_DATA_SIZE( pNC, pBinaryData );

            pReason = (SYNTAX_DISTNAME_BINARY *) new BYTE [cbDistNameBinary];
            BUILD_NAME_DATA( pReason, pNC, pBinaryData );

            pAttrValNC[ iNC ].valLen      = cbDistNameBinary;
            pAttrValNC[ iNC ].pVal        = (LPBYTE) pReason;

            // Supportability logging event 7, dump reason for connection
            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_VERBOSE,
                DIRLOG_KCC_CONNECTION_REPLICATES_NC,
                szInsertDN( GetConnectionDN() ),
                szInsertDN( pNC ),
                szInsertDN( GetTransportDN() ),
                szInsertDN( GetSourceSiteDN() ),
                szInsertUL( GetReasonForConnection() ),
                szInsertUL( fGCTopology ),
                0, 0
                ); 
        }
    }
    // rgMod[0].pNextMod is zero

    dirError = KccModifyEntry(m_pdnConnection,
                              ARRAY_SIZE(rgMods),
                              rgMods);
    if (0 != dirError) {
        KCC_LOG_MODIFYENTRY_FAILURE( m_pdnConnection, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }
}

int __cdecl
KCC_CONNECTION::CompareForRemoval(
    IN  const void *  pv1,
    IN  const void *  pv2
    )
/*++

Routine Description:

    Order the connections by:
    
        increasing source site (as per wcscmp())
        increasing number of writeable NCs supported
        increasing number of read-only NCs supported
        KCC-generated connections come before "created by admin" connections
        stale connections come before non-stale connections
        increasing connection objectGuid
    
Parameters:

    pv1, pv2 -- KCC_CONNECTION **'s of the connections to order.

Returns:

    0   identical
    <0  pcn1 "less than" pcn2
    >0  pcn1 "greater than" pcn2
    
--*/
{
    int nDiff;

    KCC_CONNECTION * pcn1 = *((KCC_CONNECTION **) pv1);
    KCC_CONNECTION * pcn2 = *((KCC_CONNECTION **) pv2);

    Assert(!fNullUuid(&pcn1->GetConnectionDN()->Guid));
    Assert(!fNullUuid(&pcn2->GetConnectionDN()->Guid));

    // Sort first by ascending source site.  Note that the GUIDs are not
    // filled in on the site DNs, so GUID-based order is not currently an option.
    // Shouldn't need to use case-insensitive version, since both names are from
    // the DS and the DS preserves case.  (Case-insensitive compares are much
    // more expensive.)
    nDiff = wcscmp(pcn1->GetSourceSiteDN()->StringName,
                   pcn2->GetSourceSiteDN()->StringName);

    if (0 == nDiff) {
        // Same source site; use ascending number of writeable NCs.
        nDiff = pcn1->GetReplicatedWriteableNCCount()
                - pcn2->GetReplicatedWriteableNCCount();
    }

    if (0 == nDiff) {
        // Same source site, same number of writeable NCs; use ascending number of
        // read-only NCs.
        nDiff = pcn1->GetReplicatedNCCount() - pcn2->GetReplicatedNCCount();
    }

    if (0 == nDiff) {
        // Same source site, same number of writeable/read-only NCs supported;
        // those created by admins sort after those that are KCC-generated.
        nDiff = !pcn1->IsGenerated() - !pcn2->IsGenerated();
    }

    if (0 == nDiff) {
    	// Stale connections can be superceded by non-stale connections, so the
    	// stale connections must come first in the sorted array.
        nDiff = !pcn1->IsStale() - !pcn2->IsStale();
    }

    if (0 == nDiff) {
        // Connections with lower GUID come first.
        nDiff = memcmp(&pcn1->GetConnectionDN()->Guid,
                       &pcn2->GetConnectionDN()->Guid,
                       sizeof(GUID));

        Assert((0 != nDiff) && "Same connection appears twice in list!");
    }
    
    return nDiff;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_CONNECTION_LIST methods
//

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::ComparePConnByDsname(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two connection objects by their source site DSNames. This function
// defines the ordering used by the m_dsnameSearchTree. The parameters a and b
// are pointers to pointers to connection objects.
{
    KCC_CONNECTION *conn1, *conn2;
    DSNAME         *dn1, *dn2;
    int             r;

    Assert( a!=NULL && b!=NULL );

    conn1 = *((KCC_CONNECTION**) a);
    conn2 = *((KCC_CONNECTION**) b);

    ASSERT_VALID( conn1 );
    ASSERT_VALID( conn2 );

    dn1 = conn1->GetConnectionDN();
    dn2 = conn2->GetConnectionDN();

    Assert( dn1!=NULL );
    Assert( dn2!=NULL );

    r = CompareDsName( &dn1, &dn2 );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::CompareSourceDsaTreeEntry(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two nodes in the m_sourceDsaSearchTree by their GUIDs. The
// parameters, a and b, are pointers to SOURCE_DSA_CONN_ARRAYs.
{
    SOURCE_DSA_CONN_ARRAY   *sde1, *sde2;
    int                     r;

    Assert( a!=NULL && b!=NULL );

    sde1 = (SOURCE_DSA_CONN_ARRAY*) a;
    sde2 = (SOURCE_DSA_CONN_ARRAY*) b;

    Assert( !fNullUuid(&sde1->uuid) );
    Assert( !fNullUuid(&sde2->uuid) );
    
    r = memcmp( &sde1->uuid, &sde2->uuid, sizeof(UUID) );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::CompareSourceSiteConnArray(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two nodes in the m_sourceSiteSearchTree by the sites' DSNAMEs.
// The parameters, a and b, are pointers to SOURCE_SITE_CONN_ARRAY's.
{
    SOURCE_SITE_CONN_ARRAY  *sse1, *sse2;
    int                     r;

    Assert( a!=NULL && b!=NULL );

    sse1 = (SOURCE_SITE_CONN_ARRAY*) a;
    sse2 = (SOURCE_SITE_CONN_ARRAY*) b;

    Assert( sse1->siteDN!=NULL );
    Assert( sse2->siteDN!=NULL );

    r = CompareDsName( &sse1->siteDN, &sse2->siteDN );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

PVOID NTAPI
KCC_CONNECTION_LIST::KccTreeAlloc(
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    )
// This function is used to allocate memory by the three search
// trees in the KCC_CONNECTION_LIST class.
{
    return new BYTE[ ByteSize ];
}

VOID NTAPI
KCC_CONNECTION_LIST::KccTreeFree(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    )
// This function is used to deallocate memory by the three search
// trees in the KCC_CONNECTION_LIST class.
{
    delete[] Buffer;
}

void
KCC_CONNECTION_LIST::Reset()
//
// Reset member variables to their pre-Init() state.
// This includes creating the three empty search trees.
//
{
    SOURCE_DSA_CONN_ARRAY      *psde;
    SOURCE_SITE_CONN_ARRAY     *psse;
    KCC_CONNECTION            **ppcn;
    DWORD                       i;
    BOOLEAN                     fSuccess;

    if( m_fTreesInited ) {

        // Clear the dsname search tree
        for( i=0; i<m_ccn; i++ ) {
            fSuccess = RtlDeleteElementGenericTable( &m_dsnameSearchTree, &m_ppcn[i] );
            Assert( fSuccess==TRUE );
        }
        Assert( RtlIsGenericTableEmpty(&m_dsnameSearchTree) );

        // The source dsa search tree is a tree of lists -- each node corresponds
        // to a distinct source dsa and contains a linked list of connections. We
        // must enumerate the tree to find every list, free the list, and then delete
        // the node from the tree.
        while( ! RtlIsGenericTableEmpty(&m_sourceDsaSearchTree) ) {
            psde = (SOURCE_DSA_CONN_ARRAY*) RtlEnumerateGenericTable(
                &m_sourceDsaSearchTree, TRUE );
            Assert( psde!=NULL );
            Assert( psde->numConnections>0 && psde->numConnections<=m_ccn );
            ppcn = psde->connection;
            Assert( NULL!=ppcn );

            fSuccess = RtlDeleteElementGenericTable( &m_sourceDsaSearchTree, psde );
            Assert( fSuccess==TRUE );
            THFree( ppcn );
        }
        Assert( RtlIsGenericTableEmpty(&m_sourceDsaSearchTree) );

        // The sourceSite search tree is a tree of lists -- each node corresponds
        // to a distinct source site and contains a linked list of connections. We
        // must enumerate the tree to find every list, free the list, and then delete
        // the node from the tree.
        while( ! RtlIsGenericTableEmpty(&m_sourceSiteSearchTree) ) {
            psse = (SOURCE_SITE_CONN_ARRAY*) RtlEnumerateGenericTable(
                &m_sourceSiteSearchTree, TRUE );
            Assert( psse!=NULL );
            Assert( psse->numConnections>0 && psse->numConnections<=m_ccn );
            ppcn = psse->connection;
            Assert( NULL!=ppcn );

            fSuccess = RtlDeleteElementGenericTable( &m_sourceSiteSearchTree, psse );
            Assert( fSuccess==TRUE );
            THFree( ppcn );
        }
    }

    m_cnAllocated    = 0;
    m_ccn            = 0;
    m_ppcn           = NULL;
    m_fIsInitialized = FALSE;
    m_fTreesInited   = FALSE;
}

void
KCC_CONNECTION_LIST::InitTrees()
// Initialize the three search trees
{

    RtlInitializeGenericTable(
       &m_dsnameSearchTree,
        ComparePConnByDsname,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );
    RtlInitializeGenericTable(
       &m_sourceDsaSearchTree,
        CompareSourceDsaTreeEntry,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );
    RtlInitializeGenericTable(
       &m_sourceSiteSearchTree,
        CompareSourceSiteConnArray,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );

    m_fTreesInited = TRUE;
}

KCC_CONNECTION *
KCC_CONNECTION_LIST::GetConnection(
    IN  DWORD   iConnection
    )
//
// Retrieve the KCC_CONNECTION object at the given index.
//
{
    KCC_CONNECTION * pcn;

    ASSERT_VALID( this );

    if ( iConnection < m_ccn )
    {
        pcn = m_ppcn[ iConnection ];
        ASSERT_VALID( pcn );
    }
    else
    {
        pcn = NULL;
    }

    return pcn;
}

KCC_CONNECTION *
KCC_CONNECTION_LIST::GetConnectionWithSameGUID(
    IN  KCC_CONNECTION *pConnection
    )
//
// Retrieve the KCC_CONNECTION object which has the same GUID
// as the connection we passed in.
//
{
    KCC_CONNECTION  *pcn;
    KCC_CONNECTION  *pcnReturn = NULL;
    KCC_CONNECTION **ppcn;

    ASSERT_VALID(this);
    ASSERT_VALID(pConnection);
    Assert( !fNullUuid(&pConnection->GetConnectionDN()->Guid) );

    ppcn = (KCC_CONNECTION**) RtlLookupElementGenericTable(
        &m_dsnameSearchTree, &pConnection );

    if( ppcn!=NULL ) {
        pcnReturn = *ppcn;
    }

    return pcnReturn;
}

KCC_CONNECTION*
KCC_CONNECTION_LIST::GetConnectionFromSourceDSAUUID(
    IN  UUID *  puuid
    )
//
// Retrieve a KCC_CONNECTION object with source DSA matching the given
// UUID.  Returns NULL if none found. Note that there could very well
// be more than one matching connection (for example, if there were manually
// created duplicate connections). In the future, if any callers of this
// function actually need to enumerate all matching connections, we will need
// to rewrite this function slightly.
//
{
    SOURCE_DSA_CONN_ARRAY   *pSearchResult, searchKey;

    ASSERT_VALID( this );
    Assert( !fNullUuid(puuid) );

    memcpy( &searchKey.uuid, puuid, sizeof(UUID) );
    pSearchResult = (SOURCE_DSA_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceDsaSearchTree, &searchKey );

    if( pSearchResult!=NULL ) {
        Assert( pSearchResult->numConnections>=1 );
        Assert( NULL!=pSearchResult->connection );
        ASSERT_VALID( pSearchResult->connection[0] );
        return pSearchResult->connection[0];
    }

    return NULL;
}

KCC_CONNECTION_LIST::SOURCE_SITE_CONN_ARRAY*
KCC_CONNECTION_LIST::GetConnectionsFromSite(
    IN  DSNAME * pSourceSiteDN
    )
//
// Retrieve a list of KCC_CONNECTION objects, all of which source from the
// site pSourceSiteDN. Returns NULL if none found.
//
{
    SOURCE_SITE_CONN_ARRAY sseKey, *sseResult;

    Assert( NULL!=pSourceSiteDN );

    // Find this list of connections corresponding to this source site in the
    // source dsa search tree
    sseKey.siteDN = pSourceSiteDN;
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceSiteSearchTree, &sseKey );

    if( sseResult ) {
        // If the list is empty, we would have removed it from the tree
        // in KCC_CONNECTION_LIST::RemoveFromList().
        Assert( sseResult->numConnections!=0 );
    }
    
    return sseResult;
}

BOOL
KCC_CONNECTION_LIST::IsValid()
//
// Is the collection initialized and internally consistent?
//
{
    return m_fIsInitialized;
}

VOID
KCC_CONNECTION_LIST::AddConnectionToSearchTrees(
    IN KCC_CONNECTION* pcn
    )
//
// After adding new connections to the list (either in Init() or
// AddToList()), we must add the new entries to the search trees for
// efficient retrieval. This function adds new connections to all
// three search trees.
//
{
    SOURCE_DSA_CONN_ARRAY     *sdeResult, sdeKey;
    SOURCE_SITE_CONN_ARRAY    *sseResult, sseKey;
    BOOLEAN                    fNewElement;

    ASSERT_VALID(pcn);
    Assert( m_fTreesInited );


    // Add this connection to the dsname search tree
    RtlInsertElementGenericTable( &m_dsnameSearchTree, &pcn,
        sizeof(KCC_CONNECTION*), &fNewElement );
    Assert( fNewElement==TRUE );


    // Add this connection to the source dsa search tree
    Assert( !fNullUuid(&pcn->GetSourceDSA()->GetDsName()->Guid) );
    memcpy( &sdeKey.uuid, &pcn->GetSourceDSA()->GetDsName()->Guid, sizeof(UUID) );
    sdeKey.numConnections = 0;
    sdeKey.connection = NULL;
    sdeResult = (SOURCE_DSA_CONN_ARRAY*) RtlInsertElementGenericTable(
        &m_sourceDsaSearchTree,
        &sdeKey,
        sizeof(SOURCE_DSA_CONN_ARRAY),
        &fNewElement );

    if( fNewElement ) {
        // If this is the first connection which sources from this dsa,
        // we must allocate the list of connections
        sdeResult->numConnections = 1;
        sdeResult->connection = (KCC_CONNECTION**) THAlloc(sizeof(KCC_CONNECTION*));
        if(!sdeResult->connection) {
            KCC_MEM_EXCEPT(sizeof(KCC_CONNECTION*));
        }
        sdeResult->connection[0] = pcn;
    } else {
        // If this is not the first connection which sources from this site,
        // we must grow (reallocate) the list of connections.
        sdeResult->numConnections++;
        sdeResult->connection = (KCC_CONNECTION**) THReAlloc(
            sdeResult->connection,
            sdeResult->numConnections * sizeof(KCC_CONNECTION*) );
        if(!sdeResult->connection) {
            KCC_MEM_EXCEPT(sdeResult->numConnections*sizeof(KCC_CONNECTION*));
        }
        sdeResult->connection[sdeResult->numConnections-1] = pcn;
    }


    // Add this connection to the appropriate list in the source site search tree
    sseKey.siteDN = pcn->GetSourceSiteDN();
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlInsertElementGenericTable(
        &m_sourceSiteSearchTree,
        &sseKey,
        sizeof(SOURCE_SITE_CONN_ARRAY),
        &fNewElement );

    if( fNewElement ) {
        // If this is the first connection which sources from this site,
        // we must allocate the list of connections
        sseResult->numConnections = 1;
        sseResult->connection = (KCC_CONNECTION**) THAlloc(sizeof(KCC_CONNECTION*));
        if(!sseResult->connection) {
            KCC_MEM_EXCEPT(sizeof(KCC_CONNECTION*));
        }
        sseResult->connection[0] = pcn;
    } else {
        // If this is not the first connection which sources from this site,
        // we must grow (reallocate) the list of connections.
        sseResult->numConnections++;
        sseResult->connection = (KCC_CONNECTION**) THReAlloc(
            sseResult->connection,
            sseResult->numConnections * sizeof(KCC_CONNECTION*) );
        if(!sseResult->connection) {
            KCC_MEM_EXCEPT(sseResult->numConnections*sizeof(KCC_CONNECTION*));
        }
        sseResult->connection[sseResult->numConnections-1] = pcn;
    }

}

BOOL
KCC_CONNECTION_LIST::Init(
    IN DSNAME *     pdnDestinationDSA,
    IN BOOL         fIntraSite
    )
//
// Initialize the collection from the set of NTDS-Connection DS objects
// that are direct children of the given DSA.
//
{

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(KCC_CONNECTION::AttrList), KCC_CONNECTION::AttrList },
        EN_INFOTYPES_TYPES_VALS
    };

    DWORD           dwConnectionClass = CLASS_NTDS_CONNECTION;
    ULONG           dirError;
    FILTER          filtTop = {0};
    FILTER          filtConnectionObject = {0};
    FILTER          filtIntersite = {0};
    FILTER          filtNotIntersite = {0};
    SEARCHRES *     pResults;
    
    Reset();
    InitTrees();

    filtTop.choice                       = FILTER_CHOICE_AND;
    filtTop.FilterTypes.And.count        = 2;
    filtTop.FilterTypes.And.pFirstFilter = &filtConnectionObject;
    
    filtConnectionObject.choice                                     = FILTER_CHOICE_ITEM;
    filtConnectionObject.FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CLASS;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(dwConnectionClass);
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) &dwConnectionClass;
    
    if (fIntraSite) {
        filtConnectionObject.pNextFilter = &filtNotIntersite;
    
        filtNotIntersite.choice           = FILTER_CHOICE_NOT;
        filtNotIntersite.FilterTypes.pNot = &filtIntersite;
    } else {
        filtConnectionObject.pNextFilter = &filtIntersite;
    }

    filtIntersite.choice                            = FILTER_CHOICE_ITEM;
    filtIntersite.FilterTypes.Item.choice           = FI_CHOICE_PRESENT;
    filtIntersite.FilterTypes.Item.FilTypes.present = ATT_TRANSPORT_TYPE;

    dirError = KccSearch(
        pdnDestinationDSA,
        SE_CHOICE_IMMED_CHLDRN,
        &filtTop,
        &Sel,
        &pResults
        );

    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(pdnDestinationDSA, dirError);
    } else {
        Init( pdnDestinationDSA, pResults->count, &pResults->FirstEntInf );
        DirFreeSearchRes( pResults );
    }

    return m_fIsInitialized;
}

BOOL
KCC_CONNECTION_LIST::Init(
    IN  DSNAME *        pdnDestinationDSA,
    IN  DWORD           cNumEntInfs,
    IN  ENTINFLIST *    pEntInfList
    )
//
// Initialize connection list from the given search results.
//
{
    ULONG    dirError;
    DSNAME * pdnLocalDSA = gpDSCache->GetLocalDSADN();
    DWORD    iConn;

    Reset();
    InitTrees();
    
    if (0 == cNumEntInfs) {
        DPRINT1(4, "No connection objects found inbound to %ls.\n",
            pdnDestinationDSA->StringName);
        m_fIsInitialized = TRUE;
    } else {
        m_cnAllocated = cNumEntInfs;
        m_ppcn = (KCC_CONNECTION**) THAlloc( cNumEntInfs*sizeof(KCC_CONNECTION*) );
        if(!m_ppcn) {
            KCC_MEM_EXCEPT( cNumEntInfs*sizeof(KCC_CONNECTION*) );
        }

        m_ccn = 0;
        while (NULL != pEntInfList) {
            KCC_CONNECTION * pcn = new KCC_CONNECTION;
            m_ppcn[ m_ccn ] = pcn;

            if (pcn->Init(&pEntInfList->Entinf)) {
                m_ccn++;
            } else {

                // NTDS-Connection object is invalid.  The only case in which
                // this could happen currently is if the DSA referenced by the
                // From-Server attribute has been deleted.  In this case, we
                // ignore the connection object and, if it's inbound to the
                // local DSA, delete it from the DS.

                //
                // Only delete connection under local server's ntds-dsa object
                //
                if (KccIsEqualGUID(&pdnDestinationDSA->Guid,
                                   &pdnLocalDSA->Guid)) {
                    dirError = KccRemoveEntry( pEntInfList->Entinf.pName );
                    if (0 == dirError) {
                        LogEvent(DS_EVENT_CAT_KCC,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_CHK_REMOVED_CONN_FROM_DEAD_SERVER,
                                 szInsertDN(pEntInfList->Entinf.pName),
                                 0,
                                 0);

                        DPRINT1(0,
                                "Deleted connection %ls as it sourced from"
                                    " a deleted server.\n",
                                pEntInfList->Entinf.pName->StringName);
                    } else {
                        KCC_LOG_REMOVEENTRY_FAILURE(pEntInfList->Entinf.pName,
                                                    dirError);
                    }
                }


                //
                // Remove the from server from the list of failed
                // servers to initiate a link with since the server
                // no longer exists
                //
                ULONG iAttr;
                BYTE* pbVal;
                ATTR* pAttr;
                for (iAttr = 0;
                     iAttr < pEntInfList->Entinf.AttrBlock.attrCount;
                     iAttr++) {
                    pAttr = &(pEntInfList->Entinf.AttrBlock.pAttr[ iAttr ]);
            
                    if (ATT_FROM_SERVER == pAttr->attrTyp) {
                        Assert(1 == pAttr->AttrVal.valCount);
                        pbVal = pAttr->AttrVal.pAVal->pVal;
                        gConnectionFailureCache.Remove( (DSNAME *) pbVal );
                    }
                }

                //
                // Finally, delete the KCC_CONNECTION we allocated yet
                // failed to initialize.
                //
                delete pcn;
            }
            
            pEntInfList = pEntInfList->pNextEntInf;
        }
    }

    Assert(m_ccn <= cNumEntInfs);

    // Ensure that the search trees are all kept up to date.
    for( iConn=0; iConn<m_ccn; iConn++ ) {
        AddConnectionToSearchTrees( m_ppcn[iConn] );
    }
    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

void
KCC_CONNECTION_LIST::AddToList(
    IN  KCC_CONNECTION *  pcn
    )
/*++

Routine Description:

    Add a new connection to the list. If the list is full, we must reallocate
    (by doubling its size). We then add this new connection to our search trees.
    
Parameters:

    pcn - New connection to add.

Returns:

    None.
    
--*/
{
    KCC_CONNECTION    **ppcnNew;
    DWORD               newIndex;

    // Increase the size of the KCC_CONNECTION array, and add the new
    // connection to it
    newIndex = m_ccn;
    m_ccn++;

    if( m_ccn > m_cnAllocated ) {
        m_cnAllocated = 2*(m_cnAllocated+10);
        if( m_ppcn ) {
            m_ppcn = (KCC_CONNECTION**) THReAlloc( m_ppcn,
                m_cnAllocated * sizeof(KCC_CONNECTION*) );
        } else {
            m_ppcn = (KCC_CONNECTION**) THAlloc(
                m_cnAllocated * sizeof(KCC_CONNECTION*) );
        }
        if(!m_ppcn) {
            KCC_MEM_EXCEPT(m_cnAllocated*sizeof(KCC_CONNECTION*));
        }
    }

    m_ppcn[newIndex] = pcn;

    // Now, update our three search trees
    AddConnectionToSearchTrees( pcn );
}

void
KCC_CONNECTION_LIST::RemoveDuplicates(
    IN  BOOL  fDeleteDuplicatesFromDatabase
    )
//
// Scan the collection of connection objects and remove duplicates.  Two
// connection objects are duplicates if they refer to the same source
// DSA.  When we do encounter duplicates, we keep only one of them.
// The general idea is that we first prefer admin-generated connections
// over auto-generated connections and newer connections over older ones,
// in that order.
//
{
    // First, sort 'em by preference.
    qsort(m_ppcn, m_ccn, sizeof(*m_ppcn), CompareForDuplicateCheck);

    // Now, any connections that source from the same DSA will be next to
    // each other in the list.  Moreover, the one that occurs later in the
    // sequence is preferred.  Remove the duplicates, leaving just the most
    // preferred connections in the list.
    DWORD icn = 0;
    while (icn+1 < m_ccn) {
        KCC_CONNECTION * pcnCurr = m_ppcn[icn];
        KCC_CONNECTION * pcnNext = m_ppcn[icn+1];

        if (0 == memcmp(&pcnCurr->GetSourceDSADN()->Guid,
                        &pcnNext->GetSourceDSADN()->Guid,
                        sizeof(GUID))) {
            // icn is a duplicate of icn+1, and icn+1 is the one we want to
            // keep.
            DPRINT2(0, "Ignoring duplicate connection object %ls in favor of %ls.\n",
                    pcnCurr->GetConnectionDN()->StringName,
                    pcnNext->GetConnectionDN()->StringName);
            
            if (!pcnCurr->IsGenerated()) {
                // The connection object we're ignoring was created by an admin.
                // Inform him of his dastardly deed.
                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CHK_DUPLICATE_CONNECTION,
                         szInsertDN(pcnCurr->GetConnectionDN()),
                         szInsertDN(pcnNext->GetConnectionDN()),
                         0);
            }
            else if (fDeleteDuplicatesFromDatabase) {
                // Delete duplicate connection object from the database.
                pcnCurr->Remove();
            }

            // ISSUE-2000/08/01-nickhar  Removing duplicate connections from list.
            // Performance could be improved here by using lazy deletion and a
            // final sweep to remove deleted entries. (Although we probably don't
            // remove connections very often).
            //
            // Remove connection from the in-memory connection list and free it.
            RemoveFromList(icn);
            delete pcnCurr;
        }
        else {
            // Not a duplicate; move on.
            icn++;
        }
    }
}

int __cdecl
KCC_CONNECTION_LIST::CompareForDuplicateCheck(
    IN  const void *    pv1,
    IN  const void *    pv2
    )
//
// QSort helper routine to sort connection list by preference.  If two
// connection objects have the same source DSA, the connection that is
// "greater" is preferred (and it is the one that will be translated into a
// repsFrom link).
//
{
    int nDiff;

    KCC_CONNECTION * pcn1 = *((KCC_CONNECTION **) pv1);
    KCC_CONNECTION * pcn2 = *((KCC_CONNECTION **) pv2);

    // Don't allow just one of the Guids to be NULL
    Assert( ! (   fNullUuid(&pcn1->GetSourceDSADN()->Guid)
                ^ fNullUuid(&pcn2->GetSourceDSADN()->Guid) ) );
    
    // Sort first by ascending source ntdsDsa objectGuid.
    nDiff = memcmp(&pcn1->GetSourceDSADN()->Guid,
                   &pcn2->GetSourceDSADN()->Guid,
                   sizeof(GUID));
    
    if (0 == nDiff) {
        // Same source; prefer admin-generated over auto-generated.
        nDiff = !pcn1->IsGenerated() - !pcn2->IsGenerated();
    }

    if (0 == nDiff) {
        // Same source, same "generatedness"; prefer newer connections over
        // older ones.
        nDiff = (int)(pcn1->GetWhenCreated() - pcn2->GetWhenCreated());
    }

    if (0 == nDiff) {
        // This will probably never happen.  This indicates we have two
        // connections with the same source, "generatedness", and creation time.
        // Arbitrarily choose the one with the larger objectGuid.
        nDiff = memcmp(&pcn1->GetConnectionDN()->Guid,
                       &pcn2->GetConnectionDN()->Guid,
                       sizeof(GUID));

        Assert((0 != nDiff) && "Same connection appears twice in list!");
    }

    return nDiff;
}

void
KCC_CONNECTION_LIST::UpdateTransportTypeForSite(
    IN      BOOL                    fIntraSite,
    IN OUT  KCC_CONNECTION_LIST *   pMisfitCnList
    )
//
// Scan connection list and update transport type attribute for admin generated
// connections. If the source is in the same site, and there is a transport type
// attribute, remove it. If the source is in a different site but there is no
// transport type attribute, create one, defaulting to the IP transport.
//
{
    ATTRMODLIST rgMods[1];
    ATTRVAL     AttrVal;
    ULONG       dirError;
    KCC_SITE *  pLocalSite = gpDSCache->GetLocalSite();

    for (DWORD icn = 0; icn < m_ccn; /* icn++/m_ccn-- below */ ) {
        KCC_CONNECTION *pcn = m_ppcn[icn];
        KCC_TRANSPORT  *pTransport;
        BOOL            fUpdate, fInSameSite;
        DSNAME         *pTransportDN, *pDn1, *pDn2, *pNewTransportDN;

        fUpdate = FALSE;
        pDn1 = pLocalSite->GetObjectDN();
        pDn2 = pcn->GetSourceDSA()->GetSiteDN();
        fInSameSite = (CompareDsName( &pDn1, &pDn2 ) == 0);
        pTransportDN = pcn->GetTransportDN();

        if (!fIntraSite) {

            // We're processing inter-site connections. They should always
            // have a transportType.            
            Assert( NULL != pTransportDN );
            pTransport = gpDSCache->GetTransportList()->GetTransport( pTransportDN );

            if( fInSameSite ) {
                // Connection with a transport type but source and destination
                // are in the same site.  Remove the transport type.                
                fUpdate = TRUE;
                pNewTransportDN = NULL;
            } else if( NULL==pTransport ) {
                // The connection had a non-NULL but invalid transport DN.
                // We update the transport type to IP. If IP is not the
                // correct transport, the KCC will have the opportunity to
                // correct this later on.
                fUpdate = TRUE;
                pNewTransportDN = gpDSCache->GetIPTransportDN();
            }

        } else {
            // We're processing intra-site connections. They should have no
            // transportType.
            Assert( NULL == pTransportDN );

            if( !fInSameSite ) {
                // The two endpoints of this connection are not in the same
                // site -- this is in fact an inter-site connection.
                // We set the transport type to IP. If IP is not the
                // correct transport, the KCC will have the opportunity to
                // correct this later on.
                fUpdate = TRUE;
                pNewTransportDN = gpDSCache->GetIPTransportDN();
            }
        }
        
        if (fUpdate) {
            // Update in-memory and DS objects.
            pcn->SetTransport(pNewTransportDN);
            pcn->UpdateDS();
            
            DPRINT2(0, "Updated transport type on %ls to %ls.\n",
                    pcn->GetConnectionDN()->StringName,
                    pNewTransportDN ? pNewTransportDN->StringName : L"RPC" );
            LogEvent8(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CHK_UPDATED_TRANSPORT_TYPE,
                     szInsertDN(pcn->GetConnectionDN()),
                     szInsertDN(pcn->GetSourceDSADN()),
                     szInsertDN(pcn->GetDestinationDSADN()),
                     pNewTransportDN
                        ? szInsertDN(pNewTransportDN)
                        : szInsertSz("RPC"),
                     0,0,0,0
                     );

            // Remove connection from this list and add it to the misfit list.
            RemoveFromList(icn);
            pMisfitCnList->AddToList(pcn);

        } else {
            // No connection update needed.
            icn++;
        }
    }
}
void
KCC_CONNECTION_LIST::RemoveFromList(
    IN  DWORD   icn
    )
//
// Remove connection from the in-memory connection list.
// Does NOT delete the connection object from the DS.
//
{
    SOURCE_DSA_CONN_ARRAY    sdeKey, *sdeResult;
    SOURCE_SITE_CONN_ARRAY   sseKey, *sseResult;
    KCC_CONNECTION          *pcn;
    DWORD                    iConn, cConn;
    BOOLEAN                  fSuccess;

    Assert( m_fTreesInited );
    Assert(icn < m_ccn);
    pcn = m_ppcn[icn];

    // Remove this connection from the connection array.
    memmove(&m_ppcn[icn],
            &m_ppcn[icn+1],
            (m_ccn - icn - 1) * sizeof(*m_ppcn));
    m_ccn--;


    // Remove this connection from the dsname search tree
    fSuccess = RtlDeleteElementGenericTable( &m_dsnameSearchTree, &pcn );
    Assert( TRUE==fSuccess );

    
    // Find this list of connections corresponding to this source dsa in the
    // source dsa search tree
    Assert( !fNullUuid(&pcn->GetSourceDSA()->GetDsName()->Guid) );
    memcpy( &sdeKey.uuid, &pcn->GetSourceDSA()->GetDsName()->Guid, sizeof(UUID) );
    sdeKey.numConnections = 0;
    sdeKey.connection = NULL;
    sdeResult = (SOURCE_DSA_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceDsaSearchTree, &sdeKey );
    if( NULL==sdeResult ) {

        Assert( !"RtlLookupElementGenericTable() returned NULL unexpectedly" );
    
    } else {

        // Scan the list of connections corresponding to this source dsa, and
        // remove entry 'pcn'
        fSuccess = FALSE;
        cConn = sdeResult->numConnections;
        for( iConn=0; iConn<cConn; iConn++ ) {
    
            if( sdeResult->connection[iConn]!=pcn ) {
                continue;
            }
    
            // We found the entry to remove. Slide its successors down,
            // but don't bother to reclaim the memory.
            memmove(
                &sdeResult->connection[iConn],
                &sdeResult->connection[iConn+1],
                (cConn-1-iConn) * sizeof(KCC_CONNECTION*)
                );
            sdeResult->numConnections--;
            fSuccess = TRUE;
            break;
        }
        Assert( TRUE==fSuccess );
    
        // If all items have been removed from the list of connections corresponding
        // to this dsa, we remove this list from the sourceDsaSearchTree.
        if( sdeResult->numConnections==0 ) {
            THFree( sdeResult->connection );
            sdeResult->connection=NULL;
    
            fSuccess = RtlDeleteElementGenericTable( &m_sourceDsaSearchTree, sdeResult );
            Assert( TRUE==fSuccess );
        }
    }

    // Find this list of connections corresponding to this source site in the
    // source site search tree
    sseKey.siteDN = pcn->GetSourceSiteDN();
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceSiteSearchTree, &sseKey );
    if( NULL==sseResult ) {

        Assert( NULL!=sseResult );

    } else {
    
        // Scan the list of connections corresponding to this source site, and
        // remove entry 'pcn'
        fSuccess = FALSE;
        cConn = sseResult->numConnections;
        for( iConn=0; iConn<cConn; iConn++ ) {
    
            if( sseResult->connection[iConn]!=pcn ) {
                continue;
            }
    
            // We found the entry to remove. Slide its successors down,
            // but don't bother to reclaim the memory.
            memmove(
                &sseResult->connection[iConn],
                &sseResult->connection[iConn+1],
                (cConn-1-iConn) * sizeof(KCC_CONNECTION*)
                );
            sseResult->numConnections--;
            fSuccess = TRUE;
            break;
        }
        Assert( TRUE==fSuccess );
    
        // If all items have been removed from the list of connections corresponding
        // to this site, we remove this list from the sourceSiteSearchTree.
        if( sseResult->numConnections==0 ) {
            THFree( sseResult->connection );
            sseResult->connection=NULL;
    
            fSuccess = RtlDeleteElementGenericTable( &m_sourceSiteSearchTree, sseResult );
            Assert( TRUE==fSuccess );
        }
    }
}

void
KCC_CONNECTION_LIST::RemoveFromList(
    IN  KCC_CONNECTION *  pcn
    )
//
// Remove connection from the in-memory connection list.
//
{
    for (DWORD icn = 0; icn < m_ccn; icn++) {
        if (pcn == m_ppcn[icn]) {
            break;
        }
    }

    Assert((icn < m_ccn) && "pcn must be in list!");
    
    RemoveFromList(icn);
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_INTRASITE_CONNECTION_LIST methods
//

/* (All inlined.) */


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_INTERSITE_CONNECTION_LIST methods
//

VOID
KCC_INTERSITE_CONNECTION_LIST::UpdateStaleServerCache()
//
// Update the stale server cache with info from the destination bridgeheads.
//
{
    HANDLE                      hDS;
    DSNAME *                    pdnDestDSA;
    DWORD                       err;
    LPWSTR                      pszDestAddr;
    DS_REPL_KCC_DSA_FAILURESW * pFailures = NULL;
    DS_REPL_KCC_DSA_FAILUREW *  pFailure;
    DWORD                       iFail;
    DSNAME *                    pdnLocalDSA = gpDSCache->GetLocalDSADN();
    
    ASSERT_VALID(this);

    if (0 == m_ccn) {
        return;
    }

    pdnDestDSA = m_ppcn[0]->GetDestinationDSADN();

    // Note that we already have a cache of our own failures.
    if (NameMatched(pdnDestDSA, pdnLocalDSA)) {
        return;
    }

    // Contact the inbound bridgehead and ask it how replication is doing.
    pszDestAddr = GuidBasedDNSNameFromDSName(pdnDestDSA);

    err = DsBindW(pszDestAddr, NULL, &hDS);
    if (err) {
        // Inbound bridgehead not reachable.
        DPRINT2(0, "Cannot reach %ls to get staleness info, error %d.\n",
                pdnDestDSA->StringName, err);
        gConnectionFailureCache.Add(pdnDestDSA, err, FALSE);
        return;
    }

    __try {
        // Destination contacted; remove it if it's in the stale cache.
        gConnectionFailureCache.Remove(pdnDestDSA);

        Assert(NULL == pFailures);

        err = DsReplicaGetInfoW(hDS,
                                DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                                NULL,
                                NULL,
                                (void **) &pFailures);
        if (err || !pFailures) {
            DPRINT2(0, "DsReplicaGetInfoW() from %ls failed with error %d.\n",
                    pdnDestDSA->StringName, err);
        }
        else {
            // Update failure cache with any reported failures with respect
            // to remote site bridgeheads we believe the local bridgehead
            // should be replicating from.

            for (iFail = 0; iFail < pFailures->cNumEntries; iFail++) {
                pFailure = &pFailures->rgDsaFailure[iFail];
                if (NULL != GetConnectionFromSourceDSAUUID(
                                &pFailure->uuidDsaObjGuid)) {
                    gConnectionFailureCache.UpdateEntry(pFailure);
                    break;
                }
            }
        }
    
        if (NULL != pFailures) {
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, pFailures);
            pFailures = NULL;
        }

        err = DsReplicaGetInfoW(hDS,
                                DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                NULL,
                                NULL,
                                (void **) &pFailures);
        if (err) {
            DPRINT2(0, "DsReplicaGetInfoW() from %ls failed with error %d.\n",
                    pdnDestDSA->StringName, err);
        }
        else {
            // Update failure cache with any reported failures with respect
            // to remote site bridgeheads we believe the local bridgehead
            // should be replicating from.

            for (iFail = 0; iFail < pFailures->cNumEntries; iFail++) {
                pFailure = &pFailures->rgDsaFailure[iFail];
                if (NULL != GetConnectionFromSourceDSAUUID(
                                &pFailure->uuidDsaObjGuid)) {
                    gLinkFailureCache.UpdateEntry(pFailure);
                    break;
                }
            }
        }
    }
    __finally {
        if (NULL != pFailures) {
            // LINK_FAILURES and CONNECT_FAILURES are allocated/freed the
            // same way, so it doesn't matter which it is.
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                              pFailures);
            pFailures = NULL;
        }

        DsUnBindW(&hDS);
    }
}

