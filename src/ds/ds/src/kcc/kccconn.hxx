/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccconn.hxx

ABSTRACT:

    KCC_CONNECTION and KCC_CONNECTION_LIST classes.

DETAILS:

    These classes represent a single NTDS-Connection DS object and a
    collection thereof, resp.

    NTDS-Connection objects represent a uni-directional replication link,
    with the parent server object being the destination and the From-Server
    attribute holding the source.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#ifndef KCC_KCCCONN_HXX_INCLUDED
#define KCC_KCCCONN_HXX_INCLUDED

#include <w32topl.h>
#include <schedule.h>               // new replication schedule format
#include <kcctrans.hxx>
#include <kcclink.hxx>
#include <kccdsa.hxx>
#include <kccdynar.hxx>
#include <kcccref.hxx>
#include <ntrtl.h>

// dsexts dump routines.
extern "C" {
    BOOL Dump_KCC_CONNECTION(DWORD, PVOID);
    BOOL Dump_KCC_INTRASITE_CONNECTION_LIST(DWORD, PVOID);
    BOOL Dump_KCC_INTERSITE_CONNECTION_LIST(DWORD, PVOID);
};

//
// Values for "reason for connection".  A connection can be needed for
// more than one reason.
//
#define KCC_NO_REASON                ( 0 )
#define KCC_GC_TOPOLOGY              ( 1 << 0 )
#define KCC_RING_TOPOLOGY            ( 1 << 1 )
#define KCC_MINIMIZE_HOPS_TOPOLOGY   ( 1 << 2 )
#define KCC_STALE_SERVERS_TOPOLOGY   ( 1 << 3 )


class KCC_CONNECTION : public KCC_OBJECT, public CTOPL_EDGE
{
public:
    KCC_CONNECTION()    { Reset(); }
    ~KCC_CONNECTION()   { Reset(); }

    // dsexts dump routine.
    friend BOOL Dump_KCC_CONNECTION(DWORD, PVOID);

    // List of interesting attributes on objects of this class.
    static ATTR AttrList[7];

    // Initialize the internal object from an ENTINF describing a corresponding
    // NTDS-Connection DS object.
    BOOL
    Init(
        IN  ENTINF *    pentinf
        );

    // Retrieve the DN of the corresponding NTDS-Connection DS object.
    DSNAME *
    GetConnectionDN();

    // Retrieve the DN of the source DSA's NTDS-DSA DS object.
    DSNAME *
    GetSourceDSADN();

    // Retrieve the source DSA's NTDS-DSA DS object.
    KCC_DSA *
    GetSourceDSA();

    // Retrieve the DN of the source DSA's site object.
    DSNAME *
    GetSourceSiteDN();

    // Retrieve the DN of the destination DSA's NTDS-DSA DS object.
    DSNAME *
    GetDestinationDSADN();

    // Is the connection enabled?
    BOOL
    IsEnabled();

    // Is this an intra-site connection?
    BOOL
    IsIntrasite();

    // Was the connection generated by the KCC (as opposed to being created by
    // an administrator)?
    BOOL
    IsGenerated();

    // Does completion of a sync of this NC trigger a sync in the opposite
    // direction?
    BOOL
    IsTwoWaySynced();

    // Is compression enabled over this connection?
    BOOL
    IsCompressionEnabled();

    // Is notification used by this connection?
    BOOL
    UsesNotification();
    
    // Retrieve the periodic replication schedule in TOPL_SCHEDULE format.
    TOPL_SCHEDULE
    GetSchedule();

    // Get the transport associated with this connection.
    DSNAME*
    GetTransportDN();

    // Set transport associated with this connection.
    KCC_CONNECTION &
    SetTransport(
        IN DSNAME *pdn
        );
    
    // Set the DN of the corresponding NTDS-Connection DS object.
    KCC_CONNECTION &
    SetConnectionDN(
        IN  DSNAME *    pdn
        );
    
    // Set the DSA DN to the source DSA's NTDS-DSA DS object.
    KCC_CONNECTION &
    SetSourceDSA(
        IN KCC_DSA *pDsa
        );
    
    // Set the is-enabled flag to the given value.
    KCC_CONNECTION &
    SetEnabled(
        IN  BOOL    fIsEnabled
        );

    // Set the is-generated flag to the given value.
    KCC_CONNECTION &
    SetGenerated(
        IN  BOOL    fIsGenerated
        );

    // Set the periodic replication schedule.
    KCC_CONNECTION &
    SetSchedule(
        IN  TOPL_SCHEDULE toplSchedule
        );

    // Override the default notification behavior, as specified
    KCC_CONNECTION &
    SetOverrideNotification(
        IN  BOOL    fUsesNotification
        );
    
    // Set the two-way sync'd state of the connection
    KCC_CONNECTION &
    SetTwoWaySync(
        IN  BOOL    fIsTwoWaySynced
        );

    // Set the flag indicating whether or not compression should
    // be disabled over this connection. This function may only be
    // called for inter-site connections.
    KCC_CONNECTION &
    SetDisableIntersiteCompression(
        IN  BOOL    fDisableCompression
        );
    
    DSTIME
    GetWhenCreated()
    {
        return m_timeCreated;
    }

    // Is this object internally consistent?
    BOOL
    IsValid();

    // Convert to an NTDS-Connection DS object and write it to the DS.
    // If the connection object DN has not been set, it will be constructed
    // from the pdnDSA argument and a unique RDN.
    DWORD
    Add(
        IN  DSNAME *    pdnDSA
        );
        
    // Modify existing ntdsConnection object in DS to reflect recent updates
    // made to the in-memory KCC_CONNECTION.
    DWORD
    UpdateDS();
        
    // Remove the connection object from the ds. Note that the in memory copy of the
    // object remains.
    DWORD
    Remove();

    // Returns why this connection is needed by the topology generation
    ULONG 
    GetReasonForConnection()
    {
        return m_ReasonForConnection;
    }

    BOOL
    IsStale()
    {
        return !!( GetReasonForConnection() & KCC_STALE_SERVERS_TOPOLOGY );
    }
    
    // Sets a reason why this connection is needed for the topology
    VOID 
    SetReasonForConnection(
        IN DWORD Reason
        )
    {
        if ( KCC_NO_REASON == Reason )
        {
            m_ReasonForConnection = KCC_NO_REASON;
        } 
        else 
        {
            m_ReasonForConnection |= Reason;
        }
    }

    // Register an NC as being replicated over this connection.
    void
    AddReplicatedNC(
        IN  DSNAME * pNC,
        IN  BOOL     fGCTopology
        );

    // Enumerate the NCs replicated over this connection (as previously
    // registered via AddReplicatedNC()).
    DSNAME *
    GetReplicatedNC(
        IN  DWORD    iNC,
        OUT BOOL *   pfGCTopology
        );

    DWORD
    GetReplicatedNCCount() {
        return m_ReplicatedNCArray.GetCount();
    }

    DWORD
    GetReplicatedWriteableNCCount();

    BOOL
    ReplicatesSubsetOf(
        IN KCC_CONNECTION * pcn2
        );

    BOOL
    ReplicatesNothing()
    {
        return (0 == m_ReplicatedNCArray.GetCount());
    }
    
    // Is this connection used by this naming context?
    BOOL
    ReplicatesNC(
        IN KCC_CROSSREF *pCrossRef
        );

    BOOL
    IsSourceSiteUnreachable();

    BOOL
    OnProbation();

    BOOL
    Supercedes(
        IN  KCC_CONNECTION *pcn
        );

    BOOL
    IsOverIntersiteIP()
    {
        return KCC_TRANSPORT::IsIntersiteIP(GetTransportDN());
    }

    // Update pre-existing repsFrom link to reflect the state of this connection
    // object.
    void
    UpdateLink(
        IN  KCC_LINK *              plink,
        IN  KCC_CROSSREF *          pCrossRef,
        IN  DSNAME *                pdnLocalSite,
        IN  KCC_TRANSPORT_LIST *    pTransportList
        );

    // Derive new repsFrom link from this connection object.
    void
    AddLink(
        IN  KCC_CROSSREF *          pCrossRef,
        IN  BOOL                    fIsLocalMaster,
        IN  DSNAME *                pdnLocalSite,
        IN  KCC_DSA *               pLocalDSA,
        IN  KCC_DSA *               pRemoteDSA,
        IN  KCC_TRANSPORT_LIST *    pTransportList
        );

    // Record the reasons for this connection in the object
    void
    UpdateReason();

    // Order the connections by:
    //     increasing source site (as per wcscmp())
    //     increasing number of writeable NCs supported
    //     increasing number of read-only NCs supported
    //     KCC-generated connections come before "created by admin" connections
    //     stale connections come before non-stale connections
    //     increasing connection objectGuid
    static int __cdecl
    CompareForRemoval(
        IN  const void *  pv1,
        IN  const void *  pv2
        );

private:
    // Reset member variables to their pre-Init() state.
    void
    Reset()
    {
        m_pdnConnection = NULL;
        m_fIsEnabled    = FALSE;
        m_pdnDestinationDSA = NULL;
        m_dwOptions     = 0;
        m_toplSchedule = NULL;      // NULL schedule = 'always available' schedule
        m_timeCreated   = 0;
        m_ReasonForConnection = KCC_NO_REASON;
        m_pdnTransport   = NULL;
        m_fUpdatedOptions = m_fUpdatedSchedule = m_fUpdatedTransport = FALSE;
        m_cOldNCs = 0;
        m_pOldNCs = NULL;
        m_pSourceDSA = NULL;        
    }
    
    static BOOL
    ShouldSkipDraAdd(
        KCC_DSA *pRemoteDSA,
        DWORD   *pdwDsaError OPTIONAL
    );
        
    struct DN_AND_REASON {
        DSNAME     *dn;
        DWORD       reason;
    };

    static int __cdecl
    CompareDNAndReason(
        const void* elem1,
        const void* elem2 
    );

    BOOL
    NewNCsSameAsOld(
        void
    );

private:
    // The DN of the corresponding NTDS-Connection DS object.
    DSNAME *        m_pdnConnection;

    // Is the connection enabled?
    BOOL            m_fIsEnabled;

    // Which DSA sinks the connection.
    DSNAME *        m_pdnDestinationDSA;

    // Zero or more NTDSCONN_OPT_* bit flags.
    DWORD           m_dwOptions;

    // Periodic replication schedule.
    TOPL_SCHEDULE   m_toplSchedule;

    // Time stamp of when the connection object was
    // created.
    DSTIME          m_timeCreated;

    // Why the topology generator needs this connection
    DWORD           m_ReasonForConnection;

    // The transport, if any, associated with this connection
    DSNAME *        m_pdnTransport;

    // "Has the in-memory copy of the object been updated since the object was
    // read from the directory" flags.
    BOOL            m_fUpdatedOptions   : 1;
    BOOL            m_fUpdatedSchedule  : 1;
    BOOL            m_fUpdatedTransport : 1;

    // The new list of NCs replicated over this connection.
    KCC_REPLICATED_NC_ARRAY m_ReplicatedNCArray;
    
    // The size of the old list of NCs replicated over this connection
    DWORD           m_cOldNCs;

    // The old list of NCs replicated over this connection
    DN_AND_REASON*  m_pOldNCs;

    // The Source DSA
    KCC_DSA *       m_pSourceDSA;
};

//
// Collection class for KCC_CONNECTION objects.  Base class for
// KCC_INTRASITE_CONNECTION_LIST and KCC_INTERSITE_CONNECTION_LIST.
//
class KCC_CONNECTION_LIST : public KCC_OBJECT
{
public:

    // This structure is used to store the data in the m_sourceDsaSearchTree.
    // It maps between a GUID and a connection pointer.
    struct SOURCE_DSA_CONN_ARRAY {
        UUID              uuid;
        DWORD             numConnections;
        KCC_CONNECTION  **connection;
    };

    // This nested class describes the data returned by the
    // GetConnectionsFromSite() function. (It is also the same structure
    // stored internally in the RTL_GENERIC_TABLE).
    struct SOURCE_SITE_CONN_ARRAY {
        DSNAME           *siteDN;
        DWORD             numConnections;
        KCC_CONNECTION  **connection;
    };

    KCC_CONNECTION_LIST() {
        // We haven't created the trees yet, so we needn't delete them in Reset()
        m_fTreesInited = FALSE;
        Reset();
        InitTrees();
    }

    ~KCC_CONNECTION_LIST() { Reset(); }

    // Initialize connection list from the given search results.
    BOOL
    Init(
        IN  DSNAME *        pdnDestinationDSA,
        IN  DWORD           cNumEntInfs,
        IN  ENTINFLIST *    pEntInfList
        );
    
    // Reset member variables to their pre-Init() state. Clears
    // all the search trees too.
    void
    Reset();

    // Initialize all three search trees.
    void
    InitTrees();

    // Retrieve the KCC_CONNECTION object at the given index.
    KCC_CONNECTION *
    GetConnection(
        IN  DWORD   iConnection
        );

    // Retrieve the KCC_CONNECTION with the dsname. Returns NULL if no such object
    // exists
    KCC_CONNECTION *
    GetConnectionWithSameGUID(
        IN  KCC_CONNECTION *pConnection
        );

    // Retrieve the KCC_CONNECTION object with source DSA matching the given
    // UUID.  Returns NULL if none found.
    KCC_CONNECTION *
    GetConnectionFromSourceDSAUUID(
        IN  UUID *  puuid
        );

    // Get an array of connection objects which source from a particular site.
    // This structure should be considered read-only.
    KCC_CONNECTION_LIST::SOURCE_SITE_CONN_ARRAY*
    GetConnectionsFromSite(
        IN  DSNAME * pSourceSiteDN
        );

    // Retrieve the number of KCC_CONNECTION objects in the collection.
    DWORD
    GetCount() {
        ASSERT_VALID( this );
        return m_ccn;
    }

    // Is the collection initialized and internally consistent?
    BOOL
    IsValid();

    // Scan the collection of connection objects and remove duplicates.  Two
    // connection objects are duplicates if they refer to the same source
    // DSA.  When we do encounter duplicates, we keep only one of them.
    // The general idea is that we first prefer admin-generated connections
    // over auto-generated connections and newer connections over older ones,
    // in that order.
    void
    RemoveDuplicates(
        IN  BOOL  fDeleteDuplicatesFromDatabase = FALSE
        );

    // Remove connection from the in-memory connection list.
    void
    RemoveFromList(
        IN  DWORD   icn
        );

    // Remove connection from the in-memory connection list.
    void
    RemoveFromList(
        IN  KCC_CONNECTION *  pcn
        );

    // Add connection to list.
    void
    AddToList(
        IN  KCC_CONNECTION *  pcn
        );

protected:

    // This function is used internally. Compare two connection objects by
    // their source site DSNames. This function defines the ordering used by
    // the m_dsnameSearchTree. The parameters a and b are pointers to pointers
    // to connection objects.
    static RTL_GENERIC_COMPARE_RESULTS
    ComparePConnByDsname(
        struct _RTL_GENERIC_TABLE *Table,
        PVOID a,
        PVOID b
        );

    // This function is used internally. Compare two nodes in the
    // m_sourceDsaSearchTree by their GUIDs. The parameters, a and b, are
    // pointers to SOURCE_DSA_TREE_ENTRYs.
    static RTL_GENERIC_COMPARE_RESULTS
    CompareSourceDsaTreeEntry(
        struct _RTL_GENERIC_TABLE *Table,
        PVOID a,
        PVOID b
        );

    // This function is used internally. Compare two nodes in the
    // m_sourceSiteSearchTree by the sites' DSNAMEs.  The parameters, a and b,
    // are pointers to SOURCE_SITE_CONN_ARRAY's.
    static RTL_GENERIC_COMPARE_RESULTS
    CompareSourceSiteConnArray(
        struct _RTL_GENERIC_TABLE *Table,
        PVOID a,
        PVOID b
        );

    // This function is used internally. This function is used to allocate
    // memory by the three search trees in the KCC_CONNECTION_LIST class.
    static PVOID NTAPI
    KccTreeAlloc(
        struct _RTL_GENERIC_TABLE *Table,
        CLONG ByteSize
        );

    // This function is used internally. This function is used to deallocate
    // memory by the three search trees in the KCC_CONNECTION_LIST class.
    static VOID NTAPI
    KccTreeFree(
        struct _RTL_GENERIC_TABLE *Table,
        PVOID Buffer
        );

    // This function is used internally. After adding new connections to
    // the list (either in Init() or AddToList()), we must add the new entries
    // to the search trees for efficient retrieval. This function adds new
    // connections to all three search trees.
    VOID
    AddConnectionToSearchTrees(
        IN KCC_CONNECTION* pcn
        );

    // QSort helper routine to sort connection list by preference.  If two
    // connection objects have the same source DSA, the connection that is
    // "greater" is preferred (and it is the one that will be translated into a
    // repsFrom link).
    static int __cdecl
    CompareForDuplicateCheck(
        IN  const void *    pv1,
        IN  const void *    pv2
        );

    // Read connections inbound to the given DSA -- either intra-site-only or
    // inter-site-only.
    BOOL
    Init(
        IN  DSNAME *    pdnDestinationDSA,
        IN  BOOL        fIntraSite
        );

    // For all connections in the list:
    //
    // fIntraSite = TRUE:
    //    No connections in the list have a transport type set.  If the source
    //    DSA is in a different site, set the transport type to IP and move the
    //    KCC_CONNECTION from this list to pMisfitCOnnectionList.
    //
    // fIntraSite = FALSE:
    //    All connections in the list have a transport type set.  If the source
    //    DSA is the same site, remove the transport type and move the
    //    KCC_CONNECTION from this list to pMisfitCOnnectionList.
    void
    UpdateTransportTypeForSite(
        IN      BOOL                    fIntraSite,
        IN OUT  KCC_CONNECTION_LIST *   pMisfitConnectionList
        );

protected:

    // Has the object been successfully Init()-ed?
    BOOL                    m_fIsInitialized;

    // Number of objects we have allocated space for in the m_ppcn array.
    // We allocate more space than we really need to avoid reallocing too often.
    DWORD                   m_cnAllocated;

    // Actual number of KCC_CONNECTION objects in the m_ppcn array.
    DWORD                   m_ccn;

    // Array of KCC_CONNECTION objects.
    KCC_CONNECTION **       m_ppcn;

    // We need to be able to search connection lists in three different ways:
    //  - By the dsname of the connection object
    //  - By the dsname of the source dsa
    //  - By the dsname of the source site
    // We also need to be able to dynamically add / remove objects from the
    // connection lists, so a static searchable structures like sorted lists
    // cannot be used. The generic table structures provide an efficient solution.
    //
    // Both the dsnameSearchTree and sourceDsaSearchTree both contain simple
    // pointers to connection objects. The sourceSite search tree is organized
    // differently -- each node corresponds to a distinct source site and contains
    // an array of connections, all of which source from that site.
    BOOLEAN                 m_fTreesInited;
    RTL_GENERIC_TABLE       m_dsnameSearchTree;
    RTL_GENERIC_TABLE       m_sourceDsaSearchTree;
    RTL_GENERIC_TABLE       m_sourceSiteSearchTree;
};

//
// Collection of KCC_CONNECTIONs inbound to a given DSA from other DSAs in the
// same site.
//
class KCC_INTRASITE_CONNECTION_LIST : public KCC_CONNECTION_LIST {
public:
    // Initialize the collection from the set of NTDS-Connection DS objects
    // that are direct children of the given DSA.
    KCC_INTRASITE_CONNECTION_LIST() { Reset(); }
    ~KCC_INTRASITE_CONNECTION_LIST() { Reset(); }
    
    // dsexts dump routine.
    friend BOOL Dump_KCC_INTRASITE_CONNECTION_LIST(DWORD, PVOID);
    
    BOOL
    Init(
        IN  DSNAME *    pdnDestinationDSA
        ) {
        return KCC_CONNECTION_LIST::Init(pdnDestinationDSA, TRUE);
    }

    void
    UpdateTransportTypeForSite(
        IN OUT  KCC_INTERSITE_CONNECTION_LIST * pInterSiteConnectionList
        ) {
        KCC_CONNECTION_LIST::UpdateTransportTypeForSite(
                TRUE,
                (KCC_CONNECTION_LIST *) pInterSiteConnectionList);
    }
};

//
// Collection of KCC_CONNECTIONs inbound to a given DSA from DSAs in other
// sites.
//
class KCC_INTERSITE_CONNECTION_LIST : public KCC_CONNECTION_LIST
{
public:
    KCC_INTERSITE_CONNECTION_LIST() { Reset(); }
    ~KCC_INTERSITE_CONNECTION_LIST() { Reset(); }
    
    // dsexts dump routine.
    friend BOOL Dump_KCC_INTERSITE_CONNECTION_LIST(DWORD, PVOID);

    // Initialize the collection from the set of NTDS-Connection DS objects
    // for a given site
    BOOL
    Init(
        IN  DSNAME *    pdnDestinationDSA
        ) {
        return KCC_CONNECTION_LIST::Init( pdnDestinationDSA, FALSE );
    }
        
    // Initialize connection list from the given search results.
    BOOL
    Init(
        IN  DSNAME *        pdnDestinationDSA,
        IN  DWORD           cNumEntInfs,
        IN  ENTINFLIST *    pEntInfList
        ) {
        // Initialize connection list from the given search results.
        return KCC_CONNECTION_LIST::Init(pdnDestinationDSA,
                                         cNumEntInfs,
                                         pEntInfList);
    }
            
    // Update the stale server cache with info from the destination bridgeheads.
    VOID
    UpdateStaleServerCache();

    void
    UpdateTransportTypeForSite(
        IN OUT  KCC_INTRASITE_CONNECTION_LIST * pIntraSiteConnectionList
        ) {
        KCC_CONNECTION_LIST::UpdateTransportTypeForSite(
                FALSE,
                (KCC_CONNECTION_LIST *) pIntraSiteConnectionList);
    }
};

#endif
