//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsexcept.c
//
//--------------------------------------------------------------------------

//
// dsexcept.c - contains routines for raising, filtering, and handling exception generated by
// the Directory service
//

#include <NTDSpch.h>
#pragma  hdrstop

#include <esent.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB              "DSEXCEPT:" /* define the subsystem for debugging */
#include "ntdsa.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"      /* MD global definition header */
#include "mdlocal.h"      /* MD global definition header */
#include "dsatools.h"       /*needed for output allocation */
#include <dsevent.h>      /* header Audit\Alert logging (includes lanman)*/
#include "mdcodes.h"       /* header for error codes */
#include "drserr.h"
#include "draerror.h"
#include <dsexcept.h>
#include <fileno.h>
#define  FILENO FILENO_DSEXCEPT

#if DBG

// This is static because it easier to get to from the debugger
// We have to save these records indside the filter function. I've
// tried saving the exception_pointer pointer and it didn't work.

CONTEXT			gContextRecord;
EXCEPTION_RECORD 	gExceptionRecord;

#endif

// The v2 stubs raise the exceptions 43210000+errcode and 43220000+errcode
// These exceptions are searched for by checking the top 3 nibbles
// in the filter function.

#define V2_EXCEPTION_MASK 0xfff00000
#define V2_EXCEPTION_GENERIC 0x43200000

// Error routine that raises exception
// exceptions are logged with an internal identifier. This identifier should
// be parsed as follows:
//
// bits  012345678901234567890123456789012
//       |  dir || file ||    line       |
// where :
//     dir is the directory the source file is in (defined in filno.h)
//     file is the file where the exception occurred
//     line is the line at which the exception occurred
//

void RaiseDsaExcept (DWORD dwException, ULONG ulErrorCode, ULONG_PTR ul2,
    DWORD dwId ,  ULONG ulSeverity)
{
    ULONG_PTR lpArguments[NUM_DSA_EXCEPT_ARGS];

    // Always report internal errors
    if ( (ulErrorCode == ERROR_DS_INTERNAL_FAILURE) ||
         (ulErrorCode == ERROR_DS_DRA_INTERNAL_ERROR) ||
         (ulErrorCode == ERROR_INTERNAL_ERROR) ||
         (ulErrorCode == ERROR_INTERNAL_DB_ERROR) ||
         (ulErrorCode == RPC_S_INTERNAL_ERROR) ) {
        ulSeverity = DS_EVENT_SEV_ALWAYS;
    }

    if (ulSeverity != DS_EVENT_SEV_NO_LOGGING) {
        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                        ulSeverity,
		        DIRLOG_EXCEPTION,
		        szInsertHex(dwException),
		        szInsertInt(ulErrorCode),
		        szInsertPtr(ul2),
		        szInsertHex(dwId),
		        NULL,
		        NULL,
		        NULL,
		        NULL);
    }

    lpArguments[0] = ulErrorCode;
    lpArguments[1] = ul2;
    lpArguments[2] = dwId;

    RaiseException (dwException, 0, NUM_DSA_EXCEPT_ARGS, lpArguments);
}


// Error routine that raises exceptions for the DRA

void DraExcept (ULONG ulErrorCode, ULONG_PTR ul2, DWORD dwId,
                       ULONG ulSeverity)
{
    DWORD dwException =
	(ulErrorCode == DRAERR_OutOfMem) ? DSA_MEM_EXCEPTION : DRA_GEN_EXCEPTION;

    if (ulErrorCode == DRAERR_InternalError) {
        Assert(!"Replication internal error");
    }
    else if (!ulErrorCode) {
        Assert(!"DRA exception without proper error code");
        ulErrorCode = ERROR_DS_DRA_GENERIC;
    }

    RaiseDsaExcept(dwException, ulErrorCode, ul2, dwId, ulSeverity);
}


// This is the generic filter expression called directly by the DSA
// exception handlers and by the DRA filter expression.

DWORD
GetExceptionData(EXCEPTION_POINTERS* pExceptPtrs,
                 DWORD *pdwException,
                 PVOID * pExceptionAddress,
                 ULONG *pulErrorCode,
                 ULONG *pdsid)
{
    ULONG_PTR * pExceptInfo;
    ULONG ul2Unused;

#if DBG

// Save information for debugger. Have to save here, can't just save pointer.

    memcpy (&gExceptionRecord, pExceptPtrs->ExceptionRecord,
                                        sizeof(EXCEPTION_RECORD));
    memcpy (&gContextRecord, pExceptPtrs->ContextRecord,
                                        sizeof (CONTEXT));
#endif

    /* Get the address the exception was caused at. */
    *pExceptionAddress = pExceptPtrs->ExceptionRecord->ExceptionAddress;


    switch (*pdwException = pExceptPtrs->ExceptionRecord->ExceptionCode) {
      case DSA_EXCEPTION:
      case DSA_BAD_ARG_EXCEPTION:
      case DRA_GEN_EXCEPTION:
      case DSA_DB_EXCEPTION:
      case DSA_CRYPTO_EXCEPTION:
	pExceptInfo = pExceptPtrs->ExceptionRecord->ExceptionInformation;
	*pulErrorCode = (ULONG)pExceptInfo[0];
        ul2Unused = (ULONG)pExceptInfo[1];
	*pdsid = (ULONG)pExceptInfo[2];
	break;

      case STATUS_NO_MEMORY:
      case DSA_MEM_EXCEPTION:
	break;

      default:
	*pulErrorCode = 0;
	ul2Unused = 0;
	*pdsid = 0;
	break;
    }

    return DoHandleMostExceptions(pExceptPtrs, *pdwException, *pdsid);
}


// This is the generic filter expression for the top level DRA
// exception handlers.

DWORD GetDraException (EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret)
{
    DWORD dwException;
    ULONG ulErrorCode;
    ULONG dsid;
    DWORD dwStatus;
    PVOID dwEA;

    dwStatus = GetExceptionData(pExceptPtrs, &dwException, &dwEA,
				&ulErrorCode, &dsid);

    switch (dwException) {

    case STATUS_NO_MEMORY:
    case DSA_MEM_EXCEPTION:
	LogEvent(DS_EVENT_CAT_REPLICATION,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_DRA_OUT_OF_MEMORY,
		NULL,
		NULL,
		NULL);
        *pret = DRAERR_OutOfMem;
        break;

    case DRA_GEN_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        *pret = ulErrorCode;
        break;

    case DSA_DB_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        switch (ulErrorCode) {

        case JET_errKeyDuplicate:
        case JET_errWriteConflict:
            *pret = DRAERR_Busy;
            break;

        case JET_errLogDiskFull:
        case JET_errDiskFull:
            *pret = ERROR_DISK_FULL;
            break;

        case JET_errVersionStoreOutOfMemory:
            *pret = ERROR_DS_OUT_OF_VERSION_STORE;
            break;

        case JET_errRecordTooBig:
            *pret = ERROR_DS_MAX_OBJ_SIZE_EXCEEDED;
            break;

        default:
            *pret = DRAERR_DBError;
            break;
        }
        break;

    case DSA_CRYPTO_EXCEPTION:
        Assert(ulErrorCode && "Missing error code in exception");
        Assert(!"crypto exception -- call Murli, not Will & Jeff");
        *pret = ulErrorCode;
        break;

    default:

        *pret = DRAERR_InternalError;
        Assert (!"Encountered unexpected DRA exception");
        break;
    }

    return dwStatus;
}


DWORD
DoHandleMostExceptions(EXCEPTION_POINTERS* pExceptPtrs,
                       DWORD dwException,
                       ULONG ulInternalId)
{
    switch (dwException) {
      case EXCEPTION_ACCESS_VIOLATION:	        // these exceptions are
      case EXCEPTION_BREAKPOINT:                // not handeled
      case EXCEPTION_DATATYPE_MISALIGNMENT:     // (added to trap JET problems)
      case STATUS_POSSIBLE_DEADLOCK:
      case EXCEPTION_SINGLE_STEP:
      case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
      case EXCEPTION_FLT_DENORMAL_OPERAND:
      case EXCEPTION_FLT_DIVIDE_BY_ZERO:
      case EXCEPTION_FLT_INEXACT_RESULT:
      case EXCEPTION_FLT_INVALID_OPERATION:
      case EXCEPTION_FLT_OVERFLOW:
      case EXCEPTION_FLT_STACK_CHECK:
      case EXCEPTION_FLT_UNDERFLOW:
      case EXCEPTION_INT_DIVIDE_BY_ZERO:
      case EXCEPTION_INT_OVERFLOW:
      case EXCEPTION_PRIV_INSTRUCTION:
      case EXCEPTION_IN_PAGE_ERROR:
      case EXCEPTION_ILLEGAL_INSTRUCTION:
      case EXCEPTION_NONCONTINUABLE_EXCEPTION:
      case EXCEPTION_INVALID_DISPOSITION:
      case EXCEPTION_GUARD_PAGE:
      case EXCEPTION_INVALID_HANDLE:
        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_EXCEPTION,
                  szInsertHex(dwException),
                  szInsertPtr(pExceptPtrs->ExceptionRecord->ExceptionAddress),
                  szInsertInt(0),
                  szInsertHex(ulInternalId),
                  NULL,
                  NULL,
                  NULL,
                  NULL);
        // fall through...

      case EXCEPTION_STACK_OVERFLOW: // Don't try to log when we have no stack
        return EXCEPTION_CONTINUE_SEARCH;

      default:					// others, however, are
        return EXCEPTION_EXECUTE_HANDLER;
    }
}
