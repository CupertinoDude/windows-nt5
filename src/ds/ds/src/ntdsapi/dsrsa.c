/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dsrsa.c

ABSTRACT:

    Syncs a specified server with all others in its site, using transitive replication
    as necessary.

DETAILS:

CREATED:

    06/30/98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    12/11/98    Will Lees (wlees)
      1. Allow to work for synchronous (RPC-based) intersite connections
      2. Implement a "push mode" to force a change out to all servers

Suggestions for future enhancements:
o Add support for mail-based replicas. Perhaps these could be allowed as "leaf nodes" at the last,
  most distant phase of replication?
o Abstract the list handling into a class.  Right now some of the list handling is embedded in
  the body of the code.  Not the mention the fact that the lists are unusual: the list always has
  an allocated but uninitialized element hanging at the end.
o Abstract the binary tree routines into a class.

QUESTIONS
o Can threads get stuck if an exception is thrown?
o NameMatched doesn't impose an ordering on DNs; could this lead to problems?

--*/

#define _NTDSAPI_

#if !WIN95 && !WINNT4
    #include <process.h>
    #include <nt.h>
    #include <ntrtl.h>
    #include <ntdspch.h>
    #include <winerror.h>
    #include <ntdsa.h>
    #include <winldap.h>
    #include <w32topl.h>
    #include <drs.h>
    #include <bind.h>
    #include "util.h"
    #include "minmax.h"

// Debugging stuff.  Note order is important, just want the Assert() from debug.h, but not the DPRINTs, because
//   we have our own DPRINTs in dsrsa.h
    #include <debug.h>
    #define DEBSUB     "DSRSA:"           // define the subsystem for debugging
    #undef DPRINT
    #undef DPRINT1
    #undef DPRINT2
    #include "dsrsa.h"

    #if DBG
DWORD gdwDsRSADbgLevel = 0;
    #endif

// 38 = (32 GUID numerals + 4 hyhens + 1 dot + 6 chars + 1 dot + 1 null terminator)
    #define ADDITIONAL_BYTES_FOR_GUID_DNS	45

    #define DsRSAChkErr(x) { DWORD _dwWin32Err = (x); if (NO_ERROR != _dwWin32Err) DsRSAException (_dwWin32Err); }

    #define DsRSAChkLdap(x) { DWORD _dwLDAPErr = (x); if (NO_ERROR != _dwLDAPErr) DsRSAException (LdapMapErrorToWin32 (_dwLDAPErr)); }

    #define DsRSAFree(heap,lpMem) HeapFree (heap, 0L, lpMem)

    #define DsRSAHeapCreate(pHeap) \
	((*(pHeap) = HeapCreate (0L, 0L, 0L)) == NULL ? GetLastError () : NO_ERROR)

    #define DsRSAHeapDestroy(heap) \
	(HeapDestroy (heap) == FALSE ? GetLastError () : NO_ERROR)

    #define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

    #define SITES_PREFIX L"CN=Sites,"
    #define IP_PREFIX L"CN=IP,"
    #define IP_PREFIX_LEN  (ARRAY_SIZE(IP_PREFIX) - 1)
    #define DEFAULT_PAGED_SEARCH_PAGE_SIZE          (1000)

// All exceptions generated by DsReplicaSyncAll will have exception code DS_RSAI_EXCEPTION.
// The win32 error responsible for the exception is stored as the first argument.

VOID
DsRSAException (
    DWORD           dwWin32Err
    ) {
    UINT_PTR err = dwWin32Err;

    RaiseException (DS_RSAI_EXCEPTION,
        EXCEPTION_NONCONTINUABLE,
        1,
        &err);
}

// This is just a wrapper that allocates memory from a private heap.

LPVOID
DsRSAAlloc (
    HANDLE          heap,
    DWORD           dwBytes
    ) {
    LPVOID          pMem;

    if( (pMem = HeapAlloc (heap, 0L, dwBytes)) == NULL )
        DsRSAException (GetLastError ());

    return pMem;
}

// Inserts an element into a list and returns a pointer to the next (empty)
// location in the list.
// Note that the style of list used in this module is for the last element to be allocated
// but not initialized.

PDS_RSAI_LIST
DsRSAListInsert (
    HANDLE          heap,
    PDS_RSAI_LIST   pList,
    ULONG_PTR       ulpData
    ) {
    pList->ulpItem = ulpData;
    pList->next = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
    pList->next->next = NULL;
    return(pList->next);
}

// Destroys a list.
// Note that the pItem in each element is NOT deallocated. Caller must dispose.

VOID
DsRSAListDestroy (
    HANDLE          heap,
    PDS_RSAI_LIST       pList
    ) {

    PDS_RSAI_LIST       plistTemp;

    while( pList != NULL ) {
        plistTemp = pList->next;
        DsRSAFree (heap, pList);
        pList = plistTemp;
    }
}

// Converts a unicode string to an ANSI string, allocating a buffer of
// appropriate size.

LPSTR
DsRSAAllocToANSI (
    HANDLE          heap,
    LPWSTR          pszW
    ) {

    LPSTR           pszA;
    ULONG           ulBufSize;

    if( pszW == NULL ) {
        pszA = NULL;
    }
    else {
        ulBufSize = (wcslen (pszW) + 1) * sizeof (CHAR);
        pszA = (LPSTR) DsRSAAlloc (heap, ulBufSize);
        WideCharToMultiByte (
            CP_ACP,
            0L,
            pszW,
            -1,
            pszA,
            ulBufSize,
            NULL,
            NULL);
    }
    return(pszA);
}

// Perform unicode -> ANSI conversion for callback updates.

BOOL
DsRSAIssueANSIUpdate (
    HANDLE          heap,
    BOOL (__stdcall *       pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_UPDATEW  pUpdateW
    ) {

    DS_REPSYNCALL_ERRINFOA  errorA;
    DS_REPSYNCALL_SYNCA     syncA;
    DS_REPSYNCALL_UPDATEA   updateA;
    BOOL            bReturn;

    if( pUpdateW->pSync == NULL ) {
        updateA.pSync = NULL;
    }
    else {
        syncA.pszSrcId = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszSrcId);
        syncA.pszDstId = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszDstId);
        syncA.pszNC = DsRSAAllocToANSI (heap, pUpdateW->pSync->pszNC);
        syncA.pguidSrc = pUpdateW->pSync->pguidSrc;
        syncA.pguidDst = pUpdateW->pSync->pguidDst;
        updateA.pSync = &syncA;
    }
    if( pUpdateW->pErrInfo == NULL ) {
        updateA.pErrInfo = NULL;
    }
    else {
        errorA.pszSvrId = DsRSAAllocToANSI (heap, pUpdateW->pErrInfo->pszSvrId);
        errorA.error = pUpdateW->pErrInfo->error;
        errorA.dwWin32Err = pUpdateW->pErrInfo->dwWin32Err;
        errorA.pszSrcId = DsRSAAllocToANSI (heap, pUpdateW->pErrInfo->pszSrcId);
        updateA.pErrInfo = &errorA;
    }
    updateA.event = pUpdateW->event;

    bReturn = pFnCallBackA (pCallbackData, &updateA);

    if( updateA.pSync ) {
        if( syncA.pszSrcId ) DsRSAFree (heap, syncA.pszSrcId);
        if( syncA.pszDstId ) DsRSAFree (heap, syncA.pszDstId);
        if( syncA.pszNC ) DsRSAFree (heap, syncA.pszNC);
    }
    if( updateA.pErrInfo ) {
        if( errorA.pszSvrId ) DsRSAFree (heap, errorA.pszSvrId);
        if( errorA.pszSrcId ) DsRSAFree (heap, errorA.pszSrcId);
    }

    return bReturn;
}

// Send out an update using the callback function in pMainInfo.

VOID
DsRSAIssueUpdate (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    DS_REPSYNCALL_EVENT     event,
    PDS_REPSYNCALL_ERRINFOW pErrInfo,
    PDS_REPSYNCALL_SYNCW    pSync
    ) {

    DS_REPSYNCALL_UPDATEW   update;
    BOOL            bContinueExecution;

    update.event = event;
    update.pErrInfo = pErrInfo;
    update.pSync = pSync;
    bContinueExecution = TRUE;
    if( pMainInfo->pFnCallBackA ) {
        bContinueExecution = DsRSAIssueANSIUpdate (heap, pMainInfo->pFnCallBackA, pMainInfo->pCallbackData, &update);
    }
    if( pMainInfo->pFnCallBackW ) {
        bContinueExecution = pMainInfo->pFnCallBackW (pMainInfo->pCallbackData, &update);
    }
    if( !bContinueExecution ) {
        DsRSAException (ERROR_CANCELLED);               // Zap!
    }
}

// A wrapper that simplifies issuing updates of syncs.

VOID
DsRSAIssueUpdateSync (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    DS_REPSYNCALL_EVENT     event,
    PDS_RSAI_SVRINFO            pSrcSvrInfo,
    PDS_RSAI_SVRINFO            pDstSvrInfo
    ) {

    DS_REPSYNCALL_SYNCW     sync;

    sync.pszSrcId = pSrcSvrInfo->pszMsgId;
    sync.pszDstId = pDstSvrInfo->pszMsgId;
    sync.pszNC = pMainInfo->pdsnameNameContext->StringName;
    sync.pguidSrc = &(pSrcSvrInfo->guid);
    sync.pguidDst = &(pDstSvrInfo->guid);

    DsRSAIssueUpdate (heap, pMainInfo, event, NULL, &sync);
}

// When a nonfatal error occurs, this routine reports it to the callback function
// and inserts it to the error list maintained in pMainInfo.

VOID
DsRSADoError (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    LPWSTR          pszSvrId,
    DS_REPSYNCALL_ERROR     error,
    DWORD           dwWin32Err,
    LPWSTR          pszSrcId
    ) {

    PDS_REPSYNCALL_ERRINFOW pErrInfo;

    pErrInfo = DsRSAAlloc (heap, sizeof (DS_REPSYNCALL_ERRINFOW));
    pErrInfo->pszSvrId = pszSvrId;
    pErrInfo->error = error;
    pErrInfo->dwWin32Err = dwWin32Err;
    pErrInfo->pszSrcId = pszSrcId;
    DsRSAIssueUpdate (heap, pMainInfo, DS_REPSYNCALL_EVENT_ERROR, pErrInfo, NULL);
    pMainInfo->plistNextError = DsRSAListInsert (heap, pMainInfo->plistNextError, (ULONG_PTR) pErrInfo);
}

// Destroys a list of errors.

VOID
DsRSAErrListDestroy (
    HANDLE          heap,
    PDS_RSAI_LIST       plistFirstError
    ) {

    PDS_RSAI_LIST       plistNextError;

    for( plistNextError = plistFirstError;
         plistNextError->next != NULL;
         plistNextError = plistNextError->next ) {
        DsRSAFree (heap, (LPVOID) plistNextError->ulpItem);
    }
    DsRSAListDestroy (heap, plistFirstError);
}

PDSNAME
DsRSAAllocBuildDsname (
    HANDLE          heap,
    LPCWSTR                      pszDn
    ) {

    PDSNAME         pdsnameLocal;
    PDSNAME         pdsnameHeap;

    pdsnameLocal = pdsnameHeap = NULL;

    __try {

        DsRSAChkErr (AllocBuildDsname (pszDn, &pdsnameLocal));

        // Note that if pszDN is NULL, AllocBuildDsname succeeds and sets
        // pdsnameLocal to NULL, in which case pdsnameHeap remains NULL.

        if (NULL != pdsnameLocal) {
            pdsnameHeap = DsRSAAlloc (heap, pdsnameLocal->structLen);
            memcpy (pdsnameHeap, pdsnameLocal, pdsnameLocal->structLen);
        }
    } __finally {

        if( pdsnameLocal != NULL ) LocalFree (pdsnameLocal);

    }

    return pdsnameHeap;
}

// Compares two DNs.  Returns 0 if they are the same, < 0 if Dn1 < Dn2, and > 0 if Dn1 > Dn2.

INT
DsRSADnCmp (
    PDSNAME         pDsname1,
    PDSNAME         pDsname2
    ) {

    INT             iCmp;

    // if (NameMatched (pDsname1, pDsname2)) iCmp = 0;
    // else

    iCmp = _wcsicmp (pDsname1->StringName, pDsname2->StringName);

    return iCmp;
}

// DS_RSAI_SVMAP is a mapping between servers and vertices, stored as a binary
// search tree.  This routine updates the root node of a tree.

VOID
DsRSASvMapUpdate (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    if( pSvMap != NULL ) {
        pSvMap->vertex = vertex;
        if( pSvMap->pDsname != NULL ) {
            DsRSAFree (heap, pSvMap->pDsname);
        }
        if( pDsname == NULL ) {
            pSvMap->pDsname = NULL;
        }
        else {
            pSvMap->pDsname = pDsname;
        }
    }
}

// Creates a new tree, assigning the specified attributes to the root node.

PDS_RSAI_SVMAP
DsRSASvMapCreate (
    HANDLE          heap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    PDS_RSAI_SVMAP      pSvMap;

    pSvMap = (PDS_RSAI_SVMAP) DsRSAAlloc (heap, sizeof (DS_RSAI_SVMAP));
    pSvMap->left = NULL;
    pSvMap->right = NULL;
    pSvMap->pDsname = NULL;
    DsRSASvMapUpdate (heap, pSvMap, pDsname, vertex);

    return pSvMap;
}

// Inserts a server-vertex pair into an SvMap tree.

PDS_RSAI_SVMAP
DsRSASvMapInsert (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    PDSNAME         pDsname,
    TOPL_VERTEX         vertex
    ) {

    PDS_RSAI_SVMAP      psvmapTemp = pSvMap;
    INT             iCmp;

    if( pSvMap == NULL ) {
        pSvMap = DsRSASvMapCreate (heap, pDsname, vertex);
    }

    else {
        while( psvmapTemp != NULL ) {
            iCmp = DsRSADnCmp (pDsname, psvmapTemp->pDsname);
            if( iCmp == 0 ) {
                DsRSASvMapUpdate (heap, pSvMap, pDsname, vertex);
                break;
            }
            if( iCmp < 0 ) {
                if( psvmapTemp->left == NULL ) {
                    psvmapTemp->left = DsRSASvMapCreate (heap, pDsname, vertex);
                    break;
                }
                else {
                    psvmapTemp = psvmapTemp->left;
                }
            }
            else {
                if( psvmapTemp->right == NULL ) {
                    psvmapTemp->right = DsRSASvMapCreate (heap, pDsname, vertex);
                    break;
                }
                else {
                    psvmapTemp = psvmapTemp->right;
                }
            }
        }
    }

    return pSvMap;
}

// Returns the vertex that has been associated with a given Dn.

TOPL_VERTEX
DsRSASvMapGetVertex (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap,
    LPWSTR          pszDn
    ) {

    TOPL_VERTEX         vertex = NULL;
    PDSNAME         pDsname;
    INT             iCmp;

    pDsname = DsRSAAllocBuildDsname (heap, pszDn);

    while( pSvMap != NULL ) {
        iCmp = DsRSADnCmp (pDsname, pSvMap->pDsname);
        if( iCmp == 0 ) {
            vertex = pSvMap->vertex;
            break;
        }
        if( iCmp < 0 ) {
            pSvMap = pSvMap->left;
        }
        else {
            pSvMap = pSvMap->right;
        }
    }

    DsRSAFree (heap, pDsname);

    return vertex;
}

// Frees an SvMap tree.  Free the elements recursively.

VOID
DsRSASvMapDestroy (
    HANDLE          heap,
    PDS_RSAI_SVMAP      pSvMap
    ) {

    if( pSvMap != NULL ) {
        DsRSAFree (heap, pSvMap->pDsname);
        DsRSASvMapDestroy (heap, pSvMap->left);
        DsRSASvMapDestroy (heap, pSvMap->right);
        DsRSAFree (heap, pSvMap);
    }
}

// This converts a root domain and a GUID to a GUID DNS.  The return
// value should be freed with DsRSAFree ().

LPWSTR
DsRSAAllocGuidDNS (
    HANDLE          heap,
    LPWSTR          pszRootDomain,
    GUID *          pGuid
    ) {

    LPWSTR          pszGuidDNS;

    pszGuidDNS = (LPWSTR) DsRSAAlloc (heap, (wcslen (pszRootDomain) + ADDITIONAL_BYTES_FOR_GUID_DNS) * sizeof (WCHAR));
    swprintf (pszGuidDNS, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x._msdcs.%s",
        pGuid->Data1,
        pGuid->Data2,
        pGuid->Data3,
        pGuid->Data4[0],
        pGuid->Data4[1],
        pGuid->Data4[2],
        pGuid->Data4[3],
        pGuid->Data4[4],
        pGuid->Data4[5],
        pGuid->Data4[6],
        pGuid->Data4[7],
        pszRootDomain);
    return pszGuidDNS;
}

// Builds the topology.

VOID
DsRSABuildTopology (
    HANDLE          heap,
    LDAP *          hld,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO *     ppToplInfo
    ) {

    LPWSTR          ppszNtdsDsaSearch [] = {    L"hasMasterNCs",
        L"objectGUID",
        NULL};

    LPWSTR          ppszConnectionSearch [] = { L"transportType",
        L"fromServer",
        NULL};

    LPWSTR          pszNtdsDsaSearchTemplate =
        L"(&(objectCategory=ntdsDsa)(|(hasMasterNCs=%s)(hasPartialReplicaNCs=%s)))";

    LPWSTR          pszNtdsConnSearchTemplate =
        L"(&(objectCategory=nTDSConnection)(enabledConnection=TRUE))";

    HANDLE          hDS = NULL;
    DWORD           dwWin32Err;

    PDS_NAME_RESULTW        pResult = NULL;                 // For CrackNames
    PDSNAME         pDsname;
    PDSNAME         pdsnameHome;
    PDSNAME         pdsnameServer;

    LDAPMessage *       pldmRootResults = NULL;
    LDAPMessage *       pldmRootEntry = NULL;
    LPWSTR *            ppszConfigurationNC = NULL;
    LPWSTR *            ppszServiceName = NULL;
    LPWSTR *            ppszRootDNC = NULL;

    LPWSTR          pszNtdsDsaSearchFilter;
    LDAPSearch *        pDsaSearch = NULL;
    LDAPMessage *       pldmNtdsDsaResults = NULL;
    LDAPMessage *       pldmNtdsDsaEntry = NULL;
    LPWSTR *            ppszMasterNCs = NULL;
    struct berval **        ppbvObjectGUID = NULL;
    LPWSTR          pszServerDn = NULL;
    LPWSTR          pszServerTempDn = NULL;
    LPWSTR          pszSitesContainerDn = NULL;

    LDAPSearch *        pConnSearch = NULL;
    LDAPMessage *       pldmConnectionResults = NULL;
    LDAPMessage *       pldmConnectionEntry = NULL;
    LPWSTR *            ppszConnectionFrom = NULL;
    LPWSTR *            ppszTransportType = NULL;

    PDS_RSAI_SVMAP      pSvMapDnToVertex = NULL;
    PDS_RSAI_LIST       plistFirstServer;
    PDS_RSAI_LIST       plistNextServer;
    PDS_RSAI_SVRINFO        pSvrInfo;
    LPWSTR          pszGuidDNS;
    LONG            lNCAt;

    TOPL_VERTEX         vertex;
    TOPL_VERTEX         vHere;
    TOPL_VERTEX         vThere;
    TOPL_EDGE           edge;
    DWORD               dwThisId;
    ULONG               ul;
    INT                 iCmp;

    DWORD               dwLdapErr;
    DWORD               dwInnerLdapErr;
    ULONG               ulTotalEstimate = 0;
    ULONG               ulInnerTotalEstimate = 0;

    __try {

        // Set up the topology.
        *ppToplInfo = (PDS_RSAI_TOPLINFO) DsRSAAlloc (heap, sizeof (DS_RSAI_TOPLINFO));
        (*ppToplInfo)->toplGraph = NULL;

        // Create a list that will be used to store the servers.
        plistFirstServer = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
        plistFirstServer->next = NULL;
        plistNextServer = plistFirstServer;

        DsRSAChkLdap (ldap_search_sW (
            hld,
            NULL,
            LDAP_SCOPE_BASE,
            L"(objectCategory=*)",
            NULL,
            0,
            &pldmRootResults));

        if ((NULL == (pldmRootEntry = ldap_first_entry(hld, pldmRootResults)))
            || (NULL == (ppszConfigurationNC
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"configurationNamingContext")))
            || (NULL == (ppszServiceName
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"dsServiceName")))
            || (NULL == (ppszRootDNC
                         = ldap_get_valuesW(hld, pldmRootEntry,
                                            L"rootDomainNamingContext")))) {
            DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
        }

        DPRINT1( 3, "Home = %ws\n", ppszServiceName[0] );
        pdsnameHome = DsRSAAllocBuildDsname (heap, ppszServiceName[0]);

        // If the NC is NULL, default to the configuration NC
        if( pMainInfo->pdsnameNameContext == NULL ) {
            pMainInfo->pdsnameNameContext = DsRSAAllocBuildDsname (heap, ppszConfigurationNC[0]);
        }

        (*ppToplInfo)->toplGraph = ToplGraphCreate ();
        (*ppToplInfo)->vHome = NULL;

        // We use DsCrackNamesW to convert the Root Domain NC to the Root Domain Name
        // (e.g. DC=nttest,DC=microsoft,DC=com => nttest.microsoft.com)

        DsRSAChkErr (DsCrackNamesW (
            NULL,
            DS_NAME_FLAG_SYNTACTICAL_ONLY,
            DS_FQDN_1779_NAME,
            DS_CANONICAL_NAME_EX,
            1,
            ppszRootDNC,
            &pResult));

        (*ppToplInfo)->pszRootDomain = DsRSAAlloc (heap, (wcslen (pResult->rItems[0].pDomain) + 1) * sizeof (WCHAR));
        wcscpy ((*ppToplInfo)->pszRootDomain, pResult->rItems[0].pDomain);

        // *******************************************************************************************

        if( pMainInfo->ulFlags & DS_REPSYNCALL_CROSS_SITE_BOUNDARIES ) {
            // Form the Sites container dn from the sites prefix and the configuration NC DN

            pszSitesContainerDn = DsRSAAlloc( heap, sizeof( SITES_PREFIX ) + ((wcslen( ppszConfigurationNC[0] ) + 1) * sizeof( WCHAR )) );
            wcscpy( pszSitesContainerDn, SITES_PREFIX );
            wcscat( pszSitesContainerDn, ppszConfigurationNC[0] );
        }
        else {
            PDSNAME pdsnameTrimmed;
            // ppszServiceName[0] is the DN of the home server's NTDS Settings object.
            // This object is the grandchild of the Servers container, so we use TrimDSNameBy
            // to shorten its DN.
            pdsnameTrimmed = (PDSNAME) DsRSAAlloc (heap, pdsnameHome->structLen);
            TrimDSNameBy (pdsnameHome, 2, pdsnameTrimmed);

            pszSitesContainerDn = DsRSAAlloc( heap, (wcslen( pdsnameTrimmed->StringName ) + 1) * sizeof(WCHAR) );
            wcscpy( pszSitesContainerDn,  pdsnameTrimmed->StringName );
        }

        DPRINT1( 2, "Sites container = %ws\n", pszSitesContainerDn );

        // Now perform the main search to get all applicable servers.  We want references
        // to the servers' NTDS Settings objects.  Note that, because of the filter, on those
        // servers holding the desired NC (either writable or read-only) are included.
        pszNtdsDsaSearchFilter = DsRSAAlloc (heap, (wcslen (pszNtdsDsaSearchTemplate) +
                                     2 * wcslen (pMainInfo->pdsnameNameContext->StringName) + 1) * sizeof (WCHAR));
        swprintf (pszNtdsDsaSearchFilter, pszNtdsDsaSearchTemplate,
            pMainInfo->pdsnameNameContext->StringName,
            pMainInfo->pdsnameNameContext->StringName);
	
        DPRINT1( 2, "Search filter = %ws\n", pszNtdsDsaSearchFilter );

        pDsaSearch = ldap_search_init_pageW(hld,
					pszSitesContainerDn,
					LDAP_SCOPE_SUBTREE,
					pszNtdsDsaSearchFilter,
					ppszNtdsDsaSearch,
					FALSE, NULL, NULL, 0, 0, NULL);
	if(pDsaSearch == NULL){
	    DsRSAChkLdap(LdapGetLastError());
	}

	DsRSAFree (heap, pszNtdsDsaSearchFilter);
        DsRSAFree (heap, pszSitesContainerDn);	

        // *******************************************************************************************

        // Cycle through the applicable servers and add them into the plistNextServer list.

        dwThisId = 0L;      // Start the IDs at 0
		
	dwLdapErr = ldap_get_next_page_s(hld,
					 pDsaSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmNtdsDsaResults);

        while(dwLdapErr == LDAP_SUCCESS){

            pldmNtdsDsaEntry = ldap_first_entry (hld, pldmNtdsDsaResults);
	    while( pldmNtdsDsaEntry != NULL ) {
		
                pszServerDn = ldap_get_dnW (hld, pldmNtdsDsaEntry);     // The server's DN

                DPRINT1( 3, "ServerDn = %ws\n", pszServerDn );

                // Create a DS_RSAI_SVRINFO structure for this server.
		pSvrInfo = (PDS_RSAI_SVRINFO) DsRSAAlloc (heap, sizeof (DS_RSAI_SVRINFO));
		pSvrInfo->dwId = dwThisId;

                // Cache the Dn in the pSvrInfo structure
                pSvrInfo->pszSvrDn = (LPWSTR) DsRSAAlloc (heap, (wcslen(pszServerDn) + 1)  * sizeof(WCHAR));
                wcscpy(pSvrInfo->pszSvrDn, pszServerDn);

                // Check if this server is a master for this NC (otherwise it is partial)
		pSvrInfo->bIsMaster = FALSE;
		ppszMasterNCs = ldap_get_valuesW (hld, pldmNtdsDsaEntry, L"hasMasterNCs");
		for( lNCAt = 0;
		    ppszMasterNCs && ppszMasterNCs[lNCAt];
		    lNCAt++ ) {
		    pDsname = DsRSAAllocBuildDsname (heap, ppszMasterNCs[lNCAt]);
		    iCmp = DsRSADnCmp (pDsname, pMainInfo->pdsnameNameContext);
		    DsRSAFree (heap, pDsname);
		    if( 0 == iCmp ) {
			pSvrInfo->bIsMaster = TRUE;
			break;
		    }
		}
		ldap_value_freeW (ppszMasterNCs);
		ppszMasterNCs = NULL;

		// Get this server's GUID and store a copy in pSvrInfo.
		ppbvObjectGUID = ldap_get_values_lenW (hld, pldmNtdsDsaEntry, L"objectGUID");
                if (NULL == ppbvObjectGUID) {
                    DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                }
		memcpy ((LPVOID) &pSvrInfo->guid, (LPVOID) ppbvObjectGUID[0]->bv_val, ppbvObjectGUID[0]->bv_len);

		// Get this server's GUID DNS.
		pszGuidDNS = DsRSAAllocGuidDNS (heap, (*ppToplInfo)->pszRootDomain, (GUID *) ppbvObjectGUID[0]->bv_val);
		// Create the string in pSvrInfo that will be used to identify this server when reporting errors.
		if( pMainInfo->ulFlags & DS_REPSYNCALL_ID_SERVERS_BY_DN ) {
		    pSvrInfo->pszMsgId = (LPWSTR) DsRSAAlloc (heap, (wcslen (pszServerDn) + 1) * sizeof (WCHAR));
		    wcscpy (pSvrInfo->pszMsgId, pszServerDn);
		}
		else {
		    pSvrInfo->pszMsgId = pszGuidDNS;        // (pszGuidDNS has already been allocated)
		}

		// Check if this server is responding.
		if( (pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ||
		    ((dwWin32Err = DsBindWithCredW (pszGuidDNS, NULL, hRpcai, &hDS)) == NO_ERROR) ) {
                    DPRINT1( 4, "Server %ws is responding.\n", pszServerDn );
		    // Either we're supposed to skip the check, or the check was successful.  Add this
		    // server to the graph.
		    if( !(pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ) {
			DsUnBindW (&hDS);
		    }
		    vertex = ToplVertexCreate ();
		    ToplVertexSetId (vertex, dwThisId);
		    ToplGraphAddVertex ((*ppToplInfo)->toplGraph, vertex, vertex);
		    // Is this the home server?
		    pdsnameServer = DsRSAAllocBuildDsname (heap, pszServerDn);
		    if( 0 == DsRSADnCmp (pdsnameServer, pdsnameHome) ) {
			(*ppToplInfo)->vHome = vertex;
		    }

		    // Insert this server-vertex pair into the SvMap.
		    pSvMapDnToVertex = DsRSASvMapInsert (heap, pSvMapDnToVertex, pdsnameServer, vertex);
		    pSvrInfo->bIsInGraph = TRUE;
		}
		else {
		    // The check was unsuccessful.  Do not add this server to the graph.
		    hDS = NULL;
		    if( !(pMainInfo->ulFlags & DS_REPSYNCALL_SKIP_INITIAL_CHECK) ) {
			DsRSADoError (heap, pMainInfo, pSvrInfo->pszMsgId, DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER, dwWin32Err, NULL);
		    }
		    pSvrInfo->bIsInGraph = FALSE;
		}

		// If pSvrInfo->pszMsgId points to the GUID DNS then we don't need to free it.
		if( pMainInfo->ulFlags & DS_REPSYNCALL_ID_SERVERS_BY_DN ) {
		    DsRSAFree (heap, pszGuidDNS);
		}

		// Insert this pSvrInfo structure into the list of servers.
		plistNextServer = DsRSAListInsert (heap, plistNextServer, (ULONG_PTR) pSvrInfo);

		ldap_value_free_len (ppbvObjectGUID);
		ppbvObjectGUID = NULL;

		ldap_memfreeW (pszServerDn);
		pszServerDn = NULL;

		dwThisId++;
		pldmNtdsDsaEntry = ldap_next_entry (hld, pldmNtdsDsaEntry);

	    }  // while( pldmNtdsDsaEntry != NULL )

	    ldap_msgfree(pldmNtdsDsaResults);
	    pldmNtdsDsaResults = NULL;

	    dwLdapErr = ldap_get_next_page_s(hld,
					     pDsaSearch,
					     0,
					     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					     &ulTotalEstimate,
					     &pldmNtdsDsaResults);

	} // while there is not error from the next paged search result set.
	
	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    DsRSAChkLdap(dwLdapErr);
	}
        dwLdapErr = ldap_search_abandon_page(hld, pDsaSearch);
	pDsaSearch = NULL; // subtlty here, need to set NULL, before calling DsRSAChkLdap()
	DsRSAChkLdap(dwLdapErr);

        // Store the total number of servers (including servers that were not added to the graph.)
        DPRINT1( 2, "Servers found = %d\n", dwThisId );
        (*ppToplInfo)->ulSize = (ULONG) dwThisId;
        if (!dwThisId) {
            // No servers found during search - abort
            DsRSAException (ERROR_DS_CANT_FIND_EXPECTED_NC);
        }

	// Convert the DS_RSAI_SVRINFO list into an array.
        (*ppToplInfo)->servers = (PDS_RSAI_SVRINFO *) DsRSAAlloc (heap, dwThisId * sizeof (PDS_RSAI_SVRINFO));
        plistNextServer = plistFirstServer;
        for( ul = 0; plistNextServer->next != NULL; ul++ ) {
            (*ppToplInfo)->servers[ul] = (PDS_RSAI_SVRINFO) plistNextServer->ulpItem;
            plistNextServer = plistNextServer->next;
        }
        DsRSAListDestroy (heap, plistFirstServer);

        // *******************************************************************************************

        // Now add the connections between servers (graph edges.)

        // Code.Improvement: It would be better to do a single subtree search for ntdsaConnection
        //    objects once, instead of issuing one search for each ntdsa object, as is done below
        //    in the inner loop and ldap_search_init_pageW().

        for(ul = 0; ul < (*ppToplInfo)->ulSize; ul++){

            pszServerTempDn = (*ppToplInfo)->servers[ul]->pszSvrDn;

            vHere = DsRSASvMapGetVertex (heap, pSvMapDnToVertex, pszServerTempDn);

            // We only analyze this server if both:
	    // (a) vHere is alive (that is, DsRSASvMapGetVertex did not return NULL);
	    // (b) if DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY is set, then vHere is home
            //     (i.e. either DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY is clear or vHere is home.)
            if( vHere != NULL && (     !(pMainInfo->ulFlags & DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY)
                                       ||  (vHere == (*ppToplInfo)->vHome)) ) {

                // Get all connections directed into this server.
                // The filter enforces only enabled connections
		
                pConnSearch = ldap_search_init_pageW(hld,
                                                     pszServerTempDn,
                                                     LDAP_SCOPE_ONELEVEL,
                                                     pszNtdsConnSearchTemplate,
                                                     ppszConnectionSearch,
                                                     FALSE, NULL, NULL, 0, 0, NULL);
                if(pConnSearch == NULL){
                    DsRSAChkLdap(LdapGetLastError());
                }

                dwInnerLdapErr = ldap_get_next_page_s(hld,
                                                      pConnSearch,
                                                      0,
                                                      DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                                      &ulInnerTotalEstimate,
                                                      &pldmConnectionResults);

                // Cycle through those connections, adding edges to the graph.
                while(dwInnerLdapErr == LDAP_SUCCESS){

                    pldmConnectionEntry = ldap_first_entry (hld, pldmConnectionResults);

                    while( pldmConnectionEntry != NULL ) {

                        ppszTransportType = ldap_get_valuesW (hld, pldmConnectionEntry, L"transportType");
                        if( (ppszTransportType == NULL) ||
                            (_wcsnicmp( ppszTransportType[0], IP_PREFIX, IP_PREFIX_LEN ) == 0) ) {

                            ppszConnectionFrom = ldap_get_valuesW (hld, pldmConnectionEntry, L"fromServer");
                            if (NULL == ppszConnectionFrom) {
                                DsRSAException(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
                            }

                            // Determine which vertex the connection comes from.
                            vThere = DsRSASvMapGetVertex (heap, pSvMapDnToVertex, ppszConnectionFrom[0]);
                            // We only add this connection if both:
                            // (a) vThere is alive (that is, DsRSASvMapGetVertex did not return NULL);
                            // (b) either vHere is a partialReplica or vThere is a master for this NC.
                            if( vThere != NULL &&
                                ( !(*ppToplInfo)->servers[ToplVertexGetId (vHere )]->bIsMaster ||
                                  (*ppToplInfo)->servers[ToplVertexGetId (vThere)]->bIsMaster) ) {
                                edge = ToplEdgeCreate ();
                                ToplEdgeSetToVertex (edge, vHere);
                                ToplEdgeSetFromVertex (edge, vThere);
                                ToplEdgeAssociate (edge);
                                // Dump edges
                                DPRINT2( 3, "to:%ws <-- from:%ws\n",
                                         pszServerTempDn, ppszConnectionFrom[0] );
                            }
			}
                        if( ppszTransportType ) {
                            ldap_value_freeW (ppszTransportType);
                            ppszTransportType = NULL;
                        }
                        ldap_value_freeW (ppszConnectionFrom);
                        ppszConnectionFrom = NULL;
                        pldmConnectionEntry = ldap_next_entry (hld, pldmConnectionEntry);
                    } // end INNER while (pldmConnectionEntry != NULL)

                    ldap_msgfree (pldmConnectionResults);
                    pldmConnectionResults = NULL;
		
                    dwInnerLdapErr = ldap_get_next_page_s(hld,
                                                          pConnSearch,
                                                          0,
                                                          DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                                          &ulInnerTotalEstimate,
                                                          &pldmConnectionResults);
                } // end INNER page search while loop
                if(dwInnerLdapErr != LDAP_NO_RESULTS_RETURNED){
                    DsRSAChkLdap(dwInnerLdapErr);
                }

                dwInnerLdapErr = ldap_search_abandon_page(hld, pConnSearch);
                pConnSearch = NULL; // subtlty here, need to set NULL, before calling DsRSAChkLdap()
                DsRSAChkLdap(dwInnerLdapErr);

                pldmConnectionResults = NULL;
            } // end if( vHere != ....)

        } // end for each DC get the connections ...


    } __finally {

	if( pDsaSearch )
	    ldap_search_abandon_page(hld, pDsaSearch);
	if( pConnSearch )
	    ldap_search_abandon_page(hld, pConnSearch);
	if( ppszConnectionFrom )
            ldap_value_freeW (ppszConnectionFrom);
        if( pldmConnectionResults )
            ldap_msgfree (pldmConnectionResults);
        if( hDS )
            DsUnBindW (&hDS);
        if( ppszMasterNCs )
            ldap_value_freeW (ppszMasterNCs);
        if( ppbvObjectGUID )
            ldap_value_free_len (ppbvObjectGUID);
        if( pszServerDn )
            ldap_memfreeW (pszServerDn);
        if( pResult )
            DsFreeNameResultW (pResult);
        if( pldmNtdsDsaResults )
            ldap_msgfree (pldmNtdsDsaResults);
        if( ppszRootDNC )
            ldap_value_freeW (ppszRootDNC);
        if( ppszServiceName )
            ldap_value_freeW (ppszServiceName);
        if( ppszConfigurationNC )
            ldap_value_freeW (ppszConfigurationNC);
        if( pldmRootResults )
            ldap_msgfree (pldmRootResults);
        if( pSvMapDnToVertex )
            DsRSASvMapDestroy (heap, pSvMapDnToVertex);

    }

}


VOID
DsRSAToplGraphDestroy (
    TOPL_GRAPH          toplGraph
    ) {

    TOPL_ITERATOR       iter;
    TOPL_VERTEX         vertex;
    DWORD           dwInEdges;
    DWORD           dw;

    // ToplGraphFree doesn't destroy edges, so we must do that manually.
    iter = ToplIterCreate ();
    if( iter != NULL ) {
        ToplGraphSetVertexIter (toplGraph, iter);
        while( (vertex = (TOPL_VERTEX) ToplIterGetObject (iter)) != NULL ) {
            dwInEdges = ToplVertexNumberOfInEdges (vertex);
            for( dw = 0; dw < dwInEdges; dw++ ) {
                ToplEdgeFree (ToplVertexGetInEdge (vertex, dw));
            }
            ToplIterAdvance (iter);
        }
        ToplIterFree (iter);
    }               // If iter is NULL there's not a whole lot we can do.

    ToplGraphFree (toplGraph, TRUE);        // Free the graph & vertices
}

// This cleans the DS_RSAI_TOPLINFO structure returned by DsRSABuildTopology ().

VOID
DsRSAToplInfoDestroy (
    HANDLE          heap,
    PDS_RSAI_TOPLINFO       pToplInfo
    ) {

    ULONG           ul;

    DsRSAToplGraphDestroy (pToplInfo->toplGraph);
    for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
        DsRSAFree (heap, pToplInfo->servers[ul]->pszMsgId);
        DsRSAFree (heap, pToplInfo->servers[ul]->pszSvrDn);
        DsRSAFree (heap, pToplInfo->servers[ul]);
    }
    DsRSAFree (heap, pToplInfo->servers);
    DsRSAFree (heap, pToplInfo->pszRootDomain);
    DsRSAFree (heap, pToplInfo);

}

/*
 * This routine executes a breadth-first algorithm.  It assigns two properties to each
 * vertex in a directed graph:
 * (a) The length of the shortest path from that vertex to a stated home vertex;
 * (b) The next vertex along that path.
 *
 * The algorithm works as follows.  DsRSAToplAssignDistances identifies only those
 * vertices of distance lMaxDepth from the home vertex.  In order for
 * DsRSAToplAssignDistances to function correctly at lMaxDepth = n, it must already
 * have been called with lMaxDepth = n-1.  It traverses the paths identified by its
 * previous iteration(s) to guarantee that the distances it finds are minimal.
 * For example, if DsRSAToplAssignDistances finds an unidentified vertex with
 * lMaxDepth = 5, it can be guaranteed that no path of length 4 exists from that
 * vertex home, since the vertex was not discovered by any previous iteration.
 * DsRSAToplAssignDistances returns TRUE if new vertices were found, indicating that
 * another iteration may be necessary in order to completely assign distances.
 *
 *	BOOL DsRSAToplAssignDistances (
 *	    IN OUT	PLONG		alDistances,	// Array that stores the min distances
 *	    IN OUT	PDWORD		adwOtherEnds,	// Array that stores the target vertices
 *	    IN		TOPL_VERTEX	vHere,		// The home node
 *	    IN		LONG		lMaxDepth,	// See description above
 *	    IN		LONG		lThisDepth	// The current depth of the search
 *	    )
 */

BOOL
DsRSAToplAssignDistances (
    PLONG           alDistances,
    PDWORD          adwOtherEnds,
    TOPL_VERTEX         vHere,
    LONG            lMaxDepth,
    LONG            lThisDepth,
    ULONG                       ulFlags
    ) {

    BOOL            bAltered;
    DWORD           dwEdges;
    DWORD           dwThisId;
    DWORD           dwNextId;
    DWORD           dw;
    PVERTEX                     vertex;

    bAltered = FALSE;
    if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
        dwEdges = ToplVertexNumberOfOutEdges (vHere);
    }
    else {
        dwEdges = ToplVertexNumberOfInEdges (vHere);
    }
    dwThisId = ToplVertexGetId (vHere);

    if( lThisDepth == lMaxDepth-1 ) {
        // We're almost at lMaxDepth.  This means all currently unidentified vertices directed into
        // vHere should be assigned distance lMaxDepth.
        for( dw = 0; dw < dwEdges; dw++ ) {  // Cycle through all in-edges
            // Get the id of the vertex corresponding to this in-edge
            if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                vertex = ToplEdgeGetToVertex (ToplVertexGetOutEdge (vHere, dw));
            }
            else {
                vertex = ToplEdgeGetFromVertex (ToplVertexGetInEdge (vHere, dw));
            }
            dwNextId = ToplVertexGetId (vertex);
            if( alDistances [dwNextId] == -1 ) {     // Not yet identified
                bAltered = TRUE;            // A new vertex has now been discovered
                alDistances [dwNextId] = lMaxDepth; // Assign this vertex distance lMaxDepth
                adwOtherEnds [dwNextId] = dwThisId; // The vertex's target is vHere (source for push)
            }
        }
    }
    else {
        // We haven't reached lMaxDepth yet.  Recursively penetrate further into the graph.  That is,
        // scan through the list of vertices directed into vHere.  For each such vertex, if that
        // vertex's target is vHere, call DsRSAToplAssignDistances with that vertex as home and
        // lThisDepth incremented by 1.  This way we will reach each vertex exactly once in our search
        // and still preserve distance minimality.
        for( dw = 0; dw < dwEdges; dw++ ) {
            if( ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                vertex = ToplEdgeGetToVertex (ToplVertexGetOutEdge (vHere, dw));
            }
            else {
                vertex = ToplEdgeGetFromVertex (ToplVertexGetInEdge (vHere, dw));
            }
            dwNextId = ToplVertexGetId ( vertex );
            if( dwThisId == adwOtherEnds [dwNextId] )
                bAltered |= DsRSAToplAssignDistances (alDistances,
                                adwOtherEnds,
                                vertex,
                                lMaxDepth,
                                lThisDepth + 1L,
                                ulFlags);
        }
    }
    return bAltered;
}

// Analyze the topology generated by DsRSABuildTopology and construct a set of replications that will
// bring pToplInfo->vHome completely up-to-date.

VOID
DsRSAAnalyzeTopology (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST **     papReps
    ) {

    PLONG           alDistances = NULL;
    PDWORD          adwOtherEnds = NULL;
    LONG            lDepth;
    LONG            lMaxDistance;
    ULONG           ul;
    LONG            l;
    PDS_RSAI_REPLIST *      apreplistPoss = NULL;

    *papReps = NULL;
    lMaxDistance = 0L;

    __try {
        alDistances = (LONG *) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof (LONG));
        adwOtherEnds = (DWORD *) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof (DWORD));

        // Initially all servers are flagged as unreachable (distance = -1).
        for( ul = 0; ul < pToplInfo->ulSize; ul++ )
            alDistances[ul] = -1L;
        alDistances[ToplVertexGetId (pToplInfo->vHome)] = 0L;   // Home vertex has distance 0

        // Iteratively call DsRSAToplAssignDistances until FALSE is returned, incrementing lDepth each time.
        lDepth = 1L;
        while( DsRSAToplAssignDistances (alDistances, adwOtherEnds, pToplInfo->vHome, lDepth++, 0L, pMainInfo->ulFlags) );

        // Determine the maximum distance given by DsRSAToplAssignDistances.
        for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
            DPRINT2( 2, "alDistances[%d] = %d\n", ul, alDistances[ul] );
            DPRINT2( 2, "adwOtherEnds[%d] = %d\n", ul, adwOtherEnds[ul] );
            if( alDistances[ul] > lMaxDistance ) lMaxDistance = alDistances[ul];
        }
        DPRINT1( 2, "maxDistance = %d\n", lMaxDistance );

    #if DBG
        if( pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster )
            DPRINT( 2, "Home hosts a master replica for this NC.\n" );
        else
            DPRINT( 2, "Home hosts a partial replica for this NC.\n" );
    #endif

        // Compile a list of unreachable nodes.
        // If we're only syncing adjacent nodes, this is irrelevant since all available servers are reachable.
        
	// If we're pulling, then only the masters matter to us, and disconected
        // partials may be ignored.    

	// If we are pushing from a master, everyone should be connected to it to recieve changes, and nothing
	// should be ignored.  If we are pushing from a partial, everything could possibly be ignored.

        if( (!(pMainInfo->ulFlags & DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY))
	    &&
       	    ( (pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster) 
	      ||
	      (!(pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD))
	    )
	   ) {  
            for( ul = 0L; ul < pToplInfo->ulSize; ul++ ) { 
		if( (alDistances[ul] == -1L) 
		     && 
		     (pToplInfo->servers[ul]->bIsInGraph) 
		     &&
		    (   
		     ( (pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD) 
		       &&
		       (pToplInfo->servers[ToplVertexGetId(pToplInfo->vHome)]->bIsMaster)  
		     )
		     ||
		     ( (!(pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD)) 
		       &&  
		       (pToplInfo->servers[ul]->bIsMaster)  
		     )
		    )
		  ) {    
		    DsRSADoError (heap, pMainInfo, pToplInfo->servers[ul]->pszMsgId, DS_REPSYNCALL_SERVER_UNREACHABLE, NO_ERROR, NULL);
		}
	    }
	}
                // Now we generate the replication pattern.  The idea is as follows.
                // We return an array of (PDS_RSAI_REPLIST)s.  Each element of the array
                // corresponds to a list of replications that may be performed
                // asynchronously.  However, all replications in the first list must
                // be performed before any replications in the second, and so on.
                // Thus each list corresponds to a particular depth in the topology.
                //
                // If the depth is 3 (say), then array[0] will contain the list of
                // 3->2 replications, array[1] 2->1 replications, array[2] 1->0
                // replications and array[3] NULL.  Thus the actual replication
                // issuer need know nothing about the topology.

                // Allocate space for the array, and allocate space for an array of PDS_RSAI_REPLIST objects that
                // track the current location in each list.
        *papReps = (PDS_RSAI_REPLIST *) DsRSAAlloc (heap, (lMaxDistance + 1) * sizeof (PDS_RSAI_REPLIST));
        apreplistPoss = (PDS_RSAI_REPLIST *) DsRSAAlloc (heap, lMaxDistance * sizeof (PDS_RSAI_REPLIST));
        // Initialize each list.
        for( l = 0L; l < lMaxDistance; l++ ) {
            (*papReps)[l] = (PDS_RSAI_REPLIST) DsRSAAlloc (heap, sizeof (DS_RSAI_REPLIST));
            apreplistPoss[l] = (*papReps)[l];
        }
        (*papReps)[lMaxDistance] = NULL;

        // Transfer all the data into the list.
        for( ul = 0L; ul < pToplInfo->ulSize; ul++ ) {
            l = alDistances[ul];
            if( l != -1L && l != 0L ) {  // This node is reachable, and isn't the home vertex
                if( pMainInfo->ulFlags & DS_REPSYNCALL_PUSH_CHANGES_OUTWARD ) {
                    l--;                        // Convert distance (1 based) to index (0 based)
                    apreplistPoss[l]->dwIdSrc = adwOtherEnds[ul];
                    apreplistPoss[l]->dwIdDst = ul;
                }
                else {
                    l = lMaxDistance - l;   // We want the list in reverse order
                    apreplistPoss[l]->dwIdSrc = ul;
                    apreplistPoss[l]->dwIdDst = adwOtherEnds[ul];
                }
                apreplistPoss[l]->next = (PDS_RSAI_REPLIST) DsRSAAlloc (heap, sizeof (DS_RSAI_REPLIST));
                apreplistPoss[l] = apreplistPoss[l]->next;
            }
        }

        // Terminate each list
        for( l = 0; l < lMaxDistance; l++ )
            apreplistPoss[l]->next = NULL;
    }
    __finally {
        if( alDistances )
            DsRSAFree (heap, alDistances);
        if( adwOtherEnds )
            DsRSAFree (heap, adwOtherEnds);
        if( apreplistPoss )
            DsRSAFree (heap, apreplistPoss);
        // The apreplistPoss[i] correspond to part of the (*papReps)[i] lists
        // so we don't need to go through and delete them
        if( AbnormalTermination() ) {
            if( *papReps != NULL ) {
                DsRSAReplicationsFree( heap, *papReps );
                *papReps = NULL;
            }
        }
    }
}

// This destroys a set of replications as generated by DsRSAAnalyzeTopology ().

VOID
DsRSAReplicationsFree (
    HANDLE          heap,
    PDS_RSAI_REPLIST *      apReps
    ) {

    PDS_RSAI_REPLIST        preplistPos;
    PDS_RSAI_REPLIST        preplistTemp;
    LONG            l;

    l = 0;
    if( apReps != NULL )
        while( (preplistPos = apReps[l++]) != NULL )
            while( preplistPos != NULL ) {
                preplistTemp = preplistPos->next;
                DsRSAFree (heap, preplistPos);
                preplistPos = preplistTemp;
            }
}

// This dumps a set of replications as generated by DsRSAAnalyzeTopology ().
#if DBG
VOID
DsRSAReplicationsDump (
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps
    ) {

    PDS_RSAI_REPLIST        preplistPos;
    LONG            l;
    ULONG                       index;

    if( pToplInfo != NULL ) {
        DPRINT1( 1, "Servers: %d\n", pToplInfo->ulSize );
        for( index = 0; index < pToplInfo->ulSize; index++ ) {
            DPRINT2( 1, "\t[%d] =%ws", index, pToplInfo->servers[index]->pszMsgId );
            if( pToplInfo->servers[index]->bIsMaster ) {
                DPRINT( 1, " (master)\n" );
            }
            else {
                DPRINT( 1, " (partial)\n" );
            }
        }
    }
    if( apReps != NULL ) {
        DPRINT( 1, "Replication ordering dump:\n" );
        l = 0;
        while( (preplistPos = apReps[l++]) != NULL ) {
            DPRINT1( 1, "Level %d:\n", l );
            while( preplistPos->next != NULL ) {
                DPRINT2(1, "\tDest:%ws <-- Source:%ws\n",
                    pToplInfo->servers[preplistPos->dwIdDst]->pszMsgId,
                    pToplInfo->servers[preplistPos->dwIdSrc]->pszMsgId
                    );
                preplistPos = preplistPos->next;
            }
        }
    }
}
#endif

/*
 * The next few functions are involved with issuing the replications found with DsRSAAnalyzeTopology.
 * Multiple threads are used to permit replications to be issued asynchronously.  Events are used to
 * facilitate communication between threads.  (Also see dsrsa.h.)
 *
 */

// Sets this thread's state to threadState and waits for the primary thread to process that information.

VOID
DsRSASignalAndWait (
    PDS_RSAI_REPINFO        pRepInfo,
    DS_RSAI_THREAD_STATE    threadState
    ) {

    *pRepInfo->pThreadState = threadState;
    SetEvent (pRepInfo->hWaiting);
    WaitForSingleObject (pRepInfo->hReady, INFINITE);
    *pRepInfo->pThreadState = DS_RSAI_THREAD_ACTIVE;
}


// These are some defines for DsRSAIssueXXXXX functions();
#define INVALID_SERVER_INDEX  0xFFFFFFFF
#define MAX_SYNC_PARALLELISM 63

// The entry function of each auxiliary thread.  lpData should point to a DS_RSAI_REPINFO structure.
// This will issue a list of replications with the same destination server.

VOID
__cdecl
DsRSAIssueRep (
    LPVOID          lpData
    ) {
/*++

Routine Description:

    This routin will do a single destination sync.  It runs through the list of source syncs it has to
    do and signals the parent thread (in DsRSAIssueLevelOfReplications()) when finnished

Arguments:

    lpData - This is a little structure holding the destinations server to be syncd, and a list of source servers

Return Value:

--*/
    PDS_RSAI_REPINFO        pRepInfo = (PDS_RSAI_REPINFO) lpData;
    HANDLE          hDS;
    PDS_RSAI_LIST       plistPos;
    *pRepInfo->pdwWin32Err = DsBindWithCredW (pRepInfo->pszDstGuidDNS, NULL, pRepInfo->hRpcai, &hDS);
    if( *pRepInfo->pdwWin32Err != NO_ERROR ) {        // Problem binding!
        // Signal the primary thread that we could not bind to this server
        DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_BIND_ERROR);
    }
    else {

        // Iterate through each source server.
        plistPos = pRepInfo->plistSrcs;
        while( plistPos->next != NULL ) {
            // Update pRepInfo so that the primary thread knows which source server is being synced.
            *pRepInfo->pdwSyncAt = ((PDS_RSAI_SVRINFO) plistPos->ulpItem)->dwId;
            DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_BEGIN_SYNC);
            if( pRepInfo->bDoSync ) {
                // Perform the actual sync!
                *pRepInfo->pdwWin32Err = DsReplicaSyncW (hDS,
                                             pRepInfo->pdsnameNameContext->StringName,
                                             &((PDS_RSAI_SVRINFO) plistPos->ulpItem)->guid,
                                             DS_REPSYNC_FORCE);
                if( *pRepInfo->pdwWin32Err != NO_ERROR ) {
                    DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_SYNC_ERROR);
                }
                else {
                    DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_DONE_SYNC);       // The sync was successful.
                }
            }
            else {
                *pRepInfo->pdwWin32Err = ERROR_CANCELLED;               // The user chose not to sync.
                DsRSASignalAndWait (pRepInfo, DS_RSAI_THREAD_SYNC_ERROR);       // (i.e. DS_REPSYNCALL_DO_NOT_SYNC set)
            }
            plistPos = plistPos->next;
        }
        DsUnBindW (&hDS);
    }

    // We're done!
    *pRepInfo->pThreadState = DS_RSAI_THREAD_FINISHED;
    SetEvent (pRepInfo->hWaiting);
    _endthread ();
}

// This issues a set of replications.
// The replications in the list apReps[i] may be issued asynchronously, but all
// replications in apReps[i] must be issued before any in apReps[i+1].

VOID
DsRSAIssueLevelOfReplications (
    HANDLE          heap,
    ULONG                       ulLevelSize,
    PULONG                      pulGlobalToLocal,
    PULONG                      pulLocalToGlobal,
    PDS_RSAI_REPLIST        preplistPos,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
    )
/*++

Routine Description:

    This routine will take do replications for ulLevelSize destinations, it uses the pulGlobalToLocal and
    pulLocalToGlobal to make the indirection happen that was needed to get around the fact that
    WaitForMultipleObject() can only wait on 64 objects.

Arguments:

    heap - a private heap
    ulLevelSize - The number of destination servers to sync in this level
    pulGlobalToLocal - an array of pToplInfo->ulSize, that maps an index in the array of apReps to an index in
       the arrays to be allocated in this routine for the worker thread.
    pulLocalToGlobal - an array of ulLevelSize, that maps an index from the arrays to be allocated in this routine
       to handle the different threads, and the value returned by WaitForMultipleObject to an array (global) index
       in apReps.
    pMainInfo - the main info for the thing
    pToplInfo - the topology info
    apReps - the different levels of replications that can happen in parrallel.  It is an array of linked lists
        that give all the replications to happen (Dst-Src Pairs)
    hRpcai - handle to the user credentials security structure

Return Value:

--*/
{
    PDS_RSAI_REPINFO        aRepInfo = NULL;
    PDS_RSAI_LIST *     aplistNextSrc = NULL;
    PDWORD          adwWin32Err = NULL;
    PDWORD          adwSyncAt = NULL;
    PDS_RSAI_THREAD_STATE   aThreadState = NULL;
    PHANDLE         ahWaiting = NULL;
    PHANDLE         ahReady = NULL;
    PBOOL           abFinished = NULL;
    BOOL            bAllFinished;

    DS_REPSYNCALL_UPDATEW   update;

    ULONG           ulDummy;
    ULONG           ulDstId;
    ULONG           ulRepNum;
    ULONG           ul;

    if( ulLevelSize == 0 ) {
        return;  // This means this function was called with 0 syncs for it to do in this run.
    }

    __try {

        aRepInfo = (PDS_RSAI_REPINFO) DsRSAAlloc (heap, ulLevelSize * sizeof (DS_RSAI_REPINFO));
        aplistNextSrc = (PDS_RSAI_LIST *) DsRSAAlloc (heap, ulLevelSize * sizeof (PDS_RSAI_LIST));
        ahWaiting = (PHANDLE) DsRSAAlloc (heap, ulLevelSize * sizeof (HANDLE));
        ahReady = (PHANDLE) DsRSAAlloc (heap, ulLevelSize * sizeof (HANDLE));
        adwWin32Err = (PULONG) DsRSAAlloc (heap, ulLevelSize * sizeof (ULONG));
        adwSyncAt = (PDWORD) DsRSAAlloc (heap, ulLevelSize * sizeof (DWORD));
        aThreadState = (PDS_RSAI_THREAD_STATE) DsRSAAlloc (heap, ulLevelSize * sizeof (DS_RSAI_THREAD_STATE));
        abFinished = (PBOOL) DsRSAAlloc (heap, ulLevelSize * sizeof (BOOL));

        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            ahReady[ulDstId] = NULL;
            ahWaiting[ulDstId] = NULL;
        }

        // Set up the aRepInfo[i] structures.  These are passed to the auxiliary threads and are used
        // for interthread communications.
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            aRepInfo[ulDstId].bDoSync = (pMainInfo->ulFlags & DS_REPSYNCALL_DO_NOT_SYNC ? FALSE : TRUE);
            aRepInfo[ulDstId].pdsnameNameContext = pMainInfo->pdsnameNameContext;
            aRepInfo[ulDstId].hRpcai = hRpcai;
            Assert(pulLocalToGlobal[ulDstId] != INVALID_SERVER_INDEX);
            aRepInfo[ulDstId].pszDstGuidDNS = DsRSAAllocGuidDNS (heap, pToplInfo->pszRootDomain,
                                                  &pToplInfo->servers[pulLocalToGlobal[ulDstId]]->guid);
            if( (ahReady[ulDstId] = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL ) {
                DsRSAException (GetLastError ());
            }
            aRepInfo[ulDstId].hReady = ahReady[ulDstId];
            if( (ahWaiting[ulDstId] = CreateEvent (NULL, FALSE, FALSE, NULL)) == NULL ) {
                DsRSAException (GetLastError ());
            }
            aRepInfo[ulDstId].hWaiting = ahWaiting[ulDstId];
            aRepInfo[ulDstId].pdwWin32Err = &(adwWin32Err[ulDstId]);
            aRepInfo[ulDstId].pdwSyncAt = &(adwSyncAt[ulDstId]);
            aRepInfo[ulDstId].pThreadState = &(aThreadState[ulDstId]);
        }

        // Initialization.
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            ResetEvent (ahWaiting[ulDstId]);        // Reset the events.
            ResetEvent (ahReady[ulDstId]);
            // Right now, no destination servers have been assigned any replications so they are all trivially finished.
            abFinished[ulDstId] = TRUE;
            // Initialize the lists of source servers.
            aRepInfo[ulDstId].plistSrcs = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
            aRepInfo[ulDstId].plistSrcs->next = NULL;
            aplistNextSrc[ulDstId] = aRepInfo[ulDstId].plistSrcs;
        }
        bAllFinished = TRUE;

        // Collate the replications at this iteration by server.  For each replication, add the SvrInfo structure
        // of the source server to the list that corresponds to the destination server's aRepInfo structure.
        while( preplistPos->next != NULL ) {
            if( pulGlobalToLocal[preplistPos->dwIdDst] != INVALID_SERVER_INDEX ) {
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->ulpItem = (ULONG_PTR) pToplInfo->servers[preplistPos->dwIdSrc];
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]] = aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next;
                aplistNextSrc[pulGlobalToLocal[preplistPos->dwIdDst]]->next = NULL;
            } // end if one of the destinations we are doing in this invocation of the function.
            preplistPos = preplistPos->next;
        }

        // Issue each list of replications (i.e. create the threads.)
        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {
            // If this server is the destination of some replications, create a thread.
            if( aRepInfo[ulDstId].plistSrcs->next != NULL ) {
                adwWin32Err[ulDstId] = ERROR_INTERNAL_ERROR;
                adwSyncAt[ulDstId] = INVALID_SERVER_INDEX;
                aThreadState[ulDstId] = DS_RSAI_THREAD_ACTIVE;
                abFinished[ulDstId] = FALSE;    // Now this destination server has replications, so it isn't finished.
                bAllFinished = FALSE;
                if( _beginthread (
                    DsRSAIssueRep,
                    0,
                    (LPVOID) (&aRepInfo[ulDstId])) == -1 ) {
                    DsRSAException (GetLastError ());
                }
            }
        }

        // Now continue waiting for the threads to send messages until all threads have finished.
        while( !bAllFinished ) {
            ulDstId = WaitForMultipleObjects (ulLevelSize,
                          ahWaiting,
                          FALSE,
                          INFINITE);
            if( ulDstId == WAIT_FAILED ) DsRSAException (GetLastError ());
            Assert(pulLocalToGlobal[ulDstId] != INVALID_SERVER_INDEX);
            // This is where the global to local redirections are about to get confusing, because adwSyncAt is actually another
            //   redirection vector like LocalToGlobal.
            switch( aThreadState[ulDstId] ) {
                case DS_RSAI_THREAD_ACTIVE:     // Thread is active; no action.
                    break;
                case DS_RSAI_THREAD_BEGIN_SYNC: // Sync begun; issue callback message.
                    DsRSAIssueUpdateSync (heap,
                        pMainInfo,
                        DS_REPSYNCALL_EVENT_SYNC_STARTED,
                        pToplInfo->servers[adwSyncAt[ulDstId]],
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]);
                    break;
                case DS_RSAI_THREAD_DONE_SYNC:  // Sync finished; issue callback message.
                    DsRSAIssueUpdateSync(heap,
                        pMainInfo,
                        DS_REPSYNCALL_EVENT_SYNC_COMPLETED,
                        pToplInfo->servers[adwSyncAt[ulDstId]],
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]);
                    break;
                case DS_RSAI_THREAD_SYNC_ERROR: // Error syncing.
                    DsRSADoError (heap,
                        pMainInfo,
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]->pszMsgId,
                        DS_REPSYNCALL_WIN32_ERROR_REPLICATING,
                        adwWin32Err[ulDstId],
                        pToplInfo->servers[adwSyncAt[ulDstId]]->pszMsgId);
                    break;
                case DS_RSAI_THREAD_BIND_ERROR: // Error binding.
                    // The source parameter is null here because we have not chosen a source yet.
                    // The adwSyncAt[] is not defined at this time.
                    DsRSADoError (heap,
                        pMainInfo,
                        pToplInfo->servers[pulLocalToGlobal[ulDstId]]->pszMsgId,
                        DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER,
                        adwWin32Err[ulDstId],
                        NULL);
                    break;
                case DS_RSAI_THREAD_FINISHED:   // Thread is finished.
                    abFinished[ulDstId] = TRUE;
                    bAllFinished = TRUE;
                    for( ul = 0;bAllFinished && (ul < ulLevelSize); ul++ )   // See if any threads are still unfinished.
                        bAllFinished &= abFinished[ul];
                    break;
                default:
                    break;
            }
            SetEvent (ahReady[ulDstId]);    // Notify the thread that we are done processing it.
        }

        // Initialization.

    } __finally {

        for( ulDstId = 0; ulDstId < ulLevelSize; ulDstId++ ) {

            if( ahReady[ulDstId] != NULL ) CloseHandle (ahReady[ulDstId]);
            if( ahWaiting[ulDstId] != NULL ) CloseHandle (ahWaiting[ulDstId]);

            if( aRepInfo[ulDstId].pszDstGuidDNS != NULL ) DsRSAFree (heap, aRepInfo[ulDstId].pszDstGuidDNS);

            DsRSAListDestroy(heap, aRepInfo[ulDstId].plistSrcs);
        }

        if( abFinished != NULL )
            DsRSAFree (heap, abFinished);
        if( aThreadState != NULL )
            DsRSAFree (heap, aThreadState);
        if( adwSyncAt != NULL )
            DsRSAFree (heap, adwSyncAt);
        if( adwWin32Err != NULL )
            DsRSAFree (heap, adwWin32Err);
        if( ahReady != NULL )
            DsRSAFree (heap, ahReady);
        if( ahWaiting != NULL )
            DsRSAFree (heap, ahWaiting);
        if( aplistNextSrc != NULL )
            DsRSAFree (heap, aplistNextSrc);
        if( aRepInfo != NULL )
            DsRSAFree (heap, aRepInfo);
    }
}


// This issues a set of replications.
// The replications in the list apReps[i] may be issued asynchronously, but all
// replications in apReps[i] must be issued before any in apReps[i+1].

VOID
DsRSAIssueReplications (
    HANDLE          heap,
    PDS_RSAI_MAININFO       pMainInfo,
    PDS_RSAI_TOPLINFO       pToplInfo,
    PDS_RSAI_REPLIST *      apReps,
    RPC_AUTH_IDENTITY_HANDLE    hRpcai
    )
/*++

Routine Description:

    This routine takes each level of destination replications that can happen in parallel and hands them to
    DsRSAIssueLevelOfReplications().  If there are more than ulMaxParallelism destinations, then it will spawn
    off ...IssueLevelOfRep.. early and continue on to finnish that level.

Arguments:

    heap - a private heap
    pMainInfo - the main info for the thing
    pToplInfo - the topology info
    apReps - the different levels of replications that can happen in parrallel.  It is an array of linked lists
        that give all the replications to happen (Dst-Src Pairs)
    hRpcai - the user credentials structure

Return Value:

--*/
{
    ULONG                       ulLevelSize;
    ULONG                       ulMaxParallelism;
    ULONG                       ul, ulTemp, ulRepNum;
    PDS_RSAI_REPLIST            preplistPos;
    // These 3 variables are to redirect for each call to DsRSAIssueLevelOfReplications(), the first two
    //   are reused for each call to ...IssueLevelOfRep..., and they must be reset after each call to it.
    // maps the global list of all servers to the temporary (local) list of servers for one sync level
    PULONG                      pulGlobalToLocal = NULL;
    // maps the temporary list of server back to the global list at any given sync level.
    PULONG                      pulLocalToGlobal = NULL;
    // maps the global list of all servers to the temporary list of servers for one sync level
    PBOOL                       pbDstServerWillBeSyncd = NULL;

    // Set the max parallelism to a reasonable maximum.
    ulMaxParallelism = min(MAXIMUM_WAIT_OBJECTS - 1, MAX_SYNC_PARALLELISM);
    // Uncomment this line to serialize all the Syncs
    //ulMaxParallelism = min(MAXIMUM_WAIT_OBJECTS - 1, 1);

    __try {

        pulGlobalToLocal = (PULONG) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof(ULONG));
        pbDstServerWillBeSyncd = (PBOOL) DsRSAAlloc (heap, pToplInfo->ulSize * sizeof(BOOL));
        pulLocalToGlobal = (PULONG) DsRSAAlloc (heap, ulMaxParallelism * sizeof(ULONG));

        Assert(pulGlobalToLocal != NULL);
        Assert(pbDstServerWillBeSyncd != NULL);
        Assert(pulLocalToGlobal != NULL);

        for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
            pulGlobalToLocal[ul] = INVALID_SERVER_INDEX;
            pbDstServerWillBeSyncd[ul] = FALSE;
        }
        for( ul = 0; ul < ulMaxParallelism; ul++ ) {
            pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
        }

        ulRepNum = 0;
        while( preplistPos = apReps[ulRepNum] ) { // Do one level of syncs.

            ulLevelSize = 0;
            while( preplistPos->next != NULL ) { // process each element of the current preplistPos for level ulRepNum

                if( !pbDstServerWillBeSyncd[preplistPos->dwIdDst] ) {
                    pbDstServerWillBeSyncd[preplistPos->dwIdDst] = TRUE;
                    pulGlobalToLocal[preplistPos->dwIdDst] = ulLevelSize;
                    pulLocalToGlobal[ulLevelSize] = preplistPos->dwIdDst;
                    ulLevelSize++;
                }

                Assert(ulLevelSize != INVALID_SERVER_INDEX);

                if( ulLevelSize >= ulMaxParallelism ) {
                    // This is an exceptional case, rarely will there be 63 or more simultaneous
                    //   destination machines that can sync in parallel ... but just in case. :)
                    //   this little section will take care of the current ulMaxParallelism cases
                    //   and reset the counter and move on.

                    DsRSAIssueLevelOfReplications(heap,
                        ulLevelSize,
                        pulGlobalToLocal,
                        pulLocalToGlobal,
                        apReps[ulRepNum],
                        pMainInfo,
                        pToplInfo,
                        apReps,
                        hRpcai);

                    // Clean up - reset the arrays (technically this shouldn't be necessary)
                    for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                        if( pulLocalToGlobal[ul] != INVALID_SERVER_INDEX ) {
                            pulGlobalToLocal[pulLocalToGlobal[ul]] = INVALID_SERVER_INDEX;
                        }
                        pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
                    }
                    for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
                        Assert(pulGlobalToLocal[ul] == INVALID_SERVER_INDEX);
                    }
                    for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                        Assert(pulLocalToGlobal[ul] == INVALID_SERVER_INDEX);
                    }

                    ulLevelSize = 0;
                }
                preplistPos = preplistPos->next;


            } // end while processing one sync

            // The normal case is the above while loop will quit without reaching ulMaxParralelism
            //   destination machines.
            DsRSAIssueLevelOfReplications(heap,
                ulLevelSize,
                pulGlobalToLocal,
                pulLocalToGlobal,
                apReps[ulRepNum],
                pMainInfo,
                pToplInfo,
                apReps,
                hRpcai);

            // Clean up
            for( ul = 0; ul < ulLevelSize; ul++ ) {
                if( pulLocalToGlobal[ul] != INVALID_SERVER_INDEX ) {
                    Assert(pulGlobalToLocal[pulLocalToGlobal[ul]] != INVALID_SERVER_INDEX);
                    pulGlobalToLocal[pulLocalToGlobal[ul]] = INVALID_SERVER_INDEX;
                }
                pulLocalToGlobal[ul] = INVALID_SERVER_INDEX;
            }
            for( ul = 0; ul < pToplInfo->ulSize; ul++ ) {
                Assert(pulGlobalToLocal[ul] == INVALID_SERVER_INDEX);
            }
            for( ul = 0; ul < ulMaxParallelism; ul++ ) {
                Assert(pulLocalToGlobal[ul] == INVALID_SERVER_INDEX);
            }

            ulRepNum++;

        } // end while doing whole level

    } __finally {

        if( pulLocalToGlobal != NULL )
            DsRSAFree (heap, pulLocalToGlobal);
        if( pbDstServerWillBeSyncd != NULL )
            DsRSAFree (heap, pbDstServerWillBeSyncd);
        if( pulGlobalToLocal != NULL )
            DsRSAFree (heap, pulGlobalToLocal);

    }
}

// Copy the error list, as an array, into one contiguous block of memory in the local heap.

VOID
DsRSABuildUnicodeErrorArray (
    PDS_RSAI_LIST       plistFirstError,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    PDS_REPSYNCALL_ERRINFOW perrinfoCur;
    PDS_RSAI_LIST       plistNextError;
    LPBYTE          lpMemPos, lpMemPosVar, lpMemBaseVar;
    ULONG           ulArraySize;
    ULONG           ulMemRequired;
    ULONG           ul;

    ulArraySize = ulMemRequired = 0L;

    // Compute the size of the array.
    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {
        ulArraySize++;
    }

    // Compute how much memory we'll need.
    // Complex structure looks like this:
    //    array of ulArraySize + 1 PDS_REPSYNCALL_ERRINFOA
    //    array of ulArraySize of DS_REPSYNCALL_ERRINFOA
    //    variable length string storage

    // For the pointers to array objects
    ulMemRequired += (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOW);
    // For the array objects themselves
    ulMemRequired += ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOW);

    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {       // For the strings
        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        ulMemRequired += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (WCHAR);
        if( perrinfoCur->pszSrcId != NULL ) {
            ulMemRequired += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (WCHAR);
        }
    }

    // *papErrInfo is the base of the array of pointers
    if( (*papErrInfo = LocalAlloc (LMEM_FIXED, ulMemRequired)) == NULL )
        DsRSAException (GetLastError ());

    // Base of the structures
    // lpMemPos - Current position moving forward in array of structures
    lpMemPos = (LPBYTE) (*papErrInfo) + (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOW);
    // lpMemBaseVar - Base of the variable length string storage
    // lpMemPosVar - Current position moving forward in variable storage
    lpMemBaseVar = lpMemPosVar = lpMemPos + ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOW);

    for( ul = 0L, plistNextError = plistFirstError;
        plistNextError->next != NULL;
        ul++, plistNextError = plistNextError->next ) {

        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;

        Assert( lpMemPos < lpMemBaseVar );
        Assert( ul < ulArraySize );
        (*papErrInfo)[ul] = (PDS_REPSYNCALL_ERRINFOW) lpMemPos;
        lpMemPos += sizeof (DS_REPSYNCALL_ERRINFOW);

        (*papErrInfo)[ul]->error = perrinfoCur->error;
        (*papErrInfo)[ul]->dwWin32Err = perrinfoCur->dwWin32Err;

        Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
        (*papErrInfo)[ul]->pszSvrId = (LPWSTR) lpMemPosVar;
        wcscpy ((*papErrInfo)[ul]->pszSvrId, perrinfoCur->pszSvrId);
        lpMemPosVar += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (WCHAR);

        if( perrinfoCur->pszSrcId != NULL ) {
            Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
            (*papErrInfo)[ul]->pszSrcId = (LPWSTR) lpMemPosVar;
            wcscpy ((*papErrInfo)[ul]->pszSrcId, perrinfoCur->pszSrcId);
            lpMemPosVar += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (WCHAR);
        }
        else {
            (*papErrInfo)[ul]->pszSrcId = NULL;
        }
    }
    (*papErrInfo)[ul] = NULL;               // Null terminator
}

VOID
DsRSABuildANSIErrorArray (
    HANDLE          heap,
    PDS_RSAI_LIST       plistFirstError,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    PDS_REPSYNCALL_ERRINFOW perrinfoCur;
    PDS_RSAI_LIST       plistNextError;
    LPBYTE          lpMemPos, lpMemPosVar, lpMemBaseVar;
    LPSTR           pszA;
    ULONG           ulArraySize;
    ULONG           ulMemRequired;
    ULONG           ul;

    ulArraySize = ulMemRequired = 0L;

    // Compute the size of the array.
    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {
        ulArraySize++;
    }

    // Compute how much memory we'll need.
    // Complex structure looks like this:
    //    array of ulArraySize + 1 PDS_REPSYNCALL_ERRINFOA
    //    array of ulArraySize of DS_REPSYNCALL_ERRINFOA
    //    variable length string storage

    // For the pointers to array objects
    ulMemRequired += (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOA);
    // For the array objects themselves
    ulMemRequired += ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOA);

    for( plistNextError = plistFirstError;
        plistNextError->next != NULL;
        plistNextError = plistNextError->next ) {       // For the strings
        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        ulMemRequired += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (CHAR);
        if( perrinfoCur->pszSrcId != NULL ) {
            ulMemRequired += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (CHAR);
        }
    }

    // *papErrInfo is the base of the array of pointers
    if( (*papErrInfo = LocalAlloc (LMEM_FIXED, ulMemRequired)) == NULL ) {
        DsRSAException (GetLastError ());
    }

    // Base of structures
    // lpMemPos - Current position moving forward in array of structures
    lpMemPos = (LPBYTE) (*papErrInfo) + (ulArraySize + 1) * sizeof (PDS_REPSYNCALL_ERRINFOA);
    // lpMemBaseVar - Base of variable length string storage
    // lpMemPosVar - Current position moving forward in variable storage

    lpMemBaseVar = lpMemPosVar =
        (lpMemPos + (ulArraySize * sizeof (DS_REPSYNCALL_ERRINFOA)));

    for( ul = 0L, plistNextError = plistFirstError;
        plistNextError->next != NULL;
        ul++, plistNextError = plistNextError->next ) {

        perrinfoCur = (PDS_REPSYNCALL_ERRINFOW) plistNextError->ulpItem;
        Assert( lpMemPos < lpMemBaseVar );
        Assert( ul < ulArraySize );
        (*papErrInfo)[ul] = (PDS_REPSYNCALL_ERRINFOA) lpMemPos;
        lpMemPos += sizeof (DS_REPSYNCALL_ERRINFOA);

        (*papErrInfo)[ul]->error = perrinfoCur->error;
        (*papErrInfo)[ul]->dwWin32Err = perrinfoCur->dwWin32Err;

        Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
        (*papErrInfo)[ul]->pszSvrId = (LPSTR) lpMemPosVar;
        pszA = DsRSAAllocToANSI (heap, perrinfoCur->pszSvrId);
        //
        // PREFIX: PREFIX complains that pszA is never checked for NULL.
        // However, DsRSAAllocToAnsi will throw an exception if it is
        // unable to alloc the necessary memory.  The only other reason
        // that it might return NULL is if perrinfoCur->pszSvrId is NULL.
        // But perrinfoCur->pszSvrId can't be NULL because it comes from
        // papErrInfo which was alloced above.
        //
        Assert( strlen( pszA ) == wcslen( perrinfoCur->pszSvrId ) );
        strcpy ((*papErrInfo)[ul]->pszSvrId, pszA);
        DsRSAFree (heap, pszA);
        lpMemPosVar += (wcslen (perrinfoCur->pszSvrId) + 1) * sizeof (CHAR);

        if( perrinfoCur->pszSrcId != NULL ) {
            Assert( lpMemPosVar < (((LPBYTE) (*papErrInfo)) + ulMemRequired) );
            (*papErrInfo)[ul]->pszSrcId = (LPSTR) lpMemPosVar;
            pszA = DsRSAAllocToANSI (heap, perrinfoCur->pszSrcId);
            Assert( strlen( pszA ) == wcslen( perrinfoCur->pszSrcId ) );
            strcpy ((*papErrInfo)[ul]->pszSrcId, pszA);
            DsRSAFree (heap, pszA);
            lpMemPosVar += (wcslen (perrinfoCur->pszSrcId) + 1) * sizeof (CHAR);
        }
        else {
            (*papErrInfo)[ul]->pszSrcId = NULL;
        }
    }
    (*papErrInfo)[ul] = NULL;               // Null terminator
}

// This is the generic filter expression for the top level dsRRA
// exception handlers.

DWORD
DsRSAGetException (
    EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret) {
    DWORD dwException;
    ULONG_PTR * pExceptInfo;
    ULONG ulErrorCode;

    dwException = pExceptPtrs->ExceptionRecord->ExceptionCode;
    // If it's a DS_RSAI_EXCEPTION then handle it here
    if( dwException != DS_RSAI_EXCEPTION ) {
        *pret = 0;
        return EXCEPTION_CONTINUE_SEARCH;
    }
    pExceptInfo = pExceptPtrs->ExceptionRecord->ExceptionInformation;
    ulErrorCode = (ULONG)pExceptInfo[0];
    DPRINT1( 1, "Handling exception %d\n", ulErrorCode );
    *pret = ulErrorCode;
    return EXCEPTION_EXECUTE_HANDLER;
}

DWORD
DsReplicaSyncAllMain (
    HANDLE          hDS,
    LPCWSTR         pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBackW) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    BOOL (__stdcall *       pFnCallBackA) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfoW,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfoA
    ) {
    HANDLE          heap;
    LDAP *          hld;
    LPWSTR          lpSvr = NULL;
    RPC_AUTH_IDENTITY_HANDLE    hRpcai = NULL;
    DS_RSAI_MAININFO        mainInfo;
    PDS_RSAI_TOPLINFO       pTopl;
    PDS_RSAI_REPLIST *      apReps;
    PDS_RSAI_LIST       plistFirstError;
    DWORD           dwWin32Err;
    ULONG           ulOptions;

    heap = NULL;
    hld = NULL;
    pTopl = NULL;
    apReps = NULL;
    plistFirstError = NULL;
    dwWin32Err = NO_ERROR;


    if( hDS == NULL ) {
        // can't do anything w/out an opened handle
        return ERROR_INVALID_PARAMETER;
    }

    if( papErrInfoW != NULL ) {
        *papErrInfoW = NULL;        // Set the error structure to NULL -- no errors yet
    }
    if( papErrInfoA != NULL ) {
        *papErrInfoA = NULL;
    }

    __try {

        DsRSAChkErr (DsRSAHeapCreate (&heap));          // Create the heap
        plistFirstError = (PDS_RSAI_LIST) DsRSAAlloc (heap, sizeof (DS_RSAI_LIST));
        plistFirstError->next = NULL;
        mainInfo.pdsnameNameContext = pszNameContext ? DsRSAAllocBuildDsname( heap, pszNameContext ) :
                                      NULL;
        mainInfo.ulFlags = ulFlags;
        mainInfo.pFnCallBackW = pFnCallBackW;
        mainInfo.pFnCallBackA = pFnCallBackA;
        mainInfo.pCallbackData = pCallbackData;
        mainInfo.plistNextError = plistFirstError;

        if ( ((BindState *) hDS)->bindAddr ) {
            // point to target svr
            lpSvr = ((BindState *) hDS)->bindAddr;
            // advance to skip leading backslashes.
            while(*lpSvr == '\\') {
                lpSvr++;
            }
        }
        if( (hld = ldap_initW (lpSvr, LDAP_PORT)) == NULL ) {
            DsRSAException (ERROR_DS_DRA_CONNECTION_FAILED);
        }
        if( ((BindState *) hDS)->hDrs == NULL ) {
            DsRSAException (ERROR_DS_DRA_CONNECTION_FAILED);
        }

        DsRSAChkErr ( RpcBindingInqAuthInfo (NDRCContextBinding ((NDR_CCONTEXT) ((BindState *) hDS)->hDrs),
            NULL, NULL, NULL, &hRpcai, NULL) );

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
        // Connect to the LDAP server and build the topology
        DsRSAChkLdap (ldap_bind_sW (hld, NULL, (LPWSTR) hRpcai, LDAP_AUTH_SSPI));

        DsRSABuildTopology (heap, hld, hRpcai, &mainInfo, &pTopl);
        ldap_unbind (hld);

        // Analyze topology and issue replications
        if( pTopl->vHome == NULL ) {
            DsRSAException (ERROR_DS_DRA_BAD_NC);       // The home server is not in this NC
        }
        DsRSAAnalyzeTopology (heap, &mainInfo, pTopl, &apReps);
    #if DBG
        DsRSAReplicationsDump (pTopl, apReps);
    #endif
        // If ABORT_IF_SERVER_UNAVAILABLE and there are any errors, then abort.
        if( (ulFlags & DS_REPSYNCALL_ABORT_IF_SERVER_UNAVAILABLE) && plistFirstError->next != NULL ) {
            DsRSAException (ERROR_CANCELLED);
        }

        DsRSAIssueReplications (heap, &mainInfo, pTopl, apReps, hRpcai);
        if( papErrInfoW != NULL && plistFirstError->next != NULL ) {
            DsRSABuildUnicodeErrorArray (plistFirstError, papErrInfoW);
        }
        if( papErrInfoA != NULL && plistFirstError->next != NULL ) {
            DsRSABuildANSIErrorArray (heap, plistFirstError, papErrInfoA);
        }

        // Cleanup
        DsRSAErrListDestroy (heap, plistFirstError);
        DsRSAReplicationsFree (heap, apReps);
        DsRSAToplInfoDestroy (heap, pTopl);
        DsRSAIssueUpdate (heap, &mainInfo, DS_REPSYNCALL_EVENT_FINISHED, NULL, NULL);
        DsRSAFree (heap, mainInfo.pdsnameNameContext);
        DsRSAHeapDestroy (heap);

    } __except( DsRSAGetException( GetExceptionInformation(), &dwWin32Err ) ) {
        // The topology is not on the heap so we must free it
        if( pTopl && pTopl->toplGraph ) DsRSAToplGraphDestroy (pTopl->toplGraph);
        // The error structure is allocated from the local heap so we must free it
        if( papErrInfoW != NULL && *papErrInfoW != NULL ) {
            LocalFree (*papErrInfoW);
        }
        if( papErrInfoA != NULL && *papErrInfoA != NULL ) {
            LocalFree (*papErrInfoA);
        }
        // We must free the ldap handle also
        if( hld ) {
            ldap_unbind (hld);
        }
        // And the heap . . .
        if( heap ) {
            DsRSAHeapDestroy (heap);
        }
    }

    return dwWin32Err;
}

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE          hDS,
    LPCWSTR                pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    return DsReplicaSyncAllMain (
        hDS,
        pszNameContext,
        ulFlags,
        pFnCallBack,
        NULL,
        pCallbackData,
        papErrInfo,
        NULL);
}

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE          hDS,
    LPCSTR                 pszNameContext,
    ULONG           ulFlags,
    BOOL (__stdcall *       pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID          pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    LPWSTR          pszNameContextW;
    DWORD           dwErr;

    pszNameContextW = NULL;
    dwErr = AllocConvertWide (pszNameContext, &pszNameContextW);

    if( dwErr == NO_ERROR ) {
        dwErr = DsReplicaSyncAllMain (
                    hDS,
                    pszNameContextW,
                    ulFlags,
                    NULL,
                    pFnCallBack,
                    pCallbackData,
                    NULL,
                    papErrInfo);

    }
    if( pszNameContextW != NULL ) {
        LocalFree (pszNameContextW);
    }

    return dwErr;
}
//
// -----
// NOT SUPPORTED IN WIN95
// -----
//
#else !WIN95 && !WINNT4
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
    #include <rpc.h>
    #include <drs.h>
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE                      hDS,
    LPCWSTR                pszNameContext,
    ULONG                       ulFlags,
    BOOL (__stdcall *           pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID                      pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **  papErrInfo
    ) {
    return ERROR_NOT_SUPPORTED;
}
NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE                      hDS,
    LPCSTR                 pszNameContext,
    ULONG                       ulFlags,
    BOOL (__stdcall *           pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID                      pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **  papErrInfo
    ) {
    return ERROR_NOT_SUPPORTED;
}
#endif !WIN95 && !WINNT4
