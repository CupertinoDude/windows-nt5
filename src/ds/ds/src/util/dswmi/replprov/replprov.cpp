/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    replprov.cpp

Abstract:

    Contains dll entry points for replprov.dll

Author:

    Akshay Nanduri (t-aksnan)  26-Mar-2000

Environment:

    User Mode - Win32

Revision History:

Notes:
    This cpp file was generated by Visual Studio...(Visual C++ 6.0)

--*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ReplProvps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ReplProv.h"

#include "ReplProv_i.c"
#include "RpcReplProv.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RpcReplProv, CRpcReplProv)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_REPLPROVLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
// AjayR 7-22-00 modified to add runonce key and then call the
// CComModule::RegisterServer method.
//

STDAPI DllRegisterServer(void)
{
    HKEY hk;
    DWORD dwData, dwErr = 0;
    WCHAR wszFilePath[2*MAX_PATH];HRESULT hr = S_OK;
    DWORD dwFailed = 1;

    dwErr = GetModuleFileNameW(
                _Module.GetModuleInstance(),
                wszFilePath,
                2*MAX_PATH
                );
    //
    // GetModuleFileName returns the length of fileName.
    //
    if (!dwErr) {
        return GetLastError();
    }

    //
    // Add a RunOnce value to do the MOF compile.
    //
    if (RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
            0,
            KEY_WRITE,
            &hk
            )) {
        return GetLastError();
    }
    else {
        //
        // This will call the DoMofComp on this dll.
        //
        LPWSTR pszString = NULL;
        DWORD dwLen = wcslen(wszFilePath) 
                     + wcslen(L"rundll32.exe ,DoMofComp")
                     + 1;
        pszString = (LPWSTR) AllocADsMem(sizeof(WCHAR) * dwLen);

        if (!pszString) {
            RegCloseKey(hk);
            return ERROR_OUTOFMEMORY;
        }

        wcscpy(pszString, L"rundll32.exe ");
        wcscat(pszString, wszFilePath);
        wcscat(pszString, L",DoMofComp");

        if (RegSetValueExW(
                hk,
                L"ReplProv",
                0,
                REG_SZ,
                (LPBYTE)pszString,
                wcslen(pszString) * sizeof(WCHAR)
                )
            ) {
            dwErr = GetLastError();
        } 
        else {
            dwErr = 0;
        }

        FreeADsMem(pszString);
        RegCloseKey(hk);
    }

    if (dwErr) {
        return dwErr;
    }

    //
    // Create the key for the event log.
    //
    if (!RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\DSReplicationProvider",
            0, // dwReserved,
            L"", // class name
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &hk,
            NULL // disposition does not matter
            )
        ) {

        DWORD dwLenFile = wcslen(wszFilePath) 
                        + 1;

        if (!RegSetValueExW(
                hk,
                L"EventMessageFile",
                0,
                REG_EXPAND_SZ,
                (LPBYTE)wszFilePath,
                dwLenFile * sizeof(WCHAR)
                )
            ) {
            //
            // Set the supported event types in the TypesSupported subkey.
            //
            DWORD dwData = EVENTLOG_ERROR_TYPE 
                          | EVENTLOG_WARNING_TYPE 
                          | EVENTLOG_INFORMATION_TYPE;

            if (!RegSetValueExW(
                    hk,
                    L"TypesSupported",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwData,
                    sizeof(DWORD))
                ) {
                dwFailed = 0;
            }
        }

        if (dwFailed != 0) {
            //
            // Setting one of the value failed.
            //
            dwFailed = GetLastError();
        }

        //
        // We opened the key successfully so need to close it.
        //
        RegCloseKey(hk);
    }   // event log keys and values.
    else {
        //
        // Creating key failed.
        //
        return GetLastError();
    }

    if (dwFailed) {
        return dwFailed;
    }

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}


//+----------------------------------------------------------------------------
//
//  Function:  DoMofComp
//
//  Purpose:   Adds the provider classes to the WMI repository.
//
//-----------------------------------------------------------------------------
VOID WINAPI 
DoMofComp(
    HWND hWndParent,
    HINSTANCE hModule,
    PCTSTR ptzCommandLine,
    INT nShowCmd
    )
{
   UNREFERENCED_PARAMETER(hWndParent);
   UNREFERENCED_PARAMETER(hModule);
   UNREFERENCED_PARAMETER(ptzCommandLine);
   UNREFERENCED_PARAMETER(nShowCmd);
   HRESULT hr;
   IMofCompiler *pmc = NULL;
   LPWSTR pszPath = NULL;
   WCHAR wszFilePath[2*MAX_PATH];
   UINT nLen;
   DWORD dwLen = 0;
   HANDLE hEvent = NULL;

   CoInitialize(NULL);

   hr = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            (PVOID *)&pmc
            );
   
   if (FAILED(hr)) {
       ASSERT(!"CoInitializeFailed In Replprov Setup.");
       return;
   }

   nLen = GetSystemWindowsDirectoryW(wszFilePath, 2*MAX_PATH);
   if (nLen == 0)
   {
      ASSERT(!"Could not get system direcotry in Replprov Setup.");
      goto cleanup;
   }

   //
   // Issue 7-22-00 AjayR - define constant for the name.
   //
   dwLen = wcslen(wszFilePath) + wcslen(L"\\System32\\replprov.mof") + 1;
   pszPath = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
   if (!pszPath) {
       ASSERT(!"Could not allocate memory - Replprov runonce failed.");
       goto cleanup;
   }
   
   wcscpy(pszPath, wszFilePath);
   wcscat(pszPath, L"\\System32\\replprov.mof");

   WBEM_COMPILE_STATUS_INFO Info;

   hr = pmc->CompileFile(
            pszPath,
            NULL,
            NULL,
            NULL,
            NULL,
            WBEM_FLAG_AUTORECOVER,
            0,
            0,
            &Info
            );

   hEvent = RegisterEventSourceW(NULL, L"DSReplicationProvider");
   
   if (!hEvent) {
       //
       // Could not Register event source to update log file.
       //
       ASSERT(!"Could not RegisterEventSource - Replprov runonce");
       goto cleanup;
   }

   if (WBEM_S_NO_ERROR != hr) {
       //
       // Send failure to EventLog.
       //
       WCHAR pszHr[25];
       wsprintfW(pszHr, L"%d", Info.hRes);
       WCHAR pszErrorString[] = 
           L"MofComp failed on %systemRoot%\\system32\\replprov.mof with code";
       const PWSTR rgArgs[2] = {pszErrorString, pszHr};
       
       ReportEventW(hEvent,
                   EVENTLOG_ERROR_TYPE,
                   0,                       // wCategory
                   REPLPROV_MOFCOMP_FAILED, // dwEventID
                   NULL,                    // lpUserSID
                   0,                       // wNumStrings
                   0,                       // dwDataSize
                   NULL,                    // lpStrings
                   NULL);                   // lpRawData
   }
   else
   {
       //
       // Send success notice to EventLog.
       //
       ReportEventW(hEvent,
                   EVENTLOG_INFORMATION_TYPE,
                   0,                        // wCategory
                   REPLPROV_MOFCOMP_SUCCESS, // dwEventID
                   NULL,                     // lpUserSID
                   0,                        // wNumStrings
                   0,                        // dwDataSize
                   NULL,                     // lpStrings
                   NULL                      // lpRawData
                   );
   }



cleanup:
    
    if (pszPath) {
        FreeADsMem(pszPath);
    }

    if (hEvent) {
        DeregisterEventSource(hEvent);
    }

    if (pmc) {
        pmc->Release();
    }

    CoUninitialize();
    return;
}

