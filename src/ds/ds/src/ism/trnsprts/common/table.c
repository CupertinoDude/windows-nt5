/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    table.c

Abstract:

    This is a generic table module.

    It is customized by macro's by the caller to return entries of whatever size and type
    the user requires.  For example, in route.c we have:

// Use the generate table template to create a type specific table!
// Site Hash Table

#define SITE_HASH_TABLE_SIZE 107  // should be prime

typedef struct _SITE_INSTANCE {
    TABLE_ENTRY TableEntry;  // must be first
    DWORD Size;
    DWORD Index;
} SITE_INSTANCE, *PSITE_INSTANCE;

typedef PTABLE_INSTANCE PSITE_TABLE;

#define SiteTableCreate() TableCreate( SITE_HASH_TABLE_SIZE, sizeof( SITE_INSTANCE ) )
#define SiteTableFree( table ) TableFree( (PTABLE_INSTANCE) table )
#define SiteTableFindCreate( table, name, create ) \
(PSITE_INSTANCE) TableFindCreateEntry( (PTABLE_INSTANCE) table, name, create )

The core structure must be embedded in the user's datatype at the start.

TODO: Deletion of entries, locking, and reference counting
For deletion, switch to using doubly linked list macros

Author:

    Will Lees (wlees) 08-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include <winsock.h>
#include <ntdsapi.h>

#include "common.h"

#define DEBSUB "TABLE:"

// This represents a generic table.  It is self describing.
typedef struct _TABLE_INSTANCE {
    DWORD Size;
    DWORD TableSize;
    DWORD EntrySize;
    struct _TABLE_ENTRY **Table;
} TABLE_INSTANCE, *PTABLE_INSTANCE;

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Thu Jan 08 16:25:46 1998 */

PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    );

VOID
TableFree(
    PTABLE_INSTANCE Table
    );

PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    );

LPWSTR
GetCanonicalDN(
    IN      LPCWCH      pDN
    );

/* End Forward */


PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    )

/*++

Routine Description:

Create a generic table.

Arguments:

    TableSize - Number of hash buckets.  Should be prime.
    EntrySize - Size of user entries.  Must embed a TABLE_ENTRY structure

Return Value:

    PTABLE_INSTANCE -

--*/

{
    DWORD i;
    PTABLE_INSTANCE table;

    if (EntrySize < sizeof( TABLE_ENTRY ) ) {
        DPRINT( 1, "table entry size is invalid\n" );
        return NULL;
    }

    table = NEW_TYPE( TABLE_INSTANCE );
    if (table == NULL) {
        // ERROR_NOT_ENOUGH_MEMORY;
        return NULL;
    }

    // INITIALIZE TABLE INSTANCE HERE

    table->Size = sizeof( TABLE_INSTANCE );
    table->TableSize = TableSize;
    table->EntrySize = EntrySize;

    table->Table = NEW_TYPE_ARRAY( TableSize, PTABLE_ENTRY );
    if (table->Table == NULL) {
        FREE_TYPE( table );
        return NULL;
    }

    // INITIALIZE TABLE INSTANCE HERE

    for( i = 0; i < TableSize; i++ ) {
        table->Table[i] = NULL;
    }

    return table;
} /* TableCreate */


VOID
TableFree(
    PTABLE_INSTANCE Table
    )

/*++

Routine Description:

Free a generic table

CODE.IMPROVEMENT: provide a means to deallocate dynamic data in user section of the entry

Arguments:

    Table -

Return Value:

    None

--*/

{
    DWORD i;

    if (Table->Size != sizeof( TABLE_INSTANCE ) ) {
        DPRINT( 1, "table is invalid\n" );
        return;
    }

    // Cleanup hash table
    for( i = 0; i < Table->TableSize; i++ ) {
        PTABLE_ENTRY current, next;

        current = Table->Table[i];
        while (current != NULL) {
            next = current->Next;

            FREE_TYPE( current->Name );
            current->Name = NULL;
            FREE_TYPE( current ); // destroys the users entry, EntrySize bytes worth

            current = next;
        }
    }
    FREE_TYPE( Table->Table );
    Table->Table = NULL;

    FREE_TYPE( Table );
} /* TableFree */


PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    )

/*++

Routine Description:

This routine stores an in the hash table.

Data structure is a hash table to a sorted single linked list by name

Arguments:

    Table - Hash table to work on
    EntryName - Name in DN form
    Create - flag to indicate wether to create if not found

Return Value:

    Success: created or found PTABLE_ENTRY
    Error: NULL.

Remarks:
    - Assumes EntryName is in DN form.
--*/

{
    DWORD hash, length;
    PWCHAR p;
    LPWSTR pCanonicalName = NULL;
    PTABLE_ENTRY current, new, previous;
    int result;
    DWORD err;

    if (Table->Size != sizeof( TABLE_INSTANCE ) ) {
        DPRINT( 1, "table is invalid\n" );
        return NULL;
    }

    pCanonicalName = GetCanonicalDN( EntryName );

    if ( !pCanonicalName ) {
        DPRINT(1, "Error: Failed to generate canonical name\n");
        return NULL;
    }

    hash = 0;
    for( p = (LPWSTR) pCanonicalName; *p != L'\0'; p++ ) {
        hash += *p;
    }
    hash %= Table->TableSize;

    previous = NULL;
    current = Table->Table[hash];
    while (current != NULL) {
        result = _wcsicmp( pCanonicalName, current->Name );
        if (result == 0) {
            goto cleanup;
        } else if (result == 1) {
            break;
        }
        previous = current;
        current = current->Next;
    }

    // If we are not allowed to create it, exit at this point

    if (!Create) {
        current = NULL;
        goto cleanup;
    }

    // Create new entry

    new = (PTABLE_ENTRY) NEW_TYPE_ARRAY_ZERO( Table->EntrySize, CHAR );
    if (new == NULL) {
        current = NULL;
        goto cleanup;
    }

    // INITIALIZE TABLE ENTRY HERE

    length = wcslen( pCanonicalName ) + 1;  // in wchars inc terminator
    new->Name = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == new->Name) {
        FREE_TYPE(new);
        current = NULL;
        goto cleanup;
    }

    wcscpy( new->Name, pCanonicalName );

    // INITIALIZE TABLE ENTRY HERE

    new->Next = current;

    if (previous == NULL) {
        Table->Table[hash] = new;
    } else {
        previous->Next = new;
    }

    current = new;

cleanup:
    if (pCanonicalName) {
        FREE_TYPE(pCanonicalName);
    }
    return current;
} /* TableFindCreateEntry */


LPWSTR
GetCanonicalDN(
    IN      LPCWCH      pDN
    )
/*++

Routine Description:

    Convert a DN into canonical form (see DsUnquoteRdnValueW for details).


    Various clients use different name forms resulting w/ misses when searched
    for in the hash table. For example, two name forms of interest are as follows:

    A) Backslash form (typically an ldap client will get this form)
        CN=site3\<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d,CN=Sites...

    B) Quoted form (typically core generated dsname format)
        CN="site3<0xA>CNF:d565bc93-293c-46d88831-69c345b30f7d",CN=Sites...

    To overcome this problem, all names are converted to the unquoted/unescaped
    form (we'll call it canonical) in this function.


Arguments:

    pDN - name to compute value for.

Return Value:

    success: name in canonical form.
    error: NULL.

Remarks:
    On success, returned name is allocated. Caller is responsible to
    free using FREE_TYPE().

--*/
{

    DWORD cDN, cKey, cVal, cRdn;
    LPCWCH pVal, pKey, pTmpDN = pDN;
    LPWCH pRdn = NULL;
    LPWCH pName = NULL, pCurName=NULL;
    DWORD err = ERROR_SUCCESS;
    DWORD len = 0, curlen = 0;


    // param sanity
    if (!pDN){
        // when would we ever try to hash an empty name?
        DPRINT(1, "Error: invalid DN\n");
        return NULL;
    }

    //
    // Convert to canonical form:
    // a) calc required mem & alloc
    // b) cycle, apply DsUnquoteRdnValueW & copy
    //

    //
    // calc required memory
    //

    // first string length
    curlen = cDN = wcslen(pDN);
    if (!cDN) {
        DPRINT(1, "Error: invalid DN\n");
        return NULL;
    }

    // now cycle rdns.
    while (cDN) {
        err = DsGetRdnW( &pTmpDN, &cDN, &pKey, &cKey, &pVal, &cVal);
        len += cKey + cVal + 2;         // 2 addt'l for '=' & ','
    }

    // allocate memory (+ term char)
    pCurName = pName = NEW_TYPE_ARRAY_ZERO( len + 1, WCHAR );
    if (!pName) {
        DPRINT(1, "Error: not enough memory\n");
        return NULL;
    }

    // restore cDN (note that pDN wasn't touched, only pTmpDN)
    cDN = curlen;
    curlen = 0;


    while (cDN) {
        //
        // Cycle & re-create DN in unquoted form
        //

        err = DsGetRdnW( &pDN, &cDN, &pKey, &cKey, &pVal, &cVal);
        if (err != ERROR_SUCCESS) {
            goto cleanup;
        }
        //
        // create formatted rdn
        //
        if (cKey) {
            // copy key (ie "CN" etc)
            wcsncpy(pCurName, pKey, cKey);
            curlen += cKey;
            // add '='
            pName[curlen++] = '=';
            pCurName = &pName[curlen];
        }
        if (cVal) {
            // copy value
            cRdn = len - curlen;
            err = DsUnquoteRdnValueW(cVal, pVal, &cRdn, pCurName);
            if (err) {
                goto cleanup;
            }
            Assert(cRdn);

            curlen += cRdn;
            pName[curlen++] = ',';
            pCurName = &pName[curlen];
        }
    }

    // terminate name excluding (overwriting) last ','
    Assert(curlen > 1 && pName[curlen-1] == ',');
    pName[curlen-1] = '\0';

    Assert(err == ERROR_SUCCESS);

cleanup:

    if (err) {
        if (pName) {
            FREE_TYPE(pName);
            pName = NULL;
        }
    }

    return pName;
}


/* end table.c */
