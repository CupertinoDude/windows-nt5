/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ldapobj.c

Abstract:

    This module implements an object specific interface to the directory.

    The current directory is the NT 5 DS, as accessed through LDAP.

    The implementation of the directory is abstracted away, so that any directory may be used.
    For example, the registry was used during testing.

    THIS IS THE LDAP IMPLEMENTATION.

Author:

    Will Lees (wlees) 07-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <winsock2.h>
#define LDAP_UNICODE 1
#include <winldap.h>
#include <ntldap.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include <dsconfig.h>                   // GetConfigParam

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_LDAPOBJ

#include <debug.h>
#define DEBSUB "LDAPOBJ:"

#include <ismapi.h>

#include <common.h>

// The number of items returned from a paged search
#if DBG
// Make smaller on checked build to stress page handling
#define ISM_LDAP_PAGE_SIZE 10
#else
#define ISM_LDAP_PAGE_SIZE 1000
#endif

// This is the internal state for a connection
typedef struct _CONNECTION_INSTANCE {
    DWORD Size;
    // ldap stuff goes here
    LDAP *LdapConnection;
    LPWSTR ConfigNC;
    // We don't cache the server dn in here because it might be renamed
    WCHAR szServerGuidDN[32+sizeof("<GUID=>")];
} CONNECTION_INSTANCE, *PCONNECTION_INSTANCE;

// This is the internal state kept across calls to the iteration routines
typedef struct _ITERATION_CONTEXT {
    LDAP *hLdap;
    LDAPSearch *pSearch;
    LDAPMessage *Results;
    LDAPMessage *Message;
} ITERATION_CONTEXT, *PITERATION_CONTEXT;

/* External */

/* Static */

static LPWSTR ExtendedErrorSpecialError = L"Failed to get server error.";

/* Forward */ /* Generated by Emacs 21.1 (patch 9) "Canyonlands" XEmacs Lucid on Wed Jan 03 10:34:07 2001 */

void
logExtendedServerError(
    IN LDAP *pLdap
    );

DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    );

DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    );

DWORD
cacheOperationalAtts(
    IN OUT  CONNECTION_INSTANCE *   pConnection
    );

DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    );

DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    );

void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    );

void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    );

DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    );

DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    );

static DWORD
iterateContainer(
    PVOID ConnectionHandle,
    LPWSTR BaseDN,
    LPWSTR LdapFilter,
    PVOID *pIterateContextHandle,
    LPWSTR Name
    );

void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    );

DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    );

DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    );

void
DirFreeMultiszString(
    LPWSTR MultiszString
    );

void
DirFreeSchedule(
    PBYTE pSchedule
    );

DWORD
cacheServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    );

DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirWriteServerSmtpAttributesUnused(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirRegisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT HANDLE *              phServerChanges
    );

DWORD
DirWaitForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

DWORD
DirUnregisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

static DWORD
stringArrayToMultiSz(
    PWSTR *pString,
    PWSTR *pFlat
    );

DWORD
static verifyExistence(
    PVOID ConnectionHandle,
    LPCWSTR ObjectDN
    );

DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

unsigned __stdcall
notifyThread(
    PVOID Argument
    );

/* End Forward */


void
logExtendedServerError(
    IN LDAP *pLdap
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR *pmsg = NULL;
    DWORD err = 0;

    ldap_get_optionW( pLdap, LDAP_OPT_SERVER_ERROR, &pmsg );
    ldap_get_optionW(pLdap, LDAP_OPT_SERVER_EXT_ERROR, &err);

    if ( pmsg || err ) {
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_EXTENDED_SERVER_ERROR,
            szInsertWC( pmsg ? pmsg : L"" ),
            szInsertWin32Msg( err ),
            NULL, NULL, NULL, NULL, NULL, NULL,
            sizeof(err), &err
            );
    }

    DPRINT2( 0, "Ism extended LDAP error info:\nServer Error: %ws\nExtended Error: %d\n",
             pmsg, err );

    if ( pmsg != NULL ) {
        ldap_memfreeW(pmsg);
    }
}


DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    )

/*++

Routine Description:

Open a connection handle to the directory service.  This package chooses the implementation and
which server to open.

This is needed because some directory services need a long-lived handle on which each call
is made.

Arguments:

    ConnectionHandle -

Return Value:

    DWORD -

--*/

{
    PCONNECTION_INSTANCE connection = NULL;
    DWORD status, ldapStatus;
    LDAP *ldapConnection = NULL;
    LPWSTR configNC = NULL;
    WCHAR pszTargetServer[MAX_PATH];

    connection = NEW_TYPE_ZERO( CONNECTION_INSTANCE );
    if (connection == NULL) {
        // no resources to free yet
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    connection->Size = sizeof( CONNECTION_INSTANCE );

    // Allow means to configure ISM to use remote directory instance
#if DBG
    if (GetConfigParamW( MAKE_WIDE( ISM_ALTERNATE_DIRECTORY_SERVER ),
                         pszTargetServer, MAX_PATH )) {
        // Parameter not found or other error
        wcscpy( pszTargetServer, L"localhost" );
    } else {
        DPRINT1( 0, "ISM using alternate directory server %ws\n", pszTargetServer );
    }
#else
    wcscpy( pszTargetServer, L"localhost" );
#endif

    // Open ourselves as the ldap server.
    // Assumption: this code is always running on a DC

    ldapConnection = ldap_initW( pszTargetServer, LDAP_PORT );
    if (ldapConnection == NULL) {
        status = GetLastError();
        DPRINT1(0, "ldap_initW failed, status = %d\n", status);
        goto cleanup;
    }

    DPRINT1( 2, "Connected to server %s.\n", ldapConnection->ld_host );

    // Force LDAP V3.  Without this, the LDAP client dumbs down to V2 and
    // rejects any searches that use controls.
    ldapConnection->ld_version = LDAP_VERSION3;

    ldapStatus = ldap_bind_s( ldapConnection, NULL, NULL, LDAP_AUTH_NTLM );
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "ldap_bind_s failed, ldap error = %d, status = %d\n",
                 ldapStatus, status );
        logExtendedServerError( ldapConnection );
        goto cleanup;
    }

    connection->LdapConnection = ldapConnection;

    status = cacheOperationalAtts(connection);
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    *ConnectionHandle = (PVOID) connection;

    return ERROR_SUCCESS;

cleanup:  // only called on failure

    if (connection->ConfigNC != NULL) {
        FREE_TYPE(connection->ConfigNC);
    }

    if (connection != NULL) {
        FREE_TYPE( connection );
    }

    if (ldapConnection != NULL) {
        ldap_unbind( ldapConnection );
    }

    return status;

} /* DirOpenConnection */


DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    )

/*++

Routine Description:

Close a connection handle.

Arguments:

    ConnectionHandle -

Return Value:

    DWORD -

--*/

{
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    ldap_unbind( connection->LdapConnection );

    FREE_TYPE( connection->ConfigNC );

    FREE_TYPE( connection );

    return ERROR_SUCCESS;
} /* DirCloseConnection */


DWORD
cacheOperationalAtts(
    IN OUT  CONNECTION_INSTANCE *   pConnection
    )

/*++

Routine Description:

    Helper routine to cache important operational atts from the DS
    into the connection handle.

Arguments:

    pConnection (IN/OUT) - Connection to poulate with cached info.

Return Value:

    Win32 error code

--*/

{
#define ATT1 L"configurationNamingContext"
#define ATT2 L"serverName"
#define ATT3 L"objectGuid"
    DWORD status, ldapStatus, length;
    PWCHAR rootAttributeList[] = { ATT1, ATT2, NULL };
    PWCHAR serverAttributeList[] = {ATT3, NULL};
    LDAPMessage *rootResults = NULL;
    LDAPMessage *serverResults = NULL;
    LDAPMessage *rootMessage;
    LDAPMessage *serverMessage;
    PWCHAR *valueList = NULL;
    struct berval **ppbv = NULL;
    WCHAR *pch;
    DWORD ib;

    // Get the config NC attribute
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               NULL,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &rootAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &rootResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, base object, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( L"Root DN" ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (rootResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    rootMessage = ldap_first_entry( pConnection->LdapConnection, rootResults );
    if (rootMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage, ATT1);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT1 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    length = wcslen( *valueList ) + 1; // length in wchars inc term
    pConnection->ConfigNC = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pConnection->ConfigNC) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy(pConnection->ConfigNC, *valueList);

    // Get the DN of the server object.
    ldap_value_free(valueList);
    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage,
                                ATT2 );
    if (NULL == valueList) {
        // error, inconsistent results found
        DPRINT1( 0, "missing attribute %ws\n", ATT2 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // TODO: Search for this attribute with the others in the previous search

    // Read the server object.
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               *valueList,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               &serverAttributeList[0],
                               FALSE,
                               &serverResults);
    if (LDAP_SUCCESS != ldapStatus) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2(0, "Ldap_search_s failed, server object, ldap error = %d, win32 error = %d\n",
                ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( *valueList ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (NULL == serverResults) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }
    serverMessage = ldap_first_entry(pConnection->LdapConnection, serverResults);
    if (NULL == serverMessage) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Extract the object GUID and cache the GUID form of the DN.
    // Referencing the server object via the GUID DN later makes us immune from
    // renames of our site and renames/moves of our server object.
    ppbv = ldap_get_values_len(pConnection->LdapConnection, serverMessage,
                               ATT3 );
    if (NULL == ppbv) {
        // error, inconsistent results found
        DPRINT1( 0, "missing attribute %ws\n", ATT3 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }
    Assert(1 == ldap_count_values_len(ppbv));
    Assert(sizeof(GUID) == (*ppbv)->bv_len);

    wcscpy(pConnection->szServerGuidDN, L"<GUID=");
    pch = pConnection->szServerGuidDN + sizeof(L"<GUID=")/sizeof(WCHAR) - 1;
    for (ib = 0; ib < sizeof(GUID); ib++) {
        swprintf(pch, L"%02x", (UCHAR) (*ppbv)->bv_val[ib]);
        pch += 2;
    }
    *(pch++) = L'>';
    *(pch++) = L'\0';
    Assert(pch - &pConnection->szServerGuidDN[0]
           == sizeof(pConnection->szServerGuidDN)/sizeof(WCHAR));

    status = ERROR_SUCCESS;

cleanup:  // called in all cases

    if (valueList != NULL) {
        ldap_value_free( valueList );
    }

    if (NULL != ppbv) {
        ldap_value_free_len(ppbv);
    }

    if (NULL != rootResults) {
        ldap_msgfree( rootResults );
    }

    if (NULL != serverResults) {
        ldap_msgfree(serverResults);
    }

    return status;
#undef ATT1
#undef ATT2
#undef ATT3
} /* cacheOperationalAtts */


DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

This routine rereads the transport object from the directory service.

Object must exist.

Arguments:

    ConnectionHandle - directory handle
    pTransport - dn of transport object

Return Value:

    DWORD -

--*/

{
#define ATT_RI L"replInterval"
#define ATT_RI_A "replInterval"
#define ATT_OP L"options"
#define ATT_OP_A "options"
    PWCHAR attributeList[] = { ATT_RI, ATT_OP, NULL };
    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PCHAR *numberList;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Get the attributes for this one site link object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               pTransport->Name,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        // error LDAP_NO_SUCH_OBJECT
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 pTransport->Name, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pTransport->Name ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // We only update the value if the attribute is present.  By presetting a
    // value in field to be updated, the caller may determine whether the
    // attribute was actually present or not.

    // Read optional replInterval attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_RI_A);
    if (numberList != NULL) {
        pTransport->ReplInterval = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
        DPRINT1( 2, "Transport default replication interval = %d\n", pTransport->ReplInterval );
    }

    // Read optional options attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_OP_A);
    if (numberList != NULL) {
        pTransport->Options = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
        DPRINT1( 2, "Transport options = 0x%x\n", pTransport->Options );
    }

    status = ERROR_SUCCESS;

cleanup:

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT_RI
#undef ATT_RI_A
#undef ATT_OP
#undef ATT_OP_A
#undef ATT_SCHED
} /* DirReadTransport */


DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    )

/*++

Routine Description:

This routine returns the bridgehead servers for a given site

Arguments:

    SiteDN - string name of site. It is supposed to be the full DN of the site.
    It must exist.
    pNumberServers - pointer to dword to receive number of servers
    ppServerList - pointer to a pointer, that will receive a pointer to a block of
           strings (which are pointers to char)
           Server list must be freed by the caller.

Return Value:

    DWORD -

--*/

{
#define ATT1 L"bridgeheadServerListBL"
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    DWORD status, ldapStatus, index, length;
    DWORD number = 0;
    LPWSTR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    LPWSTR *pServerList = NULL;
    LPWSTR *valueList = NULL, *pString;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct the element path
    // CODE.IMP - default to current stie
    if ( (SiteDN == NULL) || (*SiteDN == L'\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Bug 151694. Verify that the site dn is valid
    status = verifyExistence( ConnectionHandle, SiteDN );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_FILE_NOT_FOUND) {
            status = ERROR_NO_SUCH_SITE;
        }
        return status;
    }

    // Get the bridgehead servers for this transport.
    // Note, these are the servers for all sites
    ldapStatus = ldap_search_s( connection->LdapConnection,
                               pTransport->Name,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results

    // Attribute not found, a success case
    if (ldapStatus == LDAP_NO_SUCH_ATTRIBUTE)
    {
       *pNumberServers = 0;
       *ppServerList = NULL;
       status = ERROR_SUCCESS;
       goto cleanup;
    }

    if (ldapStatus != LDAP_SUCCESS) {
        // better error, no such transport
        // error LDAP_NO_SUCH_OBJECT
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, base object, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pTransport->Name ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // better error, no such transport
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // better error, no such transport
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values( connection->LdapConnection, message, ATT1 );
    if (valueList == NULL) {
        // Attribute is optional
        *pNumberServers = 0;
        *ppServerList = NULL;
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Count the number of servers in this site
    pString = valueList;
    while (*pString != NULL) {
        if (wcsstr( *pString, SiteDN ) != NULL) {
            number++;
        }
        pString++;
    }

    // If no matching sites, exit now
    if (number == 0) {
        *pNumberServers = 0;
        *ppServerList = NULL;
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Allocate the block of pointers
    // Zero'd for ease of cleanup
    pServerList = NEW_TYPE_ARRAY_ZERO( number, LPWSTR );
    if (pServerList == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;

    }

    // Populate the return block
    index = 0;
    pString = valueList;
    while (*pString != NULL) {
        if (wcsstr( *pString, SiteDN ) != NULL) {
            length = wcslen( *pString ) + 1; // len in wchars plus term
            pServerList[index] = NEW_TYPE_ARRAY( length, WCHAR );
            if (pServerList[index] == NULL) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            wcscpy( pServerList[index], *pString );
            index++;
        }
        pString++;
    }

    // Return out parameters

    *pNumberServers = number;
    *ppServerList = pServerList;

    pServerList = NULL; // given away, don't clean up

    status = ERROR_SUCCESS;

cleanup:

    if (pServerList != NULL) {
        for( index = 0; index < number; index++ ) {
            if (pServerList[index] != NULL) {
                FREE_TYPE( pServerList[index] );
            }
        }
        FREE_TYPE( pServerList );
    }

    if (valueList != NULL) {
        ldap_value_free( valueList );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;
#undef ATT1
} /* IpGetSiteBridgeheadList */


DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

    Return the list of all sites.
    Some of these sites may be inaccessible for our purposes if they are not mentioned in the
    site link structures.

    This site list is a counted array of pointers to strings, NOT a multi-sz format as is
    used in other places.

    The preferred method to interate a container is to do a search with only
    invalid arguments, and then get the dn out of each entry

Arguments:

    ConnectionHandle - Current open directory
    pNumberSites - pointer to dword to receive the number of sites
    ppSiteList - pointer which receives pointer to array of strings.
                 Storage must be freed by caller.

Return Value:

    DWORD -

--*/

{
#define ATT1        L"invalid"
    DWORD status, ldapStatus, length, number, i, total;
    DWORD index = 0;
    LPWSTR *pSiteList = NULL;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    WCHAR path[MAX_REG_PATH];
    PWCHAR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    LDAPSearch *pSearch = NULL;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    wcscpy( path, L"CN=Sites," );
    wcscat( path, connection->ConfigNC );

    //
    // Initialize paged search
    //
    pSearch = ldap_search_init_page(
        connection->LdapConnection,
        path,                   // base dn
        LDAP_SCOPE_ONELEVEL,    // immediate children
        L"(objectClass=site)",  // filter is all objects
        &attributeList[0],      // list of attributes
        FALSE,                  // attrs only
        NULL,                   // ServerControls
        NULL,                   // ClientControls
        0,                      // PageTimeLimit
        0,                      // TotalSizeLimit
        NULL                   // SortKeys
        );
    if (pSearch == NULL) {
        ldapStatus = LdapGetLastError();
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT3( 0, "Ldap_search_init_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 path, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
            szInsertWC( path ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        goto cleanup;
    }

    // Search for all site objects below the Sites container
    // In order to free loop resources, all exits from loop must be through
    // loop cleanup at bottom

    status = ERROR_SUCCESS;
    do {
        //
        // Get the next page of results
        //
        ldapStatus = ldap_get_next_page_s(
            connection->LdapConnection,
            pSearch,
            NULL,
            ISM_LDAP_PAGE_SIZE,
            &total,
            &results );
        if (ldapStatus != LDAP_SUCCESS) {
            status = LdapMapErrorToWin32( ldapStatus );
            if ( (ldapStatus != LDAP_SERVER_DOWN) &&
                 (ldapStatus != LDAP_NO_RESULTS_RETURNED) ) {
                DPRINT3( 0, "Ldap_get_next_page_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                         path, ldapStatus, status );
                LogEvent8WithData(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                    szInsertWC( path ),
                    szInsertWin32Msg( status ),
                    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    sizeof(status),
		    &status
                    );
                logExtendedServerError( connection->LdapConnection );
            }
            goto loop_cleanup;
        }
        if (results == NULL) {
            // 0 entry pages permissable
            goto loop_cleanup;
        }

        // Count number of entries found
        number = ldap_count_entries( connection->LdapConnection, results );
        // There should always be atleast one site
        if (number == 0) {
            // 0 entry pages permissable
            goto loop_cleanup;
        }

        // Allocate return array
        if (pSiteList) {
            // Expand existing array to encompass new entries
            LPWSTR *pTempSiteList =
                REALLOC_TYPE_ARRAY( pSiteList, (index + number), PWSTR );
            if (pTempSiteList == NULL) {
                DPRINT( 1, "failed to allocate site array\n" );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }
            pSiteList = pTempSiteList;
        } else {
            // New array
            pSiteList = NEW_TYPE_ARRAY( number, PWSTR );
            if (pSiteList == NULL) {
                DPRINT( 1, "failed to allocate site array\n" );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }
        }

        // Load the array with the sites
        message = ldap_first_entry( connection->LdapConnection, results );
        while (message != NULL ) {
            PWCHAR dn;
            dn = ldap_get_dn( connection->LdapConnection, message );
            if (dn == NULL) {
                // error, inconsistent results found
                DPRINT( 0, "missing dn in ldap message\n" );
                status = ERROR_DS_MISSING_EXPECTED_ATT;
                goto loop_cleanup;
            }

            length = wcslen( dn ) + 1;    // length in wchars inc term

            pSiteList[index] = (PWSTR) NEW_TYPE_ARRAY( length, WCHAR );   // in wchars
            if (pSiteList[index] == NULL) {
                ldap_memfree( dn );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }

            wcscpy(pSiteList[index], dn);
            ldap_memfree( dn );


            index++;
            message = ldap_next_entry( connection->LdapConnection, message );
        }

    loop_cleanup:
        if (results != NULL) {
            ldap_msgfree( results );
            results = NULL;
        }

    } while (status == ERROR_SUCCESS);
    // Make sure loop exited for right reason
    // This is the goofy ldap translation of NO_RESULTS_RETURNED
    if (status != ERROR_MORE_DATA) {
        goto cleanup;
    }
    // There should always be atleast one site
    if (index == 0) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto loop_cleanup;
    }

    // Return the OUT parameters

    *pNumberSites = index;
    *ppSiteList = pSiteList;

    // Don't clean up the list now that we've given it away
    pSiteList = NULL;

    status = ERROR_SUCCESS;

cleanup:
    if (pSiteList != NULL) {
        for( i = 0; i < index; i++ ) {
            if (pSiteList[i] != NULL) {
                FREE_TYPE( pSiteList[i] );
            }
        }
        FREE_TYPE( pSiteList );
    }

   // Clean up paged search
   if (pSearch) {
       ldapStatus = ldap_search_abandon_page(
           connection->LdapConnection,
           pSearch );
       if (ldapStatus != LDAP_SUCCESS) {
           DWORD status1 = LdapMapErrorToWin32( ldapStatus );
           DPRINT3( 0, "Ldap_search_abandon_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                    path, ldapStatus, status1 );
       }
   }

   return status;
#undef ATT1
} /* DirGetSiteList */


void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LPWSTR *pNewSiteList = NULL;
    LPWSTR pszNewSite;
    DWORD i, length;

    Assert( ppSiteList );

    *ppSiteList = NULL;

    pNewSiteList = NEW_TYPE_ARRAY_ZERO( NumberSites, LPWSTR );
    if (pNewSiteList == NULL) {
        return;
    }

    for( i = 0; i < NumberSites; i++ ) {
        length = wcslen( pSiteList[i] ) + 1;
        pszNewSite = NEW_TYPE_ARRAY( length, WCHAR );
        if (pszNewSite == NULL) {
            goto cleanup;
        }
        wcscpy( pszNewSite, pSiteList[i] );
        pNewSiteList[i] = pszNewSite;
    }

    *ppSiteList = pNewSiteList;

    pNewSiteList = NULL;  // don't clean up

cleanup:
    if (pNewSiteList) {
        DirFreeSiteList( i, pNewSiteList );
    }
}


void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    )

/*++

Routine Description:

Free the site list returned from the DirGetSiteList function.

Arguments:

    NumberSites -
    pSiteList -

Return Value:

    None

--*/

{
    DWORD i;

    // Get rid of site list
    for( i = 0; i < NumberSites; i++ ) {
        FREE_TYPE( pSiteList[i] );
    }
    FREE_TYPE( pSiteList );
} /* DirFreeSiteList */


DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    )

/*++

Routine Description:

This function is called multiple times to return the name of each site link object.

The context handle is always a pointer to a PVOID.  The PVOID should have null in it the first
time in order to start the iteration.  The iteration should be called repeatedly until this
function returns error or ERROR_NO_MORE_ITEMS.

The iteration can also be terminated prematurely by calling DirTerminateIteration.

Arguments:

    pTransport -
    ConnectionHandle -
    pIterateContextHandle - pointer to a PVOID
    SiteLinkName - user allocated; assumed to be MAX_REG_COMPONENT size

Return Value:

    DWORD - ERROR_NO_MORE_ITEMS indicates end of iteration, no data returned

--*/

{
    return
        iterateContainer( ConnectionHandle,
                          pTransport->Name,
                          L"(objectClass=siteLink)",
                          pIterateContextHandle,
                          SiteLinkName );

} /* DirIterateSiteLinks */


DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    )

/*++

Routine Description:

This function is called multiple times to return the name of each site link bridge object.

The context handle is always a pointer to a PVOID.  The PVOID should have null in it the first
time in order to start the iteration.  The iteration should be called repeatedly until this
function returns error or ERROR_NO_MORE_ITEMS.

The iteration can also be terminated prematurely by calling DirTerminateIteration.

Arguments:

    pTransport -
    ConnectionHandle -
    pIterateContextHandle -
    SiteLinkName - user allocated; assumed to be MAX_REG_COMPONENT size

Return Value:

    DWORD - ERROR_NO_MORE_ITEMS indicates end of iteration, no data returned

--*/

{
    return
        iterateContainer( ConnectionHandle,
                          pTransport->Name,
                          L"(objectClass=siteLinkBridge)",
                          pIterateContextHandle,
                          SiteLinkBridgeName );

} /* DirIterateSiteLinkBridges */


static DWORD
iterateContainer(
    PVOID ConnectionHandle,
    LPWSTR BaseDN,
    LPWSTR LdapFilter,
    PVOID *pIterateContextHandle,
    LPWSTR Name
    )

/*++

Routine Description:

Helper routine to iterate through the names of a set of child objects given a dn of
the parent.

The preferred LDAP mechanism to get the dn's of child objects is to do a
search with only invalid arguments, and retrieve the dn's of the returned
entries.  LDP also does this.  This should get around problems were we don't
have permission to read the child object's attributes, but still want to
enumerate the directory.

Arguments:

    ConnectionHandle - Handle to the directory service
    BaseDN - Parent of children to be returned
    LdapFilter - select class of objects to be returned, can use
    L"(objectClass = *)" for all.
    pIterateContextHandle - Context for the iteration. Pointer to DWORD.  DWORD is null
       to start
    Name - Storage for returned name.  Must be REG_MAX_COMPONENT

Return Value:

    DWORD -

--*/

{
#define ATT1 L"invalid"
    PWCHAR attributeList[] = { ATT1, NULL };
    DWORD status, ldapStatus, total;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    PITERATION_CONTEXT context;
    PWCHAR dn;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }
    if (pIterateContextHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (*pIterateContextHandle == NULL) {

        // *****************************
        // Set up for first time through
        // *****************************

        // Allocate a new context
        context = NEW_TYPE_ZERO( ITERATION_CONTEXT );
        if (context == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        context->hLdap = connection->LdapConnection;

        //
        // Initialize paged search
        //

        context->pSearch = ldap_search_init_page(
            connection->LdapConnection,
            BaseDN,                 // base dn
            LDAP_SCOPE_ONELEVEL,    // immediate children
            LdapFilter,             // filter is all objects
            &attributeList[0],      // list of attributes
            FALSE,                  // attrs only
            NULL,                   // ServerControls
            NULL,                   // ClientControls
            0,                      // PageTimeLimit
            0,                      // TotalSizeLimit
            NULL                   // SortKeys
            );
        if (context->pSearch == NULL) {
            ldapStatus = LdapGetLastError();
            status = LdapMapErrorToWin32( ldapStatus );
            DPRINT3( 0, "Ldap_search_init_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                     BaseDN, ldapStatus, status );
            LogEvent8WithData(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                szInsertWC( BaseDN ),
                szInsertWin32Msg( status ),
                NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(status),
		&status
                );
            logExtendedServerError( connection->LdapConnection );
            goto cleanup;
        }
        *pIterateContextHandle = (PVOID) context;
    } else {

        // On second and later iterations, ConnectionHandle, BaseDN, and
        // LdapFilter not guaranteed to be present.

        context = (PITERATION_CONTEXT) *pIterateContextHandle;
    }

    while (context->Message == NULL) {

        // *****************************
        // Set up for first entry on a new page
        // *****************************

        // Release any previous results
        if (context->Results) {
            ldap_msgfree( context->Results );
        }
        context->Results = NULL;

        // Read the next page
        ldapStatus = ldap_get_next_page_s(
            context->hLdap,
            context->pSearch,
            NULL,
            ISM_LDAP_PAGE_SIZE,
            &total,
            &(context->Results) );

        if (ldapStatus != LDAP_SUCCESS) {
            status = LdapMapErrorToWin32( ldapStatus );
            if ( (ldapStatus != LDAP_SERVER_DOWN) &&
                 (ldapStatus != LDAP_NO_RESULTS_RETURNED) ) {
                DPRINT3( 0, "Ldap_get_next_page_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                         BaseDN, ldapStatus, status );
                LogEvent8WithData(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                    szInsertWC( BaseDN ? BaseDN : L"(iteration)" ),
                    szInsertWin32Msg( status ),
                    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    sizeof(status),
		    &status
                    );
                logExtendedServerError( context->hLdap );
            }
            if (ldapStatus == LDAP_NO_RESULTS_RETURNED) {
                // Return a better translation than ldap does
                status = ERROR_NO_MORE_ITEMS;
            }
            goto cleanup;
        }
        if (context->Results == NULL) {
            continue;  // 0 entry pages are permissable
        }

        context->Message = ldap_first_entry( context->hLdap, context->Results );
        if (context->Message == NULL) {
            continue;  // 0 entry pages are permissable
        }
    }

    // *****************************
    // Return the next dn
    // *****************************

    Assert( context->Results );
    Assert( context->Message );

    dn = ldap_get_dn( context->hLdap, context->Message );
    if (dn == NULL) {
        // error, inconsistent results found
        DPRINT( 0, "missing dn in ldap message\n" );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // Name must be allocated by the caller to be MAX_REG_COMPONENT length
    wcsncpy( Name, dn, MAX_REG_COMPONENT );
    Name[MAX_REG_COMPONENT - 1] = L'\0';

    ldap_memfree( dn );

    // Advance context to next message
    context->Message = ldap_next_entry( context->hLdap, context->Message );

    return ERROR_SUCCESS;

cleanup:

    DirTerminateIteration( pIterateContextHandle );

    return status;
#undef ATT1
} /* iterateContainer */


void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    )

/*++

Routine Description:

Clean up the context of an DirIterate* call.

Arguments:

    pIterateContextHandle -

Return Value:

    None

--*/

{
    PITERATION_CONTEXT context =
        (PITERATION_CONTEXT) *pIterateContextHandle;

    Assert( context ); // don't call us twice
    if (context == NULL) {
        return;
    }

    // Release the search
    if (context->pSearch) {
        DWORD ldapStatus = ldap_search_abandon_page(
            context->hLdap,
            context->pSearch );
       if (ldapStatus != LDAP_SUCCESS) {
           DWORD status1 = LdapMapErrorToWin32( ldapStatus );
           DPRINT2( 0, "Ldap_search_abandon_page failed, ldap error = %d, win32 error = %d\n",
                    ldapStatus, status1 );
       }
    }

    // Release the results
    if (context->Results) {
        ldap_msgfree( context->Results );
    }
    context->Results = NULL;
    context->Message = NULL;
    context->hLdap = NULL;

    // Destory context
    FREE_TYPE( context );
    *pIterateContextHandle = NULL;
} /* DirTerminateIteration */


DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    )

/*++

Routine Description:

   Given the name of a site link, return its fields.

   The site list and the schedule are allocated by this routine.  The user must deallocate.

   The expectation that the site link object has already been found via
   enumeration of transport container.

Arguments:

    pTransport -
    ConnectionHandle -
    SiteLinkName -
    pSiteList - pointer to pointer to string. Receives multisz string.  Caller must free.  May be NULL
    pCost - pointer to DWORD. Filled with cost.
    pSchedule - pointer to schedule. Filled with schedule.  Caler must free.

Return Value:

    DWORD -

--*/

{
#define ATT_SL L"siteList"
#define ATT_COST L"cost"
#define ATT_COST_A "cost"
#define ATT_RI L"replInterval"
#define ATT_RI_A "replInterval"
#define ATT_OP L"options"
#define ATT_OP_A "options"
#define ATT_SCHED L"schedule"

// Note, schedule must be last in the list
#define ATT_SCHED_POS 4  // index from 0 of sched attribute
    PWCHAR attributeList[] =
    { ATT_SL, ATT_COST, ATT_RI, ATT_OP, ATT_SCHED, NULL };

    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PWCHAR *valueList;
    PCHAR *numberList;
    struct berval **ppThing;
    LPWSTR siteList = NULL;
    PBYTE pSchedule = NULL;
    DWORD cost = 0, replInterval = 0, options = 0;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Don't read schedule attribute if it wasn't requested.

    Assert(0 == _wcsicmp(ATT_SCHED, attributeList[ATT_SCHED_POS]));
    Assert(NULL == attributeList[ATT_SCHED_POS+1]);
    if (NULL == ppSchedule) {
        attributeList[ATT_SCHED_POS] = NULL;
    }

    // Get the attributes for this one site link object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               SiteLinkName,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        // error LDAP_NO_SUCH_OBJECT
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 SiteLinkName, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( SiteLinkName ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Read siteList attribute
    // CODE.IMPROVEMENT: It would be nice to return this native form, array of ptrs,
    // instead of converting to multisz.

    // Attribute may be empty if all references deleted
    valueList = ldap_get_values( connection->LdapConnection, message, ATT_SL );
    if (valueList != NULL) {
        status = stringArrayToMultiSz( valueList, &siteList );
        if (status != ERROR_SUCCESS) {
            ldap_value_free( valueList );
            goto cleanup;
        }
        ldap_value_free( valueList );
    }

    // Read optional cost attribute
    // Integers are represented as an array of ascii digits, not unicode

    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_COST_A);
    if (numberList != NULL) {
        cost = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read optional replInterval attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_RI_A);
    if (numberList != NULL) {
        replInterval = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read optional options attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_OP_A);
    if (numberList != NULL) {
        options = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read schedule attribute
    ppThing = ldap_get_values_len( connection->LdapConnection, message,
                                   ATT_SCHED );
    if ( (ppThing != NULL) && ( (*ppThing)->bv_len != 0 ) ) {
        // Validate schedule attribute.
        SCHEDULE *psched = (SCHEDULE *) (*ppThing)->bv_val;

        if (((*ppThing)->bv_len < offsetof(SCHEDULE, Size) + sizeof(psched->Size))
            || (psched->Size != sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES)
            || (psched->NumberOfSchedules != 1)
            || (psched->Schedules[0].Type != SCHEDULE_INTERVAL)
            || (psched->Schedules[0].Offset != sizeof(SCHEDULE))) {
            // The schedule blob is not a correctly formed SCHEDULE structure.
            DPRINT1(0, "The schedule attribute of siteLink object %ls is invalid.\n",
                    SiteLinkName);
            LogEvent(DS_EVENT_CAT_ISM,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_ISM_SITELINK_INVALID_SCHEDULE_FORMAT,
                     szInsertWC(SiteLinkName),
                     NULL, NULL);

            // Pretend as if we didn't find a schedule attribute....
        }
        else {
            // Is the schedule set to "never"?
            BYTE *  pEntries = (BYTE *) psched + psched->Schedules[0].Offset;
            DWORD   iEntry;
            BOOL    fIsNever = TRUE;

            for (iEntry = 0; iEntry < SCHEDULE_DATA_ENTRIES; iEntry++) {
                if (pEntries[iEntry] & 0xf) {
                    fIsNever = FALSE;
                    break;
                }
            }

            if (fIsNever) {
                // The schedule is "never".
                DPRINT1(0, "The schedule attribute of siteLink object %ls is \"never\".\n",
                        SiteLinkName);
                LogEvent(DS_EVENT_CAT_ISM,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_ISM_SITELINK_SCHEDULE_NEVER,
                         szInsertWC(SiteLinkName),
                         NULL, NULL);
                // Pretend as if we didn't find a schedule attribute....
            }
            else {
                // Schedule is acceptable -- use it.
                pSchedule = NEW_TYPE_ARRAY( (*ppThing)->bv_len, CHAR );
                if (pSchedule == NULL) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    ldap_value_free_len( ppThing );
                    goto cleanup;
                }
                CopyMemory( pSchedule, (*ppThing)->bv_val, (*ppThing)->bv_len );
            }
        }

        ldap_value_free_len( ppThing );
    }

    // Return data to user
    if (pSiteList != NULL) {
        *pSiteList = siteList;
        siteList = NULL;  // given to user
    }

    if (pLinkValue != NULL) {
        pLinkValue->ulCost = cost;
        pLinkValue->ulReplicationInterval = replInterval;
        pLinkValue->ulOptions = options;
    }

    if (ppSchedule) {
        *ppSchedule = pSchedule;
        pSchedule = NULL; // don't clean up
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteList) {
        FREE_TYPE( siteList );
    }

    if (pSchedule) {
        FREE_TYPE( pSchedule );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT_SL
#undef ATT_COST
#undef ATT_COST_A
#undef ATT_RI
#undef ATT_RI_A
#undef ATT_OP
#undef ATT_OP_A
#undef ATT_SCHED
} /* DirReadSiteLink */


DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    )

/*++

Routine Description:

   Return the fields of a site link bridge object

   The expectation that the bridge object has already been found via
   enumeration of transport container.

Arguments:

    pTransport -
    ConnectionHandle -
    SiteLinkBridgeName -
    pSiteLinkList - pointer to pointer to multisz string allocated by this routine,
        user must free

Return Value:

    DWORD -

--*/

{
#define ATT1 L"siteLinkList"
    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    PWCHAR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PWCHAR *valueList;
    LPWSTR siteLinkList = NULL;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Return the attributes for this one site link bridge object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               SiteLinkBridgeName,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        // TODO:LOG AN EVENT HERE. OBJECT WAS FOUND VIA ENUM BUT CAN'T BE READ!
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 SiteLinkBridgeName, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( SiteLinkBridgeName ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link bridge
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link bridge
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Read siteLinkList attribute

    // Attribute may not exist if all referents have been deleted
    valueList = ldap_get_values( connection->LdapConnection, message, ATT1 );
    if (valueList != NULL) {
        status = stringArrayToMultiSz( valueList, &siteLinkList );
        if (status != ERROR_SUCCESS) {
            ldap_value_free( valueList );
            goto cleanup;
        }
        ldap_value_free( valueList );
    }

    // Return data to user
    if (pSiteLinkList != NULL) {
        *pSiteLinkList = siteLinkList;
        siteLinkList = NULL;  // given to user
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteLinkList) {
        FREE_TYPE( siteLinkList );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT1
} /* DirReadSiteLinkBridge */


void
DirFreeMultiszString(
    LPWSTR MultiszString
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    if (MultiszString) {
        FREE_TYPE( MultiszString );
    }
}


void
DirFreeSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    if (pSchedule) {
        FREE_TYPE( pSchedule );
    }
}

DWORD
cacheServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    )
{
    DWORD   winError = ERROR_SUCCESS;
    DWORD   cch;

    Assert(NULL == pTransport->Smtp.pszSmtpAddress);

    // Cache SMTP address (e.g., mailbox@server-4.ntdev.microsoft.com).
    cch = 1 + wcslen(pszMailAddress);
    pTransport->Smtp.pszSmtpAddress = NEW_TYPE_ARRAY(cch, WCHAR);
    if (NULL == pTransport->Smtp.pszSmtpAddress) {
        winError = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        wcscpy(pTransport->Smtp.pszSmtpAddress, pszMailAddress);
    }

    if (ERROR_SUCCESS != winError) {
        // Failed; free any memory we allocated.
        if (NULL != pTransport->Smtp.pszSmtpAddress) {
            FREE_TYPE(pTransport->Smtp.pszSmtpAddress);
            pTransport->Smtp.pszSmtpAddress = NULL;
        }
    }

    return winError;
}


DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    )
{
#define ATT1 L"mailAddress"
    CONNECTION_INSTANCE * pConn
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD           winError;
    int             ldStatus;
    LPWSTR          rgpszServerAttrsToRead[] = {ATT1, NULL};
    LDAPMessage *   pResults = NULL;
    LDAPMessage *   pEntry;
    LPWSTR *        ppszMailAddress;

    ldStatus = ldap_search_s(pConn->LdapConnection,
                             pConn->szServerGuidDN,
                             LDAP_SCOPE_BASE,
                             L"(objectClass=*)",
                             rgpszServerAttrsToRead,
                             0,
                             &pResults);
    switch (ldStatus) {
      case LDAP_NO_SUCH_ATTRIBUTE:
        // Our server object has no mailAddress.
        DPRINT(0, "Our server object has no mailAddress attribute.\n");
        // This is not an error; detect by examining SmtpAddress field
        winError = ERROR_SUCCESS;
        break;

      case LDAP_SUCCESS:
        // Successfully read our server object's mailAddress; cache it.
        pEntry = ldap_first_entry(pConn->LdapConnection, pResults);
        Assert(NULL != pEntry);

        ppszMailAddress = ldap_get_values(pConn->LdapConnection, pEntry,
                                          ATT1);
        if (NULL == ppszMailAddress) {
            DPRINT(0, "Our server object has empty mailAddress attribute.\n");
            // This is not an error; detect by examining SmtpAddress field
            winError = ERROR_SUCCESS;
        }
        else {
            Assert(1 == ldap_count_values(ppszMailAddress));

            winError = cacheServerSmtpAttributes(pTransport, *ppszMailAddress);

            ldap_value_free(ppszMailAddress);
            DPRINT1(0, "Our SMTP address is \"%ls\".\n",
                    pTransport->Smtp.pszSmtpAddress);
        }
        break;

      default:
        // Some other error...
        DPRINT1(0, "Failed to ldap_search_s(), error %d.\n", ldStatus);
        winError = LdapMapErrorToWin32(ldStatus);
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pConn->szServerGuidDN ),
            szInsertWin32Msg( winError ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof( winError ),
	    &winError
            );
        logExtendedServerError( pConn->LdapConnection );
        break;
    }

    // bug 327001, ldap_search* functions can return failure and still allocate
    // the result buffer.
    if (pResults) {
        ldap_msgfree(pResults);
    }

    return winError;
#undef ATT1
}


DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    )

/*++

Routine Description:

Construct the mail address of the server

This routine constructs an address suitable for the SMTP service.
We should only call this when we know that SMTP service is running.
TODO: If Exchange is running, we should do something different.

The name looks like:

_IsmService@guid-based-dns-name

Arguments:

    pTransport -
    ppszMailAddress -

Return Value:

    DWORD -

--*/

{
#define NTDS_SETTINGS L"CN=NTDS Settings,"
#define ENTERPRISE_CONFIGURATION L"CN=Enterprise Configuration,CN=Partitions,"
#define ISM_SMTP_RECIPIENT L"_IsmService"
#define ATT1 L"serverName"
#define ATT2 L"objectGuid"
#define ATT3 L"dnsRoot"
#define ATT4 L"mailAddress"
    CONNECTION_INSTANCE * pConnection
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD status, ldapStatus, length;

    PWCHAR rootAttributeList[] = {ATT1, NULL};
    LDAPMessage *rootResults = NULL;
    LDAPMessage *rootMessage;

    PWCHAR serverAttributeList[] = {ATT2, NULL};
    LDAPMessage *serverResults = NULL;
    LDAPMessage *serverMessage;

    PWCHAR computerAttributeList[] = {ATT3, NULL};
    LDAPMessage *computerResults = NULL;
    LDAPMessage *computerMessage;

    PWCHAR *valueList = NULL;
    struct berval **ppbv = NULL;

    PWCHAR pszNTDSA = NULL;
    PWCHAR pszMailAddress = NULL;
    PWCHAR pszEnterprise = NULL;
    PWCHAR pszGUID = NULL;

    // Read the server name on the base dn
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               NULL,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &rootAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &rootResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( L"root dn" ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (rootResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    rootMessage = ldap_first_entry( pConnection->LdapConnection, rootResults );
    if (rootMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage, ATT1);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT1 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *valueList is the dn of the server oobject

    length = wcslen( NTDS_SETTINGS) + wcslen( *valueList ) + 1;
    pszNTDSA = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszNTDSA) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszNTDSA, NTDS_SETTINGS );
    wcscat( pszNTDSA, *valueList );

    // *********************************************************************

    // Read the object guid on the NTDS settings object
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               pszNTDSA,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &serverAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &serverResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pszNTDSA ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (serverResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    serverMessage = ldap_first_entry( pConnection->LdapConnection, serverResults );
    if (serverMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    ppbv = ldap_get_values_len(pConnection->LdapConnection, serverMessage,
                               ATT2 );
    if ( (ppbv == NULL) ||
         ( 1 != ldap_count_values_len(ppbv)) ||
         ( sizeof(GUID) != (*ppbv)->bv_len ) ) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT2 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *********************************************************************

    // Read the dnsRoot for the enterprise

    length = wcslen( ENTERPRISE_CONFIGURATION ) +
        wcslen( pConnection->ConfigNC ) + 1;
    pszEnterprise = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszEnterprise) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszEnterprise, ENTERPRISE_CONFIGURATION );
    wcscat( pszEnterprise, pConnection->ConfigNC );

    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               pszEnterprise,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &computerAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &computerResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pszEnterprise ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (computerResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    computerMessage = ldap_first_entry( pConnection->LdapConnection, computerResults );
    if (computerMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    ldap_value_free(valueList);  // get rid of last value
    valueList = ldap_get_values(pConnection->LdapConnection, computerMessage, ATT3);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT3 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *valueList is the dns root of the enterprise

    // *********************************************************************

    status = UuidToStringW( (PVOID) (*ppbv)->bv_val, &pszGUID );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "UuidToString failed, error %d\n", status );
        goto cleanup;
    }

    //
    // Form new mail address
    //
    length = wcslen( ISM_SMTP_RECIPIENT ) + 1 +
        wcslen( pszGUID ) + 8 +
        wcslen( *valueList ) + 1; // length in wchars inc term
    pszMailAddress = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszMailAddress) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszMailAddress, ISM_SMTP_RECIPIENT );
    wcscat( pszMailAddress, L"@" );
    wcscat( pszMailAddress, pszGUID );
    wcscat( pszMailAddress, L"._msdcs." );
    wcscat( pszMailAddress, *valueList);

    // *********************************************************************

    // Return mail address

    *ppszMailAddress = pszMailAddress;

    pszMailAddress = NULL; // don't clean up

    status = ERROR_SUCCESS;

cleanup:  // executed in all cases

    if (pszGUID) {
        RpcStringFreeW( &pszGUID );
    }
    if (pszEnterprise) {
        FREE_TYPE( pszEnterprise );
    }
    if (pszNTDSA) {
        FREE_TYPE( pszNTDSA );
    }
    if (pszMailAddress) {
        FREE_TYPE( pszMailAddress );
    }

    if (valueList != NULL) {
        ldap_value_free(valueList);
    }
    if (NULL != ppbv) {
        ldap_value_free_len(ppbv);
    }

    if (NULL != rootResults) {
        ldap_msgfree(rootResults);
    }
    if (NULL != serverResults) {
        ldap_msgfree(serverResults);
    }
    if (NULL != computerResults) {
        ldap_msgfree(computerResults);
    }

    return status;

} /* DirGetServerSmtpAttributes */


DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    )

/*++

Routine Description:

This routine auto configures the mail address attribute.

It is assumed the mail address is empty at this point.

Note, we should only put a mail address on a server object if we are sure
that the server can receive mail.  The KCC uses the presense of the mailAddress
of an indicator of which system it should choose as form a connection to.

Arguments:

    pTransport - Transport object
    pszMailAddress - Mail address to be written. A null means to remove it.

Return Value:

    DWORD -

--*/

{
    CONNECTION_INSTANCE * pConnection
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD status, ldapStatus;
    LDAPModW *ppModifyList[2];
    LDAPModW modMailAddress;
    PWCHAR ppszValueList[2];

    // Get rid of any old cached address
    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE(pTransport->Smtp.pszSmtpAddress);
        pTransport->Smtp.pszSmtpAddress = NULL;
    }

    //
    // Write it to server object
    //

    ppszValueList[0] = pszMailAddress;
    ppszValueList[1] = NULL;
    modMailAddress.mod_op = LDAP_MOD_REPLACE;
    modMailAddress.mod_type = ATT4;
    modMailAddress.mod_vals.modv_strvals = ppszValueList;
    ppModifyList[0] = &modMailAddress;
    ppModifyList[1] = NULL;

    ldapStatus = ldap_modify_s( pConnection->LdapConnection,
                                pConnection->szServerGuidDN,  // base dn
                                ppModifyList );
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_modify_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_MODIFY_FAILED,
            szInsertWC( pConnection->szServerGuidDN ),
            szInsertWin32Msg( status ),
            NULL
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (pszMailAddress) {
        DPRINT1(0, "Wrote new SMTP address \"%ls\".\n", pszMailAddress );

        // Cache the new server mail address
        cacheServerSmtpAttributes( pTransport, pszMailAddress );
    }

    status = ERROR_SUCCESS;

cleanup:  // executed in all cases

    return status;
} /* DirWriteServerSmtpAttributes */


static DWORD
stringArrayToMultiSz(
    PWSTR *pString,
    PWSTR *pFlat
    )

/*++

Routine Description:

Given a null-terminated array of string pointers, convert that into a multisz array.

Arguments:

    pString - pointer to null-terminated array of pointers
    pFlat - pointer to receive allocated buffer.  Buffer contains the multisz rep of the
            input string array, for example member1\0member2\0\member3\0\0

Return Value:

    DWORD -

--*/

{
    DWORD status, length;
    PWSTR flat = NULL, *pItem, element;

    // Count number of characters and terminators
    length = 0;
    pItem = pString;

    if (pItem == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    while (*pItem != NULL) {
        length += wcslen( *pItem ) + 1;
        pItem++;
    }
    length++; // length in whars plus all terminators

    // Allocate the multisz array
    flat = NEW_TYPE_ARRAY( length, WCHAR );
    if (flat == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        return status;
    }

    // Populate it
    pItem = pString;
    element = flat;
    while (*pItem != NULL) {
        length = wcslen( *pItem ) + 1;
        wcscpy( element, *pItem );
        element += length;
        pItem++;
    }
    *element = L'\0';

    *pFlat = flat;
    return ERROR_SUCCESS;
} /* stringArrayToMultiSz */


DWORD
static verifyExistence(
    PVOID ConnectionHandle,
    LPCWSTR ObjectDN
    )

/*++

Routine Description:

Verify that an object exists.
This routine does not try to read any attributes.
If the object does not exist, an error is displayed

This code uses the ldap enumeration technique where we search for invalid
arguments and see how many entries are returned.

Arguments:

    ConnectionHandle -
    ObjectDN -

Return Value:

    DWORD -

--*/

{
    PWCHAR attributeList[] = { L"invalid", NULL };
    DWORD status, length, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               (LPWSTR) ObjectDN,     // base dn
                               LDAP_SCOPE_BASE,     // just this one
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // If the object is not present, this is the path that will be taken
        // LDAP_NO_SUCH_OBJECT
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 ObjectDN, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( ((LPWSTR) ObjectDN) ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }
    if (results == NULL) {
        // error, inconsistent results found
        // error, ds object missing
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // There should be an entry for the base object, but no attributes
    message = ldap_first_entry( connection->LdapConnection, results);
    if (message  == NULL) {
        DPRINT1( 0, "expected object %ws is missing.\n", ObjectDN );
        // error, inconsistent results found
        // error, ds object missing
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    //
    // Bug 26647 comment:
    // For some names such as CNF names, the ldap returned dn string
    // format isn't necessarily identical to the core generated dn string.
    // That is:
    //  wcsicmp(ObjectDN, dn) != 0
    // Example (note the "" and \):
    // CN="ExampleSite<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d",CN=Sites,
    // CN=Configuration,...DC=com !=
    // CN=ExampleSite\<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d,CN=Sites,
    // CN=Configuration,...DC=com
    // Do represent the same object yet the strings are different.
    //
    status = ERROR_SUCCESS;

cleanup:

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;
} /* static verifyExistence */


DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Start a notification thread if one is not already running
    This routine is thread-safe. Multiple callers can try to create the
    thread and only one will succeed.
    Assumes pTransport->NotifyThreadHandle is initialized to zero at first.

Arguments:

    pTransport - transport instance

Return Value:

    DWORD - error if thread could not be started

--*/

{
    DWORD status;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    LONG threadId;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pTransport->fShutdownInProgress) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    // Under protection of the lock, atomically test and set the thread
    // handle to determine if a thread should be started or not.
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if (pTransport->NotifyThreadHandle) {
            // Thread already running
            status = ERROR_SUCCESS;
            __leave;
        }

        // Note, _beginthreadex returns 0 on error
        pTransport->NotifyThreadHandle = (HANDLE)
            _beginthreadex(
                NULL,
                0,
                notifyThread,
                pTransport, // argument
                0,
                &threadId
                );
        if (0 == pTransport->NotifyThreadHandle) {
            status = _doserrno;
            Assert(status);
            DPRINT1(0, "Failed to create listener thread, error %d.\n", status);
            __leave;
        }

        DPRINT2( 2, "Started notification thread 0x%x on %ws\n",
                 pTransport->NotifyThreadHandle,
                 pTransport->Name );

        status = ERROR_SUCCESS;
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    return status;
} /* DirStartNotifyThread */


BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

Test whether notification thread is still alive.

We have having problems with the thread exiting prematurely.  This check is down
periodically by the ISM apis.  If the thread has disappeared, this call will
log the fact.

Arguments:

    pTransport -

Return Value:

    BOOL - True, active or False, exited

--*/

{
    DWORD exitCode = 0;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;

    if ( (connection->Size != sizeof( CONNECTION_INSTANCE )) ||
         (connection->LdapConnection == 0) ) {
        return FALSE;
    }

    if (pTransport->NotifyThreadHandle) {

        // Is the thread still alive?
        if ( (GetExitCodeThread( pTransport->NotifyThreadHandle, &exitCode )) &&
             (exitCode == STILL_ACTIVE) ) {
            return TRUE;
        }

        // Thread is dead - reap it

        // Note, beginthreadex requires us to close the thread handle
        CloseHandle( pTransport->NotifyThreadHandle );

        pTransport->NotifyThreadHandle = 0;
    }

    // Start another thread
    DirStartNotifyThread( pTransport );

    // Indicate thread was not active at time of check
    return FALSE;
} /* DirIsNotifyThreadActive */


BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

Cause the notification thread to exit.

Ideally, the execution of this routine would be the only legitimate way
that the thread should exit.  The problem is that because we are in a dll
of a server, we sometimes don't get notificated of shutdown in a timely
manner.  In fact, LDAP may have shutdown its searches before we are called.
In that case, the thread may have exitted on its own legitimately before
we get a chance to do so.

Arguments:

    pTransport - transport state object

Return Value:

    BOOL - whether the thread exited, or not

--*/

{
    DWORD status, ldapStatus, waitStatus, exitCode;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    BOOL fExit = FALSE;

    if ( (connection->Size != sizeof( CONNECTION_INSTANCE )) ||
         (connection->LdapConnection == 0) ) {
        return FALSE;  // don't know
    }
    // Make sure not already called
    if (pTransport->NotifyThreadHandle == 0) {
        DPRINT(1, "DirEndNotifyThread already called!\n" );
        return TRUE;  // has exitted
    }

    // We don't enforce that the thread is still alive at this point. It may
    // have terminated on its own due to LDAP shutting down

    // Stop asynchronous search
    ldapStatus = ldap_abandon(
        connection->LdapConnection,
        pTransport->NotifyMessageNumber
        );
    if (ldapStatus != LDAP_SUCCESS) {
        // May occur if LDAP is shutting down
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "ldap_abandon failed, ldap error = %d, status = %d\n",
                 ldapStatus, status );
        // Keep going to see if the thread exited or not
    }

    waitStatus = WaitForSingleObject(pTransport->NotifyThreadHandle,5*1000);
    if (waitStatus == WAIT_TIMEOUT) {
        DPRINT1( 0, "Notify thread 0x%x did not exit promptly, timeout.\n",
                 pTransport->NotifyThreadHandle );
        goto cleanup;
    } else if (waitStatus != WAIT_OBJECT_0 ) {
        status = GetLastError();
        DPRINT2(0, "Failure waiting for notify thread to exit, wait status=%d, error=%d\n",
                waitStatus, status);
        goto cleanup;
    }

    exitCode = 0;
    if (GetExitCodeThread( pTransport->NotifyThreadHandle, &exitCode )) {
        if (exitCode != ERROR_SUCCESS) {
            DPRINT1( 1, "Notify thread exited with non success code %d\n",
                     exitCode );
        }
    }

    fExit = (exitCode != STILL_ACTIVE);
    // pass status through
cleanup:
    if (!fExit) {
        DPRINT( 0, "Notify thread did not exit\n" );
    }
    if (pTransport->NotifyThreadHandle) {
        // Note, beginthreadex requires us to close the thread handle
        CloseHandle( pTransport->NotifyThreadHandle );
    }

    pTransport->NotifyThreadHandle = 0;

    return fExit;
} /* DirEndNotifyThread */


unsigned __stdcall
notifyThread(
    PVOID Argument
    )

/*++

Routine Description:

    Notification thread routine

Arguments:

    Argument - Transport object
    Note that the controller of this thread guarantees not to destroy the
    transport object until this thread has exitted cleanly

Return Value:

    unsigned __stdcall -

--*/

{
    DWORD status, ldapResultType, ldapStatus;
    PTRANSPORT_INSTANCE pTransport = (PTRANSPORT_INSTANCE) Argument;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    LDAPMessage *results = NULL;
    BOOL fDone;
    LPWSTR attributeList[] = {
        L"objectGuid", L"objectClass", L"isDeleted",
        NULL};
    LDAPControl ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *serverControls[] = {&ctrlNotify, NULL};
    DWORD i;

    DPRINT1( 1, "Started monitoring %ws\n", pTransport->Name );

    InterlockedIncrement( &(pTransport->ReferenceCount) );  // 1 for this thread

    __try {
        while (1) {
            // Check for official shutdown first
            if (pTransport->fShutdownInProgress) {
                status = ERROR_SUCCESS;
                break; // exit shutdown loop
            }

            // Start a new search
            ldapStatus = ldap_search_ext(
                connection->LdapConnection,     // ldap connection
                pTransport->Name,               // base dn
                LDAP_SCOPE_ONELEVEL,            // scope
                L"(objectClass=*)",             // filter
                attributeList,                  // attrs[]
                0,                              // attrsonly
                serverControls,                 // server controls
                NULL,                           // client controls
                0,                              // time limit
                0,                              // size limit
                &(pTransport->NotifyMessageNumber) // message number
                );

#ifdef FAULT_INSERTION
            if (rand() % 2 == 0) {
                DPRINT( 0, "Inserting ldap_search_ext error\n" );
                ldapStatus = LDAP_PROTOCOL_ERROR;
            }
#endif

            if (ldapStatus != LDAP_SUCCESS) {
                status = LdapMapErrorToWin32( ldapStatus );
                DPRINT2( 0, "ldap_search_ext failed, ldap error = %d, status = %d\n",
                         ldapStatus, status );
                logExtendedServerError( connection->LdapConnection );
                // This is a hard error with no recovery - exit shutdown loop
                break;
            }

            DPRINT2( 1, "Starting new notify search %d on %ws\n",
                     pTransport->NotifyMessageNumber,  pTransport->Name );

            // Loop reading results until error
            fDone = FALSE;
            while (!fDone) {
                ldapResultType = ldap_result(
                    connection->LdapConnection,      // ldap connection
                    pTransport->NotifyMessageNumber, // message id
                    LDAP_MSG_ONE,                    // all
                    NULL,                            // timeout
                    &results                         // results
                    );

                // Check for official shutdown first
                if (pTransport->fShutdownInProgress) {
                    status = ERROR_SUCCESS;
                    fDone = TRUE;
                    goto loop_cleanup;
                }

#ifdef FAULT_INSERTION
                if (rand() % 5 == 0) {
                    DPRINT( 0, "Inserting ldap_result error\n" );
                    ldapResultType = 0xffffffff;
                    connection->LdapConnection->ld_errno = LDAP_PROTOCOL_ERROR;
                }
#endif

                if (ldapResultType == 0xffffffff) {
                    ldapStatus = connection->LdapConnection->ld_errno;
                    status = LdapMapErrorToWin32( ldapStatus );
                    DPRINT2( 0, "ldap_result failed, ldap error = %d, status = %d\n",
                             ldapStatus, status );
                    fDone = TRUE;
                } else if (ldapResultType == LDAP_RES_SEARCH_ENTRY) {

                    // This is the normal, successful result
                    RouteInvalidateConnectivity( pTransport );

                } else if (ldapResultType == LDAP_RES_SEARCH_RESULT) {

                    // This means the server terminated the search

                    ldapStatus = ldap_result2error(
                        connection->LdapConnection,      // ldap connection
                        results,
                        FALSE );
                    status = LdapMapErrorToWin32( ldapStatus );
                    DPRINT1( 0, "IsmNotifyThread:Ldap result error is 0x%x\n",ldapStatus );
                    fDone = TRUE;
                } else {
                    // Something unexpected
                    DPRINT2( 0, "IsmNotifyThread: Unexpected ldap result type 0x%x for %ws\n",
                             ldapResultType, pTransport->Name );
                    LogUnhandledError( ldapResultType );
                    status = ERROR_INVALID_FUNCTION;
                    fDone = TRUE;
                }

            loop_cleanup:

                if (results) {
                    ldap_msgfree( results );
                    results = NULL;
                }

            } // while (!fDone) result loop

            // Its ambiguous whether this is a real error or a shutdown induced error.
            // See if we were asked to shutdown

            if (!pTransport->fShutdownInProgress) {
                // Give us some time to see if we're shutting down
                DWORD waitStatus;
                waitStatus = WaitForSingleObject( pTransport->hShutdownEvent,
                                                  60 * 1000 );
                if ( (waitStatus != WAIT_OBJECT_0) &&
                     (waitStatus != WAIT_TIMEOUT) ) {
                    DPRINT2( 0, "WaitForSingleObject failed with return %d, win32 = %d\n",
                             waitStatus, GetLastError() );
                }
            }

            // If shutting down, we're done
            if (pTransport->fShutdownInProgress) {
                status = ERROR_SUCCESS;
                break;
            }

            // LDAP terminated our search prematurely, do error recovery
            // This can occur under some legitimate circumstances, such as when
            // Kerberos tickets expire.
            DPRINT2( 0, "ldap_result failed!, ldapStatus = 0x%x, win32 = %d\n",
                     ldapStatus, status );
            DPRINT2( 0, "h_ldap = 0x%p, message number = %d\n",
                     connection->LdapConnection,
                     pTransport->NotifyMessageNumber );
            // Assert( !"LDAP terminated search prematurely" );

        // Record that there was a problem with the last search
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_BASIC,
                              DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT,
                              szInsertWC(pTransport->Name),
                              szInsertWin32Msg(status),
                              NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(status),
                              &status);
            // Do this before we alter the connection state
            logExtendedServerError( connection->LdapConnection );

            // Stop asynchronous search - make sure we're cleaned up
            (void) ldap_abandon(
                connection->LdapConnection,
                pTransport->NotifyMessageNumber
                );
            // ignore error - keep going
            pTransport->NotifyMessageNumber = 0;

            // Invalidate the cache on error to force re-read of data
            // in case we miss any notifications
            RouteInvalidateConnectivity( pTransport );

        } // while (1) search loop

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        DPRINT1(0, "Caught exception 0x%x in notifyThread!\n", status );
    }

    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "Notify thread terminating due to error %d\n", status );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_LINK_MONITOR_FAILURE_RESTART,
                          szInsertWC(pTransport->Name),
                          szInsertWin32Msg(status),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(status),
                          &status);
    } else {
        DPRINT1( 3, "monitor thread %ws exit\n", pTransport->Name );
    }

    InterlockedDecrement( &(pTransport->ReferenceCount) );  // 1 for this thread

    // Note that if this thread exists prematurely, we don't touch the
    // ThreadHandle. It is still open.  When we reap the thread later we will
    // close the handle at that time.

    // _endthreadex() is called automatically

    return status;
} /* notifyThread */
/* end ldapobj.c */
