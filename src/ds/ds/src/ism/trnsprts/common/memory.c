/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Debug memory allocator.
    Checks for heap corruption.
    Reports memory not deallocated

    User interface:
    ptr = NEW_TYPE( type )
    ptr = NEW_TYPE_ARRAY( count, type )
    ptr = NEW_TYPE_ZERO( type )
    ptr = NEW_TYPE_ARRAY_ZERO( count, type )
    TYPE_FREE( ptr )

Author:

    Will Lees (wlees) 22-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include "common.h"

#define DEBSUB "IPMEM:"

#define HEADER_SIGNATURE  0x01234567
#define TRAILER_SIGNATURE 0xabcdef01
#define DEAD_SIGNATURE    0xdeadbeef

// Force quadword alignment

#define ALIGNMENT 8
#define ALIGN( x ) (((x) + (ALIGNMENT-1)) & ~(ALIGNMENT-1))

typedef struct _HEADER {
    LIST_ENTRY Link;
    PCHAR File;
    DWORD Line;
    DWORD Signature;
    DWORD UserSize;
    DWORD TrailerOffset;
    LARGE_INTEGER UserData[1];
    // CODE.IMP: in use linkage
} HEADER, *PHEADER;

typedef struct _TRAILER {
    DWORD Signature;
} TRAILER, *PTRAILER;

/* External */

/* Static */

CRITICAL_SECTION gcsIsmMemoryLock;
LIST_ENTRY gleIsmMemoryListHead;

// Last entry we saw before we crashed
PLIST_ENTRY gpleIsmLastGoodEntry = NULL;

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Jul 20 17:08:24 1998 */

void
DebugMemoryInitialize(
    void
    );

void
DebugMemoryTerminate(
    void
    );

PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

PVOID
DebugMemoryRellocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );

void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );

void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    );

/* End Forward */


void
DebugMemoryInitialize(
    void
    )

/*++

Routine Description:

Initialize the package.  Call once at startup.

Arguments:

    void - 

Return Value:

    None

--*/

{
    InitializeCriticalSection( &gcsIsmMemoryLock );
    InitializeListHead( &gleIsmMemoryListHead );
} /* DebugMemoryInitialize */


void
DebugMemoryTerminate(
    void
    )

/*++

Routine Description:

Rundown the package.  Call once at shutdown.  Reports memory not deallocated.

Arguments:

    void - 

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PHEADER pHeader;

    while (!IsListEmpty(&gleIsmMemoryListHead)) {
        entry = RemoveHeadList( &gleIsmMemoryListHead );
        pHeader = CONTAINING_RECORD( entry, HEADER, Link );
        DPRINT2( 0, "Unfreed memory: %s:%d\n", pHeader->File, pHeader->Line );
    }
    DeleteCriticalSection( &gcsIsmMemoryLock );
} /* DebugMemoryTerminate */


PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Internal routine to allocate a block of memory.

Arguments:

    Size - amount in bytes
    File - file where allocation occurred, expected not to be deleted
    Line - line where allocation occurred

Return Value:

    PVOID - pointer to user portion

--*/

{
    DWORD userOffset, trailerOffset, amount;
    PHEADER pHeader;
    PTRAILER pTrailer;

//    DPRINT3( 1, "DebugMemoryAllocate, Size=%d,File=%s,Line=%d\n", Size, File, Line );

    userOffset = FIELD_OFFSET( HEADER, UserData );
    trailerOffset = ALIGN( userOffset + Size );
    amount = trailerOffset + sizeof( TRAILER );
    pHeader = (PHEADER) malloc( amount );
    if (pHeader == NULL) {
        DPRINT3( 0, "Memory allocation of %d failed at %s:%d\n", amount, File, Line );
        // CODE.IMP: Additional logging?
        return NULL;
    }
    pHeader->File = File;
    pHeader->Line = Line;
    pHeader->UserSize = Size;
    pHeader->TrailerOffset = trailerOffset;
    pHeader->Signature = HEADER_SIGNATURE;

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + trailerOffset);
    pTrailer->Signature = TRAILER_SIGNATURE;

    // Don't put on the list until fully formed
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        // Most recent to the front
        InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    return (PVOID) pHeader->UserData;
} /* DebugMemoryAllocate */


PVOID
DebugMemoryReallocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Internal routine to reallocate a block of memory.

Arguments:

    MemoryBlock - pointer to old block
    Size - amount in bytes
    File - file where allocation occurred, expected not to be deleted
    Line - line where allocation occurred

Return Value:

    PVOID - pointer to user portion

--*/

{
    DWORD userOffset, trailerOffset, amount;
    PHEADER pHeader, pNewHeader;
    PTRAILER pTrailer;

    DebugMemoryCheck( MemoryBlock, File, Line );

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );

    // Remove from list before modification
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        RemoveEntryList( &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    // Treat like a new allocation

    userOffset = FIELD_OFFSET( HEADER, UserData );
    trailerOffset = ALIGN( userOffset + Size );
    amount = trailerOffset + sizeof( TRAILER );
    pNewHeader = (PHEADER) realloc( pHeader, amount );
    if (pNewHeader == NULL) {
        DPRINT4( 0, "Memory reallocation of %p,%d failed at %s:%d\n",
                 MemoryBlock, amount, File, Line );
        // CODE.IMP: Additional logging?

        // Need to reinsert block back on the list
        EnterCriticalSection( &gcsIsmMemoryLock );
        __try {
            // Most recent to the front
            InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
        } __finally {
            LeaveCriticalSection( &gcsIsmMemoryLock );
        }

        return NULL;
    }
    pHeader = pNewHeader;

    // Reinitialize header and trailer
    pHeader->File = File;
    pHeader->Line = Line;
    pHeader->UserSize = Size;
    pHeader->TrailerOffset = trailerOffset;
    pHeader->Signature = HEADER_SIGNATURE;

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + trailerOffset);
    pTrailer->Signature = TRAILER_SIGNATURE;

    // Don't put on the list until fully formed
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        // Most recent to the front
        InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    return (PVOID) pHeader->UserData;
} /* DebugMemoryReallocate */


PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Allocate a block of memory, zero user portion

Arguments:

    Size - 
    File - 
    Line - 

Return Value:

    PVOID - 

--*/

{
    PVOID memory;
    memory = DebugMemoryAllocate( Size, File, Line );
    if (memory) {
        ZeroMemory( memory, Size );
    }
    return memory;
} /* DebugMemoryAllocateZero */


BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Check if block of memory is ok

Arguments:

    MemoryBlock - pointer to user portion

Return Value:

    True if block is ok, else false

--*/

{
    PHEADER pHeader;
    PTRAILER pTrailer;

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );
    if (pHeader->Signature != HEADER_SIGNATURE) {
        if (pHeader->Signature == DEAD_SIGNATURE) {
            DPRINT5( 0, "Check on %s:%d\nMemory block %p header is already deleted, from %s:%d\n",
                     File, Line,
                     MemoryBlock, pHeader->File, pHeader->Line );
        } else {
            DPRINT3( 0, "Check on %s:%d\nMemory block %p header has invalid signature\n",
                     File, Line, MemoryBlock );
        }
        Assert( FALSE );
        return FALSE;
    }

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + pHeader->TrailerOffset);
    if (pTrailer->Signature != TRAILER_SIGNATURE) {
        if (pTrailer->Signature == DEAD_SIGNATURE) {
           DPRINT5( 0, "Check on %s:%d\nMemory block %p trailer is already deleted, from %s:%d\n",
                    File, Line,
                    MemoryBlock, pHeader->File, pHeader->Line );
        } else {
            DPRINT5( 0, "Check on %s:%d\nMemory block %p trailer has invalid signature, from %s:%d\n",
                     File, Line, MemoryBlock, pHeader->File, pHeader->Line );
        }
        Assert( FALSE );
        return FALSE;
    }
    return TRUE;
} /* DebugMemoryCheck */


void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Free a block of memory

Arguments:

    MemoryBlock - pointer to user portion

Return Value:

    None

--*/

{
    PHEADER pHeader;
    PTRAILER pTrailer;

    DebugMemoryCheck( MemoryBlock, File, Line );

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );

    // Remove from list before modification
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        RemoveEntryList( &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    pHeader->Signature = DEAD_SIGNATURE;
    ZeroMemory( &(pHeader->Link), sizeof( LIST_ENTRY ) );

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + pHeader->TrailerOffset);
    pTrailer->Signature = DEAD_SIGNATURE;

    // Note that we preserve the remaining header contents so that if this
    // block turns up again, we may know where it came from

    memset( MemoryBlock, 'w', pHeader->UserSize );

    free( (PVOID) pHeader );
} /* DebugMemoryFree */


void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PHEADER pHeader;

/*
  Do the whole list traversal and analysis under the lock. Yuck. This guarantees a
  coherent view. If contention gets to be a problem, we need to do two things:
1. Protect access to the Flink using the critical section to prevent linked
   list simultaneous access.
2. Guarantee the lifetime of the block while we are using it.  A ref count or an
   in use flag will be needed for that.
*/

    gpleIsmLastGoodEntry = &gleIsmMemoryListHead;

    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {

        entry = gleIsmMemoryListHead.Flink;
        while ( entry != &gleIsmMemoryListHead ) {
            Assert( entry && "linked list entry should have been non-zero but was not\ndd gpleIsmLastEntry l1 for pointer to last good list entry" );

            pHeader = CONTAINING_RECORD( entry, HEADER, Link );
            DebugMemoryCheck( pHeader->UserData, File, Line );

            gpleIsmLastGoodEntry = entry;
            entry = entry->Flink;
        }

    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

}
/* end memory.c */


