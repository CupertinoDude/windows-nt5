/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    simism.c

Abstract:

    Simulate the ISM connectivity APIs    

    This module is a wrapper around the ISM plug in common library.  It exposes
    the ISM APIs in a callable library.  Normally, you have to go through the
    ISM SERVICE to access this code.

Author:

    Will Lees (wlees) 22-Jul-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#define UNICODE 1

#include <ntdspch.h>
#include <ntdsa.h>
#include <ismapi.h>

#include "common.h"         // common transport library
#include <debug.h>
#define DEBSUB "SIMISM:"
#define  FILENO FILENO_ISMSERV_ROUTE

// Memory block tags
// We have a problem with the memory allocation/deallocation model.
// Becuase this interface is normally remoted via RPCs, the expectation
// of the free routine is that all the memory returned is contigious.
// Use a Tag to determine what kind of block is being freed.

#define SIMISM_CONNECTIVITY 1
#define SIMISM_SERVER_LIST 2
#define SIMISM_SCHEDULE 3

typedef struct _TAGGED_BLOCK {
    DWORD BlockType;
    union {
        ISM_CONNECTIVITY Connectivity;
        ISM_SERVER_LIST ServerList;
        ISM_SCHEDULE Schedule;
    };
} TAGGED_BLOCK, *PTAGGED_BLOCK;

/* External */

/* Static */

// List head of transport instances
LIST_ENTRY TransportListHead;

/* Forward */ /* Generated by Emacs 19.34.1 on Fri Jul 23 10:13:39 1999 */

void
I_ISMInitialize(
    void
    );

void
I_ISMTerminate(
    void
    );

PTRANSPORT_INSTANCE
createTransport(
    IN  LPCWSTR                 pszTransportDN
    );

PTRANSPORT_INSTANCE
lookupTransport(
    IN  LPCWSTR                 pszTransportDN
    );

void
deleteTransport(
    PTRANSPORT_INSTANCE instance
    );

void
deleteTransportList(
    void
    );

void
I_ISMFree(
    IN  VOID *  pv
    );

DWORD
I_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    );

DWORD
I_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   );

DWORD
I_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    );

/* End Forward */


void
SimI_ISMInitialize(
    void
    )

/*++

Routine Description:

This function is to be called before the other functions.

This function is not part of the actual ISM API.

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG
    DebugMemoryInitialize();
#endif
    InitializeListHead( &TransportListHead );
}


void
SimI_ISMTerminate(
    void
    )

/*++

Routine Description:

This function is to be called at the end.

This function is not part of the actual ISM API.

Arguments:

    None

Return Value:

    None

--*/

{
    deleteTransportList();
#if DBG
    DebugMemoryTerminate();
#endif
    if (!IsListEmpty( &TransportListHead )) {
        DPRINT( 0, "Warning: Not all transport instances were shutdown\n" );
    }

}


PTRANSPORT_INSTANCE
createTransport(
    IN  LPCWSTR                 pszTransportDN
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD length, status;
    PTRANSPORT_INSTANCE instance = NULL;

    length = wcslen( pszTransportDN );
    if (length == 0) {
        return NULL;
    }

    // Allocate a new transport instance
    // Zero memory to simply cleanup
    instance = NEW_TYPE_ZERO( TRANSPORT_INSTANCE );
    if (instance == NULL) {
        // error: insufficient resources
        return NULL;
    }
    instance->Size = sizeof( TRANSPORT_INSTANCE );

    instance->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (instance->Name == NULL) {
        return NULL;
    }
    wcscpy( instance->Name, pszTransportDN );

    InitializeCriticalSection( &(instance->Lock) );

    // ReplInterval is 0, meaning the application should take default
    instance->ReplInterval = 0;

    if (wcsstr( pszTransportDN, L"CN=SMTP" ) == pszTransportDN) {
        // SMTP transport
        // Default is schedules not significant, bridges not required (transitive)
        instance->Options = NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;
    } else {
        // non-SMTP transport
        // Default is schedules significant, bridges not required (transitive)
        instance->Options = 0;
    }

    // Make sure key exists
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Add to transport list
    InsertTailList( &TransportListHead, &(instance->ListEntry) );

    return instance;
cleanup:
    if (instance) {
        deleteTransport( instance );
    }
    return NULL;
}


PTRANSPORT_INSTANCE
lookupTransport(
    IN  LPCWSTR                 pszTransportDN
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PTRANSPORT_INSTANCE pTransport, pFound = NULL;

    for( entry = TransportListHead.Flink;
         entry != &(TransportListHead);
         entry = entry->Flink ) {
        pTransport = CONTAINING_RECORD( entry, TRANSPORT_INSTANCE, ListEntry );
        if (_wcsicmp( pszTransportDN, pTransport->Name ) == 0) {
            pFound = pTransport;
            break;
        }
    }

    return pFound;
}


void
deleteTransport(
    PTRANSPORT_INSTANCE instance
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    Assert( instance );

    // Release any routing state
    RouteFreeState( instance );

    DeleteCriticalSection( &(instance->Lock) );

    if (instance->Name != NULL) {
        FREE_TYPE( instance->Name );
    }
    instance->Size = 0; // clear signature to prevent reuse

    FREE_TYPE( instance );
}


void
deleteTransportList(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LIST_ENTRY *entry;
    PTRANSPORT_INSTANCE pTransport;

    while (!IsListEmpty(&TransportListHead)) {

        entry = RemoveHeadList( &TransportListHead );
        pTransport = CONTAINING_RECORD( entry, TRANSPORT_INSTANCE, ListEntry );

        deleteTransport( pTransport );

    }
}

void
SimI_ISMFree(
    IN  VOID *  pv
    )
/*++

Routine Description:

    Frees memory allocated on the behalf of the client by I_ISM* APIs.

Arguments:

    pv (IN) - Memory to free.

Return Values:

    None.

--*/
{
    PTAGGED_BLOCK pBlock;
    if (pv == NULL) {
        return;
    }

    pBlock = CONTAINING_RECORD( pv, TAGGED_BLOCK, Connectivity );
    switch (pBlock->BlockType) {
    case SIMISM_CONNECTIVITY:
    {
        TRANSPORT_INSTANCE dummyInstance;

        ISM_CONNECTIVITY *pConnectivity = &(pBlock->Connectivity);

        if (pConnectivity->cNumSites > 0) {
            DirFreeSiteList( pConnectivity->cNumSites, pConnectivity->ppSiteDNs );

            RouteFreeLinkArray( &dummyInstance, pConnectivity->pLinkValues );
        }
        break;
    }
    case SIMISM_SERVER_LIST:
    {
        ISM_SERVER_LIST *pServerList = &(pBlock->ServerList);
        DWORD i;

        DirFreeSiteList( pServerList->cNumServers, pServerList->ppServerDNs );

        break;
    }
    case SIMISM_SCHEDULE:
    {
        ISM_SCHEDULE *pSchedule = &(pBlock->Schedule);
        Assert( pSchedule->cbSchedule != 0 );
        Assert( pSchedule->pbSchedule );

        FREE_TYPE( pSchedule->pbSchedule );

        pSchedule->pbSchedule = NULL;
        pSchedule->cbSchedule = 0;

        break;
    }
    default:
        Assert( FALSE );
    }

    FREE_TYPE( pBlock );
}


DWORD
SimI_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites via a
    specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppConnectivity);

Arguments:

    pszTransportDN (IN) - The transport for which to query costs.

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along the given transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE instance = NULL;
    DWORD status;
    DWORD numberSites, i;
    PWSTR *pSiteList;
    PISM_LINK pLinkArray;
    PISM_CONNECTIVITY pConnectivity;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppConnectivity) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppConnectivity = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    // Simulate the call

    // Get the site list and connectivity matrix

    status = RouteGetConnectivity( instance, &numberSites, &pSiteList,
                                   &pLinkArray, instance->Options,
                                   instance->ReplInterval );

    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "failed to get connectivity, error %d\n", status );
        goto cleanup;
    }

    // Return null structure to indicate no sites
    if (numberSites == 0) {
        ppConnectivity = NULL; // No connectivity
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    Assert( pLinkArray );
    Assert( pSiteList );

    // Build a connectivity structure to return

//    pConnectivity = NEW_TYPE( ISM_CONNECTIVITY );
    pBlock = NEW_TYPE( TAGGED_BLOCK );
    if (pBlock == NULL) {
        DPRINT( 0, "failed to allocate memory for ISM CONNECTIVITY\n" );

        // Cleanup the pieces
        DirFreeSiteList( numberSites, pSiteList );
        RouteFreeLinkArray( instance, pLinkArray );

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pBlock->BlockType = SIMISM_CONNECTIVITY;
    pConnectivity = &(pBlock->Connectivity);

    pConnectivity->cNumSites = numberSites;
    pConnectivity->ppSiteDNs = pSiteList;
    pConnectivity->pLinkValues = pLinkArray;
    *ppConnectivity = pConnectivity;

// ************************************************************

    status = ERROR_SUCCESS;
cleanup:

    return status;
}

DWORD
SimI_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via a specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppServerList);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE instance = NULL;
    PISM_SERVER_LIST pIsmServerList;
    DWORD numberServers, status, i;
    PWSTR *serverList;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppServerList) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppServerList = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    // Get the server list

    status = DirGetSiteBridgeheadList( instance, instance->DirectoryConnection,
                                       pszSiteDN, &numberServers, &serverList );
    if (status != ERROR_SUCCESS) {

        if (status == ERROR_FILE_NOT_FOUND) {
            *ppServerList = NULL; // All servers
            status = ERROR_SUCCESS;
            goto cleanup;
        }

        DPRINT1( 0, "failed to get registry server list, error = %d\n", status );
        return status;
    }

    // Return null structure to indicate no servers
    if (numberServers == 0) {
        *ppServerList = NULL; // All servers
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Construct the server structure

    // pIsmServerList = NEW_TYPE( ISM_SERVER_LIST );
    pBlock = NEW_TYPE( TAGGED_BLOCK );
    if (pBlock == NULL) {
        DPRINT( 0, "failed to allocate memory for ISM SERVER LIST\n" );

        // Clean up the pieces
        for( i = 0; i < numberServers; i++ ) {
            FREE_TYPE( serverList[i] );
        }
        FREE_TYPE( serverList );

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    pBlock->BlockType = SIMISM_SERVER_LIST;
    pIsmServerList = &(pBlock->ServerList);

    pIsmServerList->cNumServers = numberServers;
    pIsmServerList->ppServerDNs = serverList;

    *ppServerList = pIsmServerList;

// ************************************************************

    status = ERROR_SUCCESS;
cleanup:

    return status;
}


DWORD
SimI_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    )
/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via a specific
    transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN1, pszSiteDN2 (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, length;
    PTRANSPORT_INSTANCE instance = NULL;
    PBYTE pSchedule;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppSchedule) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppSchedule = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    status = RouteGetPathSchedule( instance,
                                   pszSiteDN1,
                                   pszSiteDN2,
                                   &pSchedule,
                                   &length );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (pSchedule == NULL) {
        *ppSchedule = NULL; // always connected
    } else {
//        *ppSchedule = NEW_TYPE( ISM_SCHEDULE );
        pBlock = NEW_TYPE( TAGGED_BLOCK );
        if (pBlock == NULL) {
            FREE_TYPE( pSchedule );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        pBlock->BlockType = SIMISM_SCHEDULE;
        *ppSchedule = &(pBlock->Schedule);
        (*ppSchedule)->cbSchedule = length;
        (*ppSchedule)->pbSchedule = pSchedule;
    }

// ************************************************************

    status = ERROR_SUCCESS;

cleanup:

    return status;
}

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    // Caching is always supported in the simulator
    return TRUE;
}

/* end simism.c */
