/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    graph.c

Abstract:

    Graph routines.

    The current implementation uses a matrix to represent the edge costs.  This is because the
    all pairs shortest cost algorithm uses an array as input, and also because the ISM ultimately
    wants an connectivity information as a matrix.

    It also uses a sparse array for the schedules.  This is with the expectation that scheduled
    Site-Links will be unusual.  We could also have used an array of pointers to schedules.

Author:

    Will Lees (wlees) 22-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>
#include <schedule.h>

#include "common.h"

#define DEBSUB "IPGRAPH:"

// An element in the sparse array
typedef struct _SPARSE_ELEMENT {
    DWORD To;
    PBYTE pSchedule;
    struct _SPARSE_ELEMENT *Next;
} SPARSE_ELEMENT, *PSPARSE_ELEMENT;

// An instance of type graph.  Returned by GraphCreate.  The head of the data structure
typedef struct _GRAPH_INSTANCE {
    DWORD Size;
    DWORD NumberElements;
    PISM_LINK LinkArray;
    PSPARSE_ELEMENT *SparseArray;
} GRAPH, *PGRAPH;

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Oct 27 10:58:50 1998 */

void
GraphAllCosts(
    PGRAPH Graph,
    BOOL fIgnoreSchedules
    );

void
GraphMerge(
    PGRAPH FinalGraph,
    PGRAPH TempGraph
    );

PGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    );

DWORD
GraphAddEdgeIfBetter(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    );

DWORD
GraphInit(
    PGRAPH Graph
    );

void
GraphFree(
    PGRAPH Graph
    );

void
GraphReferenceMatrix(
    PGRAPH Graph,
    PISM_LINK *ppLinkArray
    );

VOID
GraphDereferenceMatrix(
    PGRAPH Graph,
    PISM_LINK pLinkArray
    );

DWORD
GraphGetPathSchedule(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *ppSchedule,
    DWORD *pLength
    );

void
GraphComputeTransitiveClosure(
    IN OUT  GRAPH *     pGraph
    );

static PBYTE
sparseScheduleFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    );

static void
sparseArrayFree(
    PGRAPH Graph
    );

static void
sparseElementFree(
    PSPARSE_ELEMENT Element
    );

static DWORD
SparseScheduleAddDel(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE pTemplateSchedule
    );

static PSPARSE_ELEMENT
sparseElementFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    );

static BOOLEAN
scheduleOverlap(
    PBYTE pSchedule1,
    PBYTE pSchedule2,
    PBYTE *ppNewSchedule
    );

static BOOLEAN
scheduleEmpty(
    PBYTE pSchedule
    );

static DWORD
scheduleLength(
    PBYTE pSchedule
    );

static PBYTE
scheduleAllocCopy(
    PBYTE pSchedule
    );

static DWORD
scheduleDuration(
    PBYTE pSchedule
    );

/* End Forward */


void
GraphAllCosts(
    PGRAPH Graph,
    BOOL fIgnoreSchedules
    )

/*++

Routine Description:

    Find the shortest path between all pairs of nodes

    When a path is updated, its schedule is considered.  If they paths are have a common schedule,
    the path can be chosen.  When two weights are the same, the path with the most available
    schedule is chosen.

    SCALING BUG 87827: this is an order(n^3) algorithm

    This algorithm is taken from:
    Fundamentals of Data Structures, Horowitz and Sahni,
    Computer Science Press, 1976, pp. 307

    for k = 1 to n
        for i = 1 to n
            for j = 1 to n
                A(i,j) <- min{ A(i,j) , A(i,k)+A(k,j) }

    "Some speed up can be obtained by noticing that the innermost for loop
     need be executed only when A(i,k) and A(k,j) are not equal to infinity."

Arguments:

    IN OUT CostArray (global) - Input is cost matrix, Output is shortest path array

Return Value:

    None

--*/

{
    DWORD NumberSites = Graph->NumberElements;
    PISM_LINK LinkArray = Graph->LinkArray;
    PISM_LINK pElement1, pElement2, pElement3;
    ISM_LINK newPath;
    DWORD i, j, k, cost1, cost2, cost3;
    PBYTE pS1, pS2, pS3, pS23;
    BOOLEAN replace;

    if ( (Graph->Size != sizeof( GRAPH ) ) ||
         (Graph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }

    for( k = 0; k < NumberSites; k++ ) {

        for( i = 0; i < NumberSites; i++ ) {

            pElement2 = &( LinkArray[ i * NumberSites + k ] );
            cost2 = pElement2->ulCost;
            if (cost2 == INFINITE_COST) {
                continue;
            }

            pS2 = sparseScheduleFind( Graph, i, k );

            for( j = 0; j < NumberSites; j++ ) {

                // A(i,j) <- min{ A(i,j) , A(i,k)+A(k,j) }

                pElement1 = &( LinkArray[ i * NumberSites + j ] );

                cost1 = pElement1->ulCost;
                pS1 = sparseScheduleFind( Graph, i, j );

                pElement3 = &( LinkArray[ k * NumberSites + j ] );
                cost3 = pElement3->ulCost;
                if (cost3 == INFINITE_COST) {
                    continue;
                }
                pS3 = sparseScheduleFind( Graph, k, j );

                // These equations aggregate attributes along a path
                newPath.ulCost = cost2 + cost3;
                newPath.ulReplicationInterval =
                    MAX( pElement2->ulReplicationInterval,
                         pElement3->ulReplicationInterval );
                newPath.ulOptions =
                    pElement2->ulOptions & pElement3->ulOptions;

                if (!fIgnoreSchedules) {
                    // Consider Schedules

                    // new weight must be better or not a candidate
                    if (newPath.ulCost > cost1 ) {
                        continue;
                    }

                    if (!scheduleOverlap( pS2, pS3, &pS23 )) {
                        continue;   // no common schedule for candidate
                    }

                    replace = TRUE;

                    // If weights the same, schedule must be better
                    if (newPath.ulCost == cost1) {
                        replace = scheduleDuration( pS23 ) > scheduleDuration( pS1 );
                    }

                    if (replace) {
                        *pElement1 = newPath;
                        SparseScheduleAddDel( Graph, i, j, pS23 );
                    }

                    if (pS23) {
                        FREE_TYPE( pS23 );
                    }

                } else {

                    // Don't consider schedules
                    if (newPath.ulCost < cost1 ) {
                        *pElement1 = newPath;
                    }
                }

            }
        }
    }
}


void
GraphMerge(
    PGRAPH FinalGraph,
    PGRAPH TempGraph
    )

/*++

Routine Description:

"OR" two graphs together, such that an edge is added only if it is better than what was there
before.  Better is defined as small weight, or more available schedule if the weights are the
same.

Arguments:

    FinalGraph - 
    TempGraph - 

Return Value:

    None

--*/

{
    DWORD NumberSites = FinalGraph->NumberElements;
    DWORD i, j, new, *pElement;
    PBYTE pOldSchedule, pNewSchedule;
    BOOLEAN replace;

    if ( (FinalGraph->Size != sizeof( GRAPH )) ||
         (TempGraph->Size != sizeof( GRAPH )) ||
         (FinalGraph->NumberElements != TempGraph->NumberElements) ||
         (FinalGraph->LinkArray == NULL) ||
         (TempGraph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }

    for( i = 0; i < NumberSites; i++ ) {

        for( j = 0; j < NumberSites; j++ ) {

            pElement = &(FinalGraph->LinkArray[i * NumberSites + j].ulCost);

            new = TempGraph->LinkArray[i * NumberSites + j].ulCost;
            pNewSchedule = sparseScheduleFind( TempGraph, i, j );

            // Replace old value with new value *only* if smaller, or better schedule

            replace = FALSE;
            if (new == *pElement) {
                pOldSchedule = sparseScheduleFind( FinalGraph, i, j );
                replace =
                    scheduleDuration( pNewSchedule ) > scheduleDuration( pOldSchedule );
            } else {
                replace = (new < *pElement);
            }

            // Replace element value
            if (replace) {
                *pElement = new;

                // replace schedule
                SparseScheduleAddDel( FinalGraph, i, j, pNewSchedule );
            }

        }

    }
} /* GraphMerge */


PGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    )

/*++

Routine Description:

Create a new graph.

The sparse array part is not allocated until used.

Arguments:

    NumberElements - 
    Initialize - 

Return Value:

    PGRAPH - 

--*/

{
    PGRAPH graph = NULL;
    DWORD i;

    // use calloc so cleanup can know whether to free embedded pointers
    graph = NEW_TYPE_ARRAY_ZERO( 1, GRAPH );
    if (graph == NULL) {
        return NULL;
    }

    // INITIALIZE GRAPH INSTANCE
    graph->Size = sizeof( GRAPH );
    graph->NumberElements = NumberElements;

    graph->LinkArray = NEW_TYPE_ARRAY(
        NumberElements * NumberElements, ISM_LINK );
    if (graph->LinkArray == NULL) {
        goto cleanup;
    }

    // Not allocated yet
    graph->SparseArray = NULL;

    // INITIALIZE GRAPH INSTANCE

    if (Initialize) {
        GraphInit( graph );
    }

    return graph;

cleanup:
    if (graph->LinkArray) {
        FREE_TYPE( graph->LinkArray );
    }
    if (graph->SparseArray) {
        FREE_TYPE( graph->SparseArray );
    }
    if (graph) {
        FREE_TYPE( graph );
    }
    return NULL;
} /* GraphCreate */


DWORD
GraphAddEdgeIfBetter(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    )

/*++

Routine Description:

Add an edge to the graph, only if it is better.
Better is defined as lower weight, or more available schedule.

Arguments:

    Graph - 
    From - 
    To - 
    Value - 
    pSchedule - may be NULL, indicating connectivity at all times

Return Value:

    DWORD - 

--*/

{
    PISM_LINK pElement;
    BOOLEAN replace;
    PBYTE pOldSchedule;

    DPRINT5( 4, "GraphAddEdgeIfBetter, From=%d, To=%d, Value=(%d,%d), pSched=%p\n",
             From, To,
             pLinkValue->ulCost, pLinkValue->ulReplicationInterval,
             pSchedule );

    if ( (Graph->Size != sizeof( GRAPH ) ) ||
         (Graph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }
    if ( (To >= Graph->NumberElements) ||
         (From >= Graph->NumberElements) ) {
        DPRINT( 0, "node index is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }

    // Don't add obvious bad connections
    if ( scheduleEmpty( pSchedule ) || (pLinkValue->ulCost == INFINITE_COST)) {
        DPRINT( 1, "Not adding edge because schedule empty or weight infinite\n" );
        return ERROR_SUCCESS;
    }

    pElement = &( Graph->LinkArray[ From * Graph->NumberElements + To ] );

    // See if the new value is better, or the schedule is better
    replace = FALSE;
    if (pLinkValue->ulCost == pElement->ulCost) {
        pOldSchedule = sparseScheduleFind( Graph, From, To );
        replace = scheduleDuration( pSchedule ) > scheduleDuration( pOldSchedule );
    } else {
        replace = (pLinkValue->ulCost < pElement->ulCost);
    }

    if (replace) {
        *pElement = *pLinkValue;
        SparseScheduleAddDel( Graph, From, To, pSchedule );
    }

    return ERROR_SUCCESS;
} /* GraphAddEdgeIfBetter */


DWORD
GraphInit(
    PGRAPH Graph
    )

/*++

Routine Description:

Clear out old values in a graph.  Graph must already be created.  Graph may or may not
have any sparse elements yet.

Arguments:

    Graph - 

Return Value:

    DWORD - 

--*/

{
    DWORD i, number = Graph->NumberElements;

    if ( (Graph->Size != sizeof( GRAPH ) ) ||
         (Graph->LinkArray == NULL ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }

    // Zero the array of structures
    ZeroMemory( Graph->LinkArray, number * number * sizeof( ISM_LINK ) );

    // Initially all costs are infinite
    for( i = 0; i < number * number; i++ ) {
        Graph->LinkArray[i].ulCost = INFINITE_COST;
    }
    
    // Cost to ourselves is zero
    for( i = 0; i < number; i++ ) {
        Graph->LinkArray[i * number + i].ulCost = 0; // loopback cost
    }

    sparseArrayFree( Graph );

    return ERROR_SUCCESS;
} /* GraphInit */


void
GraphFree(
    PGRAPH Graph
    )

/*++

Routine Description:

Deallocate a graph.
May or may not have any sparse elements.
It may or may not have had its matrix extracted.

Arguments:

    Graph - 

Return Value:

    None

--*/

{
    if (Graph->Size != sizeof( GRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }
    if (Graph->LinkArray != NULL) {
        FREE_TYPE( Graph->LinkArray );
    }
    Graph->LinkArray = NULL;

    sparseArrayFree( Graph );

    FREE_TYPE( Graph );
} /* GraphFree */


void
GraphReferenceMatrix(
    PGRAPH Graph,
    PISM_LINK *ppLinkArray
    )

/*++

Routine Description:

Copy the cost matrix out

The caller must release the matrix when he is finished using the
GraphDereferenceMatrix function.

Arguments:

    Graph - 
    ppArray - 

Return Value:

    None

--*/

{
    PISM_LINK pLinkArray = NULL;
    DWORD number, i, j, index;

    if (Graph->Size != sizeof( GRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }
    if (ppLinkArray == NULL) {
        DPRINT( 0, "Invalid parameter\n" );
        return;
    }

    number = Graph->NumberElements;

    // Allocate a new array to hold the cost matrix
    pLinkArray = NEW_TYPE_ARRAY( number * number, ISM_LINK );
    if (pLinkArray == NULL) {
        goto cleanup;
    }

    CopyMemory( pLinkArray, Graph->LinkArray,
                number * number * sizeof( ISM_LINK ) );

cleanup:

    *ppLinkArray = pLinkArray;
    // Note, Graph is still alive and well at this point

} /* GraphReturnMatrix */


VOID
GraphDereferenceMatrix(
    PGRAPH Graph,
    PISM_LINK pLinkArray
    )

/*++

Routine Description:

Release a matrix reference.

The idea behind the reference/dereference api is to allow us to return a
pointer to the matrix instead of copying it each time.  This is useful when
the caller is himself going to copy the data, and will protect our reference
from corruption by users.

The problem with this approach is that a reference to the matrix implies
a reference count on the graph, so it won't go away while it is referenced.
TODO: implement reference counts

Arguments:

    Graph - 
    pLinkArray - 

Return Value:

    None

--*/

{
    // Warning, at this writing there is no reference count on the graph, so
    // it may be NULL or different entirely at this point from when it was
    // referenced.

    // For now, just deallocate the copy
    if (pLinkArray) {
        FREE_TYPE( pLinkArray );
    }

} /* GraphDereferenceMatrix */


DWORD
GraphGetPathSchedule(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *ppSchedule,
    DWORD *pLength
    )

/*++

Routine Description:

Public routine to get a schedule for a path in the graph.

We try to limit knowlege of the schedule.h structure of the schedule from the other modules.
We return the length here because clients need it and we don't want others to have to
calculate it.

Arguments:

    Graph - 
    From - 
    To - 
    ppSchedule - pointer to pointer to receive pointer to newly allocated schedule
    pLength - pointer to dword to receive length of blob

Return Value:

    DWORD - 

--*/

{
    PBYTE pSchedule;
    DWORD length;

    // Validate

    if (Graph->Size != sizeof( GRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return ERROR_INVALID_BLOCK;
    }
    if ( (To >= Graph->NumberElements) ||
         (From >= Graph->NumberElements) ) {
        DPRINT( 0, "node index is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }
    if ( (ppSchedule == NULL) ||
         (pLength == NULL) ) {
        DPRINT( 0, "Invalid parameter\n" );
        return ERROR_INVALID_PARAMETER;
    }

    // Find the schedule if there is one

    pSchedule = sparseScheduleFind( Graph, From, To );
    if (pSchedule == NULL) {
        *ppSchedule = NULL;
        *pLength = 0;
        return ERROR_SUCCESS;
    }

    // Make a private copy for the user

    *ppSchedule = scheduleAllocCopy( pSchedule );
    if ( *ppSchedule == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pLength = scheduleLength( pSchedule );

    return ERROR_SUCCESS;
} /* GraphGetPathSchedule */


#if 0


void
GraphComputeTransitiveClosure(
    IN OUT  GRAPH *     pGraph
    )
/*++

Routine Description:

    Given a graph containing only weighted edges, add in the shortest path
    (i.e., least cost) transitive closure.

    ** NOTE THAT SCHEDULES ARE IGNORED. **

    An adaptation of the Floyd-Warshall algorithm as illustrated in
    "Introduction to Algorithms," p. 556, by Cormen-Leiserson-Rivest, published
    by MIT Press, 1990.

    Runs in O(N^3) time, where N = pGraph->NumberElements.

Arguments:

    pGraph (IN/OUT) - The weighted graph on entry; on exit, its least cost
        transitive closure.

Return Values:

    None.

--*/
{
    DWORD i, j, k;
    DWORD *pCurrCost;
    DWORD Cost1, Cost2;

    Assert(pGraph->NumberElements > 0);

    for (k = 0; k < pGraph->NumberElements; k++) {
        for (i = 0; i < pGraph->NumberElements; i++) {
            for (j = 0; j < pGraph->NumberElements; j++) {
                pCurrCost = &pGraph->LinkArray[i*pGraph->NumberElements + j].ulCost;

                Cost1 = pGraph->LinkArray[i*pGraph->NumberElements + k].ulCost;
                Cost2 = pGraph->LinkArray[k*pGraph->NumberElements + j].ulCost;

                if ((INFINITE_COST != Cost1)
                    && (INFINITE_COST != Cost2)
                    && (Cost1 + Cost2 >= min(Cost1, Cost2))
                    && (Cost1 + Cost2 < *pCurrCost)) {
                    // This path is cheaper than the cheapest one we've
                    // found thus far.
                    *pCurrCost = Cost1 + Cost2;
                }
            }
        }
    }
}
#endif


static PBYTE
sparseScheduleFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    )

/*++

Routine Description:

    Helper routine to see if a schedule is present in a graph

Arguments:

    Graph - 
    From - 
    To - 

Return Value:

    PBYTE - 

--*/

{
    PSPARSE_ELEMENT element;
    
    element = sparseElementFind( Graph, From, To );
    if (element == NULL) {
        return NULL;
    } else {
        return element->pSchedule;
    }
} /* sparseScheduleFind */


static void
sparseArrayFree(
    PGRAPH Graph
    )

/*++

Routine Description:

Free the sparse array portion of the graph.  The sparse array portion can be deallocated while
the graph is allocated.  This is a normal mode of the sparse array, and it represents and empty
array.

Arguments:

    Graph - 

Return Value:

    None

--*/

{
    DWORD i;
    PSPARSE_ELEMENT element, next;

    if (Graph->SparseArray == NULL) {
        return;
    }

    for( i = 0; i < Graph->NumberElements; i++ ) {
        element = Graph->SparseArray[i];
        while (element != NULL) {
            next = element->Next;
            sparseElementFree( element );
            element = next;
        }
    }

    FREE_TYPE( Graph->SparseArray );

    Graph->SparseArray = NULL;
} /* sparseArrayFree */


static void
sparseElementFree(
    PSPARSE_ELEMENT Element
    )

/*++

Routine Description:

Free an individual sparse array element

Arguments:

    Element - 

Return Value:

    None

--*/

{
    FREE_TYPE( Element->pSchedule );
    FREE_TYPE( Element );
} /* sparseElementFree */


static DWORD
SparseScheduleAddDel(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE pTemplateSchedule
    )

/*++

Routine Description:

Add or delete a schedule from a sparse array.  An element may be created or destroyed in the
process.

CODE.IMP: This code ties the life of a element to the life of a schedule.  If we ever store
more stuff in the element besides the schedule, we will need to revisit this.

The sparse array is allocated only when needed.  If an
element, or the array itself is not present, it means the requested node is not present.

Arguments:

    Graph - 
    From - 
    To - 
    pSchedule - may be null, indicating any previous value should be removed
        A copy is made of the schedule.  The caller can do what he will with it after.

Return Value:

    PSPARSE_ELEMENT - 

--*/

{
    DWORD length;
    PBYTE pNewSchedule;
    PSPARSE_ELEMENT element, new, prev;

    DPRINT3( 4, "SparseScheduleAddDel, from=%d, to=%d, pSchedule=%p\n",
            From, To, pTemplateSchedule );

    // Allocate the sparse array headers the first time a sparse element is needed
    if (Graph->SparseArray == NULL) {

        // Nothing to delete
        if (pTemplateSchedule == NULL) {
            return ERROR_SUCCESS;
        }

        // Use calloc so pointers are null'd out to start
        Graph->SparseArray = NEW_TYPE_ARRAY_ZERO( Graph->NumberElements, PSPARSE_ELEMENT );
        if (Graph->SparseArray == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    // Make a copy for ourselves
    if (pTemplateSchedule) {
        pNewSchedule = scheduleAllocCopy( pTemplateSchedule );
        if (pNewSchedule == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        pNewSchedule = NULL;
    }

    // Find element

    prev = NULL;
    element = Graph->SparseArray[From];
    while (element) {

        // Found an existing sparse array element
        if (element->To == To) {
            if (pNewSchedule == NULL) {

                // Delete element 'cause schedule taken away

                if (prev == NULL) {
                    Graph->SparseArray[From] = element->Next;
                } else {
                    prev->Next = element->Next;
                }
                sparseElementFree( element );
            } else {
                // Replace schedule value
                FREE_TYPE( element->pSchedule );
                element->pSchedule = pNewSchedule;
            }
            return ERROR_SUCCESS;

        } else if (element->To > To) {
            break;
        }

        prev = element;
        element = element->Next;
    }

    // Nothing found to delete, exit
    if (pNewSchedule == NULL) {
        return ERROR_SUCCESS;
    }

    // Create new element for schedule

    new = NEW_TYPE( SPARSE_ELEMENT );
    if (new == NULL) {
        FREE_TYPE( pNewSchedule );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    new->To = To;
    new->pSchedule = pNewSchedule;
    new->Next = element;

    if (prev == NULL) {
        Graph->SparseArray[From] = new;
    } else {
        prev->Next = new;
    }

    return ERROR_SUCCESS;
} /* SparseScheduleAddDel */


static PSPARSE_ELEMENT
sparseElementFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    )

/*++

Routine Description:

Find a sparse array element.  This is used by sparseScheduleFind.

Arguments:

    Graph - 
    From - 
    To - 

Return Value:

    PSPARSE_ELEMENT - NULL indicates not found

--*/

{
    PSPARSE_ELEMENT element;
    
    if (Graph->SparseArray == NULL) {
        return NULL;
    }

    element = Graph->SparseArray[From];
    while (element) {
        if (element->To == To) {
            return element;
        } else if (element->To > To) {
            break;
        }
        element = element->Next;
    }

    return NULL;
} /* sparseElementFind */


static BOOLEAN
scheduleOverlap(
    PBYTE pSchedule1,
    PBYTE pSchedule2,
    PBYTE *ppNewSchedule
    )

/*++

Routine Description:

Determine if two schedules overlap. If so, allocate a new schedule which represents the common
time periods of the two.

A new schedule is only returned if this function returns TRUE.  Caller must deallocate.

Arguments:

    pSchedule1 - 
    pSchedule2 - 
    ppNewSchedule - 

Return Value:

    BOOLEAN - 

--*/

{
    PSCHEDULE header1, header2;
    PBYTE new, data1, data2;
    DWORD hour;
    BYTE common, overlap;

    // Always connected
    if ( (pSchedule1 == NULL) && (pSchedule2 == NULL) ) {
        *ppNewSchedule = NULL;
        return TRUE;
    }

    // If one is NULL, return the other schedule
    if (pSchedule1 == NULL) {
        new = scheduleAllocCopy( pSchedule2 );
        if (new == NULL) {
            return FALSE;
        }
        *ppNewSchedule = new;
        return TRUE;
    } else if (pSchedule2 == NULL) {
        new = scheduleAllocCopy( pSchedule1 );
        if (new == NULL) {
            return FALSE;
        }
        *ppNewSchedule = new;
        return TRUE;
    }

    header1 = (PSCHEDULE) pSchedule1;
    header2 = (PSCHEDULE) pSchedule2;

    // If formats not identical, don't even bother
    if ( (header1->Size != header2->Size) ||
         (header1->NumberOfSchedules != header2->NumberOfSchedules) ||
         (header1->Schedules[0].Type != header2->Schedules[0].Type) ) {
        DPRINT( 0, "Schedule overlap cannot be determined because formats not identical\n" );
        DPRINT3( 1, "s1: size %d number %d type %d\n",
                 header1->Size,
                 header1->NumberOfSchedules,
                 header1->Schedules[0].Type );
        DPRINT3( 1, "s2: size %d number %d type %d\n",
                 header2->Size,
                 header2->NumberOfSchedules,
                 header2->Schedules[0].Type );
        return FALSE;
    }

    // CODE.IMPROVEMENT: Must be interval format, only one schedule

    if ( (header1->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES ) ||
         (header1->NumberOfSchedules != 1) ||
         (header1->Schedules[0].Type != SCHEDULE_INTERVAL) ) {
        DPRINT( 0, "Schedule overlap cannot be determined because format not supported\n" );
        DPRINT5(1, "s1: size %d (exp %d) number %d (exp 1) type %d (exp %d)\n",
                 header1->Size, (sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES),
                 header1->NumberOfSchedules,
                 header1->Schedules[0].Type, SCHEDULE_INTERVAL );
        return FALSE;
    }

    new = scheduleAllocCopy( pSchedule1 );
    if (new == NULL) {
        return FALSE;
    }

    header1 = (PSCHEDULE) new;

    data1 = (PBYTE) (header1 + 1);  // point just beyond structure
    data2 = (PBYTE) (header2 + 1);  // point just beyond structure

    // For each hour, AND lower four bits together. High order bits left alone.
    // Overlap flag tracks whether we have seen atleast one nonzero hour

    overlap = 0;
    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour++ ) {
        *data1 &= ( (*data2++) | 0xf0 );
        overlap |= *data1++;
    }

    if (overlap & 0xf) {
        *ppNewSchedule = new;
        return TRUE;
    } else {
        FREE_TYPE( new );
        DPRINT2( 3, "No overlap found between %p and %p\n",
                 pSchedule1, pSchedule2 );
        return FALSE;
    }

} /* scheduleOverlap */


static BOOLEAN
scheduleEmpty(
    PBYTE pSchedule
    )

/*++

Routine Description:

Test if any intervals are set in the schedule.  This is a subset of the functionality of the
scheduleDuration function.

Arguments:

    pSchedule - 

Return Value:

    BOOLEAN - 

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);  // point just beyond structure
    DWORD hours;

    if (pSchedule == NULL) {
        return FALSE; // not empty
    }

    // CODE.IMP - we only handle one schedule of type INTERVAL

    // Return something reasonable if we don't understand the blob
    if ( (header->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES) ||
         (header->NumberOfSchedules != 1) ||
         (header->Schedules[0].Type != SCHEDULE_INTERVAL) ||
         (header->Schedules[0].Offset != sizeof( SCHEDULE ) ) ) {
        return FALSE;  // not empty
    }

    for( hours = 0; hours < SCHEDULE_DATA_ENTRIES; hours++ ) {
        if ( (*data++) & 0xf ) {
            return FALSE; // not empty
        }
    }
    
    return TRUE;  // empty
} /* scheduleEmpty */


static DWORD
scheduleLength(
    PBYTE pSchedule
    )

/*++

Routine Description:

Return the length of the schedule blob.  This function is abstracted to a seperate routine
in case we ever support multiple schedule formats.

Arguments:

    pSchedule - 

Return Value:

    DWORD - 

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;

    return header->Size;
} /* scheduleLength */


static PBYTE
scheduleAllocCopy(
    PBYTE pSchedule
    )

/*++

Routine Description:

Copy a schedule to a new blob.  This is made a separate function in case we support new
schedule formats.

Arguments:

    pSchedule - 

Return Value:

    PBYTE - 

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE new;

    if (pSchedule == NULL) {
        return NULL;
    }

    new = NEW_TYPE_ARRAY( header->Size, BYTE );
    if (new == NULL) {
        return NULL;
    }

    CopyMemory( new, pSchedule, header->Size );

    return new;
} /* scheduleAllocCopy */


static DWORD
scheduleDuration(
    PBYTE pSchedule
    )
    
/*++

Routine Description:

Return the amount of minutes of uptime that a schedule represents.  Used to derive a metric
to compare two schedules.

Arguments:

    pSchedule - 

Return Value:

    DWORD - Duration in minutes

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);  // point just beyond structure
    DWORD hour, entry, duration = 0;

    if (pSchedule == NULL) {
        return SCHEDULE_DATA_ENTRIES * 4 * 15;  // MAX DURATION
    }

    // CODE.IMP - we only handle one schedule of type INTERVAL

    // Return something reasonable if we don't understand the blob
    if ( (header->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES) ||
         (header->NumberOfSchedules != 1) ||
         (header->Schedules[0].Type != SCHEDULE_INTERVAL) ||
         (header->Schedules[0].Offset != sizeof( SCHEDULE ) ) ) {
        return 0; // unknown duration
    }

    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour++ ) {
        entry = (*data++) & 0xf;
        if (entry & 0x1) { duration += 15; }
        if (entry & 0x2) { duration += 15; }
        if (entry & 0x4) { duration += 15; }
        if (entry & 0x8) { duration += 15; }
    }

    return duration;
} /* scheduleDuration */

/* end graph.c */
