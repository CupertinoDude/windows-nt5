/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    xmitrecv.cxx

ABSTRACT:

    Methods to support send and receive via SMTP for the Intersite Messaging
    service.

DETAILS:

CREATED:

    3/20/98     Jeff Parham (jeffparh)

REVISION HISTORY:

    Jul 17, 1998  Will Lees (wlees)
           Restructured and simplified to use CDO V2.
1. Use events as primary means of event notification (polling as backup)
2. Send message data in-line instead of an attachment
3. Combine polling and receiving routines into one

    Sep 3, 1998   wlees
          Added support for detecting and eliminating duplicate messages

    Oct 22, 1998
          Duplicate suppression, guid-based mail names

--*/

#include <ntdspchx.h>

#include <align.h>

#include <ismapi.h>
#include <debug.h>

#include <atlbase.h>          // cccomptr
#include "cdosys.h"
// Jun 8, 1999. #ifdef necessary until new headers checked in
#ifdef __cdo_h__
using namespace CDO;
#endif

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
//#include "ntdsa.h"
//#include "taskq.h"                      // GetSecondsSince1601()
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsconfig.h"                   // Get config param
#include <ntrtl.h>                      // Generic table package

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_XMITRECV

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

// This is actually a C fragment generated by the IDL compiler
// It contains some useful constants for calling CDO
#include "cdosys_i.c"

// Include the class id for the smtp sink so we can check for it
#include "smtpsink_i.c"

#define DEBSUB "XMITRECV:"

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#define QUEUE_DIRECTORY L"Queue"
#define QUEUE_DIRECTORY_LEN (ARRAY_SIZE(QUEUE_DIRECTORY))

#define DROP_DIRECTORY L"Drop"
#define DROP_DIRECTORY_LEN (ARRAY_SIZE(DROP_DIRECTORY))

#define RCPT_TO_RULE L"RCPT TO="
#define RCPT_TO_RULE_LEN (ARRAY_SIZE(RCPT_TO_RULE))

// Format for the message subject.
#define USER_PREFIX L"_IsmService@"
#define USER_PREFIX_LEN (ARRAY_SIZE(USER_PREFIX) - 1)
#define SUBJECT_PREFIX      L"Intersite message for "
#define SUBJECT_PREFIX_LEN  (ARRAY_SIZE(SUBJECT_PREFIX) - 1)
#define SUBJECT_SEPARATOR L": "
#define SUBJECT_SEPARATOR_LEN  (ARRAY_SIZE(SUBJECT_SEPARATOR) - 1)
const WCHAR gszSubjectFormat[] =
SUBJECT_PREFIX L"%ls" SUBJECT_SEPARATOR L"%ls";
const DWORD gcchSubjectFormat = ARRAY_SIZE(gszSubjectFormat);

#define HR_SHARING_VIOLATION (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
#define HR_FILE_NOT_FOUND (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
#define HR_NOT_ENOUGH_MEMORY (HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))

#define SMTP_MSG_GUID cdoNSMailHeader L"X-MsgGuid"
#define SMTP_SUPERSEDES_MSG_GUID cdoNSMailHeader L"X-SupersedesMsgGuid"

// How frequently do we log an error if SMTP domain not available
#define NO_SMTP_DOMAIN_INTERVAL (24 * 60 * 60)  // Once a day

typedef LONGLONG DSTIME;

extern "C" {
// Return seconds since Jan 1, 1601.
DSTIME
GetSecondsSince1601( void );
}

// Forward

DWORD
configureMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

VOID
disableMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

// Static

static GUID zeroGuid = {0};


HRESULT
supersedeMessage(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    IN  IMessage *            pIMsg
    )

/*++

Routine Description:

This routine writes the necessary fields in the message so that it will supercede
a previous message with the same (service,address,subject).  This is done by
keeping keeping a circular list/cache of most recent triples, and associating
with the entry the guid of the last sent message.  On the first send, a new guid
is used.  On a second or later send, the previous guid is set for the
"supersede guid", and then a new guid is set in the cache.

Note that this cache is a performance optimization.  If an entry is bumped out
of the cache, it only means that we won't be able to regenerate the previous
supersede guid to suppress the previous message.  Under certain degenerate
circumstances (more than x services, more than y naming contexts), we will start
to drop entries out.

Note that we depend on the circular nature of the list at the subject level in
order to push out old subject entries.  We don't get feed back whether we were
successful. We depend on the fact that when communication in happening, new
subjects get inserted at the front and the old useless subjects get pushed out
the back. We limit the number of entries so we won't have to search so many each
time.  When communication isn't happening, we expect that the size of the circular
buffer is enough to contain all the unique subjects that are generated by the
application (hopefully small).  These limits can be adjusted.

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pszMessageSubject - 
    pIMsg - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr;
    CComPtr<Fields> pFields;
    PSUBJECT_INSTANCE pSubject = NULL;

    // Look up the (Service, Address, Subject) triple
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        status = SmtpTableFindSendSubject(
            pTransport,
            pszRemoteTransportAddress,
            pszServiceName,
            pszMessageSubject,
            &pSubject
            );
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "failed to find subject cache, error 0x%x\n", status );
        hr = HRESULT_FROM_WIN32( status );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Now we have a pointer to a subject record, either new or previous

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // if guid is present, ie this is a retry, load the guid into the
    // supersedes guid filed
    if (memcmp( &(pSubject->Guid), &zeroGuid, sizeof(GUID) ) != 0) {
        DPRINT3( 1, "This message supersedes prior message: (%ws,%ws,%ws)\n",
                 pszServiceName,
                 pszRemoteTransportAddress,
                 pszMessageSubject );
        hr = putFieldGuid( pFields,
                           SMTP_SUPERSEDES_MSG_GUID,
                           &(pSubject->Guid) );
        if (FAILED(hr)) {
            DPRINT1( 0, "failed to set field guid, error 0x%x\n", hr );
            LogCdoError( hr );
            goto cleanup;
        }
    }

    // Allocate a new guid, store in subject descriptor
    status = UuidCreate( &(pSubject->Guid) );
    if ( (status != RPC_S_OK) &&
         (status != RPC_S_UUID_LOCAL_ONLY) ) {
        DPRINT1( 0, "failed to create guid, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // Load guid into message
    hr = putFieldGuid( pFields, SMTP_MSG_GUID, &(pSubject->Guid) );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to set field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pFields->Update();
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to update fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* supersedeMessage */


VOID
addRemoveSmtpSvc(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fIsSmtpSvcPresent
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    fIsSmtpSvcPresent - 

Return Value:

    None

--*/

{
    DWORD status, tries, waitCode;

    if (fIsSmtpSvcPresent) {
        DPRINT( 1, "SMTPSVC is present\n" );

        // Even though SmtpSvc is installed, all the other necessary plumbing
        // to add a new domain (ADSI) support is not fully there.  Give the IIS
        // install a chance to finish
    
        for( tries = 0; tries < 40; tries++ ) {
            waitCode = WaitForSingleObject( pTransport->hShutdownEvent,
                                            15 * 1000 );
    
            if (pTransport->fShutdownInProgress) {
                return;
            }

            if (SUCCEEDED( CheckSmtpDomainContainerPresent() )) {
                break;
            }
        }
    
        if (pTransport->fShutdownInProgress) {
            return;
        }
    
        EnterCriticalSection( &(pTransport->Lock) );
        __try {
            if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
                status = configureMailAddress( pTransport );
            }
        }
        __finally {
            LeaveCriticalSection( &(pTransport->Lock) );
        }

    } else {
        // This is where we detect the SmtpSvc being uninstalled.
        
        DPRINT( 1, "SMTPSVC is absent\n" );
                    
        EnterCriticalSection( &(pTransport->Lock) );
        __try {
            if ( NULL != pTransport->Smtp.pszSmtpAddress ) {
                disableMailAddress( pTransport );
            }
        }
        __finally {
            LeaveCriticalSection( &(pTransport->Lock) );
        }

    } // if fIsSmtpSvcPresent

} /* addRemoveSmtpSvc */


unsigned __stdcall
SmtpRegistryNotifyThread(
    void *Argument1
    )

/*++

Routine Description:

Thread to wait for a registry notification that the Smtp Service
has been installed.  When we detect that the Smtp Service is present,
we configure our mail address so that we may receive mail.

This thread exits after the mail address has been set.

This thread uses closure of the registry hkey being monitored as a
single to terminate.  That way we don't need a separate event for
that purpose.

Arguments:

    Argument1 - Transport Instance

Return Value:

    void __cdecl - 

--*/

{
    TRANSPORT_INSTANCE *pTransport = (PTRANSPORT_INSTANCE) Argument1;
    DWORD status, waitCode;
    HKEY hKey = NULL;
    HANDLE hRegChange = NULL;
    HANDLE rghWaitHandles[2];
    BOOL fIsSmtpSvcPresentOldState, fIsSmtpSvcPresentNewState;

    DPRINT( 1, "SmtpRegistryNotifyThread is watching...\n" );

    InterlockedIncrement( (PLONG) &(pTransport->ReferenceCount) );  // 1 for this thread

    __try {
        status = RegOpenKey(HKEY_LOCAL_MACHINE, 
                            "SYSTEM\\CurrentControlSet\\Services",
                            &hKey);
        if (status != ERROR_SUCCESS) {
            DPRINT1(0, "failed to open services key, error %d\n",
                    status);
            LogUnhandledError(status);
            __leave;
        }

        hRegChange = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == hRegChange) {
            status = GetLastError();
            DPRINT1(0, "CreateEvent failed with %d\n", status);
            LogUnhandledError(status);
            __leave;
        }

        rghWaitHandles[0] = pTransport->hShutdownEvent;
        rghWaitHandles[1] = hRegChange;
        
        // Remember initial state
        fIsSmtpSvcPresentOldState = servicePresent("SmtpSvc");

        // Verify the proper settings on startup every time
        addRemoveSmtpSvc( pTransport, fIsSmtpSvcPresentOldState );


        // Wait in a loop watching for SmtpSvc either coming or going

        while (!pTransport->fShutdownInProgress) {
            // Register request for notification of registry change
            // This call does not wait.
            // Returns success on handle closure
            status = RegNotifyChangeKeyValue(hKey,
                                             TRUE, // bWatchSubkeys
                                             REG_NOTIFY_CHANGE_NAME,
                                             hRegChange,
                                             TRUE // fAsynchronous
                                             );
            if (status != ERROR_SUCCESS) {
                DPRINT1( 0, "RegNotifyChangeValue returned %d\n", status );
                LogUnhandledError( status );
                __leave;
            }

            // Wait for shutdown or a change in the Services portion of the
            // registry.
            waitCode = WaitForMultipleObjects(ARRAY_SIZE(rghWaitHandles),
                                              rghWaitHandles,
                                              FALSE,
                                              INFINITE);
            switch (waitCode) {
            case WAIT_OBJECT_0:
                // Shutdown was signalled; bail.
                __leave;

            case WAIT_OBJECT_0 + 1:
                // Services registry change; loop back to the top.
                break;

            case WAIT_FAILED:
            default:
                // Unexpected error return; log and bail.
                status = GetLastError();
                LogUnhandledError(waitCode);
                LogUnhandledError(status);
                __leave;
            }

            fIsSmtpSvcPresentNewState = servicePresent("SmtpSvc"); 

            if (fIsSmtpSvcPresentOldState != fIsSmtpSvcPresentNewState) {

                addRemoveSmtpSvc( pTransport, fIsSmtpSvcPresentNewState );

                fIsSmtpSvcPresentOldState = fIsSmtpSvcPresentNewState;

            } // If OldState != NewState 

        } // while ! shutdown

    } __finally {
        DPRINT( 1, "SmtpRegistryNotifyThread exit\n" );

        if (NULL != hRegChange) {
            CloseHandle(hRegChange);
        }

        if (NULL != hKey) {
            RegCloseKey(hKey);
        }

        InterlockedDecrement( (PLONG) &(pTransport->ReferenceCount) );  // 1 for this thread
    }

    if (pTransport->fShutdownInProgress) {
        // Normal thread termination.
        status = 0;
    }

    return status;
} /* SmtpRegistryNotifyThread */


DWORD
configureMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

This routine initializes the mail address for this server, and prepares the
SMTP server to receive mail on this system.

This routine does nothing if SMTP is not installed.

This routine performs several functions:
1. Generates a mail address for this server and writes it to the mailAddress
attribute if necessary
2. Initializes the transport mail address
3. Adds the Smtp mail routing domain for the guid-based name on this server
4. Register the event sink dll as a COM dll if necessary
5. Bind the event sink to SMTP/CDO

The administrator is no longer required to manually assign a mail address for
the server.  This is created automatically based on the guid-based name of the
server.

Arguments:

    pTransport - The Smtp.pszSmtpAddress field in the transport is updated

Return Value:

    DWORD - success if smtp not installed, otherwise
       hresult error if anything goes wrong

--*/

{
    HRESULT hr;
    DWORD status;
    LPWSTR pszDomain, pszOfficialMailAddress = NULL;
    BOOL fIsGuidBasedName = FALSE;
    BOOL fMailAddressSyntaxIsBad = FALSE;
    LPWSTR pwzRule = NULL;
    BSTR bstrRule = NULL;

    Assert( NULL == pTransport->Smtp.pszSmtpAddress );
    Assert( OWN_CRIT_SEC(pTransport->Lock) );

    if (pTransport->fShutdownInProgress) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    // SMTP must be installed (not nec. running) in order to set up
    if ( (!servicePresent("SmtpSvc")) ||
         (!servicePresent("IisAdmin")) ) {
        DPRINT( 1, "Dependent services not present, SMTP not configured.\n" );

        hr = S_OK;
        goto cleanup;
    }

    // SMTP administrative namespace must be available
    // If this fails, either IIS is disabled, or misconfigured
    // Warn the administrator infrequently
    if (FAILED(hr = CheckSmtpDomainContainerPresent())) {
        static DSTIME timeLastFailureLogged = 0;
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastFailureLogged)
            || (timeCurrent > (timeLastFailureLogged + NO_SMTP_DOMAIN_INTERVAL))) {
            // Log event to alert admin that we have no domain.
            timeLastFailureLogged = timeCurrent;
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_NO_SMTP_DOMAIN,
                              szInsertWin32Msg(hr),
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(hr),
                              &hr );
        }

        DPRINT1( 0, "Smtp Domain configuration not available, error 0x%x, SMTP not configured.\n",
                hr);

        hr = S_OK;
        goto cleanup;
    }

    // This check was needed before CDO was a regular part of the NT build.
    // CDOSYS.DLL sanity check. This dll should always be present
    if ( (!classPresent( &CLSID_Message )) ||
         (!classPresent( &CLSID_Configuration )) ||
         (!classPresent( &CLSID_DropDirectory )) ) {

        DPRINT(0,"One or more CDO classes not found - CDO not registered\n" );

        hr = REGDB_E_CLASSNOTREG;
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_CDO_CLASS_MISSING,
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto cleanup;
    }

    // Calculate official mail address
    status = DirGetServerSmtpAttributes( pTransport, &pszOfficialMailAddress );
    if (status != ERROR_SUCCESS) {
        // Error already logged
        DPRINT1( 0, "failed to get server mail address, error %d\n",
                 status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // See if we have a mail address attribute already set
    status = DirReadServerSmtpAttributes( pTransport );
    if (status != ERROR_SUCCESS) {
        // Error already logged
        DPRINT1( 0, "failed to read server mail address, error %d\n",
                 status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // Check if it is a guid-based name and syntax is correct
    if (pTransport->Smtp.pszSmtpAddress) {
#define UUID_STRING_LENGTH 36
        LPWSTR p1, p2;
        DWORD length;
        WCHAR szServerUuid[UUID_STRING_LENGTH + 1];
        UUID uuidServer;

        p1 = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
        if (p1) {
            p1++;
            p2 = wcschr( p1, L'.' );
            if (p2) {
                length = (DWORD) (p2 - p1);
            } else {
                length = 0;
            }
        } else {
            fMailAddressSyntaxIsBad = TRUE;
            length = 0;
        }
        if (length == UUID_STRING_LENGTH) {
            wcsncpy(szServerUuid, p1, length);
            szServerUuid[length] = L'\0';
            status = UuidFromStringW(szServerUuid, &uuidServer);
            fIsGuidBasedName = (status == ERROR_SUCCESS);
        }
        // Check that addressee is correct
        if (!fMailAddressSyntaxIsBad) {
            fMailAddressSyntaxIsBad =
                (_wcsnicmp( pTransport->Smtp.pszSmtpAddress,
                            USER_PREFIX, USER_PREFIX_LEN ) != 0 );
        }
    }

    // If we don't, set one up
    // If we have an address, if it is guid-based, check that it is correct
    // Otherwise, leave the address alone.  This allows a user-provided
    // mail address to override the official form.
    if ( (!pTransport->Smtp.pszSmtpAddress) ||
         ( (fIsGuidBasedName || fMailAddressSyntaxIsBad) &&
           (_wcsicmp( pTransport->Smtp.pszSmtpAddress,
                      pszOfficialMailAddress ) != 0 ) ) ) {
        // This call writes the new address and makes it the default
        status = DirWriteServerSmtpAttributes( pTransport,
                                               pszOfficialMailAddress);
        if (status != ERROR_SUCCESS) {
            DPRINT1(0,"Failed to auto configure mail address, error %d\n",
                    status );
            // Error already logged
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        } else if (!pTransport->Smtp.pszSmtpAddress) {
            status = ERROR_INCORRECT_ADDRESS;
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        } else {
            DPRINT1( 1, "This server was assigned mail address %ws\n",
                     pTransport->Smtp.pszSmtpAddress );
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_MAIL_ADDRESS,
                      szInsertWC(pTransport->Smtp.pszSmtpAddress ),
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        }
    }

    // Make sure guid-based mail routing domain is known to SMTP

    pszDomain = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
    if (pszDomain == NULL) {
        DPRINT1( 0, "Smtp address %ws is malformed\n",
                 pTransport->Smtp.pszSmtpAddress);
        hr = E_INVALIDARG;
        LogUnhandledError( hr );
        goto cleanup;
    }

    pszDomain++; // skip separator

    hr = AddSmtpDomainIfNeeded( pszDomain, pTransport->Smtp.bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1( 0, "AddSmtpDomain failed with error 0x%x\n", hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_DOMAIN_ADD_FAILURE,
                          szInsertWC(pszDomain),
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto cleanup;
    }

    // See if our event sink is already registered
    // Note that ismsink.dll has a registration dependency on seo.dll
    // This will only work if IIS is installed, which is implied by smtp check
    // TODO: how do we deregister when we demote?
    if (!classPresent( &CLSID_IsmSink1 )) {
        hr = registerInterfaceDll( "ismsink.dll", TRUE /* register */ );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to register ismsink.dll, error 0x%x\n", hr );
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_SMTP_SINK_REG_FAILURE,
                              szInsertWin32Msg(hr),
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(hr),
                              &hr );
            goto cleanup;
        } else {
            DPRINT( 1, "Successfully registered COM server ismsink.dll.\n" );
        }
    }

    // Create a filter rule to use with our binding
    // The rule is:
    //     RCPT TO=_IsmService@guid-based-domain
    // This will fire for mail addressed to us, and returned mail from the postmaster.
    // It will not fire for mail being routed through this system destined
    // for other servers

    pwzRule = NEW_TYPE_ARRAY(
        (DWORD)(RCPT_TO_RULE_LEN + wcslen( pTransport->Smtp.pszSmtpAddress ) + 1),
        WCHAR );
    if (pwzRule == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        LogUnhandledError( hr );
        goto cleanup;
    }
    wcscpy( pwzRule, RCPT_TO_RULE );
    wcscat( pwzRule, pTransport->Smtp.pszSmtpAddress );
    bstrRule = SysAllocString( pwzRule );
    if (bstrRule == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Bind our event sink to SMTPSVC, if necessary
    // We check this everytime we start in case IIS has been removed and re-added
    // TODO: When do we call unbind?

    hr = HrIsmSinkBinding( TRUE /* register */, bstrRule );
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to bind event sink, error 0x%x\n", hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_SINK_BIND_FAILURE,
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto cleanup;
    }

    hr = S_OK;

cleanup:

    if (pwzRule) {
        FREE_TYPE( pwzRule );
    }
    if (bstrRule) {
        SysFreeString( bstrRule );
    }
    if (pszOfficialMailAddress) {
        FREE_TYPE( pszOfficialMailAddress );
    }

    if (FAILED(hr)) {
        if (NULL != pTransport->Smtp.pszSmtpAddress) {
            FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
            pTransport->Smtp.pszSmtpAddress = NULL;
        }
    }

    return hr;
} /* configureMailAddress */


VOID
removeMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

    Undo the effects of configureMailAddress.
    Cleanup permanent changes to environment prior to service removal

    Environment:

    fShutdownInProgress is TRUE
    CDO Messages have been released
    COM is still running
    pTransport is largely intact

    At the time this is running, LDAP is not available. We do not try to
    remove the transport specific mail address.  It is largely irrelevant
    now since if this server is being demoted, it will not have a NT-DSA
    object and will not be a subject for replication.

Arguments:

    pTransport - Transport state object

Return Value:

    None.

--*/

{
    HRESULT hr;
    LPWSTR pszDomain, pszEnd;
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind;
    BOOL fMoreFound, fFilesRemaining;
    WCHAR szFileName[MAX_PATH];

    // Remove the smtp domain (if configured)

    if (pTransport->Smtp.pszSmtpAddress) {
        pszDomain = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
        if (pszDomain == NULL) {
            DPRINT1( 0, "Smtp address %ws is malformed\n",
                     pTransport->Smtp.pszSmtpAddress);
            hr = E_INVALIDARG;
            LogUnhandledError( hr );
        } else {
            pszDomain++; // Skip @
            hr = RemoveSmtpDomain( pszDomain );
            if (FAILED(hr)) {
                DPRINT1( 0, "RemoveSmtpDomain failed with error 0x%x\n", hr );
                LogEvent8WithData(DS_EVENT_CAT_ISM,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_ISM_SMTP_DOMAIN_REMOVE_FAILURE,
                                  szInsertWC(pszDomain),
                                  szInsertWin32Msg(hr),
                                  NULL, NULL, NULL, NULL, NULL, NULL,
                                  sizeof(hr),
                                  &hr );
                // Keep going
            } else {
                DPRINT1(0, "Removed Smtp Domain %ls\n", pszDomain );
            }
        }
    }

    // Remove any files in the Drop directory

    wcscpy( szFileName, pTransport->Smtp.bstrDropDirectory);
    pszEnd = szFileName + wcslen(pTransport->Smtp.bstrDropDirectory);
    *pszEnd++ = L'\\';

    wcscpy( pszEnd, L"*" );

    fFilesRemaining = FALSE;
    hFind = FindFirstFileW( szFileName, &FindFileData );
    if (hFind != INVALID_HANDLE_VALUE) {
        fMoreFound = TRUE;
        while ( fMoreFound ) {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                wcscpy( pszEnd, FindFileData.cFileName );
                if (!DeleteFileW( szFileName )) {
                    DPRINT1(0, "Failed to delete %ls\n", szFileName );
                    fFilesRemaining = TRUE;
                    // We don't log this error
                } else {
                    DPRINT1(1, "Deleted %ls\n", szFileName );
                }
            }
            fMoreFound = FindNextFileW( hFind, &FindFileData );
        }
        FindClose(hFind);
    }

    // Remove the drop directory itself
    // Don't even try if the directory is not empty
    if ( !fFilesRemaining ) {
        if (!RemoveDirectoryW(pTransport->Smtp.bstrDropDirectory)) {
            DPRINT1(0, "Failed to delete directory %ls\n",
                    pTransport->Smtp.bstrDropDirectory);
        } else {
            DPRINT1(1, "Deleted %ls\n", pTransport->Smtp.bstrDropDirectory);
        }
    }

} /* removeMailAddress */


VOID
disableMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

    Reset our configuration when SMTP service has been removed

    We leave the drop directory in place since this is tied to our service,
    not SMTPSVC.

    The SMTP domain registration was lost when SMTPSVC was deinstalled, so
    we don't try to remove it here.

    We need to handle the following removal scenarios
    1. We were configured, had a mail address attribute
    2. We are not configured, no mail address attribute
    3. We are not configured, lingering mail address attribute

    Removing the mail address attribute does not solve the problem. Without
    SMTP, there is no way for knowledge of the removal to replicate off the
    system.

Arguments:

    pTransport - 

Return Value:

    None

--*/

{
    // Mark ourselves as unconfigured so we will try again later

    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
        pTransport->Smtp.pszSmtpAddress = NULL;
    }

    // Warn the user once at removal time

    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
              NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

} /* disableMailAddress */


HRESULT
getDropDirectoryPath(
    BSTR *pbstrDropDirectory
    )

/*++

Routine Description:

Calculate the drop directory for the system and return it as a BSTR.
The drop directory is recalculated each startup according to the base
NTDS directories in the registry.
Here is the algorithm:
1. If the MAILPATH_KEY is present, it's value is used as an override
2. Otherwise we start with the LOGPATH_KEY.  We want the mail files to
follow the ntds files so they all stay together. The reason the mail files follow
the log and not the main database is that I figure they are both secondary,
supporting files to the main database.  Also, if the main database is
getting full, we want these files to migrate away as well.
2a. Prepend "Drop" as the subdirectory

Note that we expect these registry keys to only change between boots. You can
currently only change these keys during directory safe mode.

Arguments:

    pbstrDropDirectory - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr, dwFileAttributes;
    WCHAR wzPath[MAX_PATH];

    Assert( pbstrDropDirectory );

    // Construct the drop directory path
    // It comes from the mail path key, or if not defined, from the concatenation
    // of the logging path and the name Drop
    if (GetConfigParamW( MAKE_WIDE(MAILPATH_KEY), wzPath, MAX_PATH)){
        if (status = GetConfigParamW( MAKE_WIDE(LOGPATH_KEY), wzPath, MAX_PATH)){
            DPRINT1( 0, "LOGPATH_KEY not present, error %d\n", status );
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        }
        wcscat( wzPath, L"\\" );
        wcscat( wzPath, DROP_DIRECTORY );
    }

    // Make sure it exists
    dwFileAttributes = GetFileAttributesW( wzPath );
    if (dwFileAttributes == 0xffffffff) {
        status = GetLastError();
        if ( (status == ERROR_FILE_NOT_FOUND) ||
             (status == ERROR_PATH_NOT_FOUND) ) {
            if (!CreateDirectoryW( wzPath, NULL )) {
                status = GetLastError();
                DPRINT2( 0, "CreateDirectory(%ws) failed, error %d\n", wzPath, status );
                hr = HRESULT_FROM_WIN32( status );
                goto cleanup;
            }
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_DROP_DIRECTORY,
                      szInsertWC(wzPath),
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        } else {
            status = GetLastError();
            DPRINT2( 0, "GetFileAttributes(%ws) failed, error %d\n", wzPath, status );
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        }
    } else if ( (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
        DPRINT1( 0, "File %ws already exists, but is not a directory!\n", wzPath );
        hr = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
        goto cleanup;
    }

    // Allocate a return string for it
    *pbstrDropDirectory = SysAllocString( wzPath );
    if (*pbstrDropDirectory == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    DPRINT1( 1, "This server is using drop directory %ws\n", wzPath );

    hr = S_OK;
cleanup:
    return hr;
} /* getDropDirectoryPath */


HRESULT
SmtpInitialize(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

Initialize the Smtp specific aspects of the transport.

In this case, initialize COM so that we can use CDO V2

This is called by the Startup() entry point.  If things are amiss, IsmServ
will unload the dll and log a message.

PERF: Create one long lived drop directory object for the life of the dll?

Arguments:

    pTransport - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BOOLEAN fComInit = FALSE;

// NOTE: This code must return success when SMTP not installed

    // Initialize COM for multi-threaded application
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( (hr != S_OK) && (hr != S_FALSE) ) {
        DPRINT1( 0, "CoInitializeEx failed with error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }
    fComInit = TRUE;

    // We no longer call configureMailAddress at this point because it takes
    // too long. It will be called the first time the Receive or Send entry
    // points are called.

    // Calculate the drop directory
    
    pTransport->Smtp.bstrDropDirectory = NULL;
    hr = getDropDirectoryPath( &(pTransport->Smtp.bstrDropDirectory) );
    if (FAILED(hr)) {
        DPRINT1(0, "Failed to get drop directory, error 0x%x.\n", hr);
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_DROP_DIR_MISSING,
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr), &hr);
        goto cleanup;
    }

    hr = S_OK;
    fComInit = FALSE; // Don't clean this up

cleanup:

    if (fComInit) {
        CoUninitialize();
    }

    return hr;
} /* SmtpInitialize */


HRESULT
SmtpTerminate(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fRemoval
    )

/*++

Routine Description:

    Terminate the smtp transport functions

Arguments:

    pTransport - Transport object
    fRemoval - Whether service is being removed

Return Value:

    HRESULT - 

--*/

{
    DPRINT( 1, "Enter SmtpTerminate\n" );

    if (NULL != pTransport->Smtp.pvCurrentCollection) {
        IMessages *pIMessages = (IMessages *)pTransport->Smtp.pvCurrentCollection;
        pIMessages->Release();
        pTransport->Smtp.pvCurrentCollection = NULL;
        pTransport->Smtp.lCount = 0;
    }

    if (fRemoval) {
        DPRINT( 1, "Removal of ISMSERV/ISMSMTP requested.\n" );
        removeMailAddress( pTransport );
    }

    CoUninitialize();

    (VOID) ListDestroyList( SmtpServiceDestruct,
                            &(pTransport->ServiceListHead),
                            &(pTransport->ServiceCount) );

    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
    }

    if (pTransport->Smtp.bstrDropDirectory) {
        SysFreeString( pTransport->Smtp.bstrDropDirectory );
    }

    if (pTransport->Smtp.pvGuidTable) {
        SmtpDestroyGuidTable( (PGUID_TABLE) pTransport->Smtp.pvGuidTable );
    }

    MEMORY_CHECK_ALL();

    DPRINT( 1, "Exit SmtpTerminate\n" );

    return S_OK;
} /* SmtpTerminate */


HRESULT
attachMessageData(
    IN OUT CComPtr<IMessage> pIMsg,
    IN  const ISM_MSG *       pMsg
    )

/*++

Routine Description:

    Attach the ISM message data.

Arguments:

    pIMsg - 
    pMsg - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<_Stream> pStream;
    CComPtr<IBodyPart> pIBodyPart;
    VARIANT vBuffer;
    SAFEARRAY *psaData = NULL;

    // Allocate an array to describe the binary data
    hr = SafeArrayAllocDescriptor( 1, &psaData );
    if FAILED(hr) {
        DPRINT1(0, "Unable to SafeArrayAllocDescriptor, error 0x%x.\n", hr);
        LogUnhandledError( hr );
        goto exit;
    }

    // Initialize the array.  We construct the array manually so we can use
    // our own data which has been already allocated.
    psaData->cbElements = sizeof( char );
    psaData->pvData = pMsg->pbData;
    psaData->rgsabound[0].lLbound = 0;
    psaData->rgsabound[0].cElements = pMsg->cbData;

    // Set the body part options for binary data

    hr = pIMsg->get_BodyPart( &pIBodyPart );
    if FAILED(hr) {
        DPRINT1(0, "Unable to get_BodyPart, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->put_ContentTransferEncoding(cdoBase64);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_ContentTransferEncoding, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->put_ContentMediaType(cdoGif);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_ContentMediaType, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->GetDecodedContentStream(&pStream);
    if FAILED(hr) {
        DPRINT1(0, "Unable to GetDecodedContentStream, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pStream->put_Type(adTypeBinary);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_Type, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Write the binary data into the body
    VariantInit( &vBuffer );
    vBuffer.vt = VT_ARRAY | VT_UI1;
    vBuffer.parray = psaData;

    hr = pStream->Write(vBuffer);
    if FAILED(hr) {
        DPRINT1(0, "Unable to WriteStream, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pStream->Flush();
    if FAILED(hr) {
        DPRINT1(0, "Unable to Commit, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

exit:

    if (psaData != NULL) {
        HRESULT hr1;

        psaData->pvData = NULL;
        hr1 = SafeArrayDestroyDescriptor( psaData );
        if (FAILED(hr1)) {
            DPRINT1(0, "Unable to SafeArrayDestroyDescriptor, error 0x%x.\n", hr);
            LogUnhandledError( hr1 );
        }
    }

    if (pIBodyPart) {
        pIBodyPart = NULL;
    }
    if (pStream) {
        pStream = NULL;
    }

    return hr;
} /* attachMessageData */


HRESULT
getDropMessages(
    BSTR bstrDropDirectory,
    IDropDirectory **ppIDropDir,
    IMessages **ppIMessages,
    LONG *pCount
    )

/*++

Routine Description:

Helper routine to initialize a drop directory object, get the message
collection, and get the count of messages.

Note, drop directory and message collection must be freed by the caller!

Arguments:

    ppIDropDir - Returned pointer to drop directory object
    ppIMessages - Return pointer to message collection
    pCount - Returned count of messgaes

Return Value:

    HRESULT - 

--*/

{
    HRESULT     hr;

    Assert( ppIDropDir );
    Assert( ppIMessages );
    Assert( *ppIDropDir == NULL );
    Assert( *ppIMessages == NULL );

    // Create the drop directory object
    hr = CoCreateInstance(CLSID_DropDirectory, 
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDropDirectory,
                          (void**) ppIDropDir);
    if (FAILED(hr)) {
        DPRINT1(0, "CoCreateInstance(DropDirectory) failed, error 0x%x\n", hr);
        DPRINT(0, "Check that CDOSYS.DLL is registered via regsvc32\n" );
        LogCdoError( hr );
        goto cleanup;
    }

    // Get the object representing the list of all messages

    hr = (*ppIDropDir)->GetMessages(bstrDropDirectory, ppIMessages);
    if (FAILED(hr)) {
        DPRINT1(0, "getMessages() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }
    
    // Get count of messages

    *pCount = 0;
    hr = (*ppIMessages)->get_Count( pCount );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Count() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    DPRINT2( 1, "Found %d messages in the drop directory %ws\n",
             *pCount, bstrDropDirectory ? bstrDropDirectory : L"default" );

    return S_OK;

cleanup:

    if (*ppIMessages) {
        (*ppIMessages)->Release();
        *ppIMessages = NULL;
    }
    if (*ppIDropDir) {
        (*ppIDropDir)->Release();
        *ppIDropDir = NULL;
    }

    return hr;
} /* getDropMessages */


DWORD
SmtpSend(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  const ISM_MSG *       pMsg
    )

/*++

Routine Description:

   Send a message using the smtp transport.
   Message is sent as a binary blob.

   Our approach is to keep the dll running even when the smtp service is
   not running.  The dll can operate without the smtp
   service running since the CDO library only uses the file system for
   communication.

   We check for valid conditions when the ism server tries to use the dll
   for sending or receiving.

CDO provides three ways to send a message:
1. Send by pickup directory.  That is the default and what we are doing.  The
mail is actually "relayed", in the sense that it is received by here, queued,
and sent to the destination when possible.  Triggers OnArrival routine as
a mail receiption on localhost as well as ultimate destination host.
Benefit: if the destination is down, it will resend.
2. Send to local host and port.  Same as #1. The mail is received, queued, and
sent on when possible.
3. Send to destination host, using port number. The destination must be up.
OnArrival routine on triggered on destination.  No queuing on localhost.

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pMsg - 

Return Value:

    DWORD - 

--*/

{
    DWORD       status;
    HRESULT     hr;
    LPWSTR      pszSubject, pszMessageSubject, pszServer;
    DWORD       cchSubject;
    CComPtr<IMessage> pIMsg;
    BSTR bstrFrom = NULL, bstrTo = NULL, bstrSubj = NULL;

    if ( (!pTransport) ||
         (!pszRemoteTransportAddress) ||
         (!pszServiceName) ||
         (!pMsg) ) {
        status = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        LogUnhandledError( status );
        return status;
    }

    DPRINT4( 1, "SmtpSend, addr = %ws, serv = %ws, subj = %ws, size = %d\n",
             pszRemoteTransportAddress,
             pszServiceName,
             pMsg->pszSubject,
             pMsg->cbData );

    MEMORY_CHECK_ALL();

    // If we don't have a mail address, try to auto configure
    // A mailAddress attribute has to have been written in order for the KCC
    // to have created a mail-based replica.
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
            hr = configureMailAddress( pTransport );
        } else {
            hr = S_OK;
        }
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    if ( ( hr == S_OK ) &&
         ( NULL == pTransport->Smtp.pszSmtpAddress ) ) {
        // SMTP not installed
        hr = HRESULT_FROM_WIN32( ERROR_SERVICE_DOES_NOT_EXIST );
    }

    if (FAILED(hr)) {
        static DSTIME timeLastNoSmtpLogged = 0;
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastNoSmtpLogged)
            || (timeCurrent > (timeLastNoSmtpLogged + NO_SMTP_DOMAIN_INTERVAL))) {

            // Log event to alert admin we have no SMTP transport
            timeLastNoSmtpLogged = timeCurrent;
            DPRINT( 0, "Cannot send: SMTP transport not installed.\n" );
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        }
        return hr;
    }

    // CDO does not depend on any services to queue the message.
    // Some service needs to be running in order for the messages to get off
    // the machine.
    // That service could be SmtpSvc or Exchange

//***************************************************************************

    // Create an instance of the message object
    hr = CoCreateInstance(CLSID_Message, 
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IMessage,
                          (void**) &pIMsg);
    if FAILED(hr) {
        DPRINT1(0, "Unable to create CLSID_Message object, error 0x%x.\n", hr);
        DPRINT(0, "Check that CDOSYS.DLL is registered via regsvc32\n" );
        LogCdoError( hr );
        goto exit;
    }

    Assert( pTransport->Smtp.pszSmtpAddress );
    // Set the 'From' property.
    bstrFrom = SysAllocString( pTransport->Smtp.pszSmtpAddress );
    if (bstrFrom == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }

    hr = pIMsg->put_From( bstrFrom );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_From, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Determine the server to send to
    pszServer = wcschr( pszRemoteTransportAddress, L'@' );
    if (pszServer == NULL) {
        DPRINT1( 0, "Remote transport address %ws is malformed\n",
                 pszRemoteTransportAddress);
        hr = E_INVALIDARG;
        LogUnhandledError( hr );
        goto exit;
    }
    pszServer++;  // Skip separator

    // Set the 'To' property.
    bstrTo = SysAllocString( pszRemoteTransportAddress );
    if (bstrTo == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate to bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }
    hr = pIMsg->put_To( bstrTo );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_To, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // This field may be null
    pszMessageSubject = pMsg->pszSubject ? pMsg->pszSubject : L"";

    // Set the 'Subject' property.
    cchSubject = gcchSubjectFormat +
        wcslen(pszServiceName) + wcslen( pszMessageSubject );

    __try {
        pszSubject = (LPWSTR) alloca(cchSubject * sizeof(*pszSubject));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    swprintf(pszSubject, gszSubjectFormat, pszServiceName, pszMessageSubject);

    bstrSubj = SysAllocString( pszSubject );
    if (bstrSubj == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate subj bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }
    hr = pIMsg->put_Subject( bstrSubj );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_Subject, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Attach the data

    hr = attachMessageData( pIMsg, pMsg );
    if (FAILED(hr)) {
        DPRINT1(0, "Unable to attach message data, error 0x%x.\n", hr);
        // Event already logged at lower layer
        goto exit;
    }

    hr = supersedeMessage( pTransport,
                           pszRemoteTransportAddress,
                           pszServiceName,
                           pszMessageSubject,
                           pIMsg );
    if (FAILED(hr)) {
        DPRINT1(0, "Unable to supersede message, error 0x%x.\n", hr);
        // Keep going, not fatal
    }

//***************************************************************************

    // Serialize access to queue directory, by this dll anyway
    EnterCriticalSection(&QueueDirectoryLock);
    __try {

        // queue the message locally
        hr = pIMsg->Send();
    }
    __finally {
        LeaveCriticalSection(&QueueDirectoryLock);
    }

    if (FAILED(hr)) {
        DPRINT1(0, "Unable to Send(), error 0x%x.\n", hr);
        // Error will be logged at a higher level
        goto exit;
    }

exit:

    if (bstrFrom) {
        SysFreeString( bstrFrom );
    }
    if (bstrTo) {
        SysFreeString( bstrTo );
    }
    if (bstrSubj) {
        SysFreeString( bstrSubj );
    }

    MEMORY_CHECK_ALL();

    // IsmServ will log the send failure

    if (pIMsg) {
        pIMsg = NULL;
    }

    return hr;
} /* SmtpSend */



HRESULT
getIsmMsgFromAttachment(
    CComPtr<IMessage> pIMsg,
    OUT ISM_MSG **  ppMsg,
    LPWSTR pszMessageSubject
    )

/*++

Routine Description:

Read the contents of a message.  The message is read into the message
descriptor

Arguments:

    pIMsg - CDO message object
    ppMsg - New message descriptor allocated to repesent the decoded message

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IBodyPart> pIBodyPart;
    CComPtr<_Stream> pStream;
    VARIANT vBuffer;
    SAFEARRAY *psaData;
    ULONG cbData, cbDataAligned, len, subjectLength;
    BYTE *ptr;
    int i = 0;
    
    if (!pszMessageSubject) {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        LogUnhandledError( hr );
        return hr;
    }

    DPRINT1( 4, "getIsmMsgFromAttachment, subj=%ws\n", pszMessageSubject );

    VariantInit( &vBuffer );

    hr = pIMsg->get_BodyPart( &pIBodyPart );
    if (FAILED(hr)) {
        DPRINT1(0, "get_BodyPart() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pIBodyPart->GetDecodedContentStream(&pStream);
    if (FAILED(hr)) {
        DPRINT1(0, "get_GetDecodedContentStream() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pStream->Read(adReadAll, &vBuffer);
    if (FAILED(hr)) {
        DPRINT1(0, "Read() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    if (vBuffer.vt != (VT_ARRAY | VT_UI1)) {
        hr = E_INVALIDARG;
        DPRINT1(0, "ismsmtp, Body part type %d was not expected!\n",
                vBuffer.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    psaData = vBuffer.parray;
    cbData = psaData->rgsabound[0].cElements;
    cbDataAligned = ROUND_UP_COUNT( cbData, ALIGN_WCHAR );

    subjectLength = wcslen( pszMessageSubject );

// wlees Sep 1, 1998. Getting mysterious AVs while freeing messages. Switch
// to simpler buffer management until we can track this down

#ifdef NO_COPY
// Minimize the number of data copies by extracting the binary data right out
// of the returned safe array.  We free the array descriptor manually.  Later,
// when we free the message, we use the right OLE api to free the data

    // Allocate an ISM_MSG to hold the data
    *ppMsg = NEW_TYPE( ISM_MSG );
    if (NULL == *ppMsg) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup;
    }

    // Steal the data chuck out of the safe array.

    (*ppMsg)->cbData = cbData;
    (*ppMsg)->pbData = (BYTE *) psaData->pvData;

    // Free the descriptor manually.

    psaData->rgsabound[0].cElements = 0;
    psaData->pvData = NULL;

    hr = SafeArrayDestroyDescriptor( psaData );
    if (FAILED(hr)) {
        DPRINT1(0, "SafeArrayDestroyDescriptor() failed, error 0x%x\n", hr);
        // keep going
    }

    // No need to free this now
    vBuffer.vt = VT_EMPTY;
    vBuffer.parray = NULL;

    // Allocate a subject
    (*ppMsg)->pszSubject = NEW_TYPE_ARRAY( subjectLength + 1, WCHAR );
    wcscpy( (*ppMsg)->pszSubject, pszMessageSubject );

#else
    // Allocate a buffer for the ISM_MSG, the data, and the subject string
    len = sizeof( ISM_MSG ) + 
        cbDataAligned +
        (subjectLength + 1) * sizeof( WCHAR );
    *ppMsg = (ISM_MSG *) NEW_TYPE_ARRAY( len, CHAR );
    if (NULL == *ppMsg) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        LogUnhandledError( hr );
        goto cleanup;
    }
    (*ppMsg)->cbData = cbData;
    ptr = (BYTE *) &( (*ppMsg)[1] ); // point past struct
    (*ppMsg)->pbData = ptr;
    // PERF: this is a data copy
    memcpy( ptr, psaData->pvData, cbData );
    ptr += cbDataAligned;
    Assert( POINTER_IS_ALIGNED( ptr, ALIGN_WCHAR ) );
    (*ppMsg)->pszSubject = (LPWSTR) ptr;
    wcscpy( (*ppMsg)->pszSubject, pszMessageSubject );
#endif

    hr = NOERROR;

cleanup:

    if (pIBodyPart) {
        pIBodyPart = NULL;
    }
    if (pStream) {
        pStream = NULL;
    }

    if (vBuffer.vt != VT_EMPTY) {
        VariantClear( &vBuffer );
    }

    if FAILED(hr) {
        Assert(NULL == *ppMsg);
    }
    else {
        Assert(NULL != *ppMsg);
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "NTDS ISM SMTP failed to read a message stream, error 0x%x\n", hr );
    }

    return hr;
} /* getIsmMsgFromAttachment */


VOID
SmtpFreeMessage(
    IN ISM_MSG *pMsg
    )

/*++

Routine Description:

Free the message alllocated by SmtpReceive.

This routine has the actual knowledge of how the data should be deallocated.

Arguments:

    pMsg - ism message descriptor

Return Value:

    None

--*/

{
    HRESULT hr;
    SAFEARRAY saData;

    Assert( pMsg );
    Assert( pMsg->pbData );

    DPRINT1( 3, "SmtpFreeMessage, size = %d\n", pMsg->cbData );

#ifdef NO_COPY
    // Whip up a phony safe array descriptor to describe the data
    // Try to use it to deallocate the data
    // Hope that this descriptor is close enough to the one originally
    // allocated.  Note if we have problems, we may need to see what the
    // "features" field had at time of allocation, and set accordingly.

    ZeroMemory( &saData, sizeof( SAFEARRAY ) );
    saData.cDims = 1;
    saData.cbElements = sizeof( char );
    saData.pvData = pMsg->pbData;
    saData.rgsabound[0].lLbound = 0;
    saData.rgsabound[0].cElements = pMsg->cbData;

    hr = SafeArrayDestroyData( &saData );
    if (FAILED(hr)) {
        DPRINT1( 0, "SafeArrayDestroyData failed with error 0x%x\n", hr );
    }

    if (pMsg->pszSubject) {
        FREE_TYPE( pMsg->pszSubject );
    }
#else
    // In this mode, data allocated with the msg descriptor
#endif

    pMsg->cbData = 0;
    pMsg->pbData = NULL;

    FREE_TYPE( pMsg );

} /* SmtpFreeMessage */


BOOL
messageIsDuplicate(
    PGUID_TABLE pGuidTable,
    BSTR bstrFrom,
    BSTR bstrSubject,
    IMessage *pIMsg
    )

/*++

Routine Description:

We can take advantage of the fact that all messages have a message guid, and that
retried messages have a supersedes guid.  As we receive messages, we record the
message guid in a guid table.  The guid table is only for the current drop
directory.  If the message we receive has a supersedes guid, we check to see if
that superseded guid is in the table.  If so, then we have recently seen the
predecessor of the current message, and we do not have to process the current
message.

The reason that we only consider messages in the current drop directory to be
candidates for recently seen messages is that mail delivery is unreliable.  The
fact that we have seen a request mail doesn't mean the reply was delivered.  The
requestor may send us the same request again for legitimate reasons and we
don't want to drop it on the floor.  The current drop directory becomes a kind
of simple grouping mechanism: all messages in the same drop directory instance
we received together in time and can be treated as equivalent.

Arguments:

    pGuidTable - Table of guid's recently seen
    bstrFrom - From field from message
    bstrSubject - Subject field from message
    pIMsg - Current message object

Return Value:

    BOOL - 

--*/

{
    HRESULT hr;
    BOOL fResult = FALSE;   // say no if not sure
    CComPtr<Fields> pFields;
    GUID guidMessage, guidSupersedes;

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Record that we have seen this message
    // Note that we record the message as seen regardless of whether we later
    // decide to discard it as a duplicate.  This is because of the transitive
    // nature of the supersedes guid:
    // message A
    // message B, supersedes A
    // message C, supersedes B
    // A is accepted, B is a duplicate of A, and in order to suppress C,
    // we must note B as seen, which it was transitively.

    hr = getFieldGuid( pFields, SMTP_MSG_GUID, &guidMessage );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to guid field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // If the message has a guid
    if (memcmp( &guidMessage, &zeroGuid, sizeof(GUID) ) != 0) {
        // Insert in table of guids that have been seen
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &guidMessage, &pszUuid );
        DPRINT1( 4, "Message contains messageGuid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif
        if (!SmtpGuidInsertInTable( pGuidTable, &guidMessage )) {
            DPRINT( 0, "Failed to insert msg guid into table\n" );
            // Keep going
        }
    } else {
        DPRINT2( 0, "Warning: Message from %ws, subject %ws lacks a message guid.\n",
                 bstrFrom, bstrSubject );
    }

    // See if there is a supersedes guid in the message
    hr = getFieldGuid( pFields, SMTP_SUPERSEDES_MSG_GUID, &guidSupersedes );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to guid field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    if (memcmp( &guidSupersedes, &zeroGuid, sizeof(GUID) ) != 0) {
        // See if we've seen the prior message
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &guidSupersedes, &pszUuid );
        DPRINT1( 4, "Message contains supersedesGuid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif
        if (SmtpGuidPresentInTable( pGuidTable, &guidSupersedes )) {
            // It is a duplicate of a message we have seen recently
            fResult = TRUE;
            goto cleanup;
        }
    }

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return fResult;
} /* messageIsDuplicate */



HRESULT
parseDeliveryStatus(
    CComPtr<IBodyPart> pBodyPart,
    LPWSTR pszExpectedContentType,
    BSTR *pbstrText
    )

/*++

Routine Description:

This is a helper routine to parse the delivery status section of a
delivery status report.

Arguments:

    pBodyPart - 
    pszExpectedContentType - 
    pbstrText - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrContentType = NULL;
    CComPtr<_Stream> pStream;
    StreamTypeEnum streamType;
    DWORD length;
    BSTR bstrCharset = NULL;

    hr = pBodyPart->get_ContentMediaType(&bstrContentType);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_ContentMediaType, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    if (_wcsicmp( bstrContentType, pszExpectedContentType ) != 0) {
        hr = E_INVALIDARG;
        DPRINT2( 0, "DSN does not have expected content type, expected = %ws, actual = %ws\n", pszExpectedContentType, bstrContentType );
        // Do not log
        goto cleanup;
    }

    // Get the content stream
    hr = pBodyPart->GetDecodedContentStream(&pStream);
    if (FAILED(hr)) {
        DPRINT1(0, "get_GetDecodedContentStream() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    // Check the stream type
    hr = pStream->get_Type( &streamType );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Type() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    if (streamType != adTypeText) {
        hr = E_INVALIDARG;
        DPRINT1(0, "ismsmtp, ndr, Stream type %d was not expected!\n",
                streamType );
        LogCdoError( hr );
        goto cleanup;
    }

    // Check the character set.  Adjust if not correct.
    // This works around a problem where body parts are incorrectly marked
    // with the wrong character set.
    hr = pStream->get_Charset( &bstrCharset );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Charset() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }
    if (_wcsicmp( bstrCharset, cdoISO_8859_1 ) != 0) {
        SysFreeString(bstrCharset);
        bstrCharset = SysAllocString( cdoISO_8859_1 );
        if (bstrCharset == NULL) {
            hr = E_OUTOFMEMORY;
            DPRINT( 0, "Failed to allocate from bstr\n" );
            LogUnhandledError( hr );
            goto cleanup;
        }
        hr = pStream->put_Charset( bstrCharset );
        if (FAILED(hr)) {
            DPRINT1(0, "set_Charset() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto cleanup;
        }
    }

    // Read it into a bstr
    hr = pStream->ReadText( adReadAll, pbstrText );
    if (FAILED(hr)) {
        DPRINT1(0, "ReadText(All) failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:
    if (bstrCharset) {
        SysFreeString(bstrCharset);
    }

    if (bstrContentType) {
        SysFreeString(bstrContentType);
    }
    if (pStream) {
        pStream = NULL;
    }

    return hr;
} /* parseDeliveryStatus */


HRESULT
parseNondeliveryReport(
    BSTR bstrSubject,
    CComPtr<IMessage> pIMsg
    )

/*++

Routine Description:

Decode a Nondelivery report.  It is encoded as a hierarchy of body parts:

root body part
   body part 1 - plain text, the session transcript
   body part 2 - message/delivery-status
         ... n-1
   body part n - message/rfc822, the original message

Warning, this may change in the future.  To accomodate this, we don't log
when we encounter unexpected syntax.  We simply stop parsing.  The caller
won't delete the report and the user can dispose of it himself. Note that we
do log function errors, since they should not happen.

We are only interested in the first and second parts

Arguments:

    pIMsg - 

Return Value:

    HRESULT - 

--*/

{
#define CDO_CONTENT_TYPE_MULTIPART_REPORT L"multipart/report"
#define CDO_CONTENT_TYPE_DELIVERY_STATUS L"message/delivery-status"
    DWORD win32Status;
    HRESULT hr;
    LONG count, i;
    CComPtr<IBodyPart> pRootBodyPart;
    CComPtr<IBodyParts> pBodyParts;
    BSTR bstrContentType = NULL;

    CComPtr<IBodyPart> pBodyPart;
    BSTR bstrText = NULL;
    LPWSTR pwzErrorString;

    // Get the root body part
    hr = pIMsg->get_BodyPart(&pRootBodyPart);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get root body part, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Get content type of whole message
    hr = pRootBodyPart->get_ContentMediaType(&bstrContentType);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_ContentMediaType, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // It better be a multi-part report
    if (_wcsicmp( bstrContentType, CDO_CONTENT_TYPE_MULTIPART_REPORT ) != 0) {
        hr = E_INVALIDARG;
        DPRINT2( 0, "DSN does not have expected content type, expected = %ws, actual = %ws\n", CDO_CONTENT_TYPE_MULTIPART_REPORT, bstrContentType );
        // Do not log
        goto cleanup;
    }

    // Get the collection of 1st level body parts
    hr = pRootBodyPart->get_BodyParts(&pBodyParts);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_BodyParts, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // See how many there are
    hr = pBodyParts->get_Count(&count);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_Count, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Should be atleast one
    if (count < 3) {
        hr = E_INVALIDARG;
        DPRINT( 0, "Malformed DSN doesn't have enough parts!\n" );
        // Do not log
        goto cleanup;
    }

    //DPRINT1( 0, "NDR has %d body parts\n", count );

// ***********************************************************************

    DPRINT1( 1, "ISM SMTP %ws:\n", bstrSubject );

    // Skip the first and the last

    count--;
    for( i = 2; i <= count; i++ ) {
        pBodyPart = NULL;
        bstrText = NULL;

        hr = pBodyParts->get_Item(i,&pBodyPart);
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to get_Item, error 0x%x\n", hr );
            LogCdoError( hr );
            goto loop_cleanup;
        }

        hr = parseDeliveryStatus( pBodyPart,
                                  (i == 1) ?
                                  cdoTextPlain :
                                  CDO_CONTENT_TYPE_DELIVERY_STATUS,
                                  &bstrText );
        if (FAILED(hr)) {
            DPRINT1( 0, "parseDeliveryStatus failed, error 0x%x\n", hr );
            // don't log
            goto loop_cleanup;
        }

        // This string is static and doesn't need to be freed
        pwzErrorString = parseStatus( bstrText, &win32Status );

        DPRINT4( 1, "\t(%d): Status: 0x%x - %ws\nText: %ws\n",
                 i, win32Status, pwzErrorString, bstrText );

        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_DSN,
                          szInsertWin32Msg(win32Status),
                          szInsertWC(pwzErrorString),
                          szInsertWC(bstrText),
                          NULL, NULL, NULL, NULL, NULL,
                          sizeof(win32Status),
                          &win32Status
            );


    loop_cleanup:
        pBodyPart = NULL;
        if(bstrText)
        {
            SysFreeString(bstrText);
        }
    }

    hr = S_OK;

cleanup:

    if(bstrContentType)
    {
        SysFreeString(bstrContentType);
    }

    pBodyParts = NULL;
    pRootBodyPart = NULL;

    return hr;
} /* parseNondeliveryReport */


HRESULT
scanMessages(
    IN TRANSPORT_INSTANCE *pTransport,
    IN IMessages *pIMessages,
    IN  LPCWSTR pszServiceName,
    IN OUT LONG *plCount,
    IN OUT PGUID_TABLE pGuidTable,
    OUT ISM_MSG **ppMsg
    )

/*++

Routine Description:

Enumerate the messages in the drop directory.  Return the first one.
Duplicates are eliminated as they are encountered in the drop directory.

If we encounter any nondelivery reports for ISM messages, we log and delete.

We loop through the messages in the drop directory.  We read the first message
each time.  At the end of the loop we delete the first message, making the
next one the first.  If we can dispose of the message in the loop because
it is a notification or a duplicate, we do so.  On the first valid message, we
break out of the loop and return.  If we can't read a message, we log an event
and delete it.

There is no notion of skipped messages. We don't track unreadable messages still
in the collection. Our current reading position is always at the start and we
expect we can delete each message as we go.  There are no errors returned out of this
routine. We always delete the message or return it.  When we exit the routine
there are no messages left, or we are returning a valid message.

The only exception to this is file busy errors.  If we get such
an error, we exit the loop and do not return a message.  This appears that the
drop directory is empty to the caller, and he will rebuild a new drop directory
collection at a later time and try again.

Arguments:

    pTransport - Transport object
    pIMessages - Collection of messages
    pszServiceName - Name of server we are looking for
    plCount - Pointer to count of how many left to read. This is updated
               as we read each so we don't read them again next time
    pGuidTable - pointer to guid table to track duplicates
    ppMsg - Pointer to receive a message

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr, hr1;
    CComPtr<IMessage> pIMsg;
    BSTR bstrSubject, bstrTo, bstrFrom;
    LPWSTR pszMsgForServiceName, pszMessageSubject;
    BOOL done, busy;

    DPRINT1( 2, "scanning message collection entry, %d unread\n", *plCount );

    Assert( pIMessages );
    Assert( plCount );
    Assert( *plCount >= 1 );
    Assert( ppMsg );
    Assert( *ppMsg == NULL );

    // Initial conditions: not done, not busy and atleast one message

    // Note the structure of this loop.  We have to go through the next_
    // message processing at the bottom to free the resources.  The only way
    // out is through the for test at the bottom of the loop.

    done = busy = FALSE;
    do {
        DWORD busyTries = 0, waitCode;
        bstrSubject = bstrTo = bstrFrom = NULL;

        // We always read the first message
        // Each time we delete message 1, moving the rest up

        // If shutdown detected exit immediately
        if (pTransport->fShutdownInProgress) {
            DPRINT(2, "Message was skipped due to shutdown\n");
            hr = S_OK;
            busy = TRUE;
            goto next_message;
        }

        // NOTE: Busy retry loop could be avoided with an improved ismsink.dll
        // paragdigm -- see bug 88430: ISM SMTP sink should pre-process received
        // messages.
        
        // Read a message with retry
        // Deal with contention with writer process. This is a fact of life since
        // we will try to read a new file as soon as it appears in the directory.
        
        while (1) {
            hr = pIMessages->get_Item(1,&pIMsg);
            if (FAILED(hr)) {
                DPRINT1(0, "get_Item(1) failed, error 0x%x\n", hr);
                LogCdoError( hr );
                goto next_message;
            }

            // This is the first field we read from the message. If something is going
            // to fail, this is where it happens
            hr = pIMsg->get_To( &bstrTo );

            // Workaround. It appears that CDO will succeed with an empty value
            // when there is a sharing violation.
            if ( (SUCCEEDED(hr)) && ((bstrTo == NULL) || (wcslen(bstrTo) == 0)) ) {
                DPRINT( 1, "get_To returned empty string, treating as busy.\n" );
                hr = HR_SHARING_VIOLATION;
            }

            if ( (hr != HR_SHARING_VIOLATION) ||
                 (busyTries > 4) ||
                 (pTransport->fShutdownInProgress) ) {
                break;
            }
            busyTries++;
            DPRINT1( 1, "get_To returned busy, try %d\n", busyTries );
            pIMsg = NULL; // Cleanup old instance
            // Sleep while watching for shutdown
            waitCode = WaitForSingleObject( pTransport->hShutdownEvent,
                                            15 * 1000 );
            if (waitCode == WAIT_OBJECT_0) {
                // Shutdown detected.
                // Treat as busy error so message won't be deleted
                break;
            }
        }
        if (FAILED(hr)) {
            if (hr == HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )) {
                // We can legitimately get a sharing violation if the dropping process
                // is not done writing the new message file yet
                DPRINT(2, "Message was skipped due to a sharing violation\n");
                hr = S_OK;
                busy = TRUE;
            } else {
                DPRINT1(0, "get_To() failed, error 0x%x\n", hr);
                LogCdoError( hr );
            }
            goto next_message;
        }
        if ( (bstrTo == NULL) || (wcslen( bstrTo ) == 0) ) {
            DPRINT( 0, "To: field in Ism Message is empty\n" );
            goto next_message;
        }

        hr = pIMsg->get_Subject( &bstrSubject );
        if (FAILED(hr)) {
            DPRINT1(0, "get_Subject() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto next_message;
        }
        if ( (bstrSubject == NULL) || (wcslen( bstrSubject ) == 0) ) {
            DPRINT( 0, "Subj: field in Ism Message is empty\n" );
            goto next_message;
        }

        hr = pIMsg->get_From( &bstrFrom );
        if (FAILED(hr)) {
            DPRINT1(0, "get_From() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto next_message;
        }
        if ( (bstrFrom == NULL) || (wcslen( bstrFrom ) == 0) ) {
            DPRINT( 0, "From: field in Ism Message is empty\n" );
            goto next_message;
        }

        // See if the message is addressed to us
        if (!mailAddressMatch( bstrTo, pTransport->Smtp.pszSmtpAddress )) {
            DPRINT1( 0, "Ism Message not addressed to this DSA: %ws\n", bstrTo );
            // We wouldn't be finding the message unless the @domain portion of
            // the address matches. Mail being sent to the wrong user?
            goto next_message;
        }

        // Sanity check subject for basic syntax
        if (_wcsnicmp(bstrSubject, SUBJECT_PREFIX, SUBJECT_PREFIX_LEN) != 0) {

            // Check for delivery status report
            hr = parseNondeliveryReport( bstrSubject, pIMsg );
            if (SUCCEEDED(hr)) {
                goto next_message;
            }

            // Not an ISM message.
            DPRINT3(0, "IsmSmtp: Ignoring non-ISM message to %ws from %ws with subject \"%ls\".\n",
                    bstrTo, bstrFrom, bstrSubject);
            goto next_message;
        }

        // Check if message is a recently seen duplicate
        if (messageIsDuplicate(
            pGuidTable,
            bstrFrom,
            bstrSubject,
            pIMsg)) {

            DPRINT2( 1, "Duplicate message suppressed: From: \"%ws\", Subject: \"%ws\"\n",
                     bstrFrom, bstrSubject );

            // Note that we can get into a tight loop identifying and
            // deleting duplicates if there are many of them. This will be
            // true if the machine has been down or the ismserv had been
            // stopped. We will detect shutdown above. Do we need to return
            // the thread to the ismserv after every x messages so we don't
            // hog the thread?

            goto next_message;
        }

        // Looks like an ISM message.
        pszMsgForServiceName = bstrSubject + SUBJECT_PREFIX_LEN;
        pszMessageSubject = wcsstr( pszMsgForServiceName, SUBJECT_SEPARATOR );
        if (!pszMessageSubject) {
            // malformed subject line
            DPRINT1( 0, "Ism message subject line is malformed: %ws\n",
                     pszMsgForServiceName );
            goto next_message;
        }
        *pszMessageSubject = L'\0';
        pszMessageSubject += SUBJECT_SEPARATOR_LEN; // Skip over

        DPRINT2(3, "Message appears to be for service \"%ls\", from %ws.\n",
                pszMsgForServiceName, bstrFrom);

        // It is implicit in the design of this message loop that there is only
        // one type of service per drop directory.  This is fine in product 1
        // where the only client of ISM SMTP is NTDS Replication.  In the future we
        // will need to have child drop directories, one per service.  This is not
        // hard: the sink needs to save the incoming message in the right child.
        // That means we don't need a private domain either.
        if (_wcsicmp(pszServiceName, pszMsgForServiceName)) {
            // Not for us
            DPRINT1( 0, "Ism message is in wrong drop directory, claiming to be for service %ws\n", pszMsgForServiceName );
            goto next_message;
        }

        hr = getIsmMsgFromAttachment( pIMsg, ppMsg, pszMessageSubject );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to decode message, error 0x%x\n", hr );
            goto next_message;
        }

        Assert( *ppMsg );
        DPRINT3( 1, "SmtpReceive, from %ws, subj %ws, size %d bytes.\n",
                pszServiceName, (*ppMsg)->pszSubject, (*ppMsg)->cbData );

        done = TRUE;

    next_message:

        // If we are not in the busy state, try to remove a message we read.  If we
        // fail, put ourselves in the busy state.
        if (!busy) {
            hr1 = pIMessages->Delete( 1 );
            if (SUCCEEDED(hr1))
            {
                (*plCount)--;
            } else {
                // Note we can be in the strange position of having a valid message
                // but not being able to delete it.  We don't want to return a
                // message we can't delete, since we will read it again, causing
                // duplicates.
                DPRINT1(0, "Delete() failed, error 0x%x\n", hr1);
                if (hr1 != HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )) {
                    LogCdoError( hr1 );
                    if (SUCCEEDED(hr)) {
                        hr = hr1;
                    }
                }
                done = FALSE;  // don't return message
                busy = TRUE;   // exit message loop
            }
        }

        // Log an event on failure to read a message
        // Note, pIMsg may be NULL at this point
        if (FAILED(hr)) {
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_SMTP_MSG_UNREADABLE,
                              szInsertUL(1),
                              szInsertWC( pTransport->Smtp.bstrDropDirectory ),
                              szInsertWin32Msg(hr),
                              NULL, NULL, NULL, NULL, NULL,
                              sizeof(hr),
                              &hr );
        }

        // Since this can take a while to work through a large backlog, let
        // the user know the progress we've made
        if ( ( *plCount >= 1 ) && ((*plCount % 50) == 0) ) {
            DPRINT1( 0, "There are %d SMTP messages remaining to be processed.\n",
                     *plCount );

            LogEvent(DS_EVENT_CAT_ISM,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_ISM_SMTP_MESSAGE_COUNT,
                     szInsertUL(*plCount),
                     szInsertWC(pTransport->Smtp.bstrDropDirectory),
                     NULL );
        }

        // Clean up if necessary

        if ( (!done) && (*ppMsg) ) {
            SmtpFreeMessage( *ppMsg );
            *ppMsg = NULL;
        }

        if (pIMsg) {
            pIMsg = NULL;
        }

        if (bstrSubject != NULL) {
            SysFreeString( bstrSubject );
        }
        if (bstrTo != NULL) {
            SysFreeString( bstrTo );
        }
        if (bstrFrom != NULL) {
            SysFreeString( bstrFrom );
        }
    }
    while ((!done) && (!busy) && (*plCount));

    // Termination conditions:
    Assert( (*plCount == 0) ||
            (done) && (*ppMsg) ||
            (busy)
        );

    DPRINT1( 2, "scanning message collection exit, %d remaining\n", *plCount );

    hr = S_OK;

    return hr;

} /* scanMessages */


HRESULT
getMailMessage(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    )

/*++

Routine Description:

This is a wrapper around the scanMessages function.  It handles
caching of the current collection.  We only get a collection once from the
drop directory, and eliminate duplicates once.

Arguments:

    pTransport - 
    pszServiceName - 
    ppMsg - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IDropDirectory> pIDropDir;
    IMessages *pIMessages =
        (IMessages *) pTransport->Smtp.pvCurrentCollection;
    PGUID_TABLE pGuidTable = (PGUID_TABLE) pTransport->Smtp.pvGuidTable;

    Assert( ppMsg );
    Assert( *ppMsg == NULL );   // we don't have a message yet

    // If we already have a collection in progress, use it
    if (pIMessages) {

        hr = scanMessages(
            pTransport,
            pIMessages,
            pszServiceName,
            &(pTransport->Smtp.lCount),
            pGuidTable,
            ppMsg );

        // If we got a message, return it
        if ( (SUCCEEDED(hr)) && (*ppMsg) ) {
            goto cleanup;
        }

        // No message left in current collection, get rid of it
        pIMessages->Release();
        pIMessages = NULL;
        pTransport->Smtp.lCount = 0;
        SmtpDestroyGuidTable( pGuidTable);
        pGuidTable = NULL;
    }

    // We don't have a current collection
    Assert( pTransport->Smtp.lCount == 0);

    // Get the collection of messages
    hr = getDropMessages( pTransport->Smtp.bstrDropDirectory,
                          &pIDropDir,
                          &pIMessages,
                          &(pTransport->Smtp.lCount) );
    if (FAILED(hr)) {
        DPRINT1(0, "getDropMessages failed, error 0x%x\n", hr);
        // Status already logged
        goto cleanup;
    }

    Assert( pIDropDir );
    Assert( pIMessages );

    // The way the notification mechanism works, we may receive a notification
    // before the file appears in the drop directory. We delay here in order
    // to give time for the file to arrive.  A better approach would be to have
    // the sink write the file itself before signalling the event.
    //
    // See bug 88430: ISM SMTP sink should pre-process received messages.

    // Only wait when no messages pending, so that under load we pay no penelty
    if (pTransport->Smtp.lCount == 0) {
        DWORD waitCode;

        // Call destructors
        pIMessages->Release();
        pIMessages= NULL;
        pIDropDir = NULL;

        // Sleep( 10 * 1000 ) while waiting for shutdown
        waitCode = WaitForSingleObject( pTransport->hShutdownEvent, 10 * 1000 );
        if (waitCode == WAIT_OBJECT_0) {
            // Shutdown requested
            hr = S_OK;
            goto cleanup;
        }

        hr = getDropMessages( pTransport->Smtp.bstrDropDirectory,
                              &pIDropDir,
                              &pIMessages,
                              &(pTransport->Smtp.lCount) );
        if (FAILED(hr)) {
            DPRINT1(0, "getDropMessages failed, error 0x%x\n", hr);
            // Message already logged
            goto cleanup;
        }

        Assert( pIMessages );

        // Sorry, no mail today
        if (pTransport->Smtp.lCount == 0) {
            hr = S_OK;
            goto cleanup;
        }
    }

    Assert( pTransport->Smtp.lCount >= 1 );

    // Create a new guid table for tracking duplicates
    pGuidTable = SmtpCreateGuidTable();
    if (pGuidTable == NULL) {
        DPRINT( 0, "failed to allocate guid table\n" );
        hr = HR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Try to get one out
    hr = scanMessages(
        pTransport,
        pIMessages,
        pszServiceName,
        &(pTransport->Smtp.lCount),
        pGuidTable,
        ppMsg );

cleanup:

    // Update context
    if ( (SUCCEEDED(hr)) &&
         (pTransport->Smtp.lCount > 0) ) {
        pTransport->Smtp.pvCurrentCollection = pIMessages;
        pIMessages = NULL;  // don't free
        pTransport->Smtp.pvGuidTable = pGuidTable;
        pGuidTable = NULL; // don't free
    } else {
        pTransport->Smtp.pvCurrentCollection = NULL;
        pTransport->Smtp.lCount = 0;
        pTransport->Smtp.pvGuidTable = NULL;
    }

    // Free resources if necessary
    if (pIMessages) {
        pIMessages->Release();
        pIMessages= NULL;
    }

    if (pIDropDir) {
        pIDropDir = NULL;
    }

    if (pGuidTable) {
        SmtpDestroyGuidTable( pGuidTable );
        pGuidTable = NULL;
    }

    return hr;
} /* getMailMessage */


DWORD
SmtpReceive(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    )

/*++

Routine Description:

API called by the server to retrieve a message.

This routine needs to return success if we are not configured yet.

Arguments:

    pTransport - 
    pszServiceName - 
    ppMsg - pointer to receive allocated message structure
    If NULL, notify instead of return a message

Return Value:

    DWORD - 

--*/

{
    HRESULT     hr;
    DWORD       winError;

    DPRINT1( 3, "SmtpReceive, serv = %ws\n", pszServiceName );

    MEMORY_CHECK_ALL();

    if ( (NULL == ppMsg) ||
         (NULL == pszServiceName) ) {
        return E_INVALIDARG;
    }

    // Default to "none waiting."
    *ppMsg = NULL;

    // If not configured, try to do so now
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
            hr = configureMailAddress( pTransport );
        } else {
            hr = S_OK;
        }
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to configure mail address, error 0x%x\n", hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
                  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        return hr;
    }

    // Smtp not installed, its ok
    if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
        DPRINT( 3, "SMTP not present, returning no messages\n");
        return S_OK;
    }

    // Synchronize access to drop directory

    EnterCriticalSection(&DropDirectoryLock);
    __try {
        hr = getMailMessage( pTransport, pszServiceName, ppMsg );
    }
    __finally {
        LeaveCriticalSection(&DropDirectoryLock);
    }

    MEMORY_CHECK_ALL();

    return hr;
} /* SmtpReceive */
