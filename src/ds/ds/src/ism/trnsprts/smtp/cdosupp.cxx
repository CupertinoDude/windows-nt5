/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cdosupp.cxx

Abstract:

    CDO support routines

Author:

    Will Lees (wlees) 20-Oct-1998

Environment:

Notes:

Revision History:

--*/

#include <ntdspchx.h>

#include <ismapi.h>
#include <debug.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_CDOSUPP

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

#include <atlbase.h>          // cccomptr
#include "cdosys.h"

#define DEBSUB "CDOSUPP:"

#include <smtpsink.h>
#include <initguid.h>
#include <seo.h>
#include <seoexports.h> // IEventUtil   

// This code fragment defines the CLSIDs and IIDs for the event sink
#include "smtpsink_i.c"

// This code fragment defines the CLSIDs and IIDs for the event package
#include "seo_i.c"

// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
DEFINE_GUID(GUID_PLAT_SMTPSVC, 
0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
DEFINE_GUID(SMTP_PLAT_SOURCE_TYPE_GUID,
0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// {4f803d90-fd85-11d0-869a-00c04fd65616}
DEFINE_GUID(SMTP_SOURCE_TYPE_GUID,
0x4f803d90, 0xfd85, 0x11d0, 0x86, 0x9a, 0x0, 0xc0, 0x4f, 0xd6, 0x56, 0x16);

// OnArrival category guid
//"{ff3caa23-00b9-11d2-9dfb-00C04FA322BA}"
DEFINE_GUID( CATID_SMTP_ON_ARRIVAL,
0xff3caa23, 0xb9, 0x11d2, 0x9d, 0xfb, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

#define STR_DISPLAY_NAME                 "ISM SMTP Transport"
#define STR_SINKCLASS                    "CDO2EventSink.IsmSink1"
#define LONG_PRIORITY                    8192

typedef HRESULT STDAPICALLTYPE REGISTER_SERVER_FN( VOID );

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Apr 26 10:02:58 1999 */

VOID
LogCdoErrorInternal(
    HRESULT hrError,
    ULONG ulInternalId
    );

BOOL
classPresent(
    IN const GUID *puuidClass
    );

BOOL
servicePresent(
    LPSTR ServiceName
    );

BOOL
mailAddressMatch(
    BSTR bstrAddress,
    LPWSTR Name
    );

HRESULT
getFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    );

HRESULT
putFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    );

HRESULT
getMessageId(
    IMessage *pIMsg,
    BSTR *pbstrId
    );

HRESULT
putFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    );

LPWSTR
parseStatus(
    BSTR bstrDeliveryStatus,
    LPDWORD pdwWin32Status
    );

HRESULT
registerInterfaceDll(
    LPSTR DllFilename,
    BOOL Register
    );

HRESULT
modifyExistingBinding(
    IEventBinding *pBinding,
    BSTR bstrDisplayName,
    BSTR bstrRule
    );

HRESULT
eventBindingPresent(
    IEventBindings *pBindings,
    BSTR bstrDisplayName,
    BSTR bstrRule
    );

HRESULT
HrIsmSinkBinding(
    BOOL fBindSink,
    BSTR bstrRule
    );

/* End Forward */


VOID
LogCdoErrorInternal(
    HRESULT hrError,
    ULONG ulInternalId
    )

/*++

Routine Description:

    Log a CDO error event

Arguments:

    hrError - Error status to be logged
    ulInternalId - Call site

Return Value:

    None

--*/

{
    LogEvent8WithData(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_CDO_ERROR,
                      szInsertWin32Msg(hrError),
                      szInsertUL(ulInternalId),
                      NULL, NULL, NULL, NULL, NULL, NULL,
                      sizeof(hrError),
                      &hrError );
} /* LogCdoErrorInternal */


BOOL
classPresent(
    IN const GUID *puuidClass
    )

/*++

Routine Description:

Determine if a given COM class is registered

Arguments:

    puuidClass - pointer to uuid of class, the CLSID or class-id

Return Value:

    BOOL - is it registered

--*/

{
#define CLASS_REG_PATH "SOFTWARE\\Classes\\CLSID\\{%s}"
    BOOL found = FALSE;
    CHAR keyPath[80];
    unsigned char *pszUuidString = NULL;
    DWORD status;
    HKEY hkKey = NULL;

    status = UuidToString( (GUID *) puuidClass, &pszUuidString );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        goto cleanup;
    }

    sprintf( keyPath, CLASS_REG_PATH, pszUuidString );

    status = RegOpenKey( HKEY_LOCAL_MACHINE, keyPath, &hkKey );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_FILE_NOT_FOUND) ) {
        DPRINT2( 0, "RegOpenKey %s failed, error %d\n", keyPath, status );
        LogUnhandledError( status );
        goto cleanup;
    }

    found = (status == ERROR_SUCCESS);

cleanup:

    if (pszUuidString) {
        RpcStringFree( &pszUuidString );
    }

    if (hkKey) {
        RegCloseKey( hkKey );
    }

    return found;
} /* classPresent */


BOOL
servicePresent(
    LPSTR ServiceName
    )

/*++

Routine Description:

Determine if a given service is installed.  We do this by checking the registry.

Arguments:

    ServiceName - Name of service to check

Return Value:

    BOOL - 

--*/

{
#define SERVICE_REG_PATH "SYSTEM\\CurrentControlSet\\Services\\%s"
    BOOL found = FALSE;
    CHAR keyPath[80];
    DWORD status;
    HKEY hkKey = NULL;

    sprintf( keyPath, SERVICE_REG_PATH, ServiceName );

    status = RegOpenKey( HKEY_LOCAL_MACHINE, keyPath, &hkKey );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_FILE_NOT_FOUND) ) {
        DPRINT2( 0, "RegOpenKey %s failed, error %d\n", keyPath, status );
        LogUnhandledError( status );
        goto cleanup;
    }

    found = (status == ERROR_SUCCESS);

cleanup:

    if (hkKey) {
        RegCloseKey( hkKey );
    }

    return found;
} /* servicePresent */


BOOL
mailAddressMatch(
    BSTR bstrAddress,
    LPWSTR Name
    )

/*++

Routine Description:

    See if the given name matches the mail address
    This handle the mail address syntax "person" <user@domain>
    A prefix match is done on the name, so that we may match on user only

Arguments:

    bstrAddress - 
    Name - 

Return Value:

    BOOL - 

--*/

{
    LPWSTR start;

    start = wcschr( bstrAddress, L'<' );
    if (start == NULL) {
        return FALSE;
    }
    start++;
    return (_wcsnicmp( start, Name, wcslen( Name ) ) == 0 );

} /* mailAddressMatch */


HRESULT
getFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    )

/*++

Routine Description:

Helper routine
Get the value of the named field out of a Field object
Returned as a variant, caller must free contents

Arguments:

    pFields - 
    FieldName - 
    pvarValue - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItemName = NULL;
    VARIANT vItemName;

    VariantInit( pvarValue );

    // Turn the field name in to a bstr
    bstrItemName = SysAllocString( FieldName );
    if (bstrItemName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Load the field name into a variant
    VariantInit( &vItemName );
    vItemName.vt = VT_BSTR;
    vItemName.bstrVal = bstrItemName;

    // Get a field object for the item
    hr = pFields->get_Item(vItemName, &pField);
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Item(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property out of the field object
    hr = pField->get_Value( pvarValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Value(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:

    if (pField) {
        pField = NULL;
    }
    if (bstrItemName) {
        SysFreeString( bstrItemName );
    }
    // No need to free vItemName

    return hr;
} /* getFieldVariant */


HRESULT
putFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    )

/*++

Routine Description:

Helper routine
Put the value of the named field in a Field object

Arguments:

    pFields - 
    FieldName - 
    pvarValue - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItemName = NULL;
    VARIANT vItemName;

    // Turn the field name in to a bstr
    bstrItemName = SysAllocString( FieldName );
    if (bstrItemName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Load the field name into a variant
    VariantInit( &vItemName );
    vItemName.vt = VT_BSTR;
    vItemName.bstrVal = bstrItemName;

    // Get a field object for the item
    hr = pFields->get_Item(vItemName, &pField);
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Item(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property out of the field object
    hr = pField->put_Value( *pvarValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to put_Value(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:

    if (pField) {
        pField = NULL;
    }
    if (bstrItemName) {
        SysFreeString( bstrItemName );
    }
    // No need to free vItemName

    return hr;
} /* putFieldVariant */


HRESULT
getMessageId(
    IMessage *pIMsg,
    BSTR *pbstrId
    )

/*++

Routine Description:

Return the message id of the message

Arguments:

    pIMsg - 
    pbstrFilename - pointer to receive bstr, caller must free

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Fields> pFields;
    VARIANT vMessageId;

    *pbstrId = NULL;

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        // This code is on the error handling path
        // Don't log
        // The system may be too hosed at this point to retrieve the message id
        goto cleanup;
    }

    hr = getFieldVariant( pFields, cdoMessageId, &vMessageId );
    if (FAILED(hr)) {
        DPRINT1( 0, "getFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    if (vMessageId.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Message id type %d was not expected!\n",
                vMessageId.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Steal the bstr out of the variant; don't clean up the variant

    *pbstrId = vMessageId.bstrVal;

    hr = S_OK;

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* getMessageId */


HRESULT
putFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    DWORD status;
    LPWSTR pwzUuidString = NULL;
    BSTR bstrGuid = NULL;
    VARIANT vGuid;

    VariantInit( &vGuid );

    status = UuidToStringW( (GUID *) pGuid, &pwzUuidString );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    bstrGuid = SysAllocString( pwzUuidString );
    if (bstrGuid == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    vGuid.vt = VT_BSTR;
    vGuid.bstrVal = bstrGuid;

    hr = putFieldVariant( pFields, FieldName, &vGuid );
    if (FAILED(hr)) {
        DPRINT1( 0, "putFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;

cleanup:
    if (pwzUuidString) {
        RpcStringFreeW( &pwzUuidString );
    }
    if (bstrGuid) {
        SysFreeString( bstrGuid );
    }

    return hr;
}


HRESULT
getFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    DWORD status;
    VARIANT vGuid;

    hr = getFieldVariant( pFields, FieldName, &vGuid );
    if (FAILED(hr)) {
        DPRINT1( 0, "getFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    if (vGuid.vt == VT_EMPTY) {
        ZeroMemory( pGuid, sizeof( GUID ) );
        goto cleanup;
    } else if (vGuid.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Guid type %d was not expected!\n", vGuid.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    status = UuidFromStringW( vGuid.bstrVal, pGuid );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    hr = S_OK;

cleanup:

    // Release resources in the variant
    if (vGuid.vt != VT_EMPTY) {
        VariantClear( &vGuid );
    }

    return hr;
}


LPWSTR
parseStatus(
    BSTR bstrDeliveryStatus,
    LPDWORD pdwWin32Status
    )

/*++

Routine Description:

Parse a delivery status message for the status: field.
Field is of the form class.subject.detail
Return a descriptive error string for each message

Arguments:

    bstrDeliveryStatus - String describing delivery status message to be
parsed.
    pdwStatus - Pointer to dword to receive closest win32 status

Return Value:

    LPWSTR - Error string returned

--*/

{
#define STATUS_KEYWORD L"Status: "
    LPWSTR pszStatus;
    LONG classCode = 0, subjectCode = 0, detailCode = 0;

    Assert( pdwWin32Status );

    pszStatus = wcsstr( bstrDeliveryStatus, STATUS_KEYWORD );
    if (pszStatus == NULL) {
        *pdwWin32Status = ERROR_INVALID_PARAMETER;
        return L"Cannot parse delivery status message";
    }

    pszStatus += wcslen( STATUS_KEYWORD );

    if (swscanf( pszStatus, L"%d.%d.%d", &classCode, &subjectCode, &detailCode )
        != 3) {
        *pdwWin32Status = ERROR_INVALID_PARAMETER;
        return L"Cannot parse status field";
    }

    // Any success
    if (classCode == 2) {
        *pdwWin32Status = ERROR_SUCCESS;
        return L"Success";
    }

    switch (subjectCode) {
    case 0:
        switch (classCode) {
        // Case 2 handled above
        case 4:
            *pdwWin32Status = ERROR_NETWORK_BUSY;
            return L"Transient failure, no other information";
        case 5:
            *pdwWin32Status = ERROR_CAN_NOT_COMPLETE;
            return L"Permanent failure, no other information";
        }
    case 1:
        *pdwWin32Status = ERROR_INCORRECT_ADDRESS;
        switch (detailCode) {
        case 1:
            return L"Bad destination mailbox address";
        case 2:
            return L"Bad destination system address";
        case 3:
            return L"Bad destination mailbox address syntax";
        case 4:
            return L"Destination mailbox address ambiguous";
        case 5:
            return L"Destination address valid";
        case 6:
            return L"Destination mailbox has moved, No forwarding address";
        case 7:
            return L"Bad sender's mailbox address syntax";
        case 8:
            return L"Bad sender's system address";
        }
        break;
    case 2:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_SERVICE_DISABLED;
            return L"Mailbox disabled, not accepting messages";
        case 2:
            *pdwWin32Status = ERROR_HANDLE_DISK_FULL;
            return L"Mailbox full";
        case 3:
            *pdwWin32Status = ERROR_DS_OBJ_TOO_LARGE;
            return L"Message length exceeds administrative limit";
        case 4:
            *pdwWin32Status = ERROR_TOO_MANY_OPEN_FILES;
            return L"Mailing list expansion problem";
        }
        break;
    case 3:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_HANDLE_DISK_FULL;
            return L"Mail system full";
        case 2:
            *pdwWin32Status = ERROR_SERVICE_DISABLED;
            return L"System not accepting network messages";
        case 3:
            *pdwWin32Status = ERROR_CALL_NOT_IMPLEMENTED;
            return L"System not capable of selected features";
        case 4:
            *pdwWin32Status = ERROR_DS_OBJ_TOO_LARGE;
            return L"Message too big for system";
        case 5:
            *pdwWin32Status = ERROR_BAD_CONFIGURATION;
            return L"System incorrectly configured";
        }
        break;
    case 4:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_HOST_UNREACHABLE;
            return L"No answer from host";
        case 2:
            *pdwWin32Status = ERROR_NETWORK_UNREACHABLE;
            return L"Bad connection";
        case 3:
            *pdwWin32Status = ERROR_FILE_NOT_FOUND;
            return L"Directory server failure";
        case 4:
            *pdwWin32Status = ERROR_NETWORK_UNREACHABLE;
            return L"Unable to route";
        case 5:
            *pdwWin32Status = ERROR_NETWORK_BUSY;
            return L"Mail system congestion";
        case 6:
            *pdwWin32Status = ERROR_DS_LOOP_DETECT;
            return L"Routing loop detected";
        case 7:
            *pdwWin32Status = ERROR_SEM_TIMEOUT;
            return L"Delivery time expired";
        }
        break;
    case 5:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_INVALID_FUNCTION;
            return L"Invalid command";
        case 2:
            *pdwWin32Status = ERROR_INVALID_DATA;
            return L"Syntax error";
        case 3:
            *pdwWin32Status = ERROR_TOO_MANY_OPEN_FILES;
            return L"Too many recipients";
        case 4:
            *pdwWin32Status = ERROR_INVALID_FUNCTION;
            return L"Invalid command arguments";
        case 5:
            *pdwWin32Status = ERROR_UNKNOWN_REVISION;
            return L"Wrong protocol version";
        }
        break;
    case 6:
        *pdwWin32Status = ERROR_BAD_FORMAT;
        switch (detailCode) {
        case 1:
            return L"Media not supported";
        case 2:
            return L"Conversion required and prohibited";
        case 3:
            return L"Conversion required but not supported";
        case 4:
            return L"Conversion with loss performed";
        case 5:
            return L"Conversion failed";
        }
        break;
    case 7:
        *pdwWin32Status = ERROR_ACCESS_DENIED;
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_CONNECTION_REFUSED;
            return L"Delivery not authorized, message refused";
        case 2:
            return L"Mailing list expansion prohibited";
        case 3:
            return L"Security conversion required but not possible";
        case 4:
            return L"Security features not supported";
        case 5:
            return L"Cryptographic failure";
        case 6:
            return L"Cryptographic algorithm not supported";
        case 7:
            return L"Message integrity failure";
        }
        break;
    }

    *pdwWin32Status = ERROR_DS_UNKNOWN_ERROR;
    return L"Unknown status code";

} /* parseStatus */


HRESULT
registerInterfaceDll(
    LPSTR DllFilename,
    BOOL Register
    )

/*++

Routine Description:

Invoke a COM dll's registration or deregistration entry point

Arguments:

    DllFilename - 
    Register - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr;
    HINSTANCE hDll = NULL;
    REGISTER_SERVER_FN *pfnRegisterServer, *pfnUnregisterServer;

    hDll = LoadLibrary( DllFilename );
    if (hDll == NULL) {
        status = GetLastError();
        DPRINT2( 0, "LoadLibrary(%s) failed with %d\n", DllFilename, status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    pfnRegisterServer = (REGISTER_SERVER_FN *) GetProcAddress( hDll, "DllRegisterServer" );
    pfnUnregisterServer = (REGISTER_SERVER_FN *) GetProcAddress( hDll, "DllUnregisterServer" );
    if ( (pfnRegisterServer == NULL) ||
         (pfnUnregisterServer == NULL) ) {
        status = GetLastError();
        DPRINT2( 0, "GetProcAddress(%s) failed with %d\n", DllFilename, status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    hr = S_OK;
    __try {
        if (Register) {
            hr = (*pfnRegisterServer)();
        } else {
            hr = (*pfnUnregisterServer)();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = GetExceptionCode();
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "Registration function failed with %d\n", hr );
    }

cleanup:
    if (NULL != hDll) {
        FreeLibrary(hDll);
    }

    return hr;
} /* registerInterfaceDll */


HRESULT
modifyExistingBinding(
    IEventBinding *pBinding,
    BSTR bstrDisplayName,
    BSTR bstrRule
    )

/*++

Routine Description:

Update the existing binding with new properties if necessary

Arguments:

    pBinding - 
    bstrRule - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IEventPropertyBag> pSourceProps = NULL;
    VARIANT vOldRule;

    VariantInit( &vOldRule );

    hr = pBinding->get_SourceProperties(&pSourceProps);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "Bindings.put_SourceProperties failed with error 0x%x\n", hr );
        goto cleanup;
    }

    // Get the old value of the rule
    hr = pSourceProps->Item( &CComVariant(CComBSTR(_T("Rule"))), &vOldRule );
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "SourceProps->Item(Rule) failed with error 0x%x\n", hr );
        goto cleanup;
    }

    if (vOldRule.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Rule type %d was not expected!\n", vOldRule.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // If changed, modify the rule
    if (_wcsicmp( vOldRule.bstrVal, bstrRule ) != 0 ) {
        hr = pSourceProps->Add(CComBSTR(_T("Rule")),&CComVariant(bstrRule));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop rule failed with error 0x%x\n", hr );
            goto cleanup;
        }

        hr = pBinding->Save();
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Save failed with error 0x%x\n", hr );
            goto cleanup;
        }

        DPRINT2( 1, "Event sink binding '%ws' Rule=%ws was modified.\n",
                 bstrDisplayName, bstrRule );
    }

cleanup:
    pSourceProps = NULL;

    if (vOldRule.vt != VT_EMPTY) {
        VariantClear( &vOldRule );
    }

    return hr;
} /* modifyBinding */


HRESULT
eventBindingPresent(
    IEventBindings *pBindings,
    BSTR bstrDisplayName,
    BSTR bstrRule
    )

/*++

Routine Description:

Check if the desired binding is present in the binding list.
If so, verify the fields are up to date

Arguments:

    pBindings - 
    bstrDisplayName - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IUnknown> pIUnknown;
    CComPtr<IEnumVARIANT> pIEnumVariant;
    CComPtr<IEventBinding> pBinding	= NULL;
    LONG count = 0;
    DWORD fetched;
    VARIANT varRet;
    BSTR bstrBindingDisplayName = NULL;
    BOOLEAN found;

    VariantInit( &varRet );

    // Get a new enumeration
    hr = pBindings->get__NewEnum( &pIUnknown );
    if (FAILED(hr))
        goto error_exit;

    // How many?
    hr = pBindings->get_Count(&count);
    if (FAILED(hr))
        goto error_exit;
    if (count == 0) {
        hr = S_FALSE;  // not found
        goto error_exit;
    }

    // Enumerate a series of variants
    hr = pIUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pIEnumVariant);
    if (FAILED(hr))
        goto error_exit;

    // Here is the search loop. We exit at the top. Resources released at loop end

    found = FALSE;
    hr = S_OK;
    while ( (hr == S_OK) && (!found) ) {

        // Get next item
        fetched = 0;
        hr = pIEnumVariant->Next(1UL,&varRet,&fetched);
        if ( FAILED(hr) || (!fetched) ) {
            hr = S_FALSE;
            goto loop_cleanup;
        }

        // Retrieve the binding
        hr = varRet.punkVal->QueryInterface(IID_IEventBinding,(void**)&pBinding);
        if (FAILED(hr)) {
            goto loop_cleanup;
        }

        // Get the display name
        hr = pBinding->get_DisplayName( &bstrBindingDisplayName );
        if (FAILED(hr)) {
            goto loop_cleanup;
        }

        // Does it match?
        if (_wcsicmp( bstrDisplayName, bstrBindingDisplayName ) == 0) {
            found = TRUE;

            hr = modifyExistingBinding( pBinding, bstrDisplayName, bstrRule );
            if (FAILED(hr)) {
                LogUnhandledError( hr );
                DPRINT1( 0, "modifyExistingBinding failed with error 0x%x\n", hr );
                goto loop_cleanup;
            }
        }

    loop_cleanup:
        // Loop resource release
        VariantClear(&varRet);
        pBinding = NULL;
        if (bstrBindingDisplayName) {
            SysFreeString( bstrBindingDisplayName );
            bstrBindingDisplayName = NULL;
        }
    }

    // hr == S_OK, found
    // hr == S_FALSE, not found
    // hr other, error

error_exit:

    return hr;
} /* eventBindingPresent */



HRESULT
HrIsmSinkBinding(
    BOOL fBindSink,
    BSTR bstrRule
    )

/* HrIsmSinkBinding()
 *
 * Credits: This code was obtained from Jeff Stammerjohn (jstammerj) of the
 * Exchange group.  It was modified to work as a CDO sink.

 * Purpose:
 *     Binds or unbinds the Ism sink
 *
 * Parameters:
 *     BOOL    fBindSink
 *                 TRUE  - bind the sink
 *                 FALSE - unbind the sink
 *     BSTR    bstrRule - rule to use when creating the binding
 *
 * Returns:
 *     HResult
 */

{
    HRESULT	hr = NULL;
    CComPtr<IEventUtil> pEventUtil = NULL;
    TCHAR szDisplayName[32]	= { NULL };
    CComPtr<IEventBindingManager> pBindingManager	= NULL;
    CComPtr<IEventBindings>	pBindings= NULL;
    CComPtr<IEventBinding> pBinding	= NULL;
    CComPtr<IEventPropertyBag> pSourceProps = NULL;

    // SEO.DLL sanity check. This dll should always be present
    if ( (!classPresent( &CLSID_CEventUtil )) ) {
        DPRINT(0,"One or more SEO classes not found - SEO not registered\n" );
        hr = REGDB_E_CLASSNOTREG;
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_CLASS_MISSING,
                          szInsertWC( L"SEO.DLL" ),
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto error_exit;
    }

    // Set up the default site (instance)
    lstrcpy(szDisplayName,_T("smtpsvc 1"));

    hr = CoCreateInstance(CLSID_CEventUtil,NULL,CLSCTX_ALL,IID_IEventUtil,(LPVOID *) &pEventUtil);
    if (FAILED(hr))
    {
        LogUnhandledError( hr );
        DPRINT1( 0, "CoCreateInstance CEventUtil failed with error 0x%x\n", hr );
        goto error_exit;
    }

    hr = pEventUtil->RegisterSource(CComBSTR((LPCWSTR) CStringGUID(SMTP_PLAT_SOURCE_TYPE_GUID)),
                                    CComBSTR((LPCWSTR) CStringGUID(GUID_PLAT_SMTPSVC)),
                                    1,
                                    CComBSTR(_T("smtpsvc")),
                                    CComBSTR(_T("")),
                                    CComBSTR(_T("event.metabasedatabasemanager")),
                                    CComBSTR(szDisplayName),
                                    &pBindingManager);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "RegisterSource smtpsvc failed with error 0x%x\n", hr );
        goto error_exit;
    }

    hr = pBindingManager->get_Bindings(CComBSTR((LPCWSTR) CStringGUID(CATID_SMTP_ON_ARRIVAL)),
									   &pBindings);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "get_Bindings failed with error 0x%x\n", hr );
        goto error_exit;
    }

    // Check if binding already registered

    hr = eventBindingPresent( pBindings, CComBSTR(STR_DISPLAY_NAME), bstrRule);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "eventBindingPresent failed with error 0x%x\n", hr );
        goto error_exit;
    }

    if (fBindSink)
    {
        if (hr == S_OK) {
            // Binding already present
            DPRINT2( 1, "Event sink binding '%s' %s already present.\n",
                     STR_DISPLAY_NAME, STR_SINKCLASS );
            goto error_exit;
        }
        // Create binding
        hr = pBindings->Add(CComBSTR((LPCWSTR) CStringGUID(CLSID_IsmSink1)),&pBinding);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Add failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->put_DisplayName(CComBSTR(STR_DISPLAY_NAME));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_DisplayName failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->put_SinkClass(CComBSTR(STR_SINKCLASS));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_SinkClass failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->get_SourceProperties(&pSourceProps);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_SourceProperties failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pSourceProps->Add(CComBSTR(_T("priority")),&CComVariant(LONG_PRIORITY));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop priority failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pSourceProps->Add(CComBSTR(_T("Rule")),&CComVariant(bstrRule));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop rule failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->Save();
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Save failed with error 0x%x\n", hr );
            goto error_exit;
        }

        DPRINT3( 1, "Event sink binding '%s' Class=%s Rule=%ws was added.\n",
                 STR_DISPLAY_NAME, STR_SINKCLASS, bstrRule );
    }
    else
    {
        if (hr == S_FALSE) {
            // Binding not present
            DPRINT2( 1, "Event sink binding '%s' %s is not present.\n",
                     STR_DISPLAY_NAME, STR_SINKCLASS );
            goto error_exit;
        }
        // Delete binding
        CComVariant vID (CComBSTR((LPCWSTR) CStringGUID(CLSID_IsmSink1)));
        
        hr = pBindings->Remove(&vID);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Remove failed with error 0x%x\n", hr );
            goto error_exit;
        }
    }
error_exit:

    return hr;
}

/* end cdosupp.cxx */
