/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    DNS Resolver Service

    Memory management.

Author:

    James Gilroy (jamesg)       March 2000

Revision History:

--*/


#include "local.h"


//
//  Note:  most records are created by dnsapi heap -- from
//  query or hosts file routines.  However, we do create
//  name error caching records ourselves using dnslib routines.
//
//  This means -- until we either
//      - extend query or dnslib record creation interfaces to
//        include heap parameter
//      - explicitly free and recreate
//      - tag records (dnsapi\not) somehow (flags field)
//  that
//  dnsapi and dnslib heaps MUST be the same.
//  With dnsapi now potentially having it's own heap, this means
//  dnslib should use dnsapi heap.
//
//  So we'll put off using the debug heap for dnslib.
//
//
//  Note the ideal solution:
//      - dnsapi (query and hosts file) creates records in
//          the cache heap (by passed heap handle)
//      - we create our NAME_ERROR records locally in that
//          heap also (our functionalize to dnsapi)
//      - copy for RPC can be in separate heap used only by MIDL
//      - we have a separate heap for other random crap in the process
//          


//
//  Counters for heap debugging
//

DWORD   g_ResAllocCount     = 0;
DWORD   g_ResAllocMemory    = 0;
DWORD   g_ResFreeCount      = 0;

DWORD   g_MidlAllocCount    = 0;
DWORD   g_MidlAllocMemory   = 0;
DWORD   g_MidlFreeCount     = 0;




//
//  RPC memory routines
//
//  These are called by the stub code generated by MIDL.
//

PVOID
WINAPI
MIDL_user_allocate(
    IN      size_t          Size
    )
{
    DNSDBG( HEAP, (
        "MIDL_user_allocate( %d )\n",
        Size ));

    g_MidlAllocCount++;
    g_MidlAllocMemory += Size;

    // return( ALLOCATE_HEAP( Size ) );
    // return  DnsApiAlloc( Size );

    return  Dns_Alloc( Size );
}

VOID
WINAPI
MIDL_user_free(
    IN OUT  PVOID           pMem
    )
{
    DNSDBG( HEAP, (
        "MIDL_user_free( %p )\n",
        pMem ));

    g_MidlFreeCount++;

    // FREE_HEAP( pMem );
    // DnsApiFree( pMem );

    Dns_Free( pMem );
}



//
//  Resolver heap routines
//
//  Currently (see note above) everything RPC, record allocs
//  and general allocs are in the same heap.
//  However the Tag field sets us up to dispatch to different
//  heaps.  The file and line info allow us to later use
//  debug heap routines.
//  

PVOID
Res_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    )
{
    DNSDBG( HEAP, (
        "Res_Alloc( %d, tag=%d )\n",
        Length,
        Tag ));

    g_ResAllocCount++;
    g_ResAllocMemory += Length;

    return  Dns_Alloc( Length );
}


PVOID
Res_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    )
{
    return  Dns_AllocZero( Length );
}


VOID
Res_Free(
    IN OUT  PVOID           pMemory,
    IN      DWORD           Tag
    )
{
    DNSDBG( HEAP, (
        "Res_Free( %p, tag=%d )\n",
        pMemory,
        Tag ));

    g_ResFreeCount++;

    Dns_Free( pMemory );
}

//
//  End memory.c
//
