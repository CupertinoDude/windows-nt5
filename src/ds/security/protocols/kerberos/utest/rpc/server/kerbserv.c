/****************************************************************************
                          Microsoft RPC Version 1.0
                         Copyright Microsoft Corp. 1992
                                Hello Example

    FILE:       hellos.c
    USAGE:      hellos
    PURPOSE:    Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "kerbtest.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -s authn service\n");
    exit(1);
}

HANDLE TerminateEvent;
ULONG AuthnService = RPC_C_AUTHN_GSS_KERBEROS;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszEndpoint         = "30760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    unsigned char * PrincipalName       = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
                case 'p':  // protocol sequence
                    pszProtocolSequence = argv[++i];
                    break;
                case 'e':
                    pszEndpoint = argv[++i];
                    break;
                case 'o':
                    pszOptions = argv[++i];
                    break;
                case 's':
                    sscanf(argv[++i],"%d",&AuthnService);
                    break;
                case 'h':
                case '?':
                default:
                    Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    printf("Server using protseq %s endpoint %s\n",pszProtocolSequence, pszEndpoint );
    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   3, // maximum concurrent calls
                                   pszEndpoint,
                                   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(srv_kerbtest_ServerIfHandle, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerInqDefaultPrincName(
                AuthnService,
                &PrincipalName
                );
    if (status)
    {
        printf("RpcServerInqDefaultPrincName returned %d\n",status);
        exit(2);
    }
    status = RpcServerRegisterAuthInfo(
                PrincipalName,
                AuthnService,
                NULL,
                NULL
                );

    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API
MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API
MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

ULONG
RecurseRemoteCall(
    ULONG Options,
    LPSTR RemoteAddress,
    LPSTR RemoteProtocol,
    LPSTR RemoteEndpoint,
    LPSTR Principal,
    LPSTR Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{

    unsigned char * pszStringBinding;
    RPC_STATUS status;
    handle_t BindingHandle;

    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(NULL,
                                     RemoteProtocol,
                                     RemoteAddress,
                                     RemoteEndpoint,
                                     NULL,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned %d\n", status);
        return(status);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &BindingHandle);

    RpcStringFree(&pszStringBinding);

    if (status) {

        printf("RpcBindingFromStringBinding returned %d\n", status);
        return(status);
    }


    //
    // Tell RPC to do the security thing.
    //

    printf("Binding auth info set to level %d, service %d, principal %s\n",
        AuthnLevel, AuthnService, Principal );
    status = RpcBindingSetAuthInfo(
                    BindingHandle,
                    Principal,
                    AuthnLevel,
                    AuthnService,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        return( status );
    }


    //
    // Do the actual RPC calls to the server.
    //


    RpcTryExcept {
        status = RemoteCall(
                    BindingHandle,
                    Options,
                    Address,
                    RemoteProtocol,
                    RemoteEndpoint,
                    Principal,
                    RemoteAddress,
                    AuthnLevel,
                    AuthnService,
                    RecursionLevel
                    );
        if (status != 0)
        {
            printf("RemoteCall failed: 0x%x\n",status);
        }

    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        printf("Runtime library reported an exception %d\n",
               RpcExceptionCode());

    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the binding handle


    status = RpcBindingFree(&BindingHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned %d\n", status);
        exit(2);
    }


}


ULONG
srv_RemoteCall(
    handle_t BindingHandle,
    ULONG Options,
    LPSTR RemoteAddress,
    LPSTR RemoteProtocol,
    LPSTR RemoteEndpoint,
    LPSTR Principal,
    LPSTR Address,
    ULONG AuthnLevel,
    ULONG AuthnSvc,
    ULONG RecursionLevel
    )
{
    RPC_STATUS RpcStatus;
    CHAR ClientName[100];
    ULONG NameLen = sizeof(ClientName);

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
        goto Cleanup;
    }
    GetUserName(ClientName,&NameLen);
    printf("Recursion %d: Client called: name = %s\n",RecursionLevel, ClientName);

    if (RecursionLevel != 0)
    {
        RpcStatus = RecurseRemoteCall(
                        Options,
                        RemoteAddress,
                        RemoteProtocol,
                        RemoteEndpoint,
                        Principal,
                        Address,
                        AuthnLevel,
                        AuthnSvc,
                        RecursionLevel - 1
                        );
    }
    RpcRevertToSelf();


Cleanup:


    return(RpcStatus);
}

void
srv_Shutdown(
    handle_t BindingHandle
    )
{
    RPC_STATUS status;

    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

