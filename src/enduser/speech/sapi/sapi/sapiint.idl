/****************************************************************************
*   sapiint.idl
*
*   This is the interface definition file for the Microsoft Speech API
*   Version 5.0.
*
*   It contains definitions only used internally.
*
*   Copyright 1998, 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

// wtypes.idl does not import basetsd.h in Windows CE.
#ifdef _WIN32_WCE
import "basetsd.h";
#endif

//--- Includes --------------------------------------------------------------
import "oaidl.idl";
import "ocidl.idl";
import "sapi.idl";
import "sapiddk.idl";

// Private core interfaces
interface ISpObjectTokenEnumBuilder;
interface _ISpRecoMaster;

// Private SR interfaces (PRIVATE)
interface _ISpRecoCtxtPrivate;
interface _ISpRecognizerPrivate;

// Private SR server interfaces (PRIVATE)
interface ISpServerCallContext;
interface ISpIPC;
interface ISpObjectRef;
interface ISpIPCObject;
interface ISpServer;

//--- CFG Engine
interface ISpCFGEngine;

//--- Interfaces used to communicate between processes
interface ISpCallSender;
interface ISpCallReceiver;
interface ISpCommunicator;
interface ISpCommunicatorInit;
interface ISpSapiServer;

// Private audio interfaces (PRIVATE)
interface ISpMMSysAudioConfig;

//--- Locally scoped define for LANGID
#ifndef LANGID
#define LANGID WORD
#endif

//--- Grammar Data formats
cpp_quote("EXTERN_C const GUID SPGDF_ContextFree;")

cpp_quote( "#define SP_ZWSP 0x200B" )
cpp_quote( "#define SP_ZWSPSTR L\"\x200B\"" )

//
// -- Define a "Relative Pointer" type which is used for serialized structures (just a byte offset)
//
typedef ULONG SPRELATIVEPTR;

typedef enum
{
    Uninitialized,
    Memory,
    File,
    Resource,
    Object
}  SPGRAMMARTYPE;

//
//--- Grammar Structure Definintions ----------------------------------------
//

const DWORD SPGF_RESET_DIRTY_FLAG = 0x80000000;

//
//  CFG rule (in binary format)
//
cpp_quote("#if 0")
typedef struct SPCFGRULE
{
    DWORD       FLAGS;
    DWORD       NameSymbolOffset;
    DWORD       RuleId;
} SPCFGRULE;
cpp_quote("#else")
cpp_quote("typedef struct SPCFGRULE")
cpp_quote("{")
cpp_quote("    DWORD       fTopLevel : 1;")
cpp_quote("    DWORD       fDefaultActive : 1;")
cpp_quote("    DWORD       fPropRule : 1;")
cpp_quote("    DWORD       fImport : 1;")
cpp_quote("    DWORD       fExport : 1;")
cpp_quote("    DWORD       fHasResources : 1;")
cpp_quote("    DWORD       fDynamic : 1;")
cpp_quote("    DWORD       fHasDynamicRef : 1;")
cpp_quote("    DWORD       FirstArcIndex : 22;")
cpp_quote("    DWORD       Reserved : 1;")
cpp_quote("    DWORD       fDirtyRule : 1;")
cpp_quote("    DWORD       NameSymbolOffset;")
cpp_quote("    DWORD       RuleId;")
cpp_quote("} SPCFGRULE;")
cpp_quote("#endif // 0")


//
//  An arc
//
cpp_quote("#if 0")
typedef [restricted] struct SPCFGARC
{
    DWORD  PART1;
    DWORD  PART2;
} SPCFGARC;
cpp_quote("#else")
cpp_quote("typedef struct SPCFGARC")
cpp_quote("{")
cpp_quote("    DWORD       fRuleRef : 1;")
cpp_quote("    DWORD       fLastArc : 1;")
cpp_quote("    DWORD       fHasSemanticTag : 1;")
cpp_quote("    DWORD       fLowConfRequired : 1;")
cpp_quote("    DWORD       fHighConfRequired : 1;")
cpp_quote("    DWORD       TransitionIndex : 22;   // If fRuleRef then index into rule table, else index in word table")
cpp_quote("    DWORD       Reserved1 : 5;")
cpp_quote("    DWORD       Weight : 8;")
cpp_quote("    DWORD       NextStartArcIndex : 22;")
cpp_quote("    DWORD       Reserved2 : 2;")
cpp_quote("} SPCFGARC;")
cpp_quote("#endif // 0")

//
//  An GLOBAL arc
//
cpp_quote("#if 0")
typedef [restricted] struct SPCFGGARC
{
    int         PART1;
} SPCFGGARC;
cpp_quote("#else")
cpp_quote("typedef struct SPCFGGARC")
cpp_quote("{")
cpp_quote("    DWORD       ArcIndex : 22;")
cpp_quote("    DWORD       ulGrammarID : 10;")
cpp_quote("} SPCFGGARC;")
cpp_quote("#endif // 0")




// NOTE -- Here are the declarations for supported variant types.  Note that the only one
// that will not fit into a byte is the VT_BYREF.  In the helper function Assign

// VT_EMPTY	= 0,
// VT_I2	= 2,
// VT_I4	= 3,
// VT_R4	= 4,
// VT_R8	= 5,
// VT_CY	= 6,
// VT_DATE	= 7,
// VT_BOOL	= 11,
// VT_I1	= 16,
// VT_UI1	= 17,
// VT_UI2	= 18,
// VT_UI4	= 19,
// VT_INT	= 22,
// VT_UINT	= 23,
// VT_BYREF	= 0x4000 -- This will be assigned SPVT_BYREF

const BYTE SPVT_BYREF = 0xFF;

typedef [restricted] struct SPVARIANTSUBSET
{
    union 
    {
        LONG lVal;
        BYTE bVal;
        SHORT iVal;
        FLOAT fltVal;
        DOUBLE dblVal;
        VARIANT_BOOL boolVal;
        CY cyVal;
        DATE date;
        PVOID byref;
        CHAR cVal;
        USHORT uiVal;
        ULONG ulVal;
        INT intVal;
        UINT uintVal;
    };
} SPVARIANTSUBSET;

//
//  Semantic tag
//
typedef [restricted] struct SPCFGSEMANTICTAG
{
    DWORD       StartArcIndex : 22;
    DWORD       fStartParallelEpsilonArc : 1;
    DWORD       dwReserved1 : 9;
    DWORD       EndArcIndex : 22;
    DWORD       fEndParallelEpsilonArc : 1;
    DWORD       dwReserved2 : 9;
    DWORD       PropVariantType : 8;
    DWORD       ArcIndex : 22;
    DWORD       dwReserved3 : 2;
    ULONG       PropNameSymbolOffset;
    DWORD       PropId;
    ULONG       PropValueSymbolOffset;
    // Field is determined by PropVariantType...
    SPVARIANTSUBSET SpVariantSubset;
} SPCFGSEMANTICTAG;


//
//
//  Resource
//
typedef [restricted] struct SPCFGRESOURCE
{
    ULONG       RuleIndex;
    ULONG       ResourceNameSymbolOffset;
    ULONG       ResourceValueSymbolOffset;
} SPCFGRESOURCE;

typedef [restricted] struct SPCFGHEADER 
{
    GUID        FormatId;
    GUID        GrammarGUID;
    LANGID      LangID;
    WORD        wReserved;
    ULONG       cArcsInLargestState;
    ULONG       cchWords;
    ULONG       cWords;
    WCHAR     * pszWords;
    ULONG       cchSymbols; 
    WCHAR     * pszSymbols;
    ULONG       cRules;
    SPCFGRULE * pRules;
    ULONG       cArcs;
    SPCFGARC  * pArcs;
    float     * pWeights;
    ULONG       cSemanticTags;
    SPCFGSEMANTICTAG * pSemanticTags;
    ULONG       cResources;
    SPCFGRESOURCE * pResources;
} SPCFGHEADER;

//
//  Serialized grammar declaration
//
//  Header stored in data files for a grammar.  All SPRELATIVEPTR fields are 
//  relative to the first byte in the file.  SAPI reads this header and then 
//  converts the data to a SPCFGHEADER for processing.
//
//  NOTE:  Since MIDL does not support structure inheritance, we have to CPP_QUOTE this thingie

cpp_quote("typedef struct SPCFGSERIALIZEDHEADER : public SPBINARYGRAMMAR")
cpp_quote("{")
cpp_quote("    GUID            FormatId;")
cpp_quote("    GUID            GrammarGUID;")
cpp_quote("    LANGID          LangID;")
cpp_quote("    WORD            wReserved;")
cpp_quote("    ULONG           cArcsInLargestState;")
cpp_quote("    ULONG           cchWords;")
cpp_quote("    ULONG           cWords;")
cpp_quote("    SPRELATIVEPTR   pszWords;")
cpp_quote("    ULONG           cchSymbols;") 
cpp_quote("    SPRELATIVEPTR   pszSymbols;")
cpp_quote("    ULONG           cRules;")
cpp_quote("    SPRELATIVEPTR   pRules;")
cpp_quote("    ULONG           cArcs;")
cpp_quote("    SPRELATIVEPTR   pArcs;")
cpp_quote("    SPRELATIVEPTR   pWeights;")
cpp_quote("    ULONG           cSemanticTags;")
cpp_quote("    SPRELATIVEPTR   pSemanticTags;")
cpp_quote("    ULONG           cResources;")
cpp_quote("    SPRELATIVEPTR   pResources;")
cpp_quote("} SPCFGSERIALIZEDHEADER;")


typedef [restricted] struct _SPPATHENTRY
{
    union
    {
        SPTRANSITIONID      hTransition;
        SPWORDHANDLE        hWord;
    };
    SPPHRASEELEMENT     elem;
} _SPPATHENTRY;


//--- ISpCFGGrammar ----------------------------------------------------------
[
    object,
    uuid(BBD61E95-C544-4167-AB64-B78E5D6E64B2),
    helpstring("ISpCFGGrammar Interface"),
    pointer_default(unique),
	local,
    restricted
]
interface ISpCFGGrammar : IUnknown
{
    HRESULT ActivateRule(const WCHAR * pszRuleName, DWORD dwRuleId, SPRULESTATE NewState, ULONG * pulNumActivated);
    HRESULT DeactivateRule(const WCHAR * pszRuleName, DWORD dwRuleId, ULONG * pulNumDeactivated);
    HRESULT SetGrammarState(const SPGRAMMARSTATE eGrammarState);
    HRESULT Reload([in] const SPBINARYGRAMMAR * pNewSerializedData);
    HRESULT GetNumberDictationTags([out] ULONG * pulTags);
};


//--- ISpCFGEngine ----------------------------------------------------------
[
    object,
    uuid(C83212D3-D5C9-408c-B353-311896878897),
    helpstring("ISpCFGEngine Interface"),
    pointer_default(unique),
    local,
    restricted
]
interface ISpCFGEngine : IUnknown
{
	HRESULT ParseITN( [in] ISpPhraseBuilder *pPhrase );

    HRESULT ParseFromTransitions(
                [in] const SPPARSEINFO * pParseInfo,
                [out] ISpPhraseBuilder **ppPhrase);
    HRESULT ParseFromPhrase(
                [in] ISpPhraseBuilder *pPhrase,
                [in] const SPPHRASE *pSPPhrase,
                [in] const ULONG ulFirstElementToParse, 
                [in] BOOL fIsITN,
                [out] ULONG *pulWordsParsed);
    HRESULT LoadGrammarFromFile(const WCHAR * pszGrammarName, void * pvOwnerCookie, void * pvClientCookie, ISpCFGGrammar **ppGrammarObject);
    HRESULT LoadGrammarFromObject(REFCLSID rcid, const WCHAR * pszGrammarName, void * pvOwnerCookie, void * pvClientCookie, ISpCFGGrammar ** ppGrammarObject);
    HRESULT LoadGrammarFromMemory(const SPBINARYGRAMMAR * pData, 
                                  void * pvOwnerCookie, 
                                  void * pvClientCookie, 
                                  ISpCFGGrammar **ppGrammarObject,
                                  WCHAR * pszGrammarName);
    HRESULT LoadGrammarFromResource(const WCHAR *pszModuleName,
                                    const WCHAR *pszResourceName,
                                    const WCHAR *pszResourceType,
                                    WORD wLanguage,
                                    void * pvOwnerCookie,
                                    void * pvClientCookie,
                                    ISpCFGGrammar **ppGrammarObject);
    HRESULT SetClient(_ISpRecoMaster * pClient);

    HRESULT GetWordInfo([in, out] SPWORDENTRY * pWordEntry, [in] SPWORDINFOOPT Options);    // Caller must fill in hRule
    HRESULT SetWordClientContext(SPWORDHANDLE hWord, void * pvClientContext);
    HRESULT GetRuleInfo([in, out] SPRULEENTRY * pRuleEntry, [in] SPRULEINFOOPT Options); // Caller must fill in hRule.SPRULEHANDLE hRule, BOOL * pfActive, BOOL *pfAutoPause, SPSTATEHANDLE * phInitialState, void ** ppvClientContext);
    HRESULT SetRuleClientContext(SPRULEHANDLE hRule, void * pvClientContext);
    HRESULT GetStateInfo(SPSTATEHANDLE hState, SPSTATEINFO * pStateInfo);

    HRESULT GetOwnerCookieFromRule([in] SPRULEHANDLE rulehandle, [out] void ** ppvOwnerCookie);

    HRESULT GetResourceValue(
            [in] const SPRULEHANDLE hRule,
            [in] const WCHAR *pszResourceName,
            [out] WCHAR ** ppCoMemResource);

    HRESULT GetRuleDescription(
            [in] const SPRULEHANDLE hRule,
            [out] WCHAR ** ppszCoMemRuleName,
            [out] ULONG * pulRuleId,
            [out] LANGID * pLangID);

    HRESULT GetTransitionProperty(
            [in] SPTRANSITIONID ID,
            [out] SPTRANSITIONPROPERTY ** ppCoMemProperty);

    HRESULT SetLanguageSupport(
            [in] const LANGID * paLangIDs,
            [in] ULONG cLangIDs);
};

//--- ISpGramCompBackendPrivate ----------------------------------------------------------
[
    object,
    uuid(B423F56F-1221-46fa-ADE9-CDF19F06658D),
    helpstring("ISpGramCompBackendPrivate Interface"),
    pointer_default(unique),
	local,
    restricted
]
interface ISpGramCompBackendPrivate : ISpGramCompBackend
{
    HRESULT GetRuleCount( [out, retval] long * pCount );
    HRESULT GetHRuleFromIndex( [in] ULONG index, [out,retval] SPSTATEHANDLE * pHRule );
    HRESULT GetNameFromHRule( [in] SPSTATEHANDLE HRule, [out,retval] WCHAR ** ppszRuleName );
    HRESULT GetIdFromHRule( [in] SPSTATEHANDLE HRule, [out,retval] long * pId );
    HRESULT GetAttributesFromHRule( SPSTATEHANDLE HRule, SpeechRuleAttributes* pAttributes );
    HRESULT GetTransitionCount( [in] SPSTATEHANDLE hState, [out, retval] long * pCount);
    HRESULT GetTransitionType( [in] SPSTATEHANDLE hState, [in] void * Cookie, [out] VARIANT_BOOL *pfIsWord, [out] ULONG * pulSpecialTransitions);
    HRESULT GetTransitionText( [in] SPSTATEHANDLE hState, [in] void * Cookie, [out] BSTR * Text);
    HRESULT GetTransitionRule( [in] SPSTATEHANDLE hState, [in] void * Cookie, [out] SPSTATEHANDLE * phRuleInitialState);
    HRESULT GetTransitionWeight( [in] SPSTATEHANDLE hState, [in] void * Cookie, [out] VARIANT * Weight);
    HRESULT GetTransitionProperty( [in] SPSTATEHANDLE hState, [in] void * Cookie, [out] SPTRANSITIONPROPERTY * pProperty);
    HRESULT GetTransitionNextState( [in] SPSTATEHANDLE hState, [in] void * Cookie, [out] SPSTATEHANDLE * phNextState);
    HRESULT GetTransitionCookie( [in] SPSTATEHANDLE hState, [in] ULONG Index, [out] void ** pCookie );
};

//--- ISpRecoCtxtPrivate ----------------------------------------------------

cpp_quote("#if 0")
typedef void CRecoInst;
typedef void CRecoMaster;
cpp_quote("#else")
cpp_quote("class CRecoMaster;   // Forward define")
cpp_quote("class CRecoInst;")
cpp_quote("#endif")



typedef enum
{
    // Special Reco-Master performed task
    ERMT_REMOVERECOINST,

    // Grammar related tasks
    EGT_DELETEGRAMMAR,   
    EGT_LOADCMDFROMMEMORY,
    EGT_LOADCMDFROMFILE,
    EGT_LOADCMDFROMOBJECT,
    EGT_LOADCMDFROMRSRC,
    EGT_RELOADCMD,
    EGT_LOADCMDPROPRIETARY,
    EGT_UNLOADCMD,
    EGT_SETCMDRULESTATE, 
    EGT_SETGRAMMARSTATE,
    EGT_LOADDICTATION,
    EGT_UNLOADDICTATION,
    EGT_SETDICTATIONRULESTATE,
    EGT_SETWORDSEQUENCEDATA,
    EGT_SETTEXTSELECTION,
    EGT_ISPRON,
        
    // Context creation / deletion
    ECT_DELETECONTEXT,        
    ECT_CREATEGRAMMAR,
    ECT_ADAPTATIONDATA,
    ECT_SETEVENTINTEREST,
    ECT_SETMAXALTERNATES,
    ECT_SETRETAINAUDIO,
    ECT_PAUSECONTEXT,
    ECT_RESUMECONTEXT,
    ECT_BOOKMARK,
    ECT_SETCONTEXTSTATE,
    ECT_CALLENGINE,         // pvAdditionalData is in/out buffer 
    ECT_CALLENGINEEX,       // CoMemResponse

    // Engine related tasks
    EIT_CREATECONTEXT,
    EIT_SETPROFILE,
    EIT_GETPROFILE,
    EIT_SETRECOSTATE,
    EIT_GETRECOSTATE,
    EIT_EMULATERECOGNITION,  // pvAdditionalData contains the phrase
    EIT_GETPROPERTYNUM,
    EIT_SETPROPERTYNUM,
    EIT_GETPROPERTYSTRING,
    EIT_SETPROPERTYSTRING,
    EIT_GETRECOGNIZER,
    EIT_SETRECOGNIZER,
    EIT_SETINPUT,
    EIT_GETINPUTTOKEN,
    EIT_GETINPUTSTREAM,
    EIT_GETRECOINSTSTATUS,
    EIT_GETAUDIOFORMAT

} ENGINETASKENUM;

cpp_quote("#if 0")
#define MAX_PATH 260
cpp_quote("#endif")

typedef struct _ENGINETASKRESPONSE ENGINETASKRESPONSE;
typedef struct _ENGINETASK ENGINETASK;


struct _ENGINETASKRESPONSE
{
    ENGINETASK      *   __pCallersTask;           // Set by ProcessTask method for marshalling (points to client side task struct)
    HRESULT             hr;                     // HRESULT of call.
    ULONG               ulTaskID;               // Task ID used to time-out calls
    union
    {
        // ET_GETRECOSTATE
        struct
        {   
            SPRECOSTATE         RecoState;
        };
        // ET_CREATECONTEXT
        struct
        {
            SPRECOCONTEXTHANDLE hCreatedRecoCtxt;
            WCHAR               wszRequestTypeOfUI[255];
        };
        struct
        {
            WCHAR               wszPronunciation[SP_MAX_PRON_LENGTH];
        };
        // ET_CREATEGRAMMAR
        struct
        {
            SPGRAMMARHANDLE     hRecoInstGrammar;
        };
        // ET_GETPROPERTYNUM:
        struct
        {
            LONG                lPropertyValue;
        };
        // ET_GETPROPERTYSTRING:
        struct
        {   
            WCHAR               szStringValue[MAX_PATH];
        };
        // ET_GETRECOGNIZER
        struct 
        {
            WCHAR               szRecognizerTokenId[MAX_PATH];
        };
        // ET_GETINPUTTOKEN
        struct
        {
            WCHAR               szInputTokenId[MAX_PATH];
            HRESULT             hrGetInputToken;        // HR to return from API call.
        };
        // ET_GETPROFILE
        struct
        {
            WCHAR               szProfileTokenId[MAX_PATH];
        };
        // ET_GETINPUTSTREAM
        struct
        {
            ISpStreamFormat     * pInputStreamObject;    // Only in InProc and does hold ref to object
        };
        // ET_GETRECOINSTSTATUS
        struct
        {
            SPRECOGNIZERSTATUS    RecoInstStatus;
        };
        // ET_ISPRON
        struct
        {
            SPWORDPRONOUNCEABLE WordPronounceable;
        };
        // ET_CALLENGINE has no data in response.  fAdditionalBufferInResponse is set so additional buffer
        // contains the data to be copied back.

        //
        //  ET_CALLENGINEEX sets the fExpectCoMemResponse which causes these fields to be filled in
        //  Also, ET_GETAUDIOFORMAT uses a variable size return buffer
        //
        struct
        {
            void                *   pvCoMemResponse;
            ULONG                   cbCoMemResponse;
        };
    };
};


struct _ENGINETASK
{
    ENGINETASKENUM eTask;
    SPRECOCONTEXTHANDLE hRecoInstContext; // if NULL then for engine, not specific context 
    SPGRAMMARHANDLE     hRecoInstGrammar; // if NULL then not for specific grammar object
    void *              pvAdditionalBuffer;
    ULONG               cbAdditionalBuffer;
    HANDLE              hCompletionEvent;         
    ENGINETASKRESPONSE  Response;
    BOOL                fAdditionalBufferInResponse;    // If TRUE then additional buffer should be copied as part of response.
    BOOL                fExpectCoMemResponse;           // If TRUE then pvCoMemResponse will be filled when task completes

    union
    {
        struct
        {
            union
            {
                // ET_BOOKMARK
                struct
                {
                    SPBOOKMARKOPTIONS BookmarkOptions;
                    ULONGLONG ullStreamPosition;
                    LPARAM lParamEvent;
                };
                // ET_GETAUDIOFORMAT
                struct
                {
                    SPSTREAMFORMATTYPE  AudioFormatType;
                };
                // ET_SETRETAINAUDIO
                struct
                {
                    BOOL                fRetainAudio;
                };
                // ET_SETMAXALTERNATES
                struct
                {
                    ULONG               ulMaxAlternates;
                };
                // ET_SETEVENTINTEREST
                struct
                {
                    ULONGLONG           ullEventInterest;  
                };
                // ET_LOADDICTATION
                struct
                {
                    WCHAR szTopicName[MAX_PATH];
                };

                // ET_RELOAD (Not ET_LOADMEMORY any more)
//                const SPBINARYGRAMMAR * pBinaryData;

                // ET_LOADRSRC
                struct
                {
                    WORD wLanguage;
                    WCHAR szModuleName[MAX_PATH];
                    union
                    {
                        WCHAR szResourceName[MAX_PATH]; // if (szResourceName[0] == 0) use dwNameInt
                        struct
                        {
                            WCHAR fResourceNameValid;   // 0, if szResourceName[0] == 0
                            DWORD dwNameInt;
                        };
                    };
                    union
                    {
                        WCHAR szResourceType[MAX_PATH]; // if (szResourceType[0] == 0) use dwTypeInt
                        struct
                        {
                            WCHAR fResourceTypeValid;   // 0, if szResourceType[0] == 0
                            DWORD dwTypeInt;
                        };
                    };
                };

                // ET_LOADCMDPROPRIETARY
                struct
                {
                 //   const void * pvDataParam;
                 //   ULONG ulDataSize;
                    WCHAR szStringParam[MAX_PATH];
                    GUID  guid;
                };

                // ET_SETWORDSEQUENCEDATA and
                // ET_SETTEXTSELECTION 
                struct
                {
                //    ULONG cch;                      // Ignored for SETTEXTSELECTION
                //    const WCHAR *pBuffer;           // Ignored for SETTEXTSELECTION
                    SPTEXTSELECTIONINFO TextSelInfo;// Used for both methods.
                    BOOL  fSelInfoValid;            // If FALSE then NULL passed for TextSelInfo
                };

                // ET_LOADFILE & ET_LOADMEMORY
                WCHAR szFileName[MAX_PATH];

                // ET_LOADOBJECT
                struct
                {
                    CLSID clsid;
                    WCHAR szGrammarName[MAX_PATH];
                };

                // ET_SETCMDRULESTATE or ET_SETDICTATIONRULESTATE (fActive only valid param)
                struct
                {
                    WCHAR szRuleName[MAX_PATH];
                    DWORD dwRuleId;
                    SPRULESTATE RuleState;
                };
                // ET_SETGRAMMARSTATE
                struct
                {
                    SPGRAMMARSTATE eGrammarState;
                };
				// ET_ISPRON
				struct
				{
					WCHAR szWord[SP_MAX_WORD_LENGTH];
				};
                // ET_CREATEGRAMMAR
                struct
                {
                    ULONGLONG ullApplicationGrammarId;
                };
                // ET_SETRECOSTATE;
                struct  
                {
                    SPRECOSTATE NewState;
                };
                // ET_SETPROFILE
                struct
                {
                    WCHAR szProfileTokenId[MAX_PATH];
                };
                // ET_GET/SET PROPERTY NUM / STRING
                struct
                {
                    WCHAR szPropertyName[MAX_PATH];
                    WCHAR szPropertyValue[MAX_PATH];
                    LONG  lPropertyValue;
                };
                // ET_SETRECOGNIZER
                struct
                {
                    WCHAR szRecognizerTokenId[MAX_PATH];  // This is the only field used for ET_SETRECOGNIZER
                };
                // ET_SETINPUT
                struct
                {
                    WCHAR szInputTokenId[MAX_PATH];  // This is the only field used for ET_SETRECOGNIZER
                    BOOL fAllowFormatChanges;
                    ISpStreamFormat * pInputObject; // Only allowed for inproc - If non-null then ignore szTokenId.
                };
                // ECT_SETCONTEXTSTATE
                struct
                {
                    SPCONTEXTSTATE  eContextState;
                };
            };
        };

        // ET_UNLOAD2
//        PVOID pv_Grammar;
    };
};


// serialized result block header held by the result object until detach
typedef struct SPRESULTHEADER
{
    ULONG       ulSerializedSize;       // This MUST be the first field to line up with SPSERIALIZEDRESULT
    ULONG       cbHeaderSize;           // This must be sizeof(SPRESULTHEADER)
    CLSID       clsidEngine;
    CLSID       clsidAlternates;
    ULONG       ulStreamNum;
    ULONGLONG   ullStreamPosStart;
    ULONGLONG   ullStreamPosEnd;
    ULONG       ulPhraseDataSize;       // byte size of all the phrase structure
    ULONG       ulPhraseOffset;         // offset to phrase
    ULONG       ulPhraseAltDataSize;    // byte size of all the phrase alt structures combined
    ULONG       ulPhraseAltOffset;      // offset to phrase
    ULONG       ulNumPhraseAlts;        // Number of alts in array
    ULONG       ulRetainedDataSize;     // byte size of audio data
    ULONG       ulRetainedOffset;       // offset to audio data in this phrase blob
    ULONG       ulDriverDataSize;       // byte size of driver specific data
    ULONG       ulDriverDataOffset;     // offset to driver specific data
    float       fTimePerByte;			// Conversion factor from engine stream size to time.
    float       fInputScaleFactor;      // Conversion factor from engine stream size to input stream size.
    SPRECORESULTTIMES times;            // time info of result
} SPRESULTHEADER;

/*
[
    object,
    uuid(1EDAFA51-05B6-4fa6-A90C-0BE043B0002B),
    helpstring("_ISpRecoCtxtPrivate Interface"),
    pointer_default(unique),
    local
]
interface _ISpRecoCtxtPrivate : IUnknown
{
    HRESULT SetRecoInstContextHandle([in] SPRECOCONTEXTHANDLE h);

    HRESULT EventNotify([in] const SPSERIALIZEDEVENT * pEvent, [in] ULONG cbSerializedSize);
        // For everything except recogintion events     

    HRESULT RecognitionNotify([in] SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, SPEVENTENUM eEventId);

    HRESULT TaskCompletedNotify([in] const ENGINETASKRESPONSE *pResponses);

    HRESULT StreamChangedNotify(void);
}
*/





[
    object,
    uuid(4E204149-3828-4a29-8990-A39598D2BD6D),
    pointer_default(unique),
    local
]
interface _ISpRecoMaster : ISpSREngine 
{
    HRESULT AddRecoInst(CRecoInst * pNewInst, BOOL fShared, CRecoMaster ** ppMasterThisPtr);
    HRESULT PerformTask([in]CRecoInst * pSender, [in, out] ENGINETASK *pTask);
}

//--- ISpServerCallContext --------------------------------------------------
[
    object,
    uuid(04F78833-82F6-11D2-8C9E-00C04F72DB08),
    helpstring("ISpServerCallContext Interface"),
    pointer_default(unique),
    local
]
interface ISpServerCallContext : IUnknown
{
    HRESULT Call([in] DWORD methodIdx, [in] PVOID pCallFrame, [in] ULONG ulCallFrameSize, [in] BOOL bCFInOut);
    HRESULT GetTopOfStack([out] BYTE **ppTOS, [out] ULONG *pulAvailable);
    BYTE * AdjustStack([in] LONG lAmount);
};

//--- ISpIPC ----------------------------------------------------------------
[
    object,
    uuid(B0F523DC-8BC2-11d2-8C9E-00C04F72DB08),

    helpstring("ISpIPC Interface"),
    pointer_default(unique),
    local
]
interface ISpIPC : IUnknown
{
    HRESULT MethodCall([in] DWORD dwMethod,
                       [in] ULONG ulCallFrameSize, [in] void *pCallFrame,
                       [in] ULONG paramblocks, [in] void * paramarray[]);
};

//--- ISpObjectRef ----------------------------------------------------------
typedef enum SPCALLFLAGS
{
    SPCF_RETURNBLOCK1 = 1       // copy back the first param block on return, this is
                                // the mechanism for passing back return params from
                                // the called method
} SPCALLFLAGS;

typedef struct SpCallParamBlock
{
    PVOID pParamData;
    ULONG cbParamData;
} SpCallParamBlock;

typedef struct SPCALLPARAMS
{
    DWORD   dwMethodId;
    DWORD   dwFlags;		//SPCALLFLAGS
    ULONG   ulParamBlocks;
    SpCallParamBlock paramlist[2];
} SPCALLPARAMS;


[
    object,
    uuid(9E7A2575-7001-4e05-822D-2794D6791093),

    helpstring("ISpObjectRef Interface"),
    pointer_default(unique),
    local
]
interface ISpObjectRef : IUnknown
{
    HRESULT Call([in] const SPCALLPARAMS *params);
};

//--- ISpIPCObject ----------------------------------------------------------
[
    object,
    uuid(BFFB0386-9399-11d2-8CA3-00C04F72DB08),

    helpstring("ISpIPCObject Interface"),
    pointer_default(unique),
    local
]
interface ISpIPCObject : IUnknown
{
    HRESULT SetOppositeHalf([in] ISpObjectRef *pSOR);
};

//--- ISpServer -------------------------------------------------------------
[
    object,
    uuid(B9F57209-659F-43ed-97FE-84336A63BFFB),
    helpstring("ISpServer Interface"),
    pointer_default(unique),
    local
]
interface ISpServer : IUnknown
{
    HRESULT CreateInstance([in] REFCLSID rclsid, [in] ISpIPC *pOwnerObj, [out] ISpObjectRef **ppSOR);

    HRESULT CallObject([in] PVOID pTargetObject, [in] const SPCALLPARAMS *params);
    HRESULT ReleaseObject([in] PVOID pTargetObject);
};

//--- ISpServerConnection ---------------------------------------------------
[
    object,
    uuid(D0A0911C-0DC4-4cbf-9710-F9A329F5D392),
    helpstring("ISpServerConnection Interface"),
    pointer_default(unique),
    local
]
interface ISpServerConnection : IUnknown
{
    HRESULT GetConnection([out] void **ppServerHalf, [out] HWND *phServerWnd, [out] DWORD *pdwServerProcessID);
};

//--- ISrReceiver ----------------------------------------------------------
[
    object,
    uuid(20732258-527D-4ED4-ABE3-6AB51BEB08DB),

    helpstring("ISrReceiver Interface"),
    pointer_default(unique),
    local
]
interface ISrReceiver : IUnknown
{
    HRESULT GetWindow([out] HWND *phwnd);
    HRESULT SendCall([in] HWND hTargetWnd, [in] PVOID pTargetObject,
                     [in] const SPCALLPARAMS *params);
    HRESULT SendRelease([in] HWND hTargetWnd, [in] PVOID pTargetObject);
};


//
//  Private, undocumented interface for SpPhraseBuilder object
//
[
    object,
    uuid(1B7ECC24-EC50-4642-A212-20F12E02786F),
    helpstring("_ISpCFGPhraseBuilder Interface"),
    pointer_default(unique),
    local
]
interface _ISpCFGPhraseBuilder : ISpPhraseBuilder
{
    HRESULT InitFromCFG(ISpCFGEngine * pCFGEngine, const SPPARSEINFO * pParseInfo);
    HRESULT GetCFGInfo(ISpCFGEngine ** ppCFGEngine, SPRULEHANDLE * phRule);
    HRESULT SetCFGInfo(ISpCFGEngine * pEngine, SPRULEHANDLE hRule);
    HRESULT SetTopLevelRuleConfidence(signed char Confidence);
    HRESULT ReleaseCFGInfo();
}


//
//  True serialized phrase structure
//    

typedef struct tagSPSERIALIZEDPHRASEELEMENT
{
    ULONG                   ulAudioTimeOffset;
    ULONG                   ulAudioSizeTime;    // In 100ns units
    ULONG                   ulAudioStreamOffset;
    ULONG                   ulAudioSizeBytes;
    ULONG                   ulRetainedStreamOffset;
    ULONG                   ulRetainedSizeBytes;
    SPRELATIVEPTR           pszDisplayText;
    SPRELATIVEPTR           pszLexicalForm;
    SPRELATIVEPTR           pszPronunciation;      
    BYTE                    bDisplayAttributes;           
    signed char             RequiredConfidence;
    signed char             ActualConfidence;
    BYTE                    Reserved;
    float                   SREngineConfidence;
} SPSERIALIZEDPHRASEELEMENT;


typedef struct tagSPSERIALIZEDPHRASERULE
{
    SPRELATIVEPTR           pszName;
    ULONG                   ulId;
    ULONG                   ulFirstElement;
    ULONG                   ulCountOfElements;
    SPRELATIVEPTR           pNextSibling;
    SPRELATIVEPTR           pFirstChild;
    float                   SREngineConfidence;
    signed char             Confidence;
} SPSERIALIZEDPHRASERULE;

typedef struct tagSPSERIALIZEDPHRASEPROPERTY
{
    SPRELATIVEPTR   pszName;     
    ULONG           ulId;
    SPRELATIVEPTR   pszValue;   
    VARTYPE         VariantType;
    SPVARIANTSUBSET SpVariantSubset;
    ULONG           ulFirstElement;
    ULONG           ulCountOfElements;
    SPRELATIVEPTR   pNextSibling;
    SPRELATIVEPTR   pFirstChild;
    float           SREngineConfidence;
    signed char     Confidence;
} SPSERIALIZEDPHRASEPROPERTY;
    
typedef struct tagSPSERIALIZEDPHRASEREPLACEMENT
{
    BYTE            bDisplayAttributes;
    SPRELATIVEPTR   pszReplacementText;
    ULONG           ulFirstElement;
    ULONG           ulCountOfElements;
} SPSERIALIZEDPHRASEREPLACEMENT;

// This must be cpp_quote'd since no derived structures supported by MIDL...
cpp_quote("typedef struct tagSPINTERNALSERIALIZEDPHRASE : SPSERIALIZEDPHRASE")
cpp_quote("{")
cpp_quote("    ULONG                   cbSize;      // size of just this structure within the serialized block header")
cpp_quote("    WORD                    LangID;")
cpp_quote("    WORD                    wReserved;")
cpp_quote("    ULONGLONG               ullGrammarID;")
cpp_quote("    ULONGLONG               ftStartTime;")
cpp_quote("    ULONGLONG               ullAudioStreamPosition;")
cpp_quote("    ULONG                   ulAudioSizeBytes;")
cpp_quote("    ULONG                   ulRetainedSizeBytes;")
cpp_quote("    ULONG                   ulAudioSizeTime;")
cpp_quote("    SPSERIALIZEDPHRASERULE  Rule;")
cpp_quote("    SPRELATIVEPTR           pProperties;")
cpp_quote("    SPRELATIVEPTR           pElements;")
cpp_quote("    ULONG                   cReplacements;")
cpp_quote("    SPRELATIVEPTR           pReplacements;")
cpp_quote("    GUID                    SREngineID;")
cpp_quote("    ULONG                   ulSREnginePrivateDataSize;")
cpp_quote("    SPRELATIVEPTR           pSREnginePrivateData;")
cpp_quote("} SPINTERNALSERIALIZEDPHRASE;")

// CFG special transitions
const ULONG SPTEXTBUFFERTRANSITION  = 0x03fffff;
const ULONG SPWILDCARDTRANSITION    = 0x03ffffe;
const ULONG SPDICTATIONTRANSITION   = 0x03ffffd;


typedef struct SPCALL
{
    DWORD dwMethodId;
    PVOID pvData;
    ULONG cbData;
    
    HANDLE heventCompleted;
    
    BOOL  fWantReturn;
    HWND  hwndReturnTo;

    PVOID pvDataReturn;
    ULONG cbDataReturn;
    HRESULT hrReturn;

    struct SPCALL * pspcall;
} SPCALL;

//--- ISpCallSender ---------------------------------------------------------
[
    object,
    uuid(E57C6132-F039-4f2b-92F6-FE5716822E89),
    helpstring("ISpCallSender Interface"),
    pointer_default(unique),
	restricted,
    local
]
interface ISpCallSender : IUnknown
{
    HRESULT SendCall(
                DWORD dwMethodId, 
                PVOID pvData,
                ULONG cbData,
                BOOL  fWantReturn,
                PVOID * ppvDataReturn,
                ULONG * pcbDataReturn);
};

//--- ISpCallReceiver -------------------------------------------------------
[
    object,
    uuid(9E50DA9E-8386-4af8-AD13-B848B97227AF),
    helpstring("ISpCallReceiver Interface"),
    pointer_default(unique),
	restricted,
    local
]
interface ISpCallReceiver : IUnknown
{
    HRESULT ReceiveCall(
                DWORD dwMethodId,
                PVOID pvData,
                ULONG cbData,
                PVOID * ppvDataReturn,
                ULONG * pcbDataReturn);
};

//--- ISpCommunicator -------------------------------------------------------
[
    object,
    uuid(F103FC92-0A29-4814-BF44-875D805C602B),
    helpstring("ISpCommunicator Interface"),
    pointer_default(unique),
	restricted,
    local
]
interface ISpCommunicator : ISpCallSender
{
};

//--- ISpCommunicatorInit ---------------------------------------------------
[
    object,
    uuid(16342931-E549-4857-8575-75DE37517A6D),
    helpstring("ISpCommunicatorInit Interface"),
    pointer_default(unique),
	restricted,
    local
]
interface ISpCommunicatorInit : ISpCommunicator
{
    HRESULT AttachToServer(REFCLSID clsidServerObj);
    HRESULT AttachToClient(ISpSapiServer * pSapiServer, HWND hwndClient, UINT msgSendToClient, DWORD dwClientProcessId);
};

//--- ISpSapiServer ---------------------------------------------------------
[
    object,
    uuid(31E99ED0-6AD8-431b-AE3C-652D9E8C7832),
    helpstring("ISpSapiServer Interface"),
    pointer_default(unique),
	restricted,
    local
]
interface ISpSapiServer : IUnknown
{
    HRESULT Run();

    HRESULT StartTrackingObject(IUnknown * punk);
    HRESULT StopTrackingObject(IUnknown * punk);
};

//--- ISpMMSysAudioConfig ---------------------------------------------------
[
    object,
    uuid(4DFDD13B-7A28-4678-9FEC-64483A2EDC3F),
    helpstring("ISpMMSysAudioConfig Interface"),
    pointer_default(unique),
	restricted,
    local
]
interface ISpMMSysAudioConfig : IUnknown
{
    HRESULT Get_UseAutomaticLine(BOOL *bAutomatic);
    HRESULT Set_UseAutomaticLine(BOOL bAutomatic);
    HRESULT Get_Line(UINT *uiLineIndex);
    HRESULT Set_Line(UINT uiLineIndex);
    HRESULT Get_UseBoost(BOOL *bUseBoost);
    HRESULT Set_UseBoost(BOOL bUseBoost);
    HRESULT Get_UseAGC(BOOL *bUseAGC);
    HRESULT Set_UseAGC(BOOL bUseAGC);
    HRESULT Get_FixMicOutput(BOOL *bFixMicOutput);
    HRESULT Set_FixMicOutput(BOOL bFixMicOutput);
    HRESULT Get_LineNames(WCHAR **szCoMemLineList);
    HRESULT HasMixer(BOOL *bHasMixer);
    HRESULT DisplayMixer(void);
};

//--- ISpStreamAccess ---------------------------------------------------
[
    object,
    uuid(DD83D23F-66B4-4a77-A65D-C663DED45017),
    helpstring("ISpStreamAccess Interface"),
    pointer_default(unique),
	restricted
]
interface ISpStreamAccess : IUnknown
{
    HRESULT SetFormat([in] REFGUID rguidFmtId, [in] const WAVEFORMATEX * pWaveFormatEx);
    HRESULT _GetFormat([out]GUID * pguidFormatId, [out]WAVEFORMATEX ** ppCoMemWaveFormatEx);
};

//
//--- CoClass definitions ---------------------------------------------------
//

[
    helpstring("Microsoft Speech Object Internal Library"),
    uuid(264FC6E5-26BE-428a-9185-1FB6DAD1928C),
    version(1.0)
]
library SpeechInternalLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    //
    //--- Private coclasses -------------------------------------------------
    //

    //--- SpCommunicator ----------------------------------------------------
    [
        uuid(2D12DD17-6C4E-456e-A953-D210E3C64176),
        helpstring("SpCommunicator")
    ]
    coclass SpCommunicator
    {
        interface ISpCommunicator;
        interface ISpCommunicatorInit;
    };

    //--- SpSapiServer ------------------------------------------------------
    [
        uuid(1B2AFB92-0B5E-4a30-B5CC-353DB4F9E150),
        helpstring("SpSapiServer")
    ]
    coclass SpSapiServer
    {
        interface ISpSapiServer;
    };
    
    //--- SpCFGEngine -------------------------------------------------------
    [
        uuid(F3D3F924-11FC-11d3-BB97-00C04F8EE6C0),
        helpstring("SpCFGEngine Class")
    ]
    coclass SpCFGEngine
    {
        [default] interface ISpCFGEngine;
    };

    //--- SpTaskManager -----------------------------------------------------
    [
        uuid(4C6F940C-3CFE-11d2-9EE7-00C04F797396),
        helpstring("SpTaskManager"),
        restricted
    ]
    coclass SpTaskManager
    {
        interface ISpTaskManager;
    }

    //--- _SpRecoMaster -----------------------------------------------------
    [
        uuid(D6AD10F3-70AB-41e1-96B3-4C36E35D333C),
        helpstring("SpRecoMaster")
    ]
    coclass _SpRecoMaster
    {
        [default] interface _ISpRecoMaster;
    };


    //--- _SpSharedRecoInst -------------------------------------------------
    [
        uuid(DC626A64-D684-4627-83CB-44420ABDBD1A),
        helpstring("_SpSharedRecoInst")
    ]
    coclass _SpSharedRecoInst
    {
        [default] interface ISpCallReceiver;
    };

    //--- SpAudioUI ---------------------------------------------------------
    [
        uuid(364D8E0B-67CB-4547-9948-9E7F1B1743ED),
        helpstring("SpAudioUI Class")
    ]
    coclass SpAudioUI
    {
        interface ISpTokenUI;
    };

#if 0
    //--- SpDSoundAudioEnum -------------------------------------------------
    [
        uuid(AB1890A1-E91F-11d2-BB91-00C04F8EE6C0),
        helpstring("SpDSoundAudioEnum Class"),
        restricted
    ]
    coclass SpDSoundAudioEnum
    {
        interface IEnumSpObjectTokens;
    };

    //--- SpDSoundAudioIn ---------------------------------------------------
    [
        uuid(A75C5B7A-1C50-4e52-BA21-197A4579B024),
        helpstring("SpDSoundAudionIn Class")
    ]
    coclass SpDSoundAudioIn
    {
        interface ISpEventSource;
        interface ISpEventSink;
        interface ISpObjectWithToken;
        interface ISpDSoundAudio;
    };
    
    //--- SpDSoundAudioOut --------------------------------------------------
    [
        uuid(731C35DE-E39A-40e4-B110-948F91510A85),
        helpstring("SpDSoundAudioOut")
    ]
    coclass SpDSoundAudioOut
    {
        interface ISpEventSource;
        interface ISpEventSink;
        interface ISpObjectWithToken;
        interface ISpDSoundAudio;
    };
#endif // #if 0

}

#if 0

//--- Specific token ids of interest
const WCHAR SPDSOUND_AUDIO_IN_TOKEN_ID[]      = L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioInput\\TokenEnums\\DSoundAudioIn\\";
const WCHAR SPDSOUND_AUDIO_OUT_TOKEN_ID[]     = L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioOutput\\TokenEnums\\DSoundAudioOut\\";

//--- ISpDSoundAudio --------------------------------------------------------
[
    object,
    uuid(8A105102-DD05-4cc9-B603-3626478DBFA1),
    helpstring("ISpDSoundAudio Interface"),
    pointer_default(unique),
    restricted
]
interface ISpDSoundAudio : ISpAudio
{
    HRESULT SetDSoundDriverGUID([in] REFGUID rguidDSoundDriverGUID);
    HRESULT GetDSoundDriverGUID([out] GUID * pDSoundDriverGUID);
    [local] HRESULT GetDSoundInterface([in] REFIID iid, [out] void **ppvObject);
};

#endif // #if 0