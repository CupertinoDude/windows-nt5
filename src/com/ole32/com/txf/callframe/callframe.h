//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrame.h
//
#include "CallFrameImpl.h"

//////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DBG

extern LPCSTR FormatCharNames[];

#endif


//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class that understands how to read and write memory carefully, probing and checking
// as needed.
//

struct CAREFUL_MEMORY_READER_WRITER 
{
    enum 
    {                      
        m_fToUser       = TRUE,
        m_fFromUser     = TRUE,
    };

    CAREFUL_MEMORY_READER_WRITER()
    {
    }

    void SetFromUser(PVOID pv)
    {
    }

    void SetToUser(PVOID pv)
    {
    }

    BOOL InSameSpace(DWORD freeFlags = 0) const
    {
        BOOL fInSameSpace = (!!m_fFromUser == !!m_fToUser);
#ifdef DBG
        fInSameSpace = (fInSameSpace && !(freeFlags & 0x8000000)); // force other space if flag set
#endif
        return fInSameSpace;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Support for safely reading and writing (potentially) user mode addresses.
    // All of these must be called in the context of an exception handler.
    //
    ///////////////////////////////////////////////////////////////////

    template <class T> void TestWriteSrc(T* pt)            { }
    template <class T> void TestWriteDst(T* pt)            { }
    template <class T> void TestWriteSrc(T* pt, SIZE_T cb) { }
    template <class T> void TestWriteDst(T* pt, SIZE_T cb) { }

    template <class T> void TestReadSrc(T* pt)             { }
    template <class T> void TestReadDst(T* pt)             { }
    template <class T> void TestReadSrc(T* pt, SIZE_T cb)  { }
    template <class T> void TestReadDst(T* pt, SIZE_T cb)  { }

    ////////////////////

    void CopyToDst(PVOID pvLocationInDst, PVOID pvLocationInSrc, SIZE_T cb)
        // Copy a chunk of data from source frame to destination frame.
    {
        TestReadSrc (pvLocationInSrc, cb);
        TestWriteDst(pvLocationInDst, cb);
        memcpy(pvLocationInDst, pvLocationInSrc, cb);
    }

    void CopyToSrc(PVOID pvTo, PVOID pvFrom, SIZE_T cb)
    {
        TestReadDst (pvFrom, cb);
        TestWriteSrc(pvTo,   cb);
        memcpy(pvTo, pvFrom, cb);
    }
    
    ////////////////////

    template <class T>
    T DerefSrc(const T* psrc)
    {
        TestReadSrc(psrc);
        return *psrc;
    }

    template <class T>
    void DerefStoreSrc(T* pt, const T& t)
    {
        TestWriteSrc(pt);
        *pt = t;
    }
    
    template <class T>
    T DerefDst(const T* pdst)
    {
        TestReadDst(pdst);
        return *pdst;
    }

    template <class T>
    void DerefStoreDst(T* pt, const T& t)
    {
        TestWriteDst(pt);
        *pt = t;
    }

    ////////////////////

    void ZeroDst(PVOID pv, ULONG cb)
    {
        TestWriteDst(pv, cb);
        Zero(pv, cb);
    }

    template <class T> 
    void ZeroDst(T* pt)
    {
        ZeroDst(pt, sizeof(*pt));
    }

    void ZeroSrc(PVOID pv, ULONG cb)
    {
        TestWriteSrc(pv, cb);
        Zero(pv, cb);
    }

    template <class T> 
    void ZeroSrc(T* pt)
    {
        ZeroSrc(pt, sizeof(*pt));
    }

};





//////////////////////////////////////////////////////////////////////////////////////////////////

class CallFrame : 
    public ICallFrame, 
    public ICallFrameInit,
    public CAREFUL_MEMORY_READER_WRITER,
    public DedicatedAllocator<CallFrame, PagedPool>
{
  public:
    ///////////////////////////////////////////////////////////////////
    //
    // State of valid interest outside of any worker routine
    //
    ///////////////////////////////////////////////////////////////////

    BYTE* PMemberFirst() { return (BYTE*)&m_pmd; }

    // Our meta data reference
    MD_METHOD*                  m_pmd;

    // Pointer to the stack frame containing the argument data
    PVOID                       m_pvArgs;
    BOOL                        m_fIsCopy;      // Are we a copy? (that is, generated by a copy or unmarshal?)
    BOOL                        m_fIsUnmarshal; // Are we an unmarshalled call frame?

    // The return value of an invocation on us. Is REGISTER_TYPE in order that it can
    // be directly marshalled.
    REGISTER_TYPE               m_hrReturnValue;

    // Current location in the one-off block of memory we use for private buffer management
    PVOID                       m_pvMemCur;

    // If we share memory with someone, then this is the stack of the guy with whom we do
    PVOID                       m_pvArgsSrc;

    // Do our in-parameters share state with our parent frame
    BOOL                        DoWeShareMemory()   { return m_pvArgsSrc != NULL; }

#ifdef DBG
    // If true, then we definitely have made a call on this frame
    BOOL                        m_fAfterCall;
#endif

    // Our interceptor. We need to keep it alive as long as we are alive. 
    //
    Interceptor*                m_pInterceptor;


    ///////////////////////////////////////////////////////////////////
    //
    // State used to communicate with various worker routines as we
    // copy, free, etc.
    //
    ///////////////////////////////////////////////////////////////////

    BOOL                        m_fPropogatingOutParam;
    BOOL                        m_fWorkingOnInParam;
    BOOL                        m_fWorkingOnOutParam;


    // The frame that should allocate memory as we need it
    CallFrame*                  m_pAllocatorFrame;

    // Used during a Copy etc call as the guy who should get our callbacks
    ICallFrameWalker*           m_pWalkerCopy;
    ICallFrameWalker*           m_pWalkerFree;
    ICallFrameWalker*           m_pWalkerWalk;


    ///////////////////////////////////////////////////////////////////
    //
    // State used to mirror NDR runtime pStubMsg state
    //
    ///////////////////////////////////////////////////////////////////

    BYTE*                       m_StackTop;             // base pointer used for FC_TOP_LEVEL_CONFORMANCE conformance computations
    BYTE*                       m_Memory;               // base pointer used for FC_POINTER_CONFORMANCE   conformance computations

    SIZE_T                      m_MaxCount;             // Holds the max counts for a conformant array
    SIZE_T                      m_Offset;               // Holds the offsets for a varying array
    SIZE_T                      m_ActualCount;          // Holds the actual counts for a varying array
    PARRAY_INFO                 m_pArrayInfo;

    // Set limit pointer as to what we zero out during construction
    // 
    BYTE* PMemberMax() { return (BYTE*)&m_pArrayInfo + sizeof(m_pArrayInfo); }


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<CallFrame>;

    CallFrame()
    {
        m_refs              = 1;    // nb starts at one

        Zero(PMemberFirst(), PtrToUlong(PMemberMax()) - PtrToUlong(PMemberFirst()));
        
        Zero(&m_blobBuffer);
        m_fWeOwnBlobBuffer = FALSE;

        m_pvMemCur = &m_pvMem[0];

        m_fIsCopy = FALSE;

#ifdef DBG
        memset(&m_pvMem[0], 0xBB, CB_PRIVATE_BUFFER);   // init to something we'll recognize in the debugger
#endif
    }

    ~CallFrame();

    HRESULT Init() const
    {
        return S_OK;
    }

#define SetStackLocation_(pvArgs) { m_pvArgs = pvArgs; SetFromUser(m_pvArgs); }

    void Init(void* pvArgs, MD_METHOD* pmdMethod, Interceptor* pInterceptor);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetInfo(CALLFRAMEINFO *pInfo);

    HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);

    HRESULT STDCALL GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod);

    PVOID STDCALL GetStackLocation()
    {
        return m_pvArgs;
    }

    void STDCALL SetStackLocation(PVOID pvArgs)
    {
        SetStackLocation_(pvArgs);
    }

    HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS	mshlflags, ULONG *pcbBufferNeeded);

    HRESULT STDCALL Marshal( 
        CALLFRAME_MARSHALCONTEXT  *pmshlContext,
        MSHLFLAGS	mshlflags,	/* As in the IMarshal interface */
        PVOID pBuffer,
        ULONG cbBuffer,
        ULONG  *pcbBufferUsed,
        RPCOLEDATAREP* pdataRep,
        ULONG *prpcFlags);

    void MarshalParam(MIDL_STUB_MESSAGE& stubMsg, ULONG iParam, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg);

    HRESULT STDCALL Unmarshal         (PVOID pBuffer, ULONG cbBuffer,                       RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
    HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
    
    void UnmarshalParam(MIDL_STUB_MESSAGE& stubMsg, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg);
    
    HRESULT STDCALL Free( 
        ICallFrame*        pframeArgsDest,
        ICallFrameWalker*  pWalkerFreeDest,
        ICallFrameWalker*  pWalkerCopy,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);

    HRESULT STDCALL FreeParam(
        ULONG              iparam,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);
    
    void STDCALL SetReturnValue(HRESULT hrReturnValue)
    {
        m_hrReturnValue = hrReturnValue;
    }
    HRESULT STDCALL GetReturnValue()
    {
        return (HRESULT)m_hrReturnValue;
    }
    HRESULT GetReturnValueFast()
    {
        return (HRESULT)m_hrReturnValue;
    }

    HRESULT STDCALL Invoke(void *pvReceiver, ...);

    HRESULT STDCALL Copy(
        CALLFRAME_COPY callControl,
        ICallFrameWalker* pWalker,
        ICallFrame** ppFrame
    );

    HRESULT STDCALL WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker);

    HRESULT STDCALL GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO*);
    HRESULT STDCALL GetParam(ULONG iparam, VARIANT* pvar);
    HRESULT STDCALL SetParam(ULONG iparam, VARIANT* pvar);


    ///////////////////////////////////////////////////////////////////
    //
    // Xml Marshalling
    //
    ///////////////////////////////////////////////////////////////////
    HRESULT STDCALL MarshalXml( 
        CALLFRAME_MARSHALCONTEXT  *pmshlContext,
        MSHLFLAGS	mshlflags,	/* As in the IMarshal interface */
        PVOID pBuffer,
        ULONG cbBuffer,
        ULONG  *pcbBufferUsed,
        RPCOLEDATAREP* pdataRep,
        ULONG *prpcFlags);

    void MarshalParamXml(
        MIDL_STUB_MESSAGE& stubMsg,
        ULONG iParam,
        const PARAM_DESCRIPTION& param,
        const PARAM_ATTRIBUTES paramAttr,
        PBYTE pArg);

    HRESULT STDCALL UnmarshalXml(
        PVOID pBuffer,
        ULONG cbBuffer,
        RPCOLEDATAREP dataRep,
        CALLFRAME_MARSHALCONTEXT*,
        ULONG* pcbUnmarhalled);

    void UnmarshalParamXml(
        MIDL_STUB_MESSAGE& stubMsg,
        const PARAM_DESCRIPTION& param,
        const PARAM_ATTRIBUTES paramAttr,
        PBYTE pArg);
    

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrameInit
    //
    ///////////////////////////////////////////////////////////////////

    CallFrame* STDCALL GetCallFrame()
    {
        return this;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    LONG        m_refs;

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL Release()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    ///////////////////////////////////////////////////////////////////
    //
    // Memory management
    //
    ///////////////////////////////////////////////////////////////////

    enum { CB_PRIVATE_BUFFER = 256 };
    //
    // We maintain inside ourselves a chunk of memory that we use in order to do very quickly
    // get memory needed in copied frames. If we run out of this memory, we start getting memory
    // from the task allocator. We also use this memory for the child stack itself, so the size
    // of this buffer effectively puts a limit on the size of a stack frame we can deal with.
    //
    BYTE  m_pvMem[CB_PRIVATE_BUFFER];
    BOOL  m_fCanUseBuffer;
    //
    // Also, during an unmarshal call, we are given a buffer into which some of the umarshalled
    // data might eventually point. We are not to free such pointers, of course. Further we might
    // actually own the buffer, and so be responsible for freeing it when we go bye bye.
    //
    BLOB  m_blobBuffer;
    BOOL  m_fWeOwnBlobBuffer;


    void* AllocBuffer(size_t cb);
    void* Alloc(size_t cb);
#ifdef DBG
    void* Alloc_(size_t cb, PVOID pvReturnAddress);
#endif

    void* Alloc(size_t cb, BOOL fForceAlloc)
    {
        // Kernel-mode CallFrames on user-mode stacks should never allocate using
        // their (kernel-mode) temporary buffer, but rather always allocate user
        // mode memory.
        //
        if (!m_fCanUseBuffer)
        {
            fForceAlloc = TRUE;
        }

        if (fForceAlloc)
        {
#ifdef DBG
            return Alloc_(cb, _ReturnAddress());
#else
            return Alloc(cb);
#endif
        }
        else
        {
            return AllocBuffer(cb);
        }
    }


    HRESULT AllocStack(size_t cb, BOOL fForceUserMode = FALSE)
    {
        ASSERT(m_pvArgs == NULL);
        //
        // Automatically determine size if we can and if asked to
        //
        if (cb == 0)
        {
            cb = m_pmd->m_cbPushedByCaller;
        }
        ASSERT(cb > 0); // should always have at least a receiver

        if (m_fIsCopy)
            Free(m_pvArgs);

        // SetStackLocation assigns to m_pvArgs.
        SetStackLocation_(AllocBuffer(cb));

        if (NULL != m_pvArgs)
        {
            m_fIsCopy = TRUE;
            Zero(m_pvArgs, cb);

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    void  Free(void* pv);
    BOOL  WeOwn(void* pv);

    ///////////////////////////////////////////////////////////////////
    //
    // Worker routines
    //
    ///////////////////////////////////////////////////////////////////

    void           CopyWorker                (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyConformantArrayPriv   (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyEmbeddedPointers      (BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    PFORMAT_STRING CopyEmbeddedRepeatPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);

    void           FreeWorker                (BYTE* pMemoryFrom, PFORMAT_STRING pFormat, BOOL fFreePointer);
    void           FreeEmbeddedPointers      (BYTE* pMemory,     PFORMAT_STRING pFormat);
    PFORMAT_STRING FreeEmbeddedRepeatPointers(BYTE* pMemory,     PFORMAT_STRING pFormat);

    void            WalkWorker                  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkConformantArrayPriv     (BYTE* pMemory, PFORMAT_STRING pFormat);
    PFORMAT_STRING  WalkEmbeddedRepeatPointers  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkEmbeddedPointers        (BYTE* pMemory, PFORMAT_STRING pFormat);

    void OutInit(CallFrame*, BYTE** ppArgFrom, BYTE** ppArgTo, PFORMAT_STRING pFormat);
    void OutCopy(            BYTE*  pMemFrom,  BYTE*  pMemTo,  PFORMAT_STRING pFormat);
    void OutZero(            BYTE*  pMem,                      PFORMAT_STRING pFormat, BOOL fDst = TRUE);

//Review API Change for WIN64
#ifndef _WIN64
    ULONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#else
    ULONGLONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#endif

    void  ComputeVariance   (BYTE* pMemory, PFORMAT_STRING pFormat, ULONG* pOffset, ULONG* pCount, BOOL fProbeSrc);
    BYTE* MemoryIncrement   (BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);

    BOOL ByValue(const PARAM_ATTRIBUTES& paramAttr, PFORMAT_STRING pFormatParam,   BOOL fFromCopy) const;
    BOOL FIndirect(BYTE bPointerAttributes,         PFORMAT_STRING pFormatPointee, BOOL fFromCopy) const;
    BOOL IsSafeArray(PFORMAT_STRING pFormat) const;

    PBYTE* GetAllocatedPointer(PBYTE& pbIn)
        // Get a new pointer that will probe correctly in the destination space. pbIn
        // should be a stack variable that we might use for scratch.
    {
#ifdef KERNELMODE
        if (m_pAllocatorFrame && m_fToUser)
        {
            return (PBYTE*)m_pAllocatorFrame->Alloc(sizeof(PBYTE), TRUE);
        }
        else
#endif
        {
            return &pbIn;
        }
    }

    void FreeAllocatedPointer(PBYTE* ppb)
    {
#ifdef KERNELMODE
        if (m_pAllocatorFrame && m_fToUser)
        {
            m_pAllocatorFrame->Free(ppb);
        }
        else
#endif
        {
#ifndef _WIN64
            DEBUG(*ppb = (PBYTE)0xfefefefe);
#else
            DEBUG(*ppb = (PBYTE)0xfefefefefefefefe);
#endif
        }
    }


    BYTE* SetMemory(BYTE* pMemory)
    {
        BYTE* p = m_Memory;
        m_Memory = pMemory;
        return p;
    }
    
    CallFrame* GetFrame(CallFrame*& pFrame, PVOID pvArgs);

    OAUTIL GetHelper() const
    {
        return OAUTIL(m_fFromUser, m_fToUser, m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }
    OAUTIL GetWalker() const
    {
        return OAUTIL(FALSE, FALSE, m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }
    BOOL AnyWalkers() const
    {
        return m_pWalkerCopy || m_pWalkerFree || m_pWalkerWalk;
    }

    BOOL CanShareParameter(ULONG iparam) const
    {
        return m_pmd->m_rgParams[iparam].m_fCanShare;
    }

    ULONG CbParam(ULONG iparam, const PARAM_DESCRIPTION& param) const
    {
        return (iparam == m_pmd->m_numberOfParams ? m_pmd->m_cbPushedByCaller : m_pmd->m_params[iparam+1].StackOffset) - param.StackOffset;
    }
    
    void GetStackSize(ULONG* pcbArgs) const
    {
        *pcbArgs = m_pmd->m_cbPushedByCaller;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Misc
    //
    ///////////////////////////////////////////////////////////////////

    PMIDL_STUB_DESC GetStubDesc() const
    {
        PMIDL_SERVER_INFO pServerInfo = (PMIDL_SERVER_INFO) m_pmd->m_pHeader->pServerInfo;
        return pServerInfo->pStubDesc;
    }

    //////////////////////////////////////////

    BSTR SysAllocStringSrc(LPCWSTR wszSrc)
    {
		TestReadSrc(wszSrc, (ULONG)wcslen(wszSrc));
		return g_oaUtil.SysAllocString(wszSrc);
    }

	BSTR SysCopyBSTRSrc(BSTR bstrSrc)
    {
		UINT len = g_oaUtil.SysStringByteLen(bstrSrc);
		TestReadSrc(bstrSrc, len);
		return g_oaUtil.SysAllocStringByteLen((LPCSTR)bstrSrc, len);
    }

    void SysFreeStringDst(BSTR bstrDst)
    {
        if (bstrDst)
        {
            BSTR_INTERNAL* pint = BSTR_INTERNAL::From(bstrDst);
            TestWriteDst(pint, (ULONG)pint->CbAlloc());
            g_oaUtil.SysFreeString(bstrDst);
        }
    }

};

//////////////////////////////////////////////////////////////////////////////////////////////////
