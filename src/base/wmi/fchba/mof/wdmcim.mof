//***************************************************************************
//
//  wdmcim.mof
// 
//  Module: Fibre channel CIM Mapping classes
//
//  Purpose: Contains WDM classes that are mapped into equivalent CIM classes
//           Includes base CIM classes and fibre channel classes
//
//  Copyright (c) 2001 Microsoft Corporation
//
//***************************************************************************

#pragma namespace("\\\\.\\root\\wmi")

[abstract]
class WDM_ManagedElement
{
    [key]
    string InstanceName;
    boolean Active;
};


[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{37B80E19-8990-40cf-9D31-27CFC5F5D3CE}")
]
class WDM_ManagedSystemElement : WDM_ManagedElement
{
   [Description ( 
         "  A string indicating the current status of the object. "
         "Various operational and non-operational statuses are "
         "defined. Operational statuses are \"OK\", \"Degraded\", "
         "\"Stressed\" and \"Pred Fail\". \"Stressed\" indicates that "
         "the Element is functioning, but needs attention. Examples "
         "of \"Stressed\" states are overload, overheated, etc. The "
         "condition \"Pred Fail\" (failure predicted) indicates that "
         "an Element is functioning properly but predicting a failure "
         "in the near future. An example is a SMART-enabled hard "
         "drive. \n"
         "  Non-operational statuses can also be specified. These "
         "are \"Error\", \"NonRecover\", \"Starting\", \"Stopping\", "
         "\"Service\", \"No Contact\" and \"Lost Comm\". \"NonRecover\" "
         "indicates that a non-recoverable error has occurred. "
         "\"Service\" describes an Element being configured, maintained, "
         "cleaned, or otherwise administered. This status could apply "
         "during mirror-resilvering of a disk, reload of a user "
         "permissions list, or other administrative task. Not all such "
         "work is on-line, yet the Element is neither \"OK\" nor in "
         "one of the other states. \"No Contact\" indicates that the "
         "current instance of the monitoring system has knowledge of "
         "this Element but has never been able to establish "
         "communications with it. \"Lost Comm\" indicates that "
         "the ManagedSystemElement is known to exist and has been "
         "contacted successfully in the past, but is currently unreachable.") : amended,
     ValueMap{   "0",     "1",        "2",       "3",         "4",        "5",        "6",       "7",        "8"},
     Values{    "OK", "Error", "Degraded", "Unknown", "Pred Fail", "Starting", "Stopping", "Service", "Stressed"} : amended,
     WmiDataId(1)
    ]
    uint32 Status;
    
    // CIM_PhysicalElement
    [MaxLen (64), Description (
         "The name by which the PhysicalElement is generally known.") : amended,
     WmiDataId(2)
    ] 
    string Model;

    [MaxLen (64), Description (
         "The stock keeping unit number for this PhysicalElement.") : amended,
     WmiDataId(3)
    ] 
    string SKU;

    [MaxLen (64), Description (
         "A manufacturer-allocated number used to identify the Physical"
         "Element.") : amended,
     WmiDataId(4)
    ] 
    string SerialNumber;

    [MaxLen (256), Description (
         "An arbitrary string that uniquely identifies the Physical"
	   "Element and serves as the Element's key.  The Tag property "
	   "can contain information such as asset tag or serial number "
	   "data. The key for PhysicalElement is placed very high in the "
	   "object hierarchy in order to independently identify the "
	   "hardware/entity, regardless of physical placement in or on "
	   "Cabinets, Adapters, etc.  For example, a hotswappable or "
	   "removeable component may be taken from its containing "
	   "(scoping) Package and be temporarily unused.  The object "
         "still continues to exist - and may even be inserted into a "
	   "different scoping container.  Therefore, the key for Physical"
	   "Element is an arbitrary string and is defined independently "
	   "of any placement or location-oriented hierarchy.") : amended,
     WmiDataId(5)
    ]
    string Tag;

    [MaxLen (64), Description (
	   "A string indicating the version of the PhysicalElement.") : amended,
     WmiDataId(6)
    ] 
    string Version;

    [MaxLen (256), Description (
	   "The part number assigned by the organization responsible for "
	   "producing or manufacturing the PhysicalElement.") : amended,
     WmiDataId(7)
    ]
    string PartNumber;

    [MaxLen(128),
     Description (
	   "OtherIdentifyingInfo captures additional data, beyond asset "
	   "tag information, that could be used to identify a Physical"
	   "Element. One example is bar code data associated with an "
	   "Element that also has an asset tag. Note that if only bar "
	   "code data is available and is unique/able to be used as an "
	   "Element key, this property would be NULL and the bar code "
	   "data used as the class key, in the Tag property.") : amended,
     WmiDataId(8)
    ]
    string OtherIdentifyingInfo;

    [Description (
	   "Boolean indicating that the PhysicalElement is powered on "
	   "(TRUE), or is currently off (FALSE).") : amended,
     WmiDataId(9)
    ]
    boolean PoweredOn;

    [Description (
	  "Date that this PhysicalElement was manufactured.") : amended,
     WmiDataId(10)
    ]
    datetime ManufactureDate;    
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{F87313FA-6D5E-4378-B054-2A1C85F80BE3}")
]
class WDM_PhysicalPackage : WDM_PhysicalElement
{
    [Description (
	  "A PhysicalPackage is Removable if it is designed to be "
	  "taken in and out of the physical container in which it is "
	  "normally found, without impairing the function of the "
	  "overall packaging. A Package can still be Removable if "
	  "power must be 'off' in order to perform the removal. If "
	  "power can be 'on' and the Package removed, then the Element "
	  "is both Removable and HotSwappable. For example, an extra "
	  "battery in a laptop is Removable, as is a disk drive Package "
	  "inserted using SCA connectors. However, the latter is also "
	  "HotSwappable.  A laptop's display is not Removable, nor "
	  "is a non-redundant power supply.  Removing these "
	  "components would impact the function of the overall packaging "
	  "or is impossible due to the tight integration of the Package.") : amended,
     WmiDataId(1)
    ]
    boolean Removable;

    [Description (
	  "A PhysicalPackage is Replaceable if it is possible to "
	  "replace (FRU or upgrade) the Element with a physically "
	  "different one.  For example, some ComputerSystems "
	  "allow the main Processor chip to be upgraded to one of a "
	  "higher clock rating. In this case, the Processor is said "
	  "to be Replaceable. Another example is a power supply "
	  "Package mounted on sliding rails. All Removable packages "
	  "are inherently Replaceable.") : amended,
     WmiDataId(2)
    ]
    boolean Replaceable;

    [Description (
	  "A PhysicalPackage is HotSwappable if it is possible to "
	  "replace the Element with a physically different "
	  "but equivalent one while the containing Package has power "
	  "applied to it (ie, is 'on').  For example, a disk drive "
	  "Package inserted using SCA connectors is both Removable "
	  "and HotSwappable. All HotSwappable packages are inherently "
	  "Removable and Replaceable.") : amended,
     WmiDataId(3)
    ]
    boolean HotSwappable;

    [Description (
	  "The height of the PhysicalPackage in inches.") : amended,
     Units ("Inches") : amended,
     ScalingFactor(3),
     WmiDataId(4)
    ]
    sint64 Height;

    [Description (
        "The depth of the PhysicalPackage in inches.") : amended,
     Units ("Inches") : amended,
     ScalingFactor(3),
     WmiDataId(5)
    ]
    sint64 Depth;

    [Description (
	  "The width of the PhysicalPackage in inches.") : amended,
     Units ("Inches") : amended,
     ScalaingFactor(3),
     WmiDataId(6)
    ]
   sint64 Width;

    [Description (
	  "The weight of the PhysicalPackage in pounds.") : amended,
     Units ("Pounds") : amended,
     WmiDataId(7)
    ]
    sint64 Weight;

#ifdef INCLUDE_METHODS
    [Description (
        "The IsCompatible method verifies whether the referenced "
	  "PhysicalElement may be contained by or inserted into "
	  "the PhysicalPackage. The return value should be 0 if "
	  "the request was successfully executed, 1 if the request "
	  "is not supported and some other value if an error "
	  "occurred. In a subclass, the set of possible return codes "
        "could be specified, using a ValueMap qualifier on the "
        "method. The strings to which the ValueMap contents are "
        "'translated' may also be specified in the subclass as a "
        "Values array qualifier.") : amended,
     WmiMethodId(1)
    ]
    uint32 IsCompatible([IN] CIM_PhysicalElement REF ElementToCheck);
#endif
};


[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{4EC46579-62C6-4944-9D69-CE4586C14005}")
]
class WDM_Card : WDM_PhysicalPackage
{
    [Description (
	  "Boolean indicating that this Card is a Motherboard or, "
	  "more generically, a baseboard in a Chassis.") : amended,
     WmiDataId(1)
    ]
    boolean HostingBoard;

    [MaxLen(128),
     Description (
	  "SlotLayout is a free-form string that describes the "
	  "slot positioning, typical usage, restrictions, individual "
	  "slot spacings or any other pertinent information for the "
	  "slots on a Card.") : amended,
     WmiDataId(2)
    ]
    string SlotLayout;

    [Description (
	  "Boolean indicating that at least one daughterboard or "
	  "auxiliary Card is required in order to function properly.") : amended,
     WmiDataId(3)
    ]
    boolean RequiresDaughterBoard;

    [Description ("Boolean indicating that this Card is physically "
	  "unique from other Cards of the same type and therefore "
	  "requires a special Slot. For example, a double-wide Card "
	  "requires two Slots. Another example is where a certain Card "
	  "may be used for the same general function as other Cards but "
	  "requires a special Slot (e.g., extra long), whereas the "
	  "other Cards can be placed in any available Slot. "
	  "If set to TRUE, then the corresponding property, "
	  "RequirementsDescription, should specify the nature of the "
	  "uniqueness or purpose of the Card.") : amended,
     WmiDataId(4)
    ]
    boolean SpecialRequirements;

    [MaxLen(128),
     Description ("A free-form string describing the way(s) in which "
	  "this Card is physically unique from other Cards. This "
	  "property only has meaning when the corresponding boolean "
	  "property, SpecialRequirements, is set to TRUE.") : amended,
     WmiDataId(5)
    ]
    string RequirementsDescription;

    [Description("Count of operating voltages contained in the OperatingVoltages array") : amended,
     WmiDataId(6)
    ]
    uint32 OperatingVoltagesCount;

    [Description ("Operating voltages required by the Card.") : amended,
     Units("MilliVolts") : amended,
     WmiSizeIs("OperatingVoltagesCount"),
     WmiDataId(7)
    ]
    sint16 OperatingVoltages[];

#ifdef INCLUDE_METHODS
    [Description (
         "This method manipulates the power to a PhysicalConnector on a Card. "
         "It is intended to be used by a Card (especially by a motherboard - "
         "i.e., HostingBoard=TRUE) to turn the power on and off for a "
         "specific PhysicalConnector located on it. For example, in a personal "
         "computer, a system slot does not know how to turn itself on and off. "
         "However, the motherboard hosting this slot may have that capability. "
         "This is important in order to support hot swapping of an adapter card "
         "in a system slot. The method should return 0 if successful, 1 if the request "
         "is not supported, and some other value if any other error occurred. In "
         "a subclass, the set of possible return codes could be specified, using "
         "a ValueMap qualifier on the method. The strings to which the ValueMap "
         "contents are 'translated' may also be specified in the subclass as a "
         "Values array qualifier.") : amended,
     WmiMethodId(2)
    ]
    uint32 ConnectorPower([IN] CIM_PhysicalConnector REF Connector,
                          [IN] boolean PoweredOn);
#endif
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{03D5D21E-9C06-437b-A8B3-177F93F3A5EB}")
]
class MSFC_Card : WDM_Card
{
};


[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{E2DE6A58-68FA-4337-BCE1-4DC88F11006B}")
]
class WDM_PhysicalConnector : WDM_PhysicalElement
{
    [MaxLen(256),
     Description (
	  "A free-form string describing the pin configuration and "
	  "signal usage of a PhysicalConnector.") : amended,
     WmiDataId(1)
    ]
    string ConnectorPinout;

    [MaxLen(128),
     Description (
			"A string describing the Connector - used when the "
			"ConnectorType property is set to 1 (\"Other\"). OtherType "
			"Description should be set to NULL when ConnectorType is any "
			"value other than 1.") : amended,
     WmiDataId(2)
    ]
    string OtherTypeDescription;

    [Description("Count of elements in ConnectorType") : amended,
     WmiDataId(3)
    ]
    uint32 ConnectorTypeCount;

    [Description (
	  "An array of integers defining the type of PhysicalConnector. "
	  "An array is specified to allow the description of "
	  "'combinations' of Connector information. For example, one "
	  "array entry could specify RS-232 (value=25), another DB-25 "
	  "(value=23) and a third entry define the Connector as \"Male\" "
	  "(value=2).") : amended,

     Values {"Unknown", "Other", "Male", "Female", "Shielded",
             "Unshielded", "SCSI (A) High-Density (50 pins)",
             "SCSI (A) Low-Density (50 pins)",
             "SCSI (P) High-Density (68 pins)", "SCSI SCA-I (80 pins)",
             "SCSI SCA-II (80 pins)", "Fibre Channel (DB-9, Copper)",
             "Fibre Channel (Optical Fibre)",
             "Fibre Channel SCA-II (40 pins)", 
             "Fibre Channel SCA-II (20 pins)", "Fibre Channel BNC",
             "ATA 3-1/2 Inch (40 pins)", "ATA 2-1/2 Inch (44 pins)",
             "ATA-2", "ATA-3", "ATA/66", "DB-9", "DB-15", "DB-25",
             "DB-36", "RS-232C", "RS-422", "RS-423", "RS-485", "RS-449",
             "V.35", "X.21", "IEEE-488", "AUI", "UPT Category 3",
             "UPT Category 4", "UPT Category 5", "BNC", "RJ11", "RJ45",
             "Fiber MIC", "Apple AUI", "Apple GeoPort", "PCI", "ISA",
             "EISA", "VESA", "PCMCIA", "PCMCIA Type I",
             "PCMCIA Type II", "PCMCIA Type III", "ZV Port", "CardBus",
             "USB", "IEEE 1394", "HIPPI", "HSSDC (6 pins)", "GBIC",
             "DIN", "Mini-DIN", "Micro-DIN", "PS/2", "Infrared",
             "HP-HIL", "Access.bus", "NuBus", "Centronics",
             "Mini-Centronics", "Mini-Centronics Type-14",
             "Mini-Centronics Type-20", "Mini-Centronics Type-26",
             "Bus Mouse", "ADB", "AGP", "VME Bus", "VME64",
             "Proprietary", "Proprietary Processor Card Slot",
             "Proprietary Memory Card Slot", "Proprietary I/O Riser Slot",
             "PCI-66MHZ", "AGP2X", "AGP4X", "PC-98", "PC-98-Hireso",
             "PC-H98", "PC-98Note", "PC-98Full", "SSA SCSI",
             "Circular", "On Board IDE Connector", 
             "On Board Floppy Connector", "9 Pin Dual Inline", 
             "25 Pin Dual Inline", "50 Pin Dual Inline",
             "68 Pin Dual Inline", "On Board Sound Connector", 
             "Mini-jack", "PCI-X", "Sbus IEEE 1396-1993 32 bit",
             "Sbus IEEE 1396-1993 64 bit", "MCA", "GIO", "XIO", 
             "HIO", "NGIO", "PMC", "MTRJ", "VF-45", "Future I/O",
             "SC", "SG", "Electrical", "Optical", "Ribbon", "GLM", 
             "1x9", "Mini SG", "LC", "HSSC","VHDCI Shielded (68 pins)",
             "InfiniBand"} : amended,
     WmiSizeIs("ConnectorTypeCount"),
     WmiDataId(4)
    ]
    uint16 ConnectorType[];

};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{0765055B-9B32-4133-A6ED-767AF9E9BF74}")
]
class MSFC_PhysicalConnector : WDM_PhysicalConnector
{
};


class WDM_LogicalElement : WDM_ManagedSystemElement
{
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{D1CF550B-7CD6-46e0-91D3-CB0C5815B7CD}")
]
class WDM_LogicalDevice : WDM_LogicalElement
{
    [Description (
         "The number of consecutive hours that this Device has been "
         "powered, since its last power cycle.") : amended,
     Units ("Hours") : amended,
     WmiDataId(1)
    ]
    uint64 PowerOnHours;

    [Description (
         "The total number of hours that this Device has been "
         "powered.") : amended,
         Units ("Hours") : amended,
     WmiDataId(2)
    ]
    uint64 TotalPowerOnHours;

    [Description (
         "Maximum time in milliseconds, that a Device can run in a \"Quiesced\" "
         "state. A Device's state is defined in its Availability and Additional"
         "Availability properties, where \"Quiesced\" is conveyed by the value "
         "21. What occurs at the end of the time limit is device-specific. The "
         "Device may unquiesce, may offline or take other action. A value of 0 "
         "indicates that a Device can remain quiesced indefinitely.") : amended, 
     Units ("MilliSeconds") : amended,
     WmiDataId(3)
    ]
    uint64 MaxQuiesceTime;

    [Description (
		"The primary availability and status of the Device. (Additional "
		"status information can be specified using the AdditionalAvailability "
		"array property.) For example, the Availability property indicates "
		"that the Device is running and has full power (value=3), or is in "
		"a warning (4), test (5), degraded (10) or power save state (values "
		"13-15 and 17). Regarding the Power Save states, these are defined "
         "as follows: Value 13 (\"Power Save - Unknown\") indicates "
	   "that the Device is known to be in a power save mode, but its "
	   "exact status in this mode is unknown; 14 (\"Power Save - Low "
	   "Power Mode\") indicates that the Device is in a power save "
	   "state but still functioning, and may exhibit degraded "
	   "performance; 15 (\"Power Save - Standby\") describes that "
	   "the Device is not functioning but could be brought to full "
	   "power 'quickly'; and value 17 (\"Power Save - Warning\") "
	   "indicates that the Device is in a warning state, though also "
	   "in a power save mode.") : amended, 
     ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9",
	       "10", "11", "12", "13", "14", "15", "16", "17", "18", "19",
	       "20", "21"},
     Values {"Other", "Unknown", "Running/Full Power", "Warning", 
	       "In Test", "Not Applicable", "Power Off", "Off Line", 
	       "Off Duty", "Degraded", "Not Installed", "Install Error",
	       "Power Save - Unknown", "Power Save - Low Power Mode", 
	       "Power Save - Standby", "Power Cycle","Power Save - Warning", 
       	       "Paused", "Not Ready", "Not Configured", "Quiesced"} : amended, 
     WmiDataId(4)
    ]
    uint16 Availability;

    [Description (
         "StatusInfo is a string indicating whether the Logical"
         "Device is in an enabled (value = 3), disabled (value = "
         "4) or some other (1) or unknown (2) state. If this "
         "property does not apply to the LogicalDevice, the value, "
         "5 (\"Not Applicable\"), should be used. "
		"If a Device is (\"Enabled\")(value=3), it has been powered up, and is "
        "configured and operational. The Device may or may not be functionally "
        "active, depending on whether its Availability (or AdditionalAvailability) "
        "indicate that it is (\"Running/Full Power\")(value=3) or (\"Off line\")"
        "(value=8). In an enabled but offline mode, a Device may be performing "
        "out-of-band requests, such as running Diagnostics. If (\"Disabled\")"
        "(StatusInfo value=4), a Device can only be \"enabled\" or powered off. "
        "In a personal computer environment, (\"Disabled\") means that the "
        "Device's driver is not available in the stack. In other environments, "
        "a Device can be disabled by removing its configuration file. A "
        "disabled device is physically present in a System and consuming "
        "resources, but can not be communicated with until a load of a driver, "
        "a load of a configuration file or some other \"enabling\" activity has "
        "occurred.") : amended,
         ValueMap {"1", "2", "3", "4", "5"},
         Values {"Other", "Unknown", "Enabled",
	       "Disabled", "Not Applicable"} : amended,
     WmiDataId(5)
    ]
    uint16 StatusInfo;

    [Description (
	   "LastErrorCode captures the last error code reported by " 
	   "the LogicalDevice.") : amended,
     WmiDataId(6)
    ]
    uint32 LastErrorCode;

    [
     Description (
	   "ErrorDescription is a free-form string supplying more " 
	   "information about the error recorded in LastErrorCode, and " 
	   "information on any corrective actions that may be taken.") : amended,
     Values{"None Specified"} : amended,
     WmiDataId(7)
    ]
    uint32 ErrorDescription;

    [Description (
         "Boolean indicating that the Device can be power managed "
         "- ie, put into a power save state. This boolean does not "
         "indicate that power management features are currently "
         "enabled, or if enabled, what features are supported. "
         "Refer to the PowerManagementCapabilities array for this "
         "information. If this boolean is false, the integer value "
         "1, for the string, \"Not Supported\", should be the only "
         "entry in the PowerManagementCapabilities array.") : amended,
     WmiDataId(8)
    ]	
    boolean PowerManagementSupported;

    [Description (
	   "ErrorCleared is a boolean property indicating that the " 
	   "error reported in LastErrorCode is now cleared.") : amended,
     WmiDataId(9)
    ]
    boolean ErrorCleared;

    [Description("Count of elements in PowerManagementCapabilities") : amended,
     WmiDataId(10)
    ]
    uint32 PowerManagementCapabilitiesCount;

    [Description(
         "Indicates the specific power-related capabilities of a "
         "LogicalDevice. The array values, 0=\"Unknown\", 1="
	   "\"Not Supported\" and 2=\"Disabled\" are self-explanatory. "
	   "The value, 3=\"Enabled\" indicates that the power management "
	   "features are currently enabled but the exact feature set "
	   "is unknown or the information is unavailable. "
	   "\"Power Saving Modes Entered Automatically\" (4) describes "
	   "that a Device can change its power state based on usage or "
	   "other criteria. \"Power State Settable\" (5) indicates that "
	   "the SetPowerState method is supported. \"Power Cycling "
         "Supported\" (6) indicates that the SetPowerState method "
	   "can be invoked with the PowerState input variable set to 5 ("
	   "\"Power Cycle\"). \"Timed Power On Supported\" (7) indicates "
	   "that the SetPowerState method can be invoked with the Power"
	   "State input variable set to 5 (\"Power Cycle\") and the Time "
	   "parameter set to a specific date and time, or interval, "
	   "for power-on.") : amended,
    Values {"Unknown", "Not Supported", "Disabled", 
	       "Enabled", "Power Saving Modes Entered Automatically",
	       "Power State Settable", "Power Cycling Supported",
	       "Timed Power On Supported"} : amended,
    WmiSizeIs("PowerManagementCapabilitiesCount"),
    WmiDataId(11) 
    ]
    uint16 PowerManagementCapabilities[];

    [Description("Count of elements in AdditionalAvailability") : amended,
     WmiDataId(12)
    ]
    uint32 AdditionalAvailabilityCount;

    [Description (
         "Additional availability and status of the Device, beyond that "
         "specified in the Availability property. The Availability property "
         "denotes the primary status and availability of the Device. In "
         "some cases, this will not be sufficient to denote the complete "
         "status of the Device.  In those cases, the AdditionalAvailability "
         "property can be used to provide further information. For example, "
         "a Device's primary Availability may be \"Off line\" (value=8), "
         "but it may also be in a low power state (AdditonalAvailability "
         "value=14), or the Device could be running Diagnostics (Additional"
         "Availability value=5, \"In Test\").") : amended,

     ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9",
             "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", 
             "20", "21"},
     Values {"Other", "Unknown", "Running/Full Power", "Warning", 
             "In Test", "Not Applicable", "Power Off", "Off Line", 
             "Off Duty", "Degraded", "Not Installed", "Install Error",
             "Power Save - Unknown", "Power Save - Low Power Mode", 
             "Power Save - Standby", "Power Cycle", 
             "Power Save - Warning", "Paused", "Not Ready",
             "Not Configured", "Quiesced"} : amended, 
     WmiSizeIs("AdditionalAvailabilityCount"),
     WmiDataId(13)
    ]
    uint16 AdditionalAvailability[];

    [Description("Count of elements in IdentifyingDescriptions") : amended,
     WmiDataId(14)
    ]
    uint32 IdentifyingDescriptionsCount;

    [
     Description (
         "An array of free-form strings providing explanations "
         "and details behind the entries in the OtherIdentifyingInfo "
         "array. Note, each entry of this array is related to the "
         "entry in OtherIdentifyingInfo that is located at the same "
         "index.") : amended,
     WmiSizeIs("IdentifyingDescriptionsCount"),
     WmiDataId(15)
    ]
    string IdentifyingDescriptions[];

    [Description("Count of elements in OtherIdentifyingInfo") : amended,
     WmiDataId(16)
    ]
    uint32 OtherIdentifyingInfoCount;

    [
     Description (
         "OtherIdentifyingInfo captures additional data, beyond "
         "DeviceID information, that could be used to identify a "
         "LogicalDevice. One example would be to hold the Operating"
         "System's user friendly name for the Device in this "
         "property.") : amended,
     WmiSizeIs("OtherIdentifyingInfoCount"),
     WmiDataId(17)
    ]
    string OtherIdentifyingInfo[];

#ifdef INCLUDE_METHODS
    [Description(
         "SetPowerState defines the desired power state for a "
         "LogicalDevice and when a Device should be put into that "
         "state. The desired power state is specified by setting "
	   "the PowerState parameter to one of the "
         "following integer values: 1=\"Full Power\", 2=\"Power Save "
	   "- Low Power Mode\", 3=\"Power Save - Standby\", 4=\"Power "
	   "Save - Other\", 5=\"Power Cycle\" or 6=\"Power Off\". "
         "The Time parameter (for all state changes but 5, "
         "\"Power Cycle\") indicates when the power state should be "
         "set, either as a regular date-time value or as an interval "
         "value (where the interval begins when the method "
         "invocation is received). When the PowerState parameter is "
         "equal to 5, \"Power Cycle\", the Time parameter indicates "
	   "when the Device should power on again. Power off is "
	   "immediate. SetPowerState should return 0 if successful, 1 "
	   "if the specified PowerState and Time request is not "
	   "supported, and some other value if any other error "
	   "occurred. In a subclass, the set of possible return codes "
         "could be specified, using a ValueMap qualifier on the method. "
         "The strings to which the ValueMap contents are 'translated' "
         "may also be specified in the subclass as a Values array "
         "qualifier.") : amended,
     WmiMethodId(1)
    ]
    uint32 SetPowerState([IN, ValueMap {"1", "2", "3", "4", "5", "6"},
                              Values {"Full Power", "Power Save - Low Power Mode", 
                                      "Power Save - Standby", "Power Save - Other", "Power Cycle",
                                      "Power Off"}: amended] uint16 PowerState, [IN] datetime Time);

    [Description (
         "Requests a reset of the LogicalDevice. The return value "
         "should be 0 if the request was successfully executed, "
         "1 if the request is not supported and some other value "
         "if an error occurred. In a subclass, the set of possible "
         "return codes could be specified, using a ValueMap qualifier "
         "on the method. The strings to which the ValueMap contents "
         "are 'translated' may also be specified in the subclass as a "
         "Values array qualifier.") : amended,
     WmiMethodId(2) 
    ]
    uint32 Reset();

    [Description (
         "Requests that the LogicalDevice be enabled (\"Enabled\" "
         "input parameter = TRUE) or disabled (= FALSE). If "
         "successful, the Device's StatusInfo property should also "
         "reflect the desired state (enabled/disabled). The return "
         "code should be 0 if the request was successfully executed, "
         "1 if the request is not supported and some other value if "
         "an error occurred. In a subclass, the set of possible "
         "return codes could be specified, using a ValueMap qualifier "
         "on the method. The strings to which the ValueMap contents "
         "are 'translated' may also be specified in the subclass as a "
         "Values array qualifier.") : amended,
     WmiMethodId(3)
    ]
    uint32 EnableDevice([IN] boolean Enabled);

    [Description (
         "Requests that the LogicalDevice be brought online (\"Online\" "
         "input parameter = TRUE) or taken offline (= FALSE). "
         "\"Online\" indicates that the Device is ready to accept "
         "requests, and is operational and fully functioning. In this "
         "case, the Device's Availability property would be set to "
         "a value of 3 (\"Running/Full Power\"). \"Offline\" indicates "
         "that a Device is powered up and operational, but not processing "
         "functional requests. In an offline state, a Device may be capable "
         "of running diagnostics or generating operational alerts. For "
         "example, when the \"Offline\" button is pushed on a Printer, the "
         "Device is no longer available to process print jobs, but "
         "could be available for diagnostics or maintenance.\n"
         "If this method is successful, the Device's Availability and "
         "AdditionalAvailability properties should reflect the updated "
         "status. If a failure occurs trying to bring the Device online "
         "or offline, it should remain in its current state. IE, the "
         "request, if unsuccessful, should not leave the Device in an "
         "indeterminate state. When bringing a Device back \"Online\", "
         "from an \"Offline\" mode, the Device should be restored to its "
         "last \"Online\" state, if at all possible. Only a Device that "
         "has a StatusInfo of \"Enabled\" (value=3) and has been "
         "configured can be brought online or taken offline.\n"
         "OnlineDevice should return 0 if successful, 1 if the request is not "
         "supported at all, 2 if the request is not supported due to the "
         "current state of the Device, and some other value if any other "
         "error occurred. In a subclass, the set of possible return codes "
         "could be specified, using a ValueMap qualifier on the method. "
         "The strings to which the ValueMap contents are 'translated' may "
         "also be specified in the subclass as a Values array qualifier.") : amended,
     WmiMethodId(4)
    ]
    uint32 OnlineDevice([IN] boolean Online);

    [Description (
         "Requests that the LogicalDevice cleanly cease all current activity " 
         "(\"Quiesce\" input parameter = TRUE) or resume activity (= FALSE). For "
         "this method to quiesce a Device, that Device should have an Availability "
         "(or AdditionalAvailability) of \"Running/Full Power\" (value=3) and a Status"
         "Info of \"Enabled\" (value=3). For example, if quiesced, a Device may "
         "then be offlined for diagnostics, or disabled for power off and hot swap. "
         "For the method to \"unquiesce\" a Device, that Device should have an "
         "Availability (or AdditionalAvailability) of \"Quiesced\" (value=21) and "
         "a StatusInfo of \"Enabled\" (value=3). In this case, the Device would "
         "be returned to an \"Enabled\" and \"Running/Full Power\" status.\n"
         "The method's return code should indicate the success or failure of the "
         "quiesce. It should return 0 if successful, 1 if the request is not "
         "supported at all, 2 if the request is not supported due to the "
         "current state of the Device, and some other value if any other "
         "error occurred. In a subclass, the set of possible return codes "
         "could be specified, using a ValueMap qualifier on the method. "
         "The strings to which the ValueMap contents are 'translated' may "
         "also be specified in the subclass as a Values array qualifier.") : amended,
    WmiMethodId(5)
    ]
    uint32 QuiesceDevice([IN] boolean Quiesce);

    [Description (
         "Requests that the Device capture its current configuration, setup "
         "and/or state information in a backing store. The goal would be to "
         "use this information at a later time (via the RestoreProperties method), "
         "to return a Device to its present \"condition\". This method may not be "
         "supported by all Devices. The method should return 0 if successful, "
         "1 if the request is not supported, and some other value if any other "
         "error occurred. In a subclass, the set of possible return codes could "
         "be specified, using a ValueMap qualifier on the method. The strings "
         "to which the ValueMap contents are 'translated' may also be specified "
         "in the subclass as a Values array qualifier.") : amended,
     WmiMethodId(6) 
    ]
    uint32 SaveProperties();

    [Description (
         "Requests that the Device re-establish its configuration, setup "
         "and/or state information from a backing store. The intent is to "
         "capture this information at an earlier time (via the SaveProperties method), "
         "and use it to return a Device to this earlier \"condition\". This method may "
         "not be supported by all Devices. The method should return 0 if successful, "
         "1 if the request is not supported, and some other value if any other "
         "error occurred. In a subclass, the set of possible return codes could "
         "be specified, using a ValueMap qualifier on the method. The strings "
         "to which the ValueMap contents are 'translated' may also be specified "
         "in the subclass as a Values array qualifier.") : amended 
     WmiMethodId(7),
    ]
    uint32 RestoreProperties();        
#endif
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{2EC84C55-D9C8-49a6-BD5F-EE51133C8572}")
]
class WDM_NetworkAdapter : WDM_LogicalDevice
{
    [MaxLen (64), 
     Description (
	  "PermanentAddress defines the network address hardcoded into "
	  "an adapter.  This 'hardcoded' address may be changed via "
	  "firmware upgrade or software configuration. If so, this field "
	  "should be updated when the change is made.  PermanentAddress "
	  "should be left blank if no 'hardcoded' address exists for the "
	  "NetworkAdapter.") : amended,
     WmiDataId(1)
    ]	    
    string PermanentAddress;

    [Description (
	  "An estimate of the current bandwidth in Bits per Second. "
	  "For Adapters which vary in bandwidth or for those where "
	  "no accurate estimation can be made, this property should "
	  "contain the nominal bandwidth.") : amended,
     Units ("Bits per Second") : amended, 
     WmiDataId(2)
    ]
    uint64 Speed;

    [Description ( 
	  "The maximum speed, in Bits per Second, for the Network"
	  "Adapter.") : amended, 
     Units ("Bits per Second") : amended,
     WmiDataId(3)
    ] 
    uint64 MaxSpeed;

    [Description (
        "Boolean indicating that the Adapter is operating in "
        "full duplex mode.") : amended,
     WmiDataId(4)
   ]
   boolean FullDuplex;

    [Description ( 
	  "A boolean indicating whether the NetworkAdapter is capable " 
	  "of automatically determining the speed or other communications "
        "characteristics of the attached network media.") : amended,
     WmiDataId(5)
    ] 
    boolean AutoSense;

    [Description (
	  "The total number of octets transmitted, including framing "
	  "characters.") : amended,
     WmiDataId(6)
    ] 
    uint64 OctetsTransmitted;

    [Description (
	  "The total number of octets received, including framing "
	  "characters.") : amended,
     WmiDataId(7)
    ] 
    uint64 OctetsReceived;

    [Description("Count of elements in NetworkAddresses") : amended,
     WmiDataId(8)
    ]
    uint32 NetworkAddressesCount;

    [
     Description (
	  "An array of strings indicating the network addresses for an "
	  "adapter.") : amended,
     WmiDataId(9),
     WmiSizeIs("NetworkAddressesCount")
    ]
    string NetworkAddresses[]; 
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{0D84988A-42C8-42e7-820A-F7ABF1E4A0B7}")
]
class WDM_FibreChannelAdapter : WDM_NetworkAdapter
{
    [Description (
        "The maximum frame size, in bytes, supported by the Adapter.") : amended, 
     Units ("Bytes") : amended,
     WmiDataId(1)
    ]
    uint64 MaxFrameSize;

    [Description (
        "The number of times that a frame was received but no "
        "buffer was available.") : amended, 
     WmiDataId(2)
    ]
    uint64 ReceiveBufferErrors;

    [Description (
        "The number of times that a frame was received but no "
        "end-to-end credit was available.") : amended, 
     WmiDataId(3)
    ]
    uint64 ReceiveEndErrors;

    [Description (
        "A 'long' timeout value (in milliseconds) for determining "
        "when to reinstate a Recovery_Qualifier. The default value "
        "is 120 seconds (120000 milliseconds). It is typically set "
        "to the ErrorDetectTimeout value + 2*(fabric delay time).") : amended, 
     Units ("MilliSeconds") : amended,
     WmiDataId(4)
    ]
    uint64 ResourceAllocationTimeout;

    [Description (
        "A 'short' timeout value (in milliseconds) for determining "
        "that an error has occurred. The default value is 10 "
        "seconds (10000 milliseconds).") : amended, 
     Units ("MilliSeconds") : amended,
     WmiDataId(5)
    ]
    uint64 ErrorDetectTimeout;

    [Description (
        "Number of Class 1 sequences sent since last reset of the "
        "Device.") : amended,
     WmiDataId(6)
    ]
    uint64 Class1SequencesSent;

    [Description (
        "Number of Class 2 sequences sent since last reset of the "
        "Device.") : amended,
     WmiDataId(7)
    ]
    uint64 Class2SequencesSent;

    [Description (
        "Number of Class 3 sequences sent since last reset of the "
        "Device.") : amended,
     WmiDataId(8)
    ]
    uint64 Class3SequencesSent;

    [Description (
        "Number of Class 4 sequences sent since last reset of the "
        "Device.") : amended,
     WmiDataId(9)
    ]
    uint64 Class4SequencesSent;

    [Description (
        "Number of octets received by the Adapter when running "
        "Class 2 service.") : amended,
     WmiDataId(10)
    ]
    uint64 Class2OctetsReceived;

    [Description (
        "Number of octets transmitted by the Adapter when running "
        "Class 2 service.") : amended,
     WmiDataId(11)
    ]
    uint64 Class2OctetsTransmitted;

    [Description (
        "Number of frames received by the Adapter when running "
        "Class 2 service.") : amended,
     WmiDataId(12)
    ]
    uint64 Class2FramesReceived;

    [Description (
        "Number of frames transmitted by the Adapter when running "
        "Class 2 service.") : amended,
     WmiDataId(13)
    ]
    uint64 Class2FramesTransmitted;

    [Description (
        "Number of frames discarded by the Adapter when running "
        "Class 2 service.") : amended,
     WmiDataId(14)
    ]
    uint64 Class2DiscardFrames;

    [Description (
        "Number of octets received by the Adapter when running "
        "Class 3 service.") : amended,
     WmiDataId(15)
    ]
    uint64 Class3OctetsReceived;

    [Description (
        "Number of octets transmitted by the Adapter when running "
        "Class 3 service.") : amended,
     WmiDataId(16)
    ]
    uint64 Class3OctetsTransmitted;

    [Description (
        "Number of frames received by the Adapter when running "
        "Class 3 service.") : amended, 
     WmiDataId(17)
    ]
    uint64 Class3FramesReceived;

   [Description (
        "Number of frames transmitted by the Adapter when running "
        "Class 3 service.") : amended,
     WmiDataId(18)
    ]
    uint64 Class3FramesTransmitted;

   [Description (
        "Number of frames discarded by the Adapter when running "
        "Class 3 service.") : amended,
     WmiDataId(19)
    ]
    uint64 Class3DiscardFrames;

   [Description (
        "Number of parity errors detected somewhere in the "
        "data path.") : amended,
     WmiDataId(20)
    ]
    uint64 ParityErrors;

   [Description (
        "Number of Class 1 or 2 frames that are not ACKed "
        "within the time indicated by ErrorDetectTimeout.") : amended, 
     WmiDataId(21)
    ]
    uint64 FrameTimeouts;

   [Description (
        "Number of times that the Device has been without a "
        "buffer credit for a time longer than ErrorDetectTimeout.") : amended, 
     WmiDataId(22)
    ]
    uint64 BufferCreditErrors;

   [Description (
        "Number of times that the Device has been without an end "
        "credit for a time longer than ErrorDetectTimeout.") : amended, 
     WmiDataId(23)
    ]
    uint64 EndCreditErrors;

   [Description ("Number of frames received out of order.") : amended, 
     WmiDataId(24)
    ]
    uint64 OutOfOrderFramesReceived;

    [Description("Number of elements in SupportedCOS") : amended,
     WmiDataId(25)
    ]
    uint32 SupportedCOSCount;

    [Description (
        "The Fibre Channel Classes of Service that are supported by "
        "the Adapter, on its Ports. The currently negotiated COS for a "
        "connection is a property (NegotiatedCOS) on the FibrePort"
        "ActiveLogin association.") : amended, 
     Values {"Unknown", "1", "2", "3", "4", "6", "F"} : amended,
     WmiSizeIs("SupportedCOSCount"),
     WmiDataId(26)
    ]
    uint16 SupportedCOS[];

    [Description("Count of elements in FC4TypesSupported") : amended,
     WmiDataId(27)
    ]
    uint32 FC4TypesSupportedCount;

    [Description (
        "An array of integers indicating the Fibre Channel FC-4 "
        "protocols supported by the Adapter. The protocols that are "
        "active and running are indicated in the CurrentFC4Types "
        "property. The values used in this array are taken from the "
        "FC-GS2 (bitmapped) field defined in Table 11 of the standard. "
        "Also, FC-SB-2 codes are included from the T11 document, "
        "236V0. If the FC4 Type is \"Vendor Unique\" (value=255), "
        "then the specific vendor values (in the range, 0xE0 to 0xFF) "
        "should be listed in the FC4VendorUniqueTypes property.") : amended, 
       ValueMap {"0", "1", "4", "5", "8", "9", "17", "18", "19", "21", 
               "22", "23", "25", "26", "27", "28", "32", "34", "36", 
               "64", "80", "81", "82", "88", "96", "255"}, 
       Values {"Unknown", "Other", "ISO/IEC 8802 - 2 LLC", 
             "IP over FC", "SCSI - FCP", "SCSI - GPP", 
             "IPI - 3 Master", "IPI - 3 Slave", "IPI - 3 Peer", 
             "CP IPI - 3 Master", "CP IPI - 3 Slave", 
             "CP IPI - 3 Peer", "SBCCS Channel", 
             "SBCCS Control Unit", "FC-SB-2 Channel", 
             "FC-SB-2 Control Unit", 
             "Fibre Channel Services (FC-GS, FC-GS-2, FC-GS-3)", 
             "FC-SW", "FC - SNMP", "HIPPI - FP", "BBL Control", 
             "BBL FDDI Encapsulated LAN PDU", 
             "BBL 802.3 Encapsulated LAN PDU", "FC - VI", "FC - AV", 
             "Vendor Unique"} : amended, 
     WmiSizeIs("FC4TypesSupportedCount"),
     WmiDataId(28)
    ]
    uint16 FC4TypesSupported[];

    [Description("Count of elements in FC4VendorUniqueTypes") : amended,
     WmiDataId(29)
    ]
    uint32 FC4VendorUniqueTypesCount;

    [Description (
        "When the FC4TypesSupported array contains the value 255 "
        "(\"Vendor Unique\"), then the property, FC4VendorUniqueTypes, "
        "lists of all the vendor specific protocols supported by the "
        "Adapter. These values are in the range, 0xE0 to 0xFF.") : amended, 
       MinValue (240), MaxValue (255),
     WmiSizeIs("FC4VendorUniqueTypesCount"),
     WmiDataId(30)
    ]
    uint16 FC4VendorUniqueTypes[];

    [Description("Count of elements in CurrentFC4Types") : amended,
     WmiDataId(31)
    ]
    uint32 CurrentFC4TypesCount;

    [Description (
        "An array of integers indicating the Fibre Channel FC-4 "
        "protocols currently running on the Adapter. A list of all "
        "protocols supported by the Adapter is indicated in the "
        "FC4TypesSupported property. The values used in this array "
        "are taken from the FC-GS2 (bitmapped) field defined in "
        "Table 11 of the standard. Also, FC-SB-2 codes are included "
        "from the T11 document, 236V0. If the FC4 Type is \"Vendor "
        "Unique\" (value=255), then the specific vendor values "
        "(in the range, 0xE0 to 0xFF) that are currently running "
        "should be listed in the CurrentFC4VendorTypes property.") : amended, 
    ValueMap {"0", "1", "4", "5", "8", "9", "17", "18", "19", "21", 
               "22", "23", "25", "26", "27", "28", "32", "34", "36", 
               "64", "80", "81", "82", "88", "96", "255"}, 
    Values {"Unknown", "Other", "ISO/IEC 8802 - 2 LLC", 
             "IP over FC", "SCSI - FCP", "SCSI - GPP", 
             "IPI - 3 Master", "IPI - 3 Slave", "IPI - 3 Peer", 
             "CP IPI - 3 Master", "CP IPI - 3 Slave", 
             "CP IPI - 3 Peer", "SBCCS Channel", 
             "SBCCS Control Unit", "FC-SB-2 Channel", 
             "FC-SB-2 Control Unit", 
             "Fibre Channel Services (FC-GS, FC-GS-2, FC-GS-3)", 
             "FC-SW", "FC - SNMP", "HIPPI - FP", "BBL Control", 
             "BBL FDDI Encapsulated LAN PDU", 
             "BBL 802.3 Encapsulated LAN PDU", "FC - VI", "FC - AV", 
             "Vendor Unique"} : amended, 
     WmiSizeIs("CurrentFC4TypesCount"),
     WmiDataId(32)
    ]
    uint16 CurrentFC4Types[];


    [Description("Count of elements in CurrentFC4VendorTypes") : amended,
     WmiDataId(33)
    ]
    uint32 CurrentFC4VendorTypesCount;

    [Description (
        "When the CurrentFC4Types array contains the value 255 "
        "(\"Vendor Unique\"), then the property, CurrentFC4VendorTypes, "
        "lists all the vendor specific protocols running on the "
        "Adapter. These values are in the range, 0xE0 to 0xFF.") : amended, 
       MinValue (240), MaxValue (255), 
     WmiSizeIs("CurrentFC4VendorTypesCount"),
     WmiDataId(34)
    ]
    uint16 CurrentFC4VendorTypes[];

    [Description("Count of elements in Capabilities") : amended,
     WmiDataId(35)
    ]
    uint32 CapabilitiesCount;

    [Description (
        "A list of the Capabilities of the Fibre Channel Adapter. "
        "For example, that the Adapter utilizes the Directory Server, "
        "or that it generates State Change Notifications can be "
        "indicated using the values 2 and 12, respectively.") : amended, 
     Values {"Unknown", "Other", "Utilizes the Directory Server", 
             "Utilizes the Time Server", 
             "Utilizes the Management Server", 
             "Utilizes the Alias Server", 
             "Utilizes the Security Key Distribution Server", 
             "Utilizes the Clock Synchronization Server", 
             "Utilizes the Multicast Server", 
             "Utilizes QoS Facilitator", 
             "Utilizes Broadcast Services", 
             "Supports Fabric Login Server", 
             "Generates State Change Notifications", 
             "Registers for State Change Notifications", 
             "Responds to Read Connection Status", 
             "Supports Third Party Process Logout"} : amended,
     WmiSizeIs("CapabilitiesCount"),
     WmiDataId(36)
    ]
   uint16 Capabilities[];

    [Description (
	  "An array of free-form strings providing more detailed "
	  "explanations for any of the Adapter features indicated in "
	  "the Capabilities array. Note, each entry of this array "
	  "is related to the entry in the Capabilities array that "
	  "is located at the same index.") : amended,
     ValueMap{"0"},
     Values{"No Additional Information"} : amended,
     WmiSizeIs("CapabilitiesCount"),
     WmiDataId(37)
    ]
    uint32 CapabilityDescriptions[];
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{480C4319-341B-4bc5-8678-B35F1A0F0780}")
]
class MSFC_FibreChannelAdapter : WDM_FibreChannelAdapter
{
    [Description("Unique id for this specific Fibre Channel Adapter exposed by this class") : amended,
     WmiDataId(1)
    ]
    uint64 UniqueAdapterId;
};


[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{45FB6078-314D-4983-9E8E-10B8D7A3B75D}")
]
class WDM_Controller : WDM_LogicalDevice
{
    [Description ("Time of last reset of the Controller.") : amended,
     WmiDataId(1)
    ]
    datetime TimeOfLastReset;

    [Description (
	  "The protocol used by the Controller to access 'controlled' "
	  "Devices.") : amended,
     ValueMap {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
	       "11", "12", "13", "14", "15", "16", "17", "18", "19",
	       "20", "21", "22", "23", "24", "25", "26", "27", "28",
	       "29", "30", "31", "32", "33", "34", "35", "36", "37",
	       "38", "39", "40", "41", "42", "43", "44", "45", "46", 
             "47"},
    Values {"Other", "Unknown", "EISA", "ISA", "PCI", "ATA/ATAPI",
	       "Flexible Diskette", "1496", "SCSI Parallel Interface",
	       "SCSI Fibre Channel Protocol", "SCSI Serial Bus Protocol",
	       "SCSI Serial Bus Protocol-2 (1394)", 
	       "SCSI Serial Storage Architecture", "VESA", "PCMCIA",        
	       "Universal Serial Bus", "Parallel Protocol", "ESCON",
	       "Diagnostic", "I2C", "Power", "HIPPI", "MultiBus", "VME",
	       "IPI", "IEEE-488", "RS232", "IEEE 802.3 10BASE5",
	       "IEEE 802.3 10BASE2", "IEEE 802.3 1BASE5",
	       "IEEE 802.3 10BROAD36", "IEEE 802.3 100BASEVG",
	       "IEEE 802.5 Token-Ring", "ANSI X3T9.5 FDDI", "MCA", 
	       "ESDI", "IDE", "CMD", "ST506", "DSSI", "QIC2", 
	       "Enhanced ATA/IDE", "AGP", "TWIRP (two-way infrared)", 
             "FIR (fast infrared)", "SIR (serial infrared)", 
             "IrBus"} : amended, 
     WmiDataId(2)
    ]
    uint16 ProtocolSupported;

    [Description (
	  "Maximum number of directly addressable entities supported "
	  "by this Controller.  A value of 0 should be used if the "
	  "number is unknown or unlimited.") : amended,
    WmiDataId(3)
    ]
    uint32 MaxNumberControlled;	

    [MaxLen(256),
     Description (
		"A free form string providing more information related "
		"to the ProtocolSupported by the Controller.") : amended,
     WmiDataId(4)
    ]
    string ProtocolDescription;
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{F768F170-90D8-4122-88E9-AFF43F730019}")
]
class WDM_ScsiController : WDM_Controller
{
    [Description (
	  "An integer enumeration indicating whether or not the "
	  "SCSIController provides redundancy or protection against "
	  "device failures.") : amended,
     ValueMap {"1", "2", "3", "4", "5", "6"},
     Values {"Other", "Unknown", "Unprotected", "Protected", 
	       "Protected through SCC (SCSI-3 Controller Command)",
	       "Protected through SCC-2 (SCSI-3 Controller Command)"} : amended,
     WmiDataId(1)
    ]
    uint16 ProtectionManagement;

    [Description (
	 "Maximum data width (in bits) supported by the SCSI"
	 "Controller.") : amended,
       Units ("Bits") : amended, 
     WmiDataId(2)
    ]
    uint32 MaxDataWidth;

    [Description (
	  "Maximum transfer rate (in Bits per Second) supported by the "
	  "SCSIController.") : amended,
     Units ("Bits per Second") : amended, 
     WmiDataId(3)
    ]
    uint64 MaxTransferRate;

    [Description (
	  "Number of SCSIController timeouts that have occurred since "
	  "the TimeOfLastReset.") : amended, 
     WmiDataId(4)
    ]	 
    uint32 ControllerTimeouts;

    [Description("Count of elements in SignalCapabilities") : amended,
     WmiDataId(5)
    ]
    uint32 SignalCapabilitiesCount;

    [Description (
        "Signal capabilities that can be supported by the SCSI"
        "Controller. For example, the Controller may support "
        "\"Single Ended\" and \"Differential\". In this case, the "
        "values 3 and 4 would be written to the Signal"
        "Capabilities array.") : amended, 
    ValueMap {"1", "2", "3", "4", "5", "6"}, 
    Values {"Other", "Unknown", "Single Ended", "Differential", 
             "Low Voltage Differential", "Optical"} : amended, 
    WmiSizeIs("SignalCapabilitiesCount"),
    WmiDataId(6)
   ]
   uint16 SignalCapabilities[];
};


[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{D4559FDE-EEF0-48cb-A6FA-2EED3FED2707}")
]
class MSFC_ScsiController : WDM_ScsiController
{
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{23185079-C706-4baa-820E-837417F73FC1}")
]
class WDM_LogicalPort : WDM_LogicalElement
{
    [Description ("The speed of the Port in Bits per Second.") : amended, 
     Units ("Bits per Second") : amended,
     WmiDataId(1)
    ]
    uint64 Speed;

    [Description (
        "The max speed of the Port in Bits per Second.") : amended, 
     Units ("Bits per Second") : amended,
     WmiDataId(2)
    ]
    uint64 MaxSpeed;
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{59ED0456-EFD5-4595-A498-0EC45D778B19}")
]
class WDM_FibrePort : WDM_LogicalElement
{
    [Description (
        "An address value used to identify the source (S_ID) or "
        "destination (D_ID) of a frame. The FC-SW standard includes a "
        "table of special address identifier values and their "
        "meanings. Consult the FC-SW documentation for additional "
        "information.") : amended,
     WmiDataId(1)
    ]
   uint32 AddressIdentifier;

    [Description (
        "The specific mode in which the Port is currently running. The "
        "value is one of the entries in the EnabledPortTypes array. The "
        "current port type/mode is dependent on the fibre technology. "
        "For example, in a public loop network, you might indicate a "
        "port type of \"FL\" (value=6) or \"NL\" (value=2).") : amended, 
     Values {"Unknown", "N", "NL-Private", "NL-Public", "E", "F", "FL", "B"}, 
     WmiDataId(2)
    ]
    uint16 CurrentPortType;

    [MaxLen(128),
     Description (
        "Version information for the CurrentPortType that is active.") : amended, 
     WmiDataId(3)
    ]
    string CurrentVersion;

    [Description (
        "Number of times that signal is lost on the Port since last "
        "reset of the Device.") : amended, 
     WmiDataId(4)
    ]
    uint64 LossOfSignalCounter;

    [Description (
        "Number of times that synchronization is lost on the Port "
        "since last reset of the Device. Synchronization is assumed "
        "lost after a timeout period identified by the Receiver"
        "TransmitterTimeout property.") : amended, 
     WmiDataId(5)
    ]
    uint64 LossOfSyncCounter;

    [Description (
        "Number of times that the CRC in a frame does not match the "
        "CRC computed by the receiver.") : amended, 
     WmiDataId(6)
    ]
    uint64 CRCErrors;

    [Description (
        "The number of transmission words that had an 8b10b code "
        "violation in one or more of its characters, had a "
        "K28.5 in its second, third or fourth character positions, "
        "and/or was an ordered set that had an incorrect Beginning "
        "Running Disparity.") : amended, 
     WmiDataId(7)
    ]
    uint64 InvalidTransmissionWords;

    [Description (
        "The number of frames received that were shorter than 28 "
        "octets. The value of 28 is calculated based on an "
        "assumption of 24 header bytes plus 4 CRC bytes. The "
        "count does not include SOF/EOF bytes which are not data.") : amended, 
     WmiDataId(8)
    ]
    uint64 FramesTooShort;

    [Description (
        "The number of frames received that were longer than 2140 "
        "octets. The value of 2140 is calculated based on an "
        "assumption of 24 header bytes plus 4 CRC bytes and 2112 "
        "bytes of payload.") : amended, 
     WmiDataId(9)
    ]
   uint64 FramesTooLong;

    [Description (
        "The number of times that a fill word could not be "
        "inserted, when required. The Elasticity Buffer is defined "
        "in FC-AL. This event might cause data corruption and may "
        "indicate a configuration error or a device out of spec.") : amended, 
     WmiDataId(10)
    ]
    uint64 ElasticityBufferUnderruns;

    [Description (
        "The number of times that a fill word could not be deleted, "
        "when required. The Elasticity Buffer is defined in FC-AL. "
        "This event might cause data corruption and may indicate a "
        "configuration error or a device out of spec.") : amended, 
     WmiDataId(11)
    ]
    uint64 ElasticityBufferOverruns;

    [Description (
        "Timeout value in milliseconds used to determine when "
        "loss of synchronization has occurred. The typical default "
        "is 100 msec.") : amended, 
     Units ("Milliseconds") : amended, 
     WmiDataId(12)
    ]
    uint64 ReceiverTransmitterTimeout;

    [Description (
        "Indication of whether the Port is currently bypassed "
        "(value=2) or not (value=1). A value of 3 (\"Forced Insert\") "
        "describes that the Port is forced active, when it would "
        "otherwise be \"Bypassed\".") : amended, 
       Values {"Unknown", "Not Bypassed", "Bypassed", 
             "Forced Insert"} : amended,
     WmiDataId(13)
    ]
    uint16 BypassedState;

    [Description (
	  "The type of cabling as sensed by the Port. Not all FibrePorts "
	  "are capable of providing this information. In this case, a "
	  "value of 0, \"Unknown\", will be returned. Also, when single or "
	  "multi-mode fiber cabling can not be distinguished, the more "
	  "general value - 4, \"Fiber-optic\" - can be specified.") : amended, 
	Values {"Unknown", "Other", "No Media", "Copper/Twinaxial", 
	  "Fiber-optic", "Fiber Single Mode", "Fiber Multimode"} : amended,
     WmiDataId(14)
    ] 
    uint16 ConnectedMedia;

    [Description("Count of elements in AliasAddresses") : amended,
     WmiDataId(15)
    ]
    uint32 AliasAddressesCount;

    [Description (
        "One or more address identifiers that may be recognized by "
        "the Port, in addition to its port-specific identifier. "
        "Multicast or hunt group addresses that are recognized by "
        "the Port would be identified in this array.") : amended,
     WmiSizeIs("AliasAddressesCount"),
     WmiDataId(16)
    ]
    uint32 AliasAddresses[];

    [Description("Count of elements in SupportedPortTypes") : amended,
     WmiDataId(17)
    ]
    uint32 SupportedPortTypesCount;

    [Description (
        "An array indicating the modes in which the Port can operate. "
        "PortType values describe the role and behavior of the Fibre "
        "Channel entity: \"N\" = Node Port, \"NL\" = Node Port "
        "supporting FC arbitrated loop, \"E\" = Expansion Port "
        "connecting fabric elements (for example, FC switches), "
        "\"F\" = Fabric (element) Port, \"FL\" = Fabric (element) "
        "Port supporting FC arbitrated loop, and \"B\" = Bridge "
        "Port. PortTypes are defined in the ANSI X3 standards.\n\n"
        "A particular mode may be listed multiple times in the "
        "SupportedPortTypes array in order to define that multiple, "
        "unique version levels are supported. Version information is "
        "defined in the PortTypeVersions property. Note that each "
        "entry of the SupportedPortTypes array is related to the entry "
        "in PortTypeVersions that is located at the same index.") : amended,
       Values {"Unknown", "N", "NL-Private", "NL-Public", "E", "F", "FL", "B"} : amended, 
     WmiSizeIs("SupportedPortTypesCount"),
     WmiDataId(18)
    ]
    uint16 SupportedPortTypes[];

    [Description("Count of elements in EnabledPortTypes"),
     WmiDataId(19)
    ]
    uint32 EnabledPortTypesCount;

    [Description (
        "The specific modes currently enabled for the Port. The "
        "values are equal to, or a subset of the values in the Supported"
        "PortTypes array.") : amended, 
     Values {"Unknown", "N", "NL-Private", "NL-Public", "E", "F", "FL", "B"}, 
     WmiSizeIs("EnabledPortTypesCount"),
     WmiDataId(20)
    ]
    uint16 EnabledPortTypes[];

    [Description("Count of elements in PortTypeVersions"),
     WmiDataId(21)
    ]
    uint32 PortTypeVersionsCount;

    [Description (
        "Version information for each of the SupportedPortTypes. A "
        "particular PortType (mode) may be listed multiple times in "
        "the SupportedPortTypes array in order to define multiple, "
        "unique version levels. Note that each entry of this array "
        "is related to the entry in SupportedPortTypes that is "
        "located at the same index.") : amended, 
     WmiSizeIs("PortTypeVersionsCount"),
     WmiDataId(22)
    ]
    string PortTypeVersions[];
    
    [Description("Count of elements in EnabledVersions"),
     WmiDataId(23)
    ]
    uint32 EnabledVersionsCount;

    [Description (
        "Version information for each of the EnabledPortTypes. A "
        "particular PortType (mode) may be listed multiple times in "
        "the EnabledPortTypes array in order to define multiple, "
        "unique version levels. Note that each entry of this array "
        "is related to the entry in EnabledPortTypes that is located "
        "at the same index.") : amended, 
     WmiSizeIs("EnabledVersionsCount"),
     WmiDataId(24)
    ]
    string EnabledVersions[];    
};

class MSFC_FibrePort : WDM_FibrePort
{
    [Description("Unique id for this specific FibrePort exposed by this class") : amended,
     WmiDataId(1)
    ]
    uint64 UniquePortId;
};

[abstract]
class WDM_Dependency
{
    [Description (   
	"Antecedent represents the independent object in this "   
	"association.") : amended,
     WmiDataId(1)
    ]    
    uint64 Antecedent;   // CIM_ManagedElement REF

    [Description (   
	"Dependent represents the object dependent on the "   
	"Antecedent.") : amended,
     WmiDataId(2)
    ]    
    uint64 Dependent;   // CIM_ManagedElement REF
};

[abstract]
class WDM_PortOnDevice : WDM_Dependency
{
    [Description ("The Device that includes the Port.") : amended,
     WmiDataId(1)
    ]
    uint64 Antecedent;		// CIM_LogicalDevice REF

    [Description ("The Port on the Device.") : amended,
     WmiDataId(2)
    ]
    uint64 Dependent;		// CIM_LogicalPort REF
};

[abstract]
class WDM_FibrePortOnFCAdapter : WDM_PortOnDevice
{
    [Description ("The FibreChannelAdapter that includes the Port.") : amended,
     WmiDataId(1)
    ]
    uint64 Antecedent;		// CIM_FibreChannelAdapter REF

    [Description ("The FibrePort on the Adapter.") : amended,
     WmiDataId(2)
    ]
    uint64 Dependent;		// CIM_FibrePort REF

};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{0B63B9EE-FCA9-460f-B489-8349BAF8282B}")
]
class MSFC_FibrePortOnFCAdapter
{
    [key]
    string InstanceName;
    boolean Active;

    [Description ("The FibreChannelAdapter that includes the Port.") : amended,
     WmiRefClass("MSFC_FibreChannelAdapter"),
     WmiRefProperty("UniqueAdapterId"),     
     WmiDataId(1)
    ]
    uint64 Antecedent;		// CIM_FibreChannelAdapter REF

    [Description ("The FibrePort on the Adapter.") : amended,
     WmiRefClass("MSFC_FibrePort"),
     WmiRefProperty("UniquePortId"),
     WmiDataId(2)
    ]
    uint64 Dependent;		// CIM_FibrePort REF
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{0B63B9EE-FCA9-460f-B489-8349BAF8282B}")
]
class MSFC_AdapterEventCounters
{
    [key]
    string InstanceName;
    boolean Active;

    [
     Description ("The number of Abort sequence frames received.") : amended, 
     WmiDataId(1)
    ]
    uint64 ABTSFramesReceived;

    [Description ("The number of Abort sequence frames sent.") : amended, 
     WmiDataId(2)
    ]
    uint64 ABTSFramesSent;

    [Description ("The number of frames busied by the Fabric.") : amended, 
     WmiDataId(3)
    ]
    uint64 FBSYsReceived;

    [Description (
        "The number of frames busied by the receiving Node.") : amended,
     WmiDataId(4)
    ]
    uint64 PBSYsReceived;

    [Description (
        "The number of frames busied by the Adapter itself.") : amended,
     WmiDataId(5)
    ]
    uint64 PBSYsSent;

    [Description ("The number of frames rejected by the Fabric.") : amended, 
     WmiDataId(6)
    ]
    uint64 FRJTsReceived;

    [Description (
        "The number of frames rejected by the receiving Node.") : amended,
     WmiDataId(7)
    ]
    uint64 PRJTsReceived;

    [Description (
        "The number of frames rejected by the Adapter itself.") : amended,
     WmiDataId(8)
    ]
    uint64 PRJTsSent;

    [Description (
        "The number of PRLI frames sent where the response was "
        "LS_RJT.") : amended, 
     WmiDataId(9)
    ]
    uint64 PRLIsRejected;

    [Description (
        "The number of PRLO frames sent where the response was "
        "LS_RJT.") : amended, 
     WmiDataId(10)
    ]
    uint64 PRLOsRejected;

    [Description (
        "The number of Abort sequence frames sent where the response "
        "was BA_RJT.") : amended, 
     WmiDataId(11)
    ]
    uint64 ABTSFramesRejected;

#ifdef INCLUDE_METHODS
    [Description (
	  "Method to reset the Adapter event counters. The method " 
	  "takes one parameter as input - an integer indicating which "
	  "counter to reset. For this input parameter, 0 indicates all, "
	  "1 through 11 indicate a reset of the individual counters. "
	  "The method returns 0 if successful, 1 if not supported, and " 
	  "any other value if an error occurred. A method is specified "
	  "so that the Device's instrumentation, which tabulates "
	  "the errors and warnings, can also reset its internal "
	  "processing and counters.\n"
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "may also be specified in the subclass as a Values "
        "array qualifier.") : amended,
     WmiMethodId(1)
    ]
    uint32 ResetCounter ([IN, Values {"All",
	    "ABTSFramesReceived", "ABTSFramesSent", "FBSYReceived", 
	    "PBSYReceived", "PBSYSent", "FRJTReceived", "PRJTReceived", 
	    "PRJTSent", "PRLIRejected", "PRLORejected", "ABTSFramesRejected"}]
	  uint16 SelectedCounter);
#endif
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{0B63B9EE-FCA9-460f-B489-8349BAF8282B}")
]
class MSFC_FibrePortEventCounters
{
    [key]
    string InstanceName;
    boolean Active;

    [Description ("The number of login frames received.") : amended, 
     WmiDataId(1)
    ]
    uint64 PLOGIsReceived;

    [Description ("The number of login frames sent.") : amended, 
     WmiDataId(2)
    ]
    uint64 PLOGIsSent;

    [Description (
        "Number of frames received containing 'EOF Abort'.") : amended, 
     WmiDataId(3)
    ]
    uint64 EOFAbortsReceived;

    [Description (
        "Number of frames transmitted containing 'EOF Abort'.") : amended, 
     WmiDataId(4)
    ]
    uint64 EOFAbortsTransmitted;

    [Description (
        "The number of logouts received from various targets.") : amended, 
     WmiDataId(5)
    ]
    uint64 PLOGOsReceived;

    [Description ("The number of logout frames sent.") : amended, 
     WmiDataId(6)
    ]
    uint64 PLOGOsSent;

    [Description (
        "The number of PLOGI frames sent where the response was "
        "LS_RJT.") : amended, 
     WmiDataId(7)
    ]
    uint64 PLOGIsRejected;

    [Description (
        "The number of PLOGO frames sent where the response was "
        "LS_RJT.") : amended, 
     WmiDataId(8)
    ]
    uint64 PLOGOsRejected;

#ifdef INCLUDE_METHODS
    [Description (
	  "Method to reset the Port event counters. The method " 
	  "takes one parameter as input - an integer indicating which "
	  "counter to reset. For this input parameter, 0 indicates all, "
	  "1 through 8 indicate a reset of the individual counters. "
	  "The method returns 0 if successful, 1 if not supported, and " 
	  "any other value if an error occurred. A method is specified "
	  "so that the Device's instrumentation, which tabulates "
	  "the errors and warnings, can also reset its internal "
	  "processing and counters.\n"
        "In a subclass, the set of possible return codes could be "
        "specified, using a ValueMap qualifier on the method. The "
        "strings to which the ValueMap contents are 'translated' "
        "may also be specified in the subclass as a Values "
        "array qualifier.") : amended,
     WmiMethodId(1)
    ]
    uint32 ResetCounter ([IN, Values {"All", "PLOGIsReceived", 
	    "PLOGIsSent", "EOFAbortsReceived", "EOFAbortsTransmitted", 
	    "PLOGOsReceived", "PLOGOsSent", "PLOGIsRejected", 
	    "PLOGOsRejected"}] uint16 SelectedCounter);
#endif
};

[WMI, 
 Dynamic,
 Provider("WmiProv"),
 guid("{80360D8C-C870-43c9-9129-31F996BB1245}")
]
class MSFC_FibrePortActiveLogin
{
    [key]
    string InstanceName;
    boolean Active;

    [
     Description ("The originator of the login.") : amended,
     WmiRefClass("MSFC_FibrePort"),
     WmiRefProperty("UniquePortId"),
     WmiDataId(1)
    ]
    uint64 LoginOriginator;		// FC_FibrePort REF

    [Description ("The responder to the login.") : amended,
     WmiRefClass("MSFC_FibrePort"),
     WmiRefProperty("UniquePortId"),
     WmiDataId(2)
    ]
    uint64 LoginResponder;              // CIM_FibrePort REF 

    [
     Description (
        "The Fibre Channel Class of Service that is currently running "
        "between the Ports. Since two Ports can be simultaneously "
        "connected at different Classes of Service, this property had "
        "to be part of the object's key and therefore, an instance's "
        "identity.") : amended, 
     Values {"Unknown", "1", "2", "3", "4", "6", "F"} : amended, 
     WmiDataId(3)
    ]
    uint16 NegotiatedCOS;

    [Description (
        "The Fibre Channel frame size, in bytes, that is currently "
        "negotiated between the two Ports.") : amended, 
     Units ("Bytes") : amended,
     WmiDataId(4)
    ]
    uint64 NegotiatedFrameSize;

    [Description (
        "The speed for communications that is currently negotiated "
        "between the two Ports. Speed is specified in bits per second. "
        "If this information is not available, the property should be "
        "set to 0.") : amended, 
     Units ("Bits per Second") : amended,
     WmiDataId(5)
    ]
    uint64 NegotiatedSpeed;

    [Description (
        "Acknowledgement model negotiated during Port login. For "
        "example, ACK-1 indicates that each frame should be "
        "acknowledged.") : amended, 
     Values {"Unknown", "ACK-0", "ACK-1", "ACK-N"} : amended,
     WmiDAtaId(6)
    ]
    uint16 ACKModel;

    [Description (
        "The buffer-to-buffer model negotiated during Port login. "
        "Either the model defined by the FC-PH standard is used "
        "(value=1, \"Regular\"), or an \"Alternate\" model is "
        "negotiated.") : amended, 
     Values {"Unknown", "Regular", "Alternate"} : amended,
     WmiDataId(7)
    ]
    uint16 BufferToBufferModel;

    [Description (
        "OriginatorBufferCredit reflects the buffer credit of the "
        "Port defined as the LoginOriginator. It is the number of "
        "frame buffers made available BY the originating Port, TO "
        "the responder Port. Buffer credits are used in point to "
        "point connections, when an NL-Local Port is logged into "
        "another NL-Local Port, and when Nx Ports are logged into "
        "Fx Ports. In other scenarios, this value is undefined.") : amended,
     WmiDataId(8)
    ]
    uint64 OriginatorBufferCredit;

    [Description (
        "ResponderBufferCredit reflects the buffer credit of the "
        "Port defined as the LoginResponder. It is the number of "
        "frame buffers made available BY the responder Port, TO "
        "the originating Port. Buffer credits are used in point to "
        "point connections, when an NL-Local Port is logged into "
        "another NL-Local Port, and when Nx Ports are logged into "
        "Fx Ports. In other scenarios, this value is undefined.") : amended,
     WmiDataId(9)
    ]
    uint64 ResponderBufferCredit;

    [Description (
        "OriginatorEndCredit reflects the end credit of the Port "
        "defined as the LoginOriginator. It is the number of frame "
        "buffers made available BY the originating Port, TO the "
        "responder Port. End credits are used in point to point "
        "connections, when an NL-Local Port is logged into another "
        "NL-Local Port, and when Nx Ports are logged into remote "
        "Nx Ports. In other scenarios, this value is undefined.") : amended,
     WmiDataId(10)
    ]
    uint64 OriginatorEndCredit;

    [Description (
        "ResponderEndCredit reflects the end credit of the Port "
        "defined as the LoginResponder. It is the number of frame "
        "buffers made available BY the responder Port, TO the "
        "originating Port. End credits are used in point to point "
        "connections, when an NL-Local Port is logged into another "
        "NL-Local Port, and when Nx Ports are logged into remote "
        "Nx Ports. In other scenarios, this value is undefined.") : amended,
     WmiDataId(11)
    ]
    uint64 ResponderEndCredit;
};


