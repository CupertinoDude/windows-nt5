
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "skeleton.h"
#include "database.h"
#include "funcs.h"

/* Globals used throughout */
DWORD                        nPropertyLevel  = 1;
BOOL                         fIsFlipped      = FALSE;
BOOL                         fIgnoreFlatPart = FALSE;
BOOL                         fIgnorePointers = FALSE;

DWORD                        Conformance       = 0;
BOOL                         fConformanceIsSet = FALSE;

/* ======================================================================== *
 * Protocol Entry points for Interface resmon
 *          uuid=(e76ea56d-453f-11cf-bfec-08002be23f2f)
 * ======================================================================== */

VOID   WINAPI resmon_Register(HPROTOCOL);
VOID   WINAPI resmon_Deregister(HPROTOCOL);
LPBYTE WINAPI resmon_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL,
                  DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI resmon_AttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI resmon_FormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS resmon_EntryPoints =
{
	resmon_Register,
	resmon_Deregister,
	resmon_RecognizeFrame,
	resmon_AttachProperties,
	resmon_FormatProperties
};

HPROTOCOL hresmon = NULL;

/* ======================================================================== *
 * Function DLLEntry called at loading and unloading time
 * ======================================================================== */

DWORD Attached = 0;

BOOL WINAPI DLLEntry(HANDLE hInstance, ULONG Command, LPVOID Reserved)
{
	if ( Command == DLL_PROCESS_ATTACH )
	{
		if ( Attached++ == 0 )
		{
			hresmon = CreateProtocol("R_RESMON", &resmon_EntryPoints, ENTRYPOINTS_SIZE);
		}
	}

	if ( Command == DLL_PROCESS_DETACH )
	{
		if ( --Attached == 0 )
		{
			DestroyProtocol(hresmon);
		}
	}
	return TRUE;
}

/* ======================================================================== *
 * Implementation of the entry point functions for each interface
 * ======================================================================== */

/*
 * Interface resmon, protocol RPC_resmon:
 * uuid=(e76ea56d-453f-11cf-bfec-08002be23f2f)
 */

VOID   WINAPI resmon_Register(HPROTOCOL hProtocol)
{
	register DWORD i;

	CreatePropertyDatabase(hProtocol, nresmonProperties);

	for (i = 0; i < nresmonProperties; ++i)
	{
		AddProperty(hProtocol, &resmon_Database[i]);
	}
}

VOID   WINAPI resmon_Deregister(HPROTOCOL hProtocol)
{
	DestroyPropertyDatabase(hProtocol);
}

LPBYTE WINAPI resmon_RecognizeFrame(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  LPDWORD         ProtocolStatusCode,
                  LPHPROTOCOL     hNextProtocol,
                  LPDWORD         InstData)
{
	HPROTOCOL hNext=NULL; 	// next protocol to hand off to...
	WORD nStubLength;

	*ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;

	//  IF MSRPC VERSION == 4 AND AUTHPROTID !=0 THEN PASS OFF TO SSP
	if((*(MacFrame + hPreviousProtocolOffset) == 4) && (*(MacFrame + hPreviousProtocolOffset + 78)))
	  {
	  hNext = GetProtocolFromName("SSP");
	  if(hNext)
	    {
	    *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
	    *hNextProtocol = hNext;
	    nStubLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
	    return(lpFrame + nStubLength);
	    }
	  }

	return(NULL);
}

DWORD  WINAPI resmon_FormatProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           nPropertyInsts,
                  LPPROPERTYINST  lpInst)
{
	while (nPropertyInsts--)
	{
		((FORMAT)lpInst->lpPropertyInfo->InstanceData)(lpInst);
		lpInst++;
	}

	return(BHERR_SUCCESS);
}

LPBYTE WINAPI resmon_AttachProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  DWORD           InstData)
{
	CHAR AuthenticationProtocolID = 0;
	WORD nRPCLength;
	CHAR AuthenticationLevel;
	nPropertyLevel     = 1;
	fIgnoreFlatPart    = FALSE;
	fIgnorePointers    = FALSE;

	Conformance        = 0;
	fConformanceIsSet  = FALSE;

	//  IF THE MSRPC VERSION IS 4 LOOK FOR SECURITY TRAILER
	if(*(MacFrame + hPreviousProtocolOffset) == 4)
	{
		AuthenticationProtocolID = *(MacFrame + hPreviousProtocolOffset + 78);
		nRPCLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
		AuthenticationLevel = *(lpFrame + nRPCLength);
	}

	//  CHECK FOR ENCRYPTION
	if(AuthenticationProtocolID && (AuthenticationLevel == 6))
	{
		AttachPropertyInstance(hFrame, 
		                      resmon_Database[I0_ENCRYPTED].hProperty,
		                      nRPCLength,
		                      lpFrame, 0, 0, 0);
	}
	else
	{
	switch (InstData & 0xffffL)
	{
		case 0:
			/* Handler for procedure RmCreateResource() */
			resmon_RmCreateResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 1:
			/* Handler for procedure RmCloseResource() */
			resmon_RmCloseResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 2:
			/* Handler for procedure RmChangeResourceParams() */
			resmon_RmChangeResourceParams_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 3:
			/* Handler for procedure RmOnlineResource() */
			resmon_RmOnlineResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 4:
			/* Handler for procedure RmOfflineResource() */
			resmon_RmOfflineResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 5:
			/* Handler for procedure RmTerminateResource() */
			resmon_RmTerminateResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 6:
			/* Handler for procedure RmArbitrateResource() */
			resmon_RmArbitrateResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 7:
			/* Handler for procedure RmReleaseResource() */
			resmon_RmReleaseResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 8:
			/* Handler for procedure RmNotifyChanges() */
			resmon_RmNotifyChanges_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 9:
			/* Handler for procedure RmFailResource() */
			resmon_RmFailResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 10:
			/* Handler for procedure RmShutdownProcess() */
			resmon_RmShutdownProcess_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 11:
			/* Handler for procedure RmResourceControl() */
			resmon_RmResourceControl_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 12:
			/* Handler for procedure RmResourceTypeControl() */
			resmon_RmResourceTypeControl_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		default:
			/* Error: bad OpCode */
			AttachPropertyInstance(hFrame,
			                       resmon_Database[I0_ERROR_BAD_OPCODE].hProperty,
			                       FrameLength,
			                       lpFrame, 0, 0, 0);
	}

	}
	return(NULL);
}

