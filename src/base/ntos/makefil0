!INCLUDE $(NTMAKEENV)\makefile.plt

!IFNDEF NTOSINC
NTOSINC = $(PROJECT_ROOT)\ntos\inc
!ENDIF
PRVINC = $(PRIVATE_INC_PATH)
PUBLISHEDDIR = $(PROJECT_ROOT)\published

NTDDK_DEPENDS = $(NTOSINC)\ntosdef.h \
                $(SDK_INC_PATH)\nti386.h \
                $(SDK_INC_PATH)\ntamd64.h \
                $(SDK_INC_PATH)\ntia64.h \
                $(SDK_INC_PATH)\ntseapi.h \
                $(SDK_INC_PATH)\ntkeapi.h \
                $(SDK_INC_PATH)\ntrtl.h \
                $(SDK_INC_PATH)\devioctl.h \
                $(SDK_INC_PATH)\ntioapi.h \
                $(SDK_INC_PATH)\ntiolog.h \
                $(SDK_INC_PATH)\ntlpcapi.h \
                $(SDK_INC_PATH)\ntregapi.h \
                $(SDK_INC_PATH)\ntobapi.h \
                $(SDK_INC_PATH)\ntmmapi.h \
                $(SDK_INC_PATH)\ntpsapi.h \
                $(SDK_INC_PATH)\ntpoapi.h \
                $(SDK_INC_PATH)\ntpnpapi.h

NTDDK_DEPENDS1= $(NTOSINC)\i386.h \
                $(NTOSINC)\amd64.h \
                $(NTOSINC)\ia64.h \
                $(SDK_INC_PATH)\ntexapi.h \
                $(SDK_INC_PATH)\ntconfig.h \
                $(SDK_INC_PATH)\ntxcapi.h \
                $(PUBLISHEDDIR)\arc.w \
                $(NTOSINC)\ke.h \
                $(NTOSINC)\kd.h \
                $(NTOSINC)\ex.h \
                $(NTOSINC)\cm.h \
                $(NTOSINC)\exboosts.h \
                $(NTOSINC)\mm.h \
                $(NTOSINC)\se.h \
                $(NTOSINC)\ps.h \
                $(NTOSINC)\io.h \
                $(NTOSINC)\wmi.h \
                $(PUBLISHEDDIR)\ntwmi.w \
                $(NTOSINC)\pnp.h \
                $(NTOSINC)\hal.h \
                $(NTOSINC)\po.h \
                $(NTOSINC)\fsrtl.h \
                $(NTOSINC)\ob.h \
                $(NTOSINC)\pci.h

NTWDM_DEPENDS = $(NTOSINC)\ntosdef.h \
                $(SDK_INC_PATH)\nti386.h \
                $(SDK_INC_PATH)\ntamd64.h \
                $(SDK_INC_PATH)\ntia64.h \
                $(SDK_INC_PATH)\ntseapi.h \
                $(SDK_INC_PATH)\ntkeapi.h \
                $(SDK_INC_PATH)\ntrtl.h \
                $(SDK_INC_PATH)\devioctl.h \
                $(SDK_INC_PATH)\ntioapi.h \
                $(SDK_INC_PATH)\ntiolog.h \
                $(SDK_INC_PATH)\ntlpcapi.h \
                $(SDK_INC_PATH)\ntregapi.h \
                $(SDK_INC_PATH)\ntobapi.h \
                $(SDK_INC_PATH)\ntmmapi.h \
                $(SDK_INC_PATH)\ntpsapi.h \
                $(SDK_INC_PATH)\ntpoapi.h \
                $(SDK_INC_PATH)\ntpnpapi.h

NTWDM_DEPENDS1= $(NTOSINC)\i386.h \
                $(NTOSINC)\amd64.h \
                $(NTOSINC)\ia64.h \
                $(SDK_INC_PATH)\ntexapi.h \
                $(SDK_INC_PATH)\ntconfig.h \
                $(SDK_INC_PATH)\ntxcapi.h \
                $(NTOSINC)\ke.h \
                $(NTOSINC)\kd.h \
                $(NTOSINC)\ex.h \
                $(NTOSINC)\cm.h \
                $(NTOSINC)\exboosts.h \
                $(NTOSINC)\mm.h \
                $(NTOSINC)\se.h \
                $(NTOSINC)\ps.h \
                $(NTOSINC)\io.h \
                $(NTOSINC)\wmi.h \
                $(PUBLISHEDDIR)\ntwmi.w \
                $(NTOSINC)\pnp.h \
                $(NTOSINC)\hal.h \
                $(NTOSINC)\po.h \
                $(NTOSINC)\ob.h \
                $(NTOSINC)\pci.h

NTHAL_DEPENDS1= $(SDK_INC_PATH)\nti386.h \
                $(SDK_INC_PATH)\ntamd64.h \
                $(SDK_INC_PATH)\ntia64.h \
                $(SDK_INC_PATH)\ntpsapi.h \
                $(SDK_INC_PATH)\devioctl.h \
                $(SDK_INC_PATH)\ntseapi.h \
                $(SDK_INC_PATH)\ntkeapi.h \
                $(SDK_INC_PATH)\ntlpcapi.h \
                $(SDK_INC_PATH)\ntrtl.h \
                $(SDK_INC_PATH)\ntregapi.h \
                $(SDK_INC_PATH)\ntioapi.h \
                $(SDK_INC_PATH)\ntiolog.h \
                $(SDK_INC_PATH)\ntexapi.h \
                $(SDK_INC_PATH)\ntobapi.h \
                $(SDK_INC_PATH)\ntconfig.h \
                $(SDK_INC_PATH)\ntpnpapi.h \
                $(SDK_INC_PATH)\ntpoapi.h \
                $(SDK_INC_PATH)\ntxcapi.h \
                $(NTOSINC)\ntosdef.h \
                $(NTOSINC)\i386.h \
                $(NTOSINC)\amd64.h \
                $(NTOSINC)\ia64.h

NTHAL_DEPENDS2= $(NTOSINC)\ke.h \
                $(NTOSINC)\kd.h \
                $(NTOSINC)\ex.h \
                $(NTOSINC)\se.h \
                $(NTOSINC)\ps.h \
                $(NTOSINC)\io.h \
                $(NTOSINC)\pnp.h \
                $(NTOSINC)\po.h \
                $(NTOSINC)\mm.h \
                $(NTOSINC)\ob.h \
                $(NTOSINC)\hal.h


NTMINIPORT_DEPENDS = \
                $(SDK_INC_PATH)\ntdef.h \
                $(SDK_INC_PATH)\nti386.h \
                $(SDK_INC_PATH)\ntia64.h \
                $(SDK_INC_PATH)\ntioapi.h \
                $(SDK_INC_PATH)\ntrtl.h \
                $(NTOSINC)\ke.h \
                $(NTOSINC)\v86emul.h \
                $(NTOSINC)\pci.h \
                $(NTOSINC)\mm.h \
                $(NTOSINC)\io.h \
                $(NTOSINC)\pnp.h \
                $(SDK_INC_PATH)\ntconfig.h

NTIFS_DEPENDS = $(SDK_INC_PATH)\ntseapi.h \
                $(NTOSINC)\ntosdef.h \
                $(SDK_INC_PATH)\ntkeapi.h

NTIFS_DEPENDS1= $(SDK_INC_PATH)\nti386.h \
                $(SDK_INC_PATH)\ntamd64.h \
                $(SDK_INC_PATH)\ntia64.h

NTIFS_DEPENDS2= $(SDK_INC_PATH)\ntrtl.h \
                $(SDK_INC_PATH)\ntpoapi.h \
                $(SDK_INC_PATH)\devioctl.h \
                $(SDK_INC_PATH)\ntpsapi.h \
                $(SDK_INC_PATH)\ntlsa.h \
                $(SDK_INC_PATH)\ntmsv1_0.h \
                $(SDK_INC_PATH)\ntioapi.h \
                $(SDK_INC_PATH)\ntlpcapi.h \
                $(SDK_INC_PATH)\ntobapi.h \
                $(SDK_INC_PATH)\ntmmapi.h \
                $(NTOSINC)\exboosts.h

NTIFS_DEPENDS3= $(NTOSINC)\i386.h \
                $(NTOSINC)\amd64.h \
                $(NTOSINC)\ia64.h \
                $(BASE_INC_PATH)\arc.h \
                $(SDK_INC_PATH)\ntobapi.h \
                $(SDK_INC_PATH)\ntconfig.h \
                $(SDK_INC_PATH)\ntregapi.h \
                $(SDK_INC_PATH)\ntmmapi.h \
                $(SDK_INC_PATH)\ntxcapi.h \
                $(SDK_INC_PATH)\ntlpcapi.h \
                $(SDK_INC_PATH)\ntiolog.h

NTIFS_DEPENDS4= $(SDK_INC_PATH)\ntexapi.h \
                $(NTOSINC)\ke.h \
                $(NTOSINC)\ex.h \
                $(NTOSINC)\se.h \
                $(NTOSINC)\ps.h \
                $(NTOSINC)\io.h \
                $(NTOSINC)\po.h \
                $(NTOSINC)\hal.h \
                $(NTOSINC)\mm.h \
                $(NTOSINC)\ob.h \
                $(NTOSINC)\fsrtl.h \
                $(NTOSINC)\cache.h \
                $(SDK_INC_PATH)\sspi.h \
                $(DS_INC_PATH)\secint.h \
                $(BASE_INC_PATH)\zwapi.h \
                $(NTOSINC)\kd.h \
                $(DRIVERS_INC_PATH)\ntddsnap.h


NTWMIKM_DEPENDS = $(NTOSINC)\io.h \
                $(PUBLISHEDDIR)\ntwmi.w \
                $(NTOSINC)\wmi.h

NTOSP_DEPENDS = $(NTOSINC)\ntosdef.h \
                $(SDK_INC_PATH)\ntkeapi.h \
                $(SDK_INC_PATH)\ntrtl.h \
                $(NTOSINC)\v86emul.h    \
                $(NTOSINC)\i386.h \
                $(NTOSINC)\init.h \
                $(NTOSINC)\amd64.h \
                $(NTOSINC)\ia64.h \
                $(SDK_INC_PATH)\ntseapi.h \
                $(NTOSINC)\cm.h \
                $(PUBLISHEDDIR)\arc.w \
                $(NTOSINC)\ke.h \
                $(NTOSINC)\ex.h \
                $(NTOSINC)\kd.h \
                $(NTOSINC)\exboosts.h \
                $(NTOSINC)\io.h \
                $(NTOSINC)\pnp.h \
                $(NTOSINC)\hal.h \
                $(NTOSINC)\mm.h \
                $(NTOSINC)\se.h \
                $(NTOSINC)\po.h \
                $(NTOSINC)\ps.h \
                $(NTOSINC)\ob.h \
                $(NTOSINC)\pci.h \
                $(NTOSINC)\fsrtl.h \
                $(NTOSINC)\lpc.h

NDIS_BASE_DEPENDS = \
                $(SDK_INC_PATH)\ntdef.h \
                $(NTOSINC)\ntosdef.h \
                $(SDK_INC_PATH)\ntkeapi.h \
                $(SDK_INC_PATH)\ntioapi.h \
                $(SDK_INC_PATH)\ntrtl.h \
                $(SDK_INC_PATH)\ntiolog.h \
                $(NTOSINC)\i386.h \
                $(NTOSINC)\amd64.h \
                $(NTOSINC)\ia64.h \
                $(SDK_INC_PATH)\ntconfig.h \
                $(NTOSINC)\ke.h \
                $(NTOSINC)\io.h \
                $(NTOSINC)\hal.h \
                $(NTOSINC)\ex.h \
                $(NTOSINC)\pci.h \
                $(NTOSINC)\mm.h \

!ifndef O
O=$(_OBJ_DIR)\$(TARGET_DIRECTORY)
!endif

!if !exist($(O))
!if [-mkdir $(O)]
!endif
!endif

all: $(DDK_INC_PATH)\ntddk.h \
     $(SDK_INC_PATH)\wdm.nt \
     $(HALKIT_INC_PATH)\nthal.h \
     $(DDK_INC_PATH)\miniport.h \
     $(PRVINC)\wmikm.h \
     $(IFSKIT_INC_PATH)\ntifs.h \
     $(PRVINC)\ntosp.h \
     $(PRVINC)\class.h \
     $(PRVINC)\tape.h \
     $(PRVINC)\ndisbase.w \
     keheaders
!IF "$(BUILDMSG)" != ""
    echo $(BUILDMSG)
!ENDIF

clean: cleaninc all

cleaninc:
    -del $(O)\*.* /q

$(DDK_INC_PATH)\ntddk.h: $(O)\ntddk.h
    $(PUBLISH_CMD) {$?=$@}

$(SDK_INC_PATH)\wdm.nt: $(O)\wdm.nt
    $(PUBLISH_CMD) {$?=$@}

$(HALKIT_INC_PATH)\nthal.h: $(O)\nthal.h
    $(PUBLISH_CMD) {$?=$@}

$(DDK_INC_PATH)\miniport.h: $(O)\miniport.h
    $(PUBLISH_CMD) {$?=$(DDK_INC_PATH)\miniport.h}

$(PRVINC)\ndisbase.w: $(O)\ndisbase.w
    $(PUBLISH_CMD) {$?=$@}

$(IFSKIT_INC_PATH)\ntifs.h: $(O)\ntifs.h
    $(PUBLISH_CMD) {$?=$@}

$(PRVINC)\wmikm.h: $(O)\wmikm.h
    $(PUBLISH_CMD) {$?=$@}

$(PRVINC)\ntosp.h: $(O)\ntosp.h
    $(PUBLISH_CMD) {$?=$@}

$(PRVINC)\class.h: inc\class.h
    $(PUBLISH_CMD) {$?=$@}

$(PRVINC)\tape.h:  inc\tape.h
    $(PUBLISH_CMD) {$?=$@}


$(O)\ntddk.h: $(NTDDK_DEPENDS) $(NTDDK_DEPENDS1) makefil0
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntddk.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _NTDDK_
#define _NTDDK_

#ifndef RC_INVOKED
#if _MSC_VER < 1300
#error Compiler version not supported by Windows DDK
#endif
#endif // RC_INVOKED

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>
<<
    type $(NTOSINC)\exlevels.h >> $@
    type << >> $@

//
// Define types that are not exported.
//

typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _DEVICE_HANDLER_OBJECT *PDEVICE_HANDLER_OBJECT;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _PEB *PPEB;

#if defined(_M_AMD64)

PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );

#endif // defined(_M_AMD64)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)

#define PsGetCurrentProcess() IoGetCurrentProcess()
#define PsGetCurrentThread() ((PETHREAD) (KeGetCurrentThread()))
extern NTSYSAPI CCHAR KeNumberProcessors;

#include <mce.h>

#ifndef FAR
#define FAR
#endif
<<
    hextract -o $@ -lt ntddk -bt begin_ntddk end_ntddk $(NTDDK_DEPENDS)
    hextract -o $@ -lt ntddk -bt begin_ntddk end_ntddk $(NTDDK_DEPENDS1)
    type << >> $@


#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' kdD')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,' kdD')
#endif

extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *ExSemaphoreObjectType;

//
// Define exported ZwXxx routines to device drivers.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

NTSTATUS
ZwCreateTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TIMER_TYPE TimerType
    );

NTSTATUS
ZwOpenTimer (
    OUT PHANDLE TimerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS
ZwCancelTimer (
    IN HANDLE TimerHandle,
    OUT PBOOLEAN CurrentState OPTIONAL
    );

NTSTATUS
ZwSetTimer (
    IN HANDLE TimerHandle,
    IN PLARGE_INTEGER DueTime,
    IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
    IN PVOID TimerContext OPTIONAL,
    IN BOOLEAN WakeTimer,
    IN LONG Period OPTIONAL,
    OUT PBOOLEAN PreviousState OPTIONAL
    );

#endif // _NTDDK_
<<

$(O)\wdm.nt: $(NTWDM_DEPENDS) $(NTWDM_DEPENDS1) makefil0 wdm.mng
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    wdm.h

Abstract:

    This module defines the WDM types, constants, and functions that are
    exposed to device drivers.

Revision History:

--*/

#ifndef _WDMDDK_
#define _WDMDDK_
#define _NTDDK_

#ifndef RC_INVOKED
#if _MSC_VER < 1300
#error Compiler version not supported by Windows DDK
#endif
#endif // RC_INVOKED

#define NT_INCLUDED
#define _CTYPE_DISABLE_MACROS

#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>

//
// Define types that are not exported.
//

typedef struct _ACCESS_STATE *PACCESS_STATE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;

#if defined(_M_AMD64)

PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );

#endif // defined(_M_AMD64)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define base address for kernel and user space
//

#ifdef _WIN64

#define UREGION_INDEX 1

#define KREGION_INDEX 7

#define UADDRESS_BASE ((ULONG_PTR)UREGION_INDEX << 61)

#define KADDRESS_BASE ((ULONG_PTR)KREGION_INDEX << 61)

#else  // !_WIN64

#define KADDRESS_BASE 0

#define UADDRESS_BASE 0

#endif // !_WIN64

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)

#include <mce.h>

#ifndef FAR
#define FAR
#endif

#define PsGetCurrentProcess() IoGetCurrentProcess()
#define PsGetCurrentThread() ((PETHREAD) (KeGetCurrentThread()))
extern NTSYSAPI CCHAR KeNumberProcessors;
<<
    hextract -o $@ -lt wdm -bt begin_wdm end_wdm $(NTWDM_DEPENDS)
    hextract -o $@ -lt wdm -bt begin_wdm end_wdm $(NTWDM_DEPENDS1)
    type << >> $@


#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' mdW')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,' kdD')
#endif

extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *ExSemaphoreObjectType;

//
// Define exported ZwXxx routines to device drivers.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

#endif // _WDMDDK_
<<
    -munge wdm.mng -k -m -i -t $@


$(O)\nthal.h: $(NTHAL_DEPENDS1) $(NTHAL_DEPENDS2) makefil0
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    nthal.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to HALs.

Revision History:

--*/

#ifndef _NTHAL_
#define _NTHAL_

#ifndef RC_INVOKED
#if _MSC_VER < 1300
#error Compiler version not supported by Windows DDK
#endif
#endif // RC_INVOKED

#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>

//
// Define types that are not exported.
//

typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _ETHREAD *PETHREAD;
typedef struct _FAST_IO_DISPATCH *PFAST_IO_DISPATCH;
typedef struct _IO_SECURITY_CONTEXT *PIO_SECURITY_CONTEXT;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
struct _IRP;

#if defined(_M_AMD64)

PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );

#endif // defined(_M_AMD64)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#include <mce.h>

<<
    hextract -o $@ -lt nthal -bt begin_nthal end_nthal $(NTHAL_DEPENDS1)
    type << >> $@

#include <arc.h>

<<
    hextract -o $@ -lt nthal -bt begin_nthal end_nthal $(NTHAL_DEPENDS2)
    type << >> $@

//
// Define exported ZwXxx routines to device drivers & hal
//

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDisplayString(
    IN PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

#endif // _NTHAL_
<<

$(O)\miniport.h: $(NTMINIPORT_DEPENDS) makefil0
    type << > $@
/*++

$(COPYRIGHT_STRING)

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif

<<
    hextract -o $@ -lt ntminiport -bt begin_ntminiport end_ntminiport $(NTMINIPORT_DEPENDS)
    type << >> $@

#endif /* _MINIPORT_ */
<<

$(O)\ntifs.h: $(NTIFS_DEPENDS) $(NTIFS_DEPENDS1) $(NTIFS_DEPENDS2) $(NTIFS_DEPENDS3) $(NTIFS_DEPENDS4) makefil0
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntifs.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to file system drivers.

Revision History:

--*/

#ifndef _NTIFS_
#define _NTIFS_

#ifndef RC_INVOKED
#if _MSC_VER < 1300
#error Compiler version not supported by Windows DDK
#endif
#endif // RC_INVOKED

#ifndef __cplusplus
#pragma warning(disable:4116)       // TYPE_ALIGNMENT generates this - move it
                                    // outside the warning push/pop scope.
#endif

#define NT_INCLUDED
#define _NTMSV1_0_
#define _CTYPE_DISABLE_MACROS

#include <excpt.h>
#include <ntdef.h>
#include <ntnls.h>
#include <ntstatus.h>
#include <bugcodes.h>
#include <ntiologc.h>
<<
    type $(NTOSINC)\exlevels.h >> $@
    type << >> $@

//
//  These macros are used to test, set and clear flags respectivly
//

#ifndef FlagOn
#define FlagOn(_F,_SF)        ((_F) & (_SF))
#endif

#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF)   ((BOOLEAN)(((F) & (SF)) != 0))
#endif

#ifndef SetFlag
#define SetFlag(_F,_SF)       ((_F) |= (_SF))
#endif

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif

//
// Define types that are not exported.
//

typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
typedef struct _DEVICE_HANDLER_OBJECT *PDEVICE_HANDLER_OBJECT;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KPROCESS *PKPROCESS ,*PRKPROCESS, *PEPROCESS;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD, *PETHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _PEB *PPEB;

#if defined(_M_AMD64)

PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );

#endif // defined(_M_AMD64)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)

#define PsGetCurrentProcess() IoGetCurrentProcess()
#define PsGetCurrentThread() ((PETHREAD) (KeGetCurrentThread()))
extern NTSYSAPI CCHAR KeNumberProcessors;
<<
    hextract -o $@ -lt ntifs -bt begin_ntifs end_ntifs $(NTIFS_DEPENDS)
    hextract -o $@ -lt ntddk -bt begin_ntddk end_ntddk $(NTIFS_DEPENDS1)
    hextract -o $@ -lt ntifs -bt begin_ntifs end_ntifs $(NTIFS_DEPENDS2)
    hextract -o $@ -lt ntddk -bt begin_ntddk end_ntddk $(NTIFS_DEPENDS3)
    hextract -o $@ -lt ntifs -bt begin_ntifs end_ntifs $(NTIFS_DEPENDS4)
    type << >> $@

//
// Runtime Library function prototypes.
//

NTSYSAPI
VOID
NTAPI
RtlCaptureContext (
    OUT PCONTEXT ContextRecord
    );

#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' sfI')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,' sfI')
#endif

extern POBJECT_TYPE *PsThreadType;
extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *ExSemaphoreObjectType;

//
// Define exported ZwXxx routines to device drivers.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    IN ULONG HandleAttributes,
    OUT PHANDLE TokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    IN PVOID TokenInformation,
    IN ULONG TokenInformationLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationToken (
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Length,
    OUT PULONG LengthNeeded
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
    IN PUNICODE_STRING DriverServiceName
    );
#endif // _NTIFS_
<<

$(O)\wmikm.h: $(NTWMIKM_DEPENDS) makefil0
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    wmikm.h

Abstract:

    This module defines the WMI types, constants, and functions that are
    exposed to internal device drivers.

Revision History:

--*/

#ifndef _WMIKM_H_
#define _WMIKM_H_

#include <evntrace.h>
#include <wmistr.h>
<<
    hextract -o $@ -lt wmikm -bt begin_wmikm end_wmikm $(NTWMIKM_DEPENDS)
    type << >> $@

#endif // _WMIKM_H_
<<


$(O)\ntosp.h: $(NTOSP_DEPENDS) makefil0
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ntosp.h

Abstract:

    This module defines the NT types, constants, and functions that are
    exposed to external projects like Windows and Termsrv

Revision History:

--*/
#ifndef _NTOSP_
#define _NTOSP_

#ifdef _NTDDK_
#error "Can't include ntddk.h and ntosp.h"
#else
#define _NTDDK_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <excpt.h>
#include <ntdef.h>
#include <bugcodes.h>
#include <arc.h>
#include <arccodes.h>
<<
    type $(NTOSINC)\exlevels.h >> $@
    type << >> $@

#ifdef __cplusplus
extern "C" {   // extern "C"
#endif
//
// Define types that are not exported.
//

typedef struct _ACCESS_STATE *PACCESS_STATE;
typedef struct _BUS_HANDLER *PBUS_HANDLER;
typedef struct _EJOB *PEJOB;
typedef struct _EPROCESS *PEPROCESS;
typedef struct _ERESOURCE *PERESOURCE;
typedef struct _ETHREAD *PETHREAD;
typedef struct _IO_TIMER *PIO_TIMER;
typedef struct _IRP *PIRP;
typedef struct _KPROCESS *PKPROCESS, *RESTRICTED_POINTER PRKPROCESS;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _KTRAP_FRAME *PKTRAP_FRAME;
typedef struct _LOADER_PARAMETER_BLOCK *PLOADER_PARAMETER_BLOCK;
typedef struct _TRANSLATOR_INTERFACE *PTRANSLATOR_INTERFACE;
typedef struct _HANDLE_TABLE *PHANDLE_TABLE;

//
// Define macros to fix up structure references
//

#define PEProcessToPKProcess(P) ((PKPROCESS)P)

#if defined(_M_AMD64)

PKTHREAD
NTAPI
KeGetCurrentThread(
    VOID
    );

#endif // defined(_M_AMD64)

#if defined(_M_IX86)
PKTHREAD NTAPI KeGetCurrentThread();
#endif // defined(_M_IX86)

#if defined(_M_IA64)

//
// Define Address of Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xffff0000))            // kernel address of first PCR

//
// Define Pointer to Processor Control Registers.
//

#define PCR ((volatile KPCR * const)KIPCR)

PKTHREAD NTAPI KeGetCurrentThread();

#endif // defined(_M_IA64)

<<

    hextract -o $@ -lt ntosp -bt begin_ntosp end_ntosp $(NTOSP_DEPENDS)
    type << >> $@

extern POBJECT_TYPE *ExEventPairObjectType;
extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *IoDriverObjectType;
extern POBJECT_TYPE *PsProcessType;
extern POBJECT_TYPE *PsThreadType;
extern POBJECT_TYPE *PsJobType;
extern POBJECT_TYPE *LpcPortObjectType;
extern POBJECT_TYPE *LpcWaitablePortObjectType;
extern POBJECT_TYPE MmSectionObjectType;

#ifdef __cplusplus
}    // extern "C"
#endif

#endif // _NTOSP_
<<


$(O)\ndisbase.w: $(NDIS_BASE_DEPENDS) makefil0
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    ndis.h

Abstract:

    This module defines the structures, macros, and functions available
    to NDIS drivers.

Revision History:

--*/

#if !defined(_NDIS_)
#define _NDIS_

#if !defined(NDIS_WDM)
#define NDIS_WDM        0
#endif

//
// If we're building a miniport on x86, set BINARY_COMPATIBLE so that
// we don't use functions that aren't available on Windows 9x.
//

#if !defined(BINARY_COMPATIBLE)
#if defined(NDIS_MINIPORT_DRIVER) && defined(_M_IX86)
#define BINARY_COMPATIBLE 1
#else
#define BINARY_COMPATIBLE 0
#endif
#endif

#if !defined(_M_IX86)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0
#endif

//
// BEGIN INTERNAL DEFINITIONS
//

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 1 then use wdm.h
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 0 then use ndis.h only
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 1 then use ntddk.h
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 0 then use ntddk.h
//

#if (BINARY_COMPATIBLE && !NDIS_WDM)

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 0 then use ndis.h only
//
// The following internal definitions are included here in order to allow
// the exported NDIS structures, macros, and functions to compile.  They
// must not be used directly by miniport drivers.
//

#define _NTDDK_

<<
    hextract -o $@ -lt ntndis -bt begin_ntndis end_ntndis $(NDIS_BASE_DEPENDS)
    type << >> $@

#else // BINARY_COMPATIBLE && !NDIS_WDM

#if (!BINARY_COMPATIBLE)

//
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 1 then use ntddk.h
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 0 then use ntddk.h
//
//
// The definitions available in ntddk.h must not be used directly by non-WDM miniport drivers.
//

#include <ntddk.h>

#else // !BINARY_COMPATIBLE

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 1 then use wdm.h
//

#include <wdm.h>

#endif  // else !BINARY_COMPATIBLE

#endif //  else BINARY_COMPATIBLE && !NDIS_WDM
<<

keheaders:
    cd $(PROJECT_ROOT)\ntos\ke\up
    build -OZ
    nmake -l genxx BUILDMSG=
    cd $(MAKEDIR)


