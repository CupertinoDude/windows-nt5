<outfile:stub.h>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Stub class portion
* Target = $<target>
* 
\***************************************************************************/

#pragma once

#include "Gadget.h"

// Forward Declarations
<repeat:iClass,$<classes.count>>
$<namespace.open>
class $<class>;
$<namespace.close>
</repeat>


// Stub implementations

<repeat:iClass,$<classes.count>>

//---------------------------------------------------------------------------
//
// Stub class $<class.full>
//

$<namespace.open>

<if:"$<super>"=="">
class $<class> : public DUser::Gadget
</if>
<if:"$<super>"!="">
class $<class> : public $<super.full>
</if>
{
public:
	static  BOOL Init();

    static inline $<class> * Build(DUser::Gadget::ConstructInfo * pciData = NULL) 
    { 
        $<class> * pctl = reinterpret_cast<$<class> *> (DUserBuildGadget(s_hclMe, pciData));
        return pctl;
    }

    static inline BOOL InstanceOf(const DUser::Gadget * pg)
    {
        return DUserInstanceOf(const_cast<DUser::Gadget *> (pg), s_hclMe);
    }

    static inline $<class> * Cast(const DUser::Gadget * pg)
    {
        return reinterpret_cast<$<class> *> (DUserCastClass(const_cast<DUser::Gadget *> (pg), s_hclMe));
    }

    static inline $<class> * Cast(HGADGET hgad)
    {
        return Cast(DUserCastDirect(hgad));
    }

    static HCLASS GetClass()
    {
        ASSERT(s_hclMe != NULL);  // Ensure class is properly initialized
        return s_hclMe;
    }

$<helper>

            // Convenience wrappers
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
    inline dapi $<func.return> $<func.short>($<params.proto>)
    { ASSERT(IsInsideContext(GetHandle()));
      \
<if:"$<func.return>"!="void">
      return \
</if>
      Call$<func.short>($<params.call>);
}

</if>           ; !isInherited
</repeat>       ; iFunc

            // Call API's- direct invocation
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
    dapi    $<func.return> Call$<func.short>($<params.proto>);
</if>
</repeat>       ; iFunc

            // Send API's- wrappers around DUserSendMethod()
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
	        $<func.return> Send$<func.short>($<params.proto>);
</if>           ; !isInherited
</repeat>       ; iFunc

            // Post API's- wrappers around DUserPostMethod()
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
	        void Post$<func.short>($<params.proto>);
</if>           ; !isInherited
</repeat>       ; iFunc

            // Message structures
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
    struct GMSG_$<func.short> : public MethodMsg
    {
<repeat:iParam,$<params.count>>
	    $<param.type> m_$<param>;
</repeat>
<if:"$<func.return>"!="void">
        $<func.return> m_result;
</if>
    };

</if>           : !isInherited
</repeat>       ; iFunc

protected:
    static  HCLASS s_hclMe;
    static  DUser::MessageClassStub s_mc;
}; // stub class $<class.full>
<if:$<funcs.count>!=0>
DUser::MessageInfoStub s_rgmi$<class>[];
</if>

$<namespace.close>

</repeat>       ; iClass


//
// Setup a class to automatically initialize the stubs.
//

class InitStub
{
public:
    InitStub();
};
</outfile>

<outfile:stub.cpp>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Stub class portion
* Target = $<target>
* 
\***************************************************************************/

#include "stdafx.h"
<if:"$<project>"!="">
#include "$<project>"
</if>
#include "stub.h"

#pragma warning(disable:4100)   // unreferenced formal parameter

using namespace DUser;

<repeat:iClass,$<classes.count>>

/***************************************************************************\\
*
* class $<class.full>
* 
\***************************************************************************/

$<namespace.open>

HCLASS $<class>::s_hclMe = NULL;
MessageClassStub $<class>::s_mc;
<if:$<funcs.count>!=0>
MessageInfoStub s_rgmi$<class>[] = {
<repeat:iFunc,$<funcs.count>>
    { -1, L"$<func.short>" },
</repeat>
};
</if>


//---------------------------------------------------------------------------
BOOL $<class>::Init()
{
    ZeroMemory(&s_mc, sizeof(s_mc));
    s_mc.cbSize         = sizeof(s_mc);
    s_mc.nClassVersion  = $<class.version>;
    s_mc.pszClassName   = L"$<class.full>";
<if:$<funcs.count>==0>
    s_mc.rgMsgInfo      = NULL;
</if>
<if:$<funcs.count>!=0>
    s_mc.rgMsgInfo      = s_rgmi$<class>;
</if>
    s_mc.cMsgs          = $<funcs.count>;

    s_hclMe = DUserRegisterStub(&s_mc); 
    return s_hclMe != NULL;
}


<if:$<target>=="x86">
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
//---------------------------------------------------------------------------
__declspec(naked)
$<func.return>
$<class>::Call$<func.short>($<params.proto>)
{
<repeat:iParam,$<params.count>>
    UNREFERENCED_PARAMETER($<param>);
</repeat>

    {
	    __asm
        {
            lea     eax, s_rgmi$<class>;
            mov     edx, dword ptr [ecx];       // edx = start of message table
            add     edx, dword ptr [eax + ($<iFunc> * SIZE MessageInfoStub) + 0];
                                                // edx = MsgSlot for msg

            mov     eax, dword ptr [edx + 4];   // ecx = cbThisOffset
            mov     ecx, dword ptr [ecx + 4];   // eax = start of 'this' array
            add     eax, ecx;                   // ecx = &'this' ptr
            mov     edx, dword ptr [edx + 0];   // edx = get function ptr
            mov     ecx, dword ptr [eax];       // ecx = 'this' ptr
            
            jmp     edx;                        // jump  (call will mess stack up)
	    };
    }
} // end $<class>::$<func.short>


</if>           ; !func.isInherited
</repeat>       ; iFunc
</if>           ; $<target>=="x86">

<if:$<target>!="x86">
class Dummy$<class>
{
public:
};


<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
//---------------------------------------------------------------------------
$<func.return>
$<class>::Call$<func.short>($<params.proto>)
{
    BYTE * pdwData  = reinterpret_cast<BYTE *> (this);

    MessageInfoStub * pStub = &s_rgmi$<class>[$<iFunc>];

    BYTE * pbMT     = * (reinterpret_cast<BYTE **> (pdwData));
    BYTE * pbrgThis = * (reinterpret_cast<BYTE **> (pdwData + sizeof(void *)));
    BYTE * pbSlot   = (reinterpret_cast<BYTE *> (pbMT + pStub->cbSlotOffset));
    int cbThisOffset= * (reinterpret_cast<int *> (pbSlot + sizeof(void *)));
    
    union
    {
        $<func.return> (Dummy$<class>::*pfn$<func.short>)($<params.proto>);
        void * pfn;
    };
    
    pfn             = * (reinterpret_cast<void **> (pbSlot));
    void * pvThis   = * (reinterpret_cast<void **> (pbrgThis + cbThisOffset));
    Dummy$<class> * pDummy  
                    = reinterpret_cast<Dummy$<class> *> (pvThis);

<if:"$<func.return>"!="void">
    return \
</if>
    (pDummy->*pfn$<func.short>)($<params.call>);
} // end $<class>::$<func.short>

</if>           ; !func.isInherited
</repeat>       ; iFunc
</if>           ; $<target>=="ALL">


<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
//---------------------------------------------------------------------------
$<func.return>
$<class>::Send$<func.short>($<params.proto>)
{
    GMSG_$<func.short> msg;
    msg.cbSize = sizeof(msg);
    msg.nMsg = s_rgmi$<class>[$<iFunc>].cbSlotOffset;
    msg.hgadMsg = GetHandle();
<repeat:iParam,$<params.count>>
    msg.m_$<param> = $<param>;
</repeat>

    DUserSendMethod(&msg);
<if:"$<func.return>"!="void">
    return msg.m_result;
</if>           ; "$<func.return>"!="void">
} // end $<class>::Send$<func.short>


//---------------------------------------------------------------------------
void
$<class>::Post$<func.short>($<params.proto>)
{
    GMSG_$<func.short> msg;
    msg.cbSize = sizeof(msg);
    msg.nMsg = s_rgmi$<class>[$<iFunc>].cbSlotOffset;
    msg.hgadMsg = GetHandle();
<repeat:iParam,$<params.count>>
    msg.m_$<param> = $<param>;
</repeat>

    DUserPostMethod(&msg);
} // end $<class>::Post$<func.short>


</if>           ; $<func.isInherited>=="false">
</repeat>       ; iFunc
$<namespace.close>

</repeat>       ; iClass


//
// Setup a class to automatically initialize the stubs.
//

InitStub::InitStub()
{
<repeat:iClass,$<classes.count>>
    $<class.full>::Init();
</repeat>
}

#ifndef DUSER_EXPORTS
InitStub g_InitStub;
#endif

</outfile>





<outfile:super.h>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Super class portion
* Target = $<target>
* 
\***************************************************************************/

#pragma once

#include "stub.h"
#include "Gadget.h"

// Forward Declarations
<repeat:iClass,$<classes.count>>
$<namespace.open>
class S$<class>;
$<namespace.close>
</repeat>


/***************************************************************************\\
*
* Implementation class helpers
* 
\***************************************************************************/

<repeat:iClass,$<classes.count>>
//---------------------------------------------------------------------------
//
// Implementation class $<class.full>
//

$<namespace.open>

template <class T, class base>
class $<class>Impl : public base
{
public:
    static BOOL Init$<class.string>()
    {
        if (FAILED(T::InitClass())) {
            return FALSE;
        }

<if:"$<super>"!="">
        if (!$<super.namespace>::S$<super.short>::Init$<super.string>()) {
            return FALSE;
        }
</if>

        ZeroMemory(&s_mc, sizeof(s_mc));
        s_mc.cbSize         = sizeof(s_mc);
        s_mc.nClassVersion  = $<class.version>;
        s_mc.pszClassName   = L"$<class.full>";
        s_mc.pszSuperName   = L"$<super.full>";
        s_mc.rgMsgInfo      = s_rgmi;
        s_mc.cMsgs          = $<funcs.count>;
        s_mc.pfnPromote     = T::Promote$<class>;
        s_mc.pfnDemote      = T::Demote$<class>;
   
        return DUserRegisterGuts(&s_mc) != NULL;
    }

    static inline HRESULT
    InitClass()
    {
        return S_OK;
    }

    static inline HRESULT
    PreBuild(DUser::Gadget::ConstructInfo * pciData)
    {
        UNREFERENCED_PARAMETER(pciData);
        return S_OK;
    }

    inline HRESULT
    PostBuild(DUser::Gadget::ConstructInfo * pciData)
    {
        UNREFERENCED_PARAMETER(pciData);
        return S_OK;
    }

    static HRESULT CALLBACK
    Promote$<class>(DUser::ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pgad, DUser::Gadget::ConstructInfo * pciData)
    {
        HRESULT hr;

        hr = T::PreBuild(pciData);
        if (FAILED(hr)) {
            return hr;
        }

        hr = (pfnCS)(DUser::Gadget::ccSuper, T::s_hclSuper, pgad, pciData);
        if (FAILED(hr)) {
            return hr;
        }

        T * pc = new T;
        if (pc == NULL) {
            return E_OUTOFMEMORY;
        }
        pc->m_pgad = pgad;

        hr = (pfnCS)(DUser::Gadget::ccSetThis, hclCur, pgad, pc);
        if (FAILED(hr)) {
            return hr;
        }

        hr = pc->PostBuild(pciData);
        if (FAILED(hr)) {
            delete pc;
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }

    static HCLASS CALLBACK
    Demote$<class>(HCLASS hclCur, DUser::Gadget * pgad, void * pvData)
    {
        UNREFERENCED_PARAMETER(hclCur);
        UNREFERENCED_PARAMETER(pgad);

        T * pc = reinterpret_cast<T *> (pvData);
        delete pc;

<if:"$<super>"!="">
        return T::s_hclSuper;
</if>
<if:"$<super>"=="">
        return NULL;
</if>
    }

    $<class> * GetStub() const
    {
        return reinterpret_cast<$<class> *> (m_pgad);
    }

<repeat:iFunc,$<funcs.count>>
    inline dapi $<func.return> Call$<func.short>($<params.proto>)
    { \
<if:"$<func.return>"!="void">
      return \
</if>
      GetStub()->Call$<func.short>($<params.call>);
}

</repeat>       ; iFunc

<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
    static void CALLBACK Decode$<func.short>(DUser::Gadget * pg, MethodMsg * pmsg)
    {
        $<class>::GMSG_$<func.short> * pmsgD = ($<class>::GMSG_$<func.short> *) pmsg;
        $<class> * p = ($<class> *) pg;
        UNREFERENCED_PARAMETER(pmsgD);
        ASSERT($<class>::InstanceOf(pg));  // Must be of correct type

<if:"$<func.return>"!="void">
        pmsgD->m_result = p->Call$<func.short>(\
</if>
<if:"$<func.return>"=="void">
        p->$<func.short>($<params.call>);
</if>
    }
</if>
</repeat>


$<helper>

protected:
    static  DUser::MessageClassGuts s_mc;
public:
    static  DUser::MessageInfoGuts s_rgmi[];
}; // implementation class $<class.full>

#define IMPLEMENT_GUTS_$<class.string>(me, super) \\
    DUser::MessageClassGuts $<class.full>Impl<me, super>::s_mc; \\
    DUser::MessageInfoGuts $<class.full>Impl<me, super>::s_rgmi[] = { \\
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
        { member(me::Api$<func.short>), Decode$<func.short>, L"$<func.short>" }, \\
</if>
<if:$<func.isInherited>=="true">
        { member(me::Api$<func.short>) != member(super::Api$<func.short>) ? member(me::Api$<func.short>) : NULL, NULL, L"$<func.short>" }, \\
</if>
</repeat>       ; iFunc
    }; \\

$<namespace.close>

</repeat>       ; iClass



/***************************************************************************\\
*
* Super class helpers
*
* NOTE: Unlike the stub class, the super class does NOT inherit from any 
* base class.  This is because it is illegal to jump multiple levels of 
* inheritence and scope a function for the super's super.
* 
\***************************************************************************/

<repeat:iClass,$<classes.count>>
//---------------------------------------------------------------------------
//
// Super class $<class.full>
//

$<namespace.open>

<if:"$<super>"=="">
class S$<class> : public DUser::SGadget
</if>
<if:"$<super>"!="">
class S$<class> : public $<super.namespace>::S$<super.short>
</if>
{
public:
    static  BOOL        Init$<class.string>();

<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
    dapi $<func.return> Api$<func.short>($<params.proto>);
</if>
</repeat>       ; iFunc

public:
    static  HCLASS      s_hclSuper;     // HCLASS for THIS super-class
}; // stub class $<class.full>
extern DUser::MessageClassSuper
            s_mcsS$<class>;             // Super information

$<namespace.close>

</repeat>       ; iClass

</outfile>      ; super.h



<outfile:super.cpp>
/***************************************************************************\\
*
* Generated by GIDL on $<date> at $<time>
*
* Super class portion
* Target = $<target>
* 
\***************************************************************************/

#include "stdafx.h"
<if:"$<project>"!="">
#include "$<project>"
</if>
#include "super.h"
#include "stub.h"
#include <stddef.h>

#pragma warning(disable:4100)   // unreferenced formal parameter

using namespace DUser;

HCLASS SGadget::s_hclSuper = NULL;
<repeat:iClass,$<classes.count>>
<if:"$<class.namespace>"=="">
MessageClassSuper s_mcsS$<class>;
</if>
<if:"$<class.namespace>"!="">
MessageClassSuper $<class.namespace>::s_mcsS$<class>;
</if>
</repeat>

<repeat:iClass,$<classes.count>>

/***************************************************************************\\
*
* class $<class.full>
* 
\***************************************************************************/

$<namespace.open>

<if:$<target>=="x86">
const int off$<class>Direct = offsetof(S$<class>, m_pgad);
</if>

HCLASS S$<class>::s_hclSuper = NULL;

//---------------------------------------------------------------------------
BOOL
S$<class>::Init$<class.string>()
{
    if (s_hclSuper != NULL) {
        return TRUE;
    }

<if:"$<super>"!="">
    if (!$<super.namespace>::S$<super.short>::Init$<super.string>()) {
        return FALSE;
    }
</if>

    ZeroMemory(&s_mcsS$<class>, sizeof(s_mcsS$<class>));
    s_mcsS$<class>.cbSize = sizeof(s_mcsS$<class>);
    s_mcsS$<class>.nClassVersion = 1;
    s_mcsS$<class>.pszClassName = L"$<class.full>";

    s_hclSuper = DUserRegisterSuper(&s_mcsS$<class>);
    return s_hclSuper != NULL;
}


<if:$<target>=="x86">
<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
//---------------------------------------------------------------------------
__declspec(naked)
$<func.return>
S$<class>::Api$<func.short>($<params.proto>)
{
<repeat:iParam,$<params.count>>
    UNREFERENCED_PARAMETER($<param>);
</repeat>

    {
	    __asm
        {
            add     ecx, off$<class>Direct;
            mov     eax, dword ptr [ecx];       // eax = (this->m_pgad)

            lea     ecx, s_rgmi$<class>;
            mov     edx, dword ptr [s_mcsS$<class>.pmt]; // edx = start of super message table

            add     edx, dword ptr [ecx + ($<iFunc> * SIZE MessageInfoStub) + 0];
                                                // edx = MsgSlot for msg

            mov     ecx, dword ptr [edx + 4];   // ecx = cbThisOffset
            mov     eax, dword ptr [eax + 4];   // eax = start of 'this' array
            add     ecx, eax;                   // ecx = &'this' ptr
            mov     edx, dword ptr [edx + 0];   // edx = get function ptr
            mov     ecx, dword ptr [ecx];       // ecx = 'this' ptr
            
            jmp     edx;                        // jump  (call will mess stack up)
	    };
    }
} // end $<class>::$<func.short>


</if>           ; !inherited
</repeat>       ; iFunc
</if>           ; $<target>=="x86">
<if:$<target>!="x86">
class Dummy$<class>
{
public:
};


<repeat:iFunc,$<funcs.count>>
<if:$<func.isInherited>=="false">
//---------------------------------------------------------------------------
$<func.return>
S$<class>::Api$<func.short>($<params.proto>)
{
    BYTE * pdwData  = reinterpret_cast<BYTE *> (m_pgad);

    MessageInfoStub * pStub = &s_rgmi$<class>[$<iFunc>];

    BYTE * pbMT     = reinterpret_cast<BYTE *>(s_mcsS$<class>.pmt); // Get super message table

    BYTE * pbrgThis = * (reinterpret_cast<BYTE **> (pdwData + sizeof(void *)));
    BYTE * pbSlot   = (reinterpret_cast<BYTE *> (pbMT + pStub->cbSlotOffset));
    int cbThisOffset= * (reinterpret_cast<int *> (pbSlot+ sizeof(void *)));
    
    union
    {
        $<func.return> (Dummy$<class>::*pfn$<func.short>)($<params.proto>);
        void * pfn;
    };
    
    pfn             = * (reinterpret_cast<void **> (pbSlot));
    void * pvThis   = * (reinterpret_cast<void **> (pbrgThis + cbThisOffset));
    Dummy$<class> * pDummy  
                    = reinterpret_cast<Dummy$<class> *> (pvThis);

<if:"$<func.return>"!="void">
    return \
</if>
    (pDummy->*pfn$<func.short>)($<params.call>);
} // end $<class>::$<func.short>

</if>           ; !inherited
</repeat>       ; iFunc
</if>           ; $<target>=="ALL">

$<namespace.close>

</repeat>       ; iClass

</outfile>      ; super.cpp

