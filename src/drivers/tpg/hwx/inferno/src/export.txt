Under the Hood
Matt Pietrek
Microsoft Systems Journal. Copyright © 1995 

As it turns out, nearly all Win32" functions are defined as __stdcall functions. Aside from dictating a parameter-passing convention, 
the names of __stdcall functions are modified by Visual C++ in a fashion that neither Delphi nor Borland C++ recognize. Specifically, 
Visual C++ adds "_" onto the beginning and "@xxx" onto the end of the __stdcall function. The xxx is actually the size of the stack 
arguments passed to the function. Thus, MessageBeep(UINT uType) becomes _MessageBeep@4. Likewise, GetMessageA, which takes 4 parameters, 
becomes _GetMessageA@16. Some programmers refer to this renaming as __stdcall mangling, but it's definitely different from C++ name mangling.

Visual C++ expects the names of __stdcall functions to be mangled, while Borland compilers don't. Thus, the Delphi-produced OBJ has an 
external reference to just MessageBeep. MessageBeep isn't in the USER32.LIB import library that Visual C++ uses, but the public symbol 
_MessageBeep@4 is. The Microsoft" linker can't match up these two names, so there's your linker error. For what it's worth, the same 
problem appears if you try to mix Borland C++ code with Microsoft Visual C++ code.

To make matters just a bit more confusing, Microsoft's mangling of __stdcall function names is undone when the symbol name appears in 
the export table of a DLL. That is, while the MessageBeep function is mangled to _MessageBeep@4 internally by Visual C++ in your OBJ 
files, the exported name in USER32.DLL (where MessageBeep's code resides) is just MessageBeep. This allows Borland-compiled code (which 
doesn't mangle __stdcall function names) to link properly with functions exported by the Win32 DLLs. Visual C++, on the other hand, 
effectively strips the preceding "_" and following "@xxx" when it puts the symbol name into a DLL's export table.



From CPP to COM
Markus Horstmann
OLE Program Manager, Microsoft Corporation
RPC Programmer's Guide and Reference.

One simple way to export functions is by using the __declspec(dllexport) modifier (since Visual C++ 2.0), which can be applied to any 
function, including member functions. This instructs the compiler to place an entry into the exports table, just like declaring an 
export in the module definition file (.DEF) for the linker. [In the 16-bit world, _export did the same thing; in addition, the compiler 
provided additional code to change to the data segment of the DLL before entering the function, and then switch back to the caller's 
data segment before leaving the function (prologue/epilogue).]

For C++ this is the only practical way to export big numbers of functions, because C++ provides function overloading (that is, using 
one function name for many functions that differ only in the kind of parameter declared). Thus, the C++ compiler combines all the 
information it has about a member function (return type, class, parameter types, public/private) into one big name. (See the technical
 article “Exporting with Class" in the MSDN Library Archive for more details.)

By simply applying the _declspec(dllexport) modifier to all the functions in the CDB class, we make the class exportable in a DLL. 
We then just have to provide a make file to create the binary.

Due to the name mangling, it is very difficult for the client to use dynamic loading: We would have to pass all the decorated names 
to GetProcAddress and save the returned pointer somewhere. Then we would have to set up a simulation class that calls each of these 
functions. Therefore, it's definitely better to use implicit linking (using the DB.LIB file generated by the linker).




Article 2. Libraries Made Too Easy
Bruce McKinney

Here the mangling follows the Win32 stdcall mangling convention. The names always have an underscore prefix and a suffix of the 
"at" sign (@) followed by the number of bytes of parameters in hexadecimal.

...But the easier solution (to get rid of mangling) is to specify the export name in the .DEF file. 

A .DEF file is optional for Win32 DLLs. Most of the options you set in a .DEF file have acceptable defaults. 
You can define your functions like this: 

void __stdcall DoNothing(void); 

Add a .DEF file entry in the EXPORTS section for each function:

EXPORTS
    DoNothing

