/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    unit.c

Abstract:

    Implementation of the operations on the logical unit for the RAIDPORT
    driver.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaUnitSystemControlIrp)
#pragma alloc_text(PAGE, RaUnitPnpIrp)
#pragma alloc_text(PAGE, RaUnitStartDeviceIrp)
#pragma alloc_text(PAGE, RaUnitStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitSurpriseRemovalIrp)
#pragma alloc_text(PAGE, RaUnitQueryCapabilitiesIrp)
#pragma alloc_text(PAGE, RaUnitQueryPnpDeviceStateIrp)
#pragma alloc_text(PAGE, RaUnitDeviceUsageNotificationIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceRelationsIrp)
#pragma alloc_text(PAGE, RaUnitQueryIdIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceTextIrp)
#pragma alloc_text(PAGE, RaUnitIgnorePnpIrp)
#pragma alloc_text(PAGE, RaUnitSucceedPnpIrp)
#pragma alloc_text(PAGE, RaUnitUnknownSrb)
#pragma alloc_text(PAGE, RaUnitDeviceControlIrp)
#pragma alloc_text(PAGE, RaUnitScsiGetAddressIoctl)
#pragma alloc_text(PAGE, RaUnitStorageQueryPropertyIoctl)
#pragma alloc_text(PAGE, RaUnitUnknownIoctl)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceProperty)
#endif // ALLOC_PRAGMA


//
// Globals
//

//
// Chained IO consolidates the free cycle of IO Request N with the allocation
// cycle of IO Request N+1, thus reducing back-to-back free and allocate
// requests.
//

LOGICAL RaidChainedIo = TRUE;


NTSTATUS
RaidCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PRAID_UNIT_EXTENSION* UnitBuffer
    )
/*++

Routine Description:

    Create a null raid unit object.

Arguments:

    Adapter -

    UnitBuffer -
    
Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PDEVICE_OBJECT DeviceObject;

    ASSERT_ADAPTER (Adapter);
    ASSERT (UnitBuffer != NULL);
    
    PAGED_CODE ();


    Status = IoCreateDevice (Adapter->DeviceObject->DriverObject,
                             sizeof (RAID_UNIT_EXTENSION),
                             NULL, // DeviceName,
                             FILE_DEVICE_MASS_STORAGE,
                             (FILE_AUTOGENERATED_DEVICE_NAME |
                              FILE_DEVICE_SECURE_OPEN),
                             FALSE,
                             &DeviceObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

DebugPrint (("Created Unit %p\n", DeviceObject));

    Unit = DeviceObject->DeviceExtension;
    RaidZeroUnit (Unit);
    Unit->Adapter = Adapter;
    Unit->DeviceObject = DeviceObject;

    SET_FLAG (DeviceObject->Flags, DO_DIRECT_IO);
    SET_FLAG (DeviceObject->Flags, DO_BUS_ENUMERATED_DEVICE);

    Unit->DeviceObject->AlignmentRequirement =
            Adapter->DeviceObject->AlignmentRequirement;


    //
    // Since the Unit is the child PDO from the adapter, we never
    // get an AddDevice call. Hence, we start in the stopped state.
    //
    
    Unit->DeviceState = DeviceStateNotPresent;

    //
    // Allocate all resources associated with the logical unit.
    //

    Status = RaidUnitAllocateResources (Unit);

    if (!NT_SUCCESS (Status)) {

        //
        // NB: Need to delete the unit,
        //
        
        NYI();
        return Status;
    }

    //
    // The unit queue is locked until we start the device.
    //
    
    RaidLockUnitQueue (Unit);

    *UnitBuffer = Unit;
    
    return STATUS_SUCCESS;
}


VOID
RaidZeroUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Return a logical unit to a NULL status.

Arguments:

    Unit - Logical unit to NULL.

Return Value:

    None.

--*/
{
    RtlZeroMemory (Unit, sizeof (RAID_UNIT_EXTENSION));
    Unit->ObjectType = RaidUnitObject;
    RaCreateTagList (&Unit->TagList);
    RaidCreateRegion (&Unit->SrbExtensionRegion);
    RaCreatePower (&Unit->Power);
    RaSetSystemPowerState (&Unit->Power, PowerSystemWorking);
    RaSetDevicePowerState (&Unit->Power, PowerDeviceD0);
    StorCreateEventQueue (&Unit->PendingQueue);
    Unit->Address = RaidNullAddress;
}



VOID
RaidStartUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    PAGED_CODE();

    ASSERT_UNIT (Unit);
    ASSERT (Unit->DeviceObject != NULL);

    //
    // NB: Add assert to validate unit is on adapter list.
    //
    
    ASSERT (memcmp (&Unit->Address, &RaidNullAddress, sizeof (RaidNullAddress)) != 0);

    CLEAR_FLAG (Unit->DeviceObject->Flags, DO_DEVICE_INITIALIZING);
}



VOID
RaidDeleteUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine deallocates any resources associated with a RAID Unit
    object, preparing the buffer for reuse. This routine must be called
    for every unit before the unit's memory is deallocated.

Arguments:

    Unit - Unit to be deleted.

Return Value:

    NTSTATUS code

--*/
{
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    Status = RaidUnitFreeResources (Unit);
    ASSERT (NT_SUCCESS (Status));

    //
    // When we call IoDeleteDevice, the memory for the unit object is
    // deallocated. So save the memory for the unit object before 
    //
    
    DeviceObject = Unit->DeviceObject;
    DbgFillMemory (Unit,
                   sizeof (RAID_UNIT_EXTENSION),
                   DBG_DEALLOCATED_FILL);
    IoDeleteDevice (DeviceObject);
    
}



VOID
RaidUnitAssignAddress(
    IN PRAID_UNIT_EXTENSION Unit,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Assign a logical unit's RAID (SCSI) Address. Addresses CAN be modified
    dynamically, although the user should be careful that all outstanding
    requests are completed before any attempt is made to modify the
    Address.

Arguments:

    Unit - Supplies the logical unit to assign the SCSI address to.

    Address - Supplies the SCSI address to assign.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    Unit->Address = Address;
}

VOID
RaidUnitAssignIdentity(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PSTOR_SCSI_IDENTITY Identity
    )
/*++

Routine Description:

    Assign a logical unit's identity. The identity includes the SCSI
    INQUIRY data, plus pages 80 and 80 of the Vital Product Data.

Arguments:

    Unit - Supplies the logical unit whose identity is to be assigned.

    Identity - Supplies a pointer to the identity to be assigned. By
            calling this call, the caller grants ownership of the
            identity data to the logical unit. It must not access this
            buffer after calling this function.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    RtlCopyMemory (&Unit->Identity, Identity, sizeof (Unit->Identity));
    RtlZeroMemory (Identity, sizeof (*Identity));
}



NTSTATUS
RaidUnitAllocateResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Allocate all resources necessary for a logical unit to function.

Arguments:

    Unit - Supplies the logical unit to allocate resources for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG NumberOfElements;
    ULONG SrbExtensionSize;
    PVOID SrbExtensionBuffer;
    PHYSICAL_ADDRESS PhysicalAddress;
    LARGE_INTEGER LargeTimeout;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = Unit->Adapter;
    
    IoInitializeRemoveLock (&Unit->RemoveLock,
                            REMLOCK_TAG,
                            REMLOCK_MAX_WAIT,
                            REMLOCK_HIGH_MARK);


    //
    // Create two pools of shared dma memory, one for srb extensions
    // and one for sense info buffers.
    //

    NumberOfElements = TAG_QUEUE_COUNT;
    SrbExtensionSize = RaGetSrbExtensionSize (Unit->Adapter);


    //
    // Srb extension pool.
    //

    Status = RaidDmaAllocateCommonBuffer (&Unit->Adapter->Dma,
                                          NumberOfElements * SrbExtensionSize,
                                          FALSE,
                                          &Unit->SrbExtensionRegion);

    if (!NT_SUCCESS (Status)) {
        return STATUS_NO_MEMORY;
    }
    
    RaidInitializeFixedPool (&Unit->SrbExtensionPool,
                             RaidRegionGetVirtualBase (&Unit->SrbExtensionRegion),
                             NumberOfElements,
                             SrbExtensionSize);

    //
    // Xrb lookaside list.
    //

    ExInitializeNPagedLookasideList (&Unit->XrbList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (EXTENDED_REQUEST_BLOCK),
                                     XRB_TAG,
                                     0);

    RaInitializeTagList (&Unit->TagList,
                         TAG_QUEUE_COUNT,
                         Unit->DeviceObject);

    //
    // Initialize the pending queue.
    //
    
    StorInitializeEventQueue (&Unit->PendingQueue);

    KeInitializeDpc (&Unit->PendingDpc,
                     RaidUnitPendingDpcRoutine,
                     Unit->DeviceObject);

    KeInitializeTimer (&Unit->PendingTimer);

    //
    // Set timer to fire once per second.
    //

    LargeTimeout.QuadPart = 1;
    LargeTimeout.QuadPart *= SECONDS;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    
    KeSetTimerEx (&Unit->PendingTimer,
                  LargeTimeout,
                  1 * 1000,             // milli
                  &Unit->PendingDpc);
    
    KeInitializeSpinLock (&Unit->SlowLock);

    //
    // Initialize an IO_QUEUE for the unit object.
    //
    
    RaidInitializeIoQueue (&Unit->IoQueue,
                           Unit->DeviceObject,
                           &Unit->Adapter->Gateway,
                           RaUnitStartIo,
                           TAG_QUEUE_COUNT);


    //
    // Create logical unit extension, if necessary.
    //

    if (Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize) {
        Unit->UnitExtension = RaidAllocatePool (NonPagedPool,
                                                Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize,
                                                UNIT_EXT_TAG,
                                                Unit->DeviceObject);
                                                
        if (Unit->UnitExtension == NULL) {
            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;
}



NTSTATUS
RaidUnitFreeResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Release all resources associated with a logical unit.

Arguments:

    Unit - Supplies the logical unit to release resources for.

Return Value:

    NTSTATUS code.

--*/
{
    PVOID Buffer;

    PAGED_CODE();
    
    //
    // Free the XRB lookaside list.
    //

    if (Unit->XrbList.L.Size != 0) {
        ExDeleteNPagedLookasideList (&Unit->XrbList);
    }

    //
    // Free the SRB extension region and pool, if necessary.
    //
    
    if (RaidIsRegionInitialized (&Unit->SrbExtensionRegion)) {

        RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                 &Unit->SrbExtensionRegion,
                                 FALSE);
        RaidDeleteFixedPool (&Unit->SrbExtensionPool);
    }

    StorDeleteEventQueue (&Unit->PendingQueue);
    StorDeleteScsiIdentity (&Unit->Identity);
    RaDeleteTagList (&Unit->TagList);

    if (Unit->UnitExtension != NULL) {
        RaidFreePool (Unit->UnitExtension, UNIT_EXT_TAG);
        Unit->UnitExtension = NULL;
    }

    KeCancelTimer (&Unit->PendingTimer);

//    StorDeleteEventQueue (&Unit->PendingQueue);

    return STATUS_SUCCESS;
}



//
// Handler functions.
//

NTSTATUS
RaUnitCreateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (&Unit->RemoveLock, Irp);
}

NTSTATUS
RaUnitCloseIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (&Unit->RemoveLock, Irp);
}

NTSTATUS
RaUnitSystemControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for system control (WMI) irps for the logical unit.

Arguments:

    Unit - Logical unit to handle the irp.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;

    PAGED_CODE ();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_NOT_SUPPORTED);
}


NTSTATUS
RaUnitPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the PnP dispatch routine for the Raid Unit object.  It's
    purpose it to forward the irp on to sub-dispatch routines for the
    specific irp.

Arguments:

    Unit - The unit object this irp is for.

    Irp - Pnp irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    BOOLEAN RemlockHeld;
    
    PAGED_CODE ();
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);

    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    RemlockHeld = TRUE;
    Minor = RaidMinorFunctionFromIrp (Irp);
    DebugTrace (("Unit %p, Irp %p, Pnp, Minor %x\n",
                 Unit,
                 Irp,
                 Minor));

    //
    // Dispatch the IRP to one of our handlers.
    //

    switch (Minor) {

        case IRP_MN_START_DEVICE:
            Status = RaUnitStartDeviceIrp (Unit, Irp);
            break;
        
        case IRP_MN_STOP_DEVICE:
            Status = RaUnitStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = RaUnitQueryStopDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = RaUnitCancelStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            Status = RaUnitRemoveDeviceIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_REMOVE_DEVICE:
            Status = RaUnitQueryRemoveDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = RaUnitCancelRemoveDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            Status = RaUnitSurpriseRemovalIrp (Unit, Irp);
            break;
            
        case IRP_MN_QUERY_CAPABILITIES:
            Status = RaUnitQueryCapabilitiesIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Status = RaUnitQueryPnpDeviceStateIrp (Unit, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            Status = RaUnitDeviceUsageNotificationIrp (Unit, Irp);
            break;
            
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            Status = RaUnitQueryDeviceRelationsIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_ID:
            Status = RaUnitQueryIdIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_DEVICE_TEXT:
            Status = RaUnitQueryDeviceTextIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = RaUnitSucceedPnpIrp (Unit, Irp);
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_BUS_INFORMATION:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        default:
            Status = RaUnitIgnorePnpIrp (Unit, Irp);

    }

    DebugTrace (("Unit %p, Irp %p, Pnp Minor %x, ret = %08x\n",
                 Unit,
                 Irp,
                 Minor,
                 Status));

    if (RemlockHeld) {
        IoReleaseRemoveLock (&Unit->RemoveLock, Irp);
    }

    return Status;
}


NTSTATUS
RaUnitStartDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to start.

    Irp - Start device irp.

Return Value:

    NTSTATUS code.

--*/

{
    DEVICE_STATE PreviousState;
    
    PAGED_CODE ();

    RaidUnlockUnitQueue (Unit);
    PreviousState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                         DeviceStateWorking);
    ASSERT (PreviousState == DeviceStateStopped);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to stop.

    Irp - Stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    RaidLockUnitQueue (Unit);

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateStopped);
    ASSERT (PriorState == DeviceStatePendingStop);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitQueryStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )

/*++

Routine Description:

    Handler function for the unit query stop device irp.

Arguments:

    Unit - Unit to query for stop.

    Irp - Query stop device irp.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    //
    // NB: Even if we fail this IRP, we must still enter the PendingStop
    // state because the PnP manager will send us cancel stop after this.
    //
    
    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStatePendingStop);
    ASSERT (PriorState == DeviceStateWorking);
    
    if (Unit->PagingPathCount == 0) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_BUSY;
    }
    
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitCancelStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for unit cancel stop device irp.

Arguments:

    Unit - Unit to cancel stop for.

    Irp - Cancel stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateWorking);

    //
    // We can receive a cancel stop without having ever receiving a
    // pending stop. This is ok, either way we want to go back to
    // working state.
    //
    
    ASSERT (PriorState == DeviceStatePendingStop ||
            PriorState == DeviceStateWorking);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}



NTSTATUS
RaUnitRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to remove.

    Irp - Remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateRemoved);

    switch (PriorState) {

        case DeviceStateRemoved:

            //
            // This is the second remove IRP. Actually delete underlying
            // resources this time.
            //
            
            ASSERT (!Unit->Flags.Enumerated);
            RaidAdapterRemoveUnit (Unit->Adapter, Unit);
            RaidDeleteUnit (Unit);
            break;

        case DeviceStatePendingRemove:

            //
            // Release remove lock and wait for all pending IO to complete.
            //

            IoReleaseRemoveLockAndWait (&Unit->RemoveLock, Irp);
            break;

        case DeviceStateSurpriseRemoval:
        case DeviceStateStopped:

            //
            // Delete all outstanding/queued requests.
            //

            REVIEW();

            break;
            
        default:
            ASSERT (!"PnP state machine is broken.");
    }
    
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitQueryRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit query remove device irp.

Arguments:

    Unit - Unit to query remove for.

    Irp - Query remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    if (Unit->PagingPathCount == 0) {
        PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                          DeviceStatePendingRemove);
        ASSERT (PriorState == DeviceStateWorking);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_BUSY;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitCancelRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to cancel remove device for.

    Irp - Cancel remove device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateWorking);

    ASSERT (PriorState == DeviceStatePendingRemove ||
            PriorState == DeviceStateWorking);
            
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitSurpriseRemovalIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit surprise removal irp.

Arguments:

    Unit - Unit to surprise remove.

    Irp - Surprise removal irp.

Return Value:

    NTSTATUS code

--*/
{
    PAGED_CODE ();

    InterlockedExchange ((PLONG)&Unit->DeviceState,
                         DeviceStateSurpriseRemoval);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}
    

NTSTATUS
RaUnitQueryCapabilitiesIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for the query capabilities PnP irp on the unit object.

Arguments:

    Unit - Unit to query.

    Irp - Query capabilities irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_CAPABILITIES Capabilities;
    PSCSI_DEVICE_TYPE DeviceType;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    //
    // Setup parameters
    //
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Capabilities = IrpStack->Parameters.DeviceCapabilities.Capabilities;

    RtlZeroMemory (Capabilities, sizeof (*Capabilities));
    DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

    //
    // Storage devices install silently.
    //
    
    if (DeviceType->IsStorage) {
        Capabilities->SilentInstall = TRUE;
    }

    Capabilities->Address = StorGetAddressTargetId (Unit->Address);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}



NTSTATUS
RaUnitQueryPnpDeviceStateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the query device state irp for the logical unit.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Query device state irp to handle.

Return Value:
<
    NTSTATUS code

--*/
{
    PPNP_DEVICE_STATE DeviceState;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);
    
    DeviceState = (PPNP_DEVICE_STATE)&Irp->IoStatus.Information;
    if (Unit->PagingPathCount) {
        SET_FLAG (*DeviceState, PNP_DEVICE_NOT_DISABLEABLE);
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}



NTSTATUS
RaUnitDeviceUsageNotificationIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the PnP device usage notification irp.

Arguments:

    Unit - Unit the irp is for.

    Irp - Device usage irp to handle.x

Return Value:

    NTSTATUS code.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    DEVICE_USAGE_NOTIFICATION_TYPE Type;
    BOOLEAN Increment;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.UsageNotification.Type;
    Increment = IrpStack->Parameters.UsageNotification.InPath;
    

    if (Type == DeviceUsageTypeDumpFile ||
        Type == DeviceUsageTypePaging ||
        Type == DeviceUsageTypeHibernation) {

        IoAdjustPagingPathCount (&Unit->PagingPathCount,
                                 Increment);
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitQueryDeviceRelationsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query device relations irp for the unit. The unit only
    supports querying TargetDeviceRelations.

Arguments:

    Unit - Unit to query.

    Irp - Query device relations irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDEVICE_RELATIONS DeviceRelations;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_RELATION_TYPE Type;

    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceRelations.Type;

    if (Type == TargetDeviceRelation) {
        DeviceRelations = RaidAllocatePool (PagedPool,
                                            sizeof (DEVICE_RELATIONS),
                                            DEVICE_RELATIONS_TAG,
                                            Unit->DeviceObject);

        if (DeviceRelations != NULL) {
            DeviceRelations->Count = 1;
            DeviceRelations->Objects[0] = Unit->DeviceObject;
            ObReferenceObject (Unit->DeviceObject);
            Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    } else {
        //
        // We must complete the request with it's current status.
        //
        Status = Irp->IoStatus.Status;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

//
// BUGBUG: For now in free as well
//
VOID
DbgPrintIds(
    IN BUS_QUERY_ID_TYPE IdType,
    IN PWSTR Id
    );
    
NTSTATUS
RaUnitQueryIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query id request for the unit.

Arguments:

    Unit - Unit to handle the request.

    Irp - Query id request to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    BUS_QUERY_ID_TYPE IdType;
    PIO_STACK_LOCATION IrpStack;
    PWSTR Id;
    
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    IdType = IrpStack->Parameters.QueryId.IdType;
    Id = NULL;
    
    switch (IdType) {

        case BusQueryDeviceID:
            Status = RaidUnitGetDeviceId (Unit, &Id);
#if DBG
            if (NT_SUCCESS (Status)) {
                DbgPrintIds (IdType, Id);
            }
#endif
            break;

        case BusQueryInstanceID:
            Status = RaidUnitGetInstanceId (Unit, &Id);
            break;

        case BusQueryHardwareIDs:
            Status = RaidUnitGetHardwareIds (Unit, &Id);
            break;

        case BusQueryCompatibleIDs:
            Status = RaidUnitGetCompatibleIds (Unit, &Id);
            break;

        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            Id = NULL;
    }

    Irp->IoStatus.Information = (ULONG_PTR) Id;
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


VOID
DbgPrintIds(
    IN BUS_QUERY_ID_TYPE IdType,
    IN PWSTR Id
    )
{
    ULONG i;
    PWSTR String;
    
    switch (IdType) {

        case BusQueryDeviceID:
            DbgPrint ("RAID: DeviceId: %ws\n", Id);
            break;

        case BusQueryInstanceID:
            DbgPrint ("RAID: InstanceId: %ws\n", Id);
            break;

        case BusQueryHardwareIDs:
            for (String = Id, i=0;
                 String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("RAID: HardwareId[%d] %ws\n", i, String);
            }
            break;

        case BusQueryCompatibleIDs:
            for (String = Id, i=0;
                 !String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("RAID: CompatibleId[%d] %ws\n", i, String);
            }
            break;
    }
}

NTSTATUS
RaUnitQueryDeviceTextIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{

    NTSTATUS Status;
    PWCHAR Buffer;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    PSCSI_DEVICE_TYPE DeviceType;   
    PIO_STACK_LOCATION IrpStack;
    DEVICE_TEXT_TYPE Type;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceText.DeviceTextType;
    
    Buffer = RaidAllocatePool (PagedPool,
                               256 * sizeof (WCHAR),
                               QUERY_TEXT_TAG,
                               Unit->DeviceObject);

    if (Buffer == NULL) {
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_NO_MEMORY);
    }
    
    switch (Type) {

        case DeviceTextDescription:
            //
            // We use "<VENDOR> SCSI <DEVICE-TYPE> Device", like SCSIPORT.
            //

            StorGetIdentityVendorId (&Unit->Identity,
                                     VendorId,
                                     sizeof (VendorId),
                                     TRUE);

            DeviceType = StorGetIdentityDeviceType (&Unit->Identity);
            swprintf (Buffer,
                      L"%hs SCSI %hs Device",
                      VendorId,
                      DeviceType->Name);
                      
            Status = STATUS_SUCCESS;
        break;

        case DeviceTextLocationInformation:
            //
            // We use "Bus Number <PathId>, Target ID <TargetId>, LUN <LUN>",
            // like SCSIPORT.
            //
            swprintf (Buffer,
                      L"Bus Number %d, Target Id %d, LUN %d",
                      Unit->Address.PathId,
                      Unit->Address.TargetId,
                      Unit->Address.Lun);
                      
            Status = STATUS_SUCCESS;
        break;

        default:
            ExFreePool (Buffer);
            Buffer = NULL;
            Status = STATUS_NOT_SUPPORTED;
    }

    Irp->IoStatus.Information = (ULONG_PTR)Buffer;
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

       
NTSTATUS
RaUnitIgnorePnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Irp->IoStatus.Status);
}
    
NTSTATUS
RaUnitSucceedPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitScsiIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for SCSI irps. 

Arguments:

    Unit - Unit to handle the scsi irp.

    Irp - Scsi irp to handle.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    UCHAR Srb;


    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_SCSI);

    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    Srb = RaidSrbFunctionFromIrp (Irp);

    DebugTrace (("Unit %p, Irp %p, Scsi, Srb %x\n",
                 Unit,
                 Irp,
                 Srb));
                    
    switch (Srb) {

        case SRB_FUNCTION_EXECUTE_SCSI:
            Status = RaUnitExecuteScsiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_CLAIM_DEVICE:
            Status = RaUnitClaimDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_DEVICE:
            Status = RaUnitReleaseDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_BUS:
            Status = RaUnitResetBusSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH_QUEUE:
            Status = RaUnitFlushQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_QUEUE: 
            Status = RaUnitReleaseQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_LOCK_QUEUE:
            Status = RaUnitLockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_UNLOCK_QUEUE:
            Status = RaUnitUnlockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH:
            Status = RaUnitFlushSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_SHUTDOWN:
            Status = RaUnitShutdownSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_IO_CONTROL:
            Status = RaUnitIoControlSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_WMI:
            Status = RaUnitWmiSrb (Unit, Irp);
            break;
#if 0
        case SRB_FUNCTION_ATTACH_DEVICE:
            Status = RaUnitAttachDeviceSrb (Unit, Irp);
            break;


        case SRB_FUNCTION_RECEIVE_EVENT:
            Status = RaUnitReceiveEventSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_ABORT_COMMAND:
            Status = RaUnitAbortCommandSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_RECOVERY:
            Status = RaUnitReleaseRecoverySrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_DEVICE:
            Status = RaUnitResetDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_TERMINATE_IO:
            Status = RaUnitTerminateIoSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_REMOVE_DEVICE:
            Status = RaUnitRemoveDeviceSrb (Unit, Irp);
            break;

#endif

        default:
            Status = RaUnitUnknownSrb (Unit, Irp);

    }

    DebugTrace (("Unit %p, Irp %p, Scsi, Srb %x, ret = %08x\n",
                 Unit,
                 Irp,
                 Srb,
                 Status));

    IoReleaseRemoveLock (&Unit->RemoveLock, Irp);

    return Status;
}



NTSTATUS
RaidUnitSubmitRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    BOOLEAN ByPassRequest;
    PSCSI_REQUEST_BLOCK Srb;
    
    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

    //
    // We only expect two kinds of SRBs to be send down.
    //
    
    ASSERT (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI ||
            Srb->Function == SRB_FUNCTION_IO_CONTROL);

    //
    // Since the bypass frozen and bypass locked flags will not
    // normally be set, we will not normally take this conditional,
    // hence we will not normally have to figure out whether the
    // unit queue is frozen or locked (which requires the
    // aquisition of a spinlock to accomplish).
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

        if ( (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
              RaidIsUnitQueueFrozen (Unit)) ||
             (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE) &&
               RaidIsUnitQueueLocked (Unit)) ) {

            ByPassRequest = FALSE;
        } else {
            ByPassRequest = TRUE;
        }
    } else {
        ByPassRequest = FALSE;
    }

    RaidStartIoPacket (&Unit->IoQueue,
                       Irp,
                       ByPassRequest,
                       NULL);

    Status = STATUS_PENDING;

    return Status;
}


NTSTATUS
RaUnitExecuteScsiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the SRB_FUNCTION_EXECUTE_SCSI command by queuing the request
    on the LUN queue.

Arguments:

    Unit - Unit to execute the srb on.

    Irp - Irp to execute.

Return Value:

    STATUS_PENDING - On success.

    Other NTSTATUS code - On failure.

    NB: STATUS_SUCCESS should NEVER be returned from this function.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}


NTSTATUS
RaidUnitAllocateIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
{
    //
    // In the current driver architecture, the allocation of the QueueTag
    // can never fail. So don't bother to check for failure.
    //
    
    IoResources->QueueTag = RaAllocateTag (&Unit->TagList);
    ASSERT (IoResources->QueueTag != -1);

    //
    // When the queue tag is allocated, the srb extension slot is reserved.
    // Therefore, the srb extension allocation also cannot fail.
    //
    
    IoResources->SrbExtension =
            RaidAllocateSrbExtension (&Unit->SrbExtensionPool,
                                      IoResources->QueueTag);
    ASSERT (IoResources->SrbExtension != NULL);


    //
    // PERF NOTE: RaidAllocateXrb uses a lookaside list for allocations
    // which locks the bus. We could remove the bus lock by using
    // a fixed pool instead of a lookaside list and not locking at all.
    //

    IoResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                        Unit->DeviceObject);
    ASSERT (IoResources->Xrb != NULL);

    return STATUS_SUCCESS;
}

VOID
RaidUnitFreeIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PRAID_IO_RESOURCES IoResources
    )
{
    RaidFreeSrbExtension (&Unit->SrbExtensionPool, IoResources->QueueTag);

    //
    // Free the queue tag.
    //

    RaFreeTag (&Unit->TagList, IoResources->QueueTag);

    //
    // Free the XRB.
    //
    
    RaidFreeXrb (IoResources->Xrb);

    DbgFillMemory (IoResources, sizeof (RAID_IO_RESOURCES), DBG_DEALLOCATED_FILL);
}



NTSTATUS
RaidUnitClaimIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp,
    IN PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    This routine will allocate any resources necessary to accomplish the
    IO for this specific IRP. At this point, these resources are generally
    SRB resources: queue tag, srb extension, Xrb.

    After an IRP is claimed, it must be released using RaidUnitReleaseIrp.

    This function is only necessary for IRP_MJ_SCSI IRPs.
    
Arguments:

    Unit - Specifies a unit that this SRB should be claimed by.

    Irp - Specifies an IRP to claim.

    IoResources - Preallocated resources to use for this IO.

Return Value:

    NTSTATUS code.

Note:

    This function is generally called from the unit's StartIo routine.

--*/
{
    NTSTATUS Status;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PSCSI_REQUEST_BLOCK Srb;
    RAID_IO_RESOURCES IoResourcesBuffer;
        

    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);

    //
    // Each irp maintains a reference on the remove lock while being
    // processed. If this lock cannot be acquired, it means we are
    // in the process of being removed, so return status to fail
    // the irp.
    //
    
    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If we weren't given any resources, allocate necessary resources.
    // Otherwise, we'll reuse the resources from the previous IRP.
    //
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        Status = RaidUnitAllocateIoResources (Unit, IoResources);
        ASSERT (Status == STATUS_SUCCESS);
    }
    
    //
    // Fill in the SCSI target information.
    //

    Srb->TargetId = Unit->Address.TargetId;
    Srb->PathId = Unit->Address.PathId;
    Srb->Lun = Unit->Address.Lun;
    Srb->QueueTag = (UCHAR)IoResources->QueueTag;

    //
    // Fill in Xrb fields.
    //

    Xrb = IoResources->Xrb;
    Xrb->Irp = Irp;
    Xrb->Srb = Srb;
    Xrb->Unit = Unit;
    Xrb->Mdl = Irp->MdlAddress;

    //
    // Save SRB fields that we may modify.
    //
    
    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Xrb->SrbData.DataBuffer = Srb->DataBuffer;

    //
    // Link the Srb to the Xrb and backlink the Xrb to the Srb.
    //
    
    Srb->OriginalRequest = Xrb;

    //
    // Set the Srb extension.
    //

    Srb->SrbExtension = IoResources->SrbExtension;

    //
    // Perform any buffer mapping that may be necessary.
    //
    
    RaidAdapterMapBuffers (Unit->Adapter, Irp);
    
    //
    // Add the IRP to the unit pending list.
    //
    
    RaUnitAddToPendingList (Unit, Irp);
    
    return STATUS_SUCCESS;
}


VOID
RaidUnitReleaseIrp(
    IN PIRP Irp,
    OUT PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    Undo any modifications to the IRP and SRB that were done by
    RaidUnitClaimIrp.

    This function is generally called from the Dpc routine before the
    IRP has been completed.

Arguments:

    Irp - Irp to release.

    IoResources - Buffer to return resources.

Return Value:

    None.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    BOOLEAN FreeResources;
    RAID_IO_RESOURCES IoResourcesBuffer;

    Srb = RaidSrbFromIrp (Irp);
    Xrb = RaidGetAssociatedXrb (Srb);
    Unit = Xrb->Unit;
    ASSERT_UNIT (Unit);

    //
    // First, remove the irp from the pending list.
    //
    
    RaUnitRemoveFromPendingList (Unit, Irp);

    //
    // Undo any modifications we made to the srb.
    //

    Srb->OriginalRequest = Xrb->SrbData.OriginalRequest;
    Srb->DataBuffer = Xrb->SrbData.DataBuffer;

    if (IoResources) {
        FreeResources = FALSE;
    } else {
        FreeResources = TRUE;
        IoResources = &IoResourcesBuffer;
    }

    RaidPrepareXrbForReuse (Xrb);
    IoResources->QueueTag = Srb->QueueTag;
    IoResources->SrbExtension = Srb->SrbExtension;
    IoResources->Xrb = Xrb;

    //
    // Fixup the SrbExtension field so upper layers don't access
    // memory they are not permitted to access.
    //
    
    Srb->SrbExtension = NULL;

    if (FreeResources) {
        RaidUnitFreeIoResources (Unit, IoResources);
    }

    //
    // The request maintains a reference to the remove lock while being
    // processed. Release it here.
    //
    
    IoReleaseRemoveLock (&Unit->RemoveLock, Irp);

}



VOID
RaidUnitCompleteRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine is called by the adapter's DPC routine after an
    asynchronous IO has completed. It needs to complete the underlying
    IRP and deallocate any resources associated with the IRP.

Arguments:

    Xrb - Xrb to be completed.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL only.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);


    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_SUCCESS) {

        //
        // The IO was successful. Mark the IRP as successful, release
        // resources associated with the IRP and complete the request.
        //
        
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = Srb->DataTransferLength;

        //
        // Release any resources owned by this IRP/SRB, and fixup
        // any modifications we made to the SRB.
        //

        if (RaidChainedIo) {
            RaidUnitReleaseIrp (Irp, &IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }

        //
        // Complete the request
        //

        DebugTrace (("Unit %p, Irp %p, completing = %08x\n",
                     Unit,
                     Irp,
                     Irp->IoStatus.Status));

        
        RaidCompleteRequest (Irp, IO_DISK_INCREMENT, Irp->IoStatus.Status);

        //
        // Start the next io packet.
        //

        if (RaidChainedIo) {

#if 0
            {
                PSTOR_IO_GATEWAY Gateway;

                Gateway = &Unit->Adapter->Gateway;
                
                if (Gateway->BusyCount > 0 &&
                    Gateway->Outstanding - 1 < Gateway->LowWaterMark &&
                    Unit->IoQueue.DeviceQueue.DeviceRequests > 0) {

                    REVIEW();
                }
            }
#endif
            
            Started = RaidStartNextIoPacket (&Unit->IoQueue,
                                             FALSE,
                                             &IoResources,
                                             &RestartQueues);
            if (!Started) {
                RaidUnitFreeIoResources (Unit, &IoResources);
            }
        } else {
            RaidStartNextIoPacket (&Unit->IoQueue,
                                   FALSE,
                                   NULL,
                                   &RestartQueues);
        }

        if (RestartQueues) {
            RaidAdapterRestartQueues (Unit->Adapter);
        }
        
    } else {

        //
        // Error: Leave all the detail of handling the error, including
        // whether the IRP should be released and completed or not, to
        // the error handling routine.
        //
           
        RaUnitAsyncError (Unit, Xrb);
    }

}


VOID
RaUnitStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Start the next irp on the specified logical unit.

Arguments:

    DeviceObject - DeviceObject associated with the logical unit
            to start the next irp on.

    Irp - Irp to execute.

    Context - Context for this call.

Return Value:

    None. All errors will be handled asynchronously in the DPC routine.

Environment:

    Called from DISPATCH_LEVEL only.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;

    //
    // StartIo should only be called from DISPATCH_LEVEL.
    //
    
    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);

    //
    // Get the logical unit extension.
    //
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);

    //
    // Allocate any resources necessary, and modify the associated SRB
    // to be for this LU.

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {

        REVIEW ();

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        DebugTrace (("Unit %p, Irp %p, completing %08x\n",
                     Irp->IoStatus.Status));
        RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }
        
        
    ASSERT (NT_SUCCESS (Status));

    //
    // Get associated Xrb.
    //
    
    Xrb = RaidXrbFromIrp (Irp);

    //
    // Set a completion routine for the Xrb.
    //

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteRequest);
    
    //
    // Issue the Execute request to the adapter.
    //
    
    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

    //
    // Busy errors are handled synchronously. All other IO related errors
    // are handled asynchronously (in the Dpc routine).
    //
    
    if (!NT_SUCCESS (Status)) {

        REVIEW();
        
        //
        // This means we weren't even able to submit the request to the
        // miniport. There's nothing to do but fail the request.
        //

        RaidUnitReleaseIrp (Irp, NULL);
        Irp->IoStatus.Information = 0;
        RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }
}

NTSTATUS
RaUnitClaimDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    If the device is unclaimed, claim it, otherwise return STATUS_DEVICE_BUSY
    as an error.

Arguments:

    Unit - The unit to claim.

    Irp - The irp representing the claim device irp.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;
    PSCSI_REQUEST_BLOCK Srb;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    Srb = RaidSrbFromIrp (Irp);
    if (!Unit->Flags.DeviceClaimed) {
        Unit->Flags.DeviceClaimed = TRUE;
        Srb->DataBuffer = Unit->DeviceObject;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Status = STATUS_SUCCESS;
    } else {
        Srb->DataBuffer = NULL;
        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = STATUS_DEVICE_BUSY;
        Status = STATUS_DEVICE_BUSY;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitReleaseDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Release the claim on this unit.

Arguments:

    Unit - The unit which must have been claimed.

    Irp - The release device irp.
    
Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    Srb = RaidSrbFromIrp (Irp);
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // The class driver is not allowed to release the device multiple
    // times.
    //
    
    ASSERT (Unit->Flags.DeviceClaimed);
    Unit->Flags.DeviceClaimed = FALSE;

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Status = STATUS_SUCCESS;

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitIoControlSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle an ioctl SRB sent to the miniport.

Arguments:

    Unit - Logical unit the ioctl SRB is for.

    Irp - IRP representing an SRB ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitReleaseQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    RaidResumeUnitQueue (Unit);
    Irp->IoStatus.Information = 0;

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP FlushIrp
    )

/*++

Routine Description:

    Flush the pending queue, canceling all requests.

Arguments:

    Unit - Supplies pointer to unit to flush.

    FlushIrp - Supplies the IRP representing the flush queue request.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/

{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    

    ASSERT (RaidIsUnitQueueFrozen (Unit));

    //
    // Flush all entries.
    //
    
    for (Irp = RaidRemoveIoQueue (&Unit->IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (&Unit->IoQueue)) {

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;

        Irp->IoStatus.Information = 0;
        RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_UNSUCCESSFUL);
    }

    RaidResumeUnitQueue (Unit);
    
    FlushIrp->IoStatus.Information = 0;
    return RaidCompleteRequest (FlushIrp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitReceiveEventSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitAttachDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}


NTSTATUS
RaUnitShutdownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    return RaUnitFlushSrb (Unit, Irp);
}

NTSTATUS
RaUnitFlushSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    BOOLEAN ByPassFrozen;


    if (!Unit->Adapter->Miniport.PortConfiguration.CachesData) {

        Status = RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);

    } else {

        Srb = RaidSrbFromIrp (Irp);
        IoMarkIrpPending (Irp);
        RaidSrbMarkPending (RaidSrbFromIrp (Irp));
        ByPassFrozen = TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE);
        RaidStartIoPacket (&Unit->IoQueue,
                           Irp,
                           ByPassFrozen,
                           NULL);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
RaUnitAbortCommandSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitReleaseRecoverySrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitResetBusSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitResetDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitTerminateIoSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitRemoveDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitWmiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitLockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    //
    // Lock the device queue, queuing all pending IRPs for processing
    // later. This is used in Power Management.
    //

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnlockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    //
    // Unlock the unit device queue, allowing all queued IRPs to continue
    // processing. This is used in Power Management.
    //

    RaidUnlockUnitQueue (Unit);

    //
    // BUGBUG: Do we need to explicitly restart the queue? Probably.
    // See the QueueChanged loop in RaidStartNextIoPacket for an
    // example on how to do this. If we don't do this, we will not
    // send the next request down until the next IO operation is
    // started.
    //

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnknownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    PAGED_CODE ();

    //
    // Fail requests we do not handle.
    //

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
    Status = STATUS_NOT_SUPPORTED;
    Srb->InternalStatus = Status;

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for the unit's power irps.

Arguments:

    Unit - Unit to handle the power irp.

    Irp - Irp to be handled.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
    Minor = RaidMinorFunctionFromIrp (Irp);
    
    switch (Minor) {

        case IRP_MN_QUERY_POWER:
            Status = RaidUnitQueryPowerIrp (Unit, Irp);
            break;

        case IRP_MN_SET_POWER:
            Status = RaidUnitSetPowerIrp (Unit, Irp);
            break;

        default:
            PoStartNextPowerIrp (Irp);
            Status = RaidCompleteRequest (Irp,
                                          IO_NO_INCREMENT,
                                          STATUS_NOT_SUPPORTED);
    }

    return Status;
}

NTSTATUS
RaidUnitQueryPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IRP_MN_QUERY_POWER irp for the unit.
    
Arguments:

    Unit - Logical unit that must handle the irp.

    Irp - Query power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    //
    // Succeed all queries.
    //

    //
    // NB: Do we need to set the IoStatus.Status for the irp to success
    // before calling PoStartNextPowerIrp?
    //

    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaidUnitSetPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IRP_MN_SET_POWER irps for the logical unit.

Arguments:

    Unit - Logical unit to handle this irp.

    Irp - Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    POWER_STATE_TYPE PowerType;
    POWER_STATE PowerState;
    
    //
    // Ignore shutdown irps.
    //

    PowerState = RaidPowerStateFromIrp (Irp);
    
    if (PowerState.SystemState >= PowerSystemShutdown) {

        PoStartNextPowerIrp (Irp);
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
    }
    
    PowerType = RaidPowerTypeFromIrp (Irp);

    switch (PowerType) {

        case SystemPowerState:
            Status = RaidUnitSetSystemPowerIrp (Unit, Irp);
            break;

        case DevicePowerState:
            Status = RaidUnitSetDevicePowerIrp (Unit, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
RaidUnitSetSystemPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the IRP_MJ_POWER, IRP_MN_SET_POWER irp of type SystemPowerState.

Arguments:

    Unit - Logical unit to handle the irp.

    Irp - Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    SYSTEM_POWER_STATE CurrentState;
    SYSTEM_POWER_STATE RequestedState;
    POWER_STATE PowerState;
    BOOLEAN RequestHandled;

    ASSERT_UNIT (Unit);
    ASSERT (RaidPowerTypeFromIrp (Irp) == SystemPowerState);
    
    DebugTrace (("Unit %p, Irp %p, SetSystemPower\n",
                  Unit, Irp));
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Unit->Power.SystemState;
    RequestedState = IrpStack->Parameters.Power.State.SystemState;

    //
    // If the request has been handled then we do not complete it. Otherwise,
    // it is our responsability to complete it.
    //
    
    RequestHandled = FALSE;
    Unit->Power.SystemState = RequestedState;

    if (CurrentState == PowerSystemWorking &&
        RequestedState != PowerSystemWorking) {

        //
        // Transitioning from working to a sleeping state. Request
        // a device D3 state.
        //

        DebugTrace (("Unit %p, Irp %p, SetSystemPower defering to device power\n",
                      Unit, Irp));

        IoMarkIrpPending (Irp);
        
        PowerState.SystemState = PowerSystemUnspecified;
        PowerState.DeviceState = PowerDeviceD3;

        Status = PoRequestPowerIrp (Unit->DeviceObject,
                                    IRP_MN_SET_POWER,
                                    PowerState,
                                    RaidpUnitEnterD3Completion,
                                    Irp,
                                    NULL);

        //
        // The completion function will complete the system power
        // irp.
        //
        
        RequestHandled = TRUE;

    } else if (CurrentState != PowerSystemWorking &&
               RequestedState == PowerSystemWorking) {

        //
        // Transitioning from a spleeping state to a working state.
        //

        NYI ();
        Status = STATUS_UNSUCCESSFUL;

    } else {

        REVIEW();
        Status = STATUS_UNSUCCESSFUL;
    }
    

    //
    // Complete the request if it was not completed by a completion function.
    //

    if (!RequestHandled) {
        //
        // NB: Do we need to set the IRP status before calling PoStartNextPowerIrp?
        //
        PoStartNextPowerIrp (Irp);
        Status = RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    return Status;
}


VOID
RaidpUnitEnterD3Completion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemPowerIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This completion function is invoked when the unit had entered the
    PowerDeviceD3 power state.

Arguments:

    DeviceObject - Device object representing the unit object.

    MinorFunction - Minor function this irp is for; must be IRP_MN_SET_POWER.

    PowerState - Power state we are entering; must be PowerDeviceD3.

    SystemPowerIrp - Pointer to the system power irp that generated the
            device power irp we are completing.

    IoStatus - IoStatus for the device irp.

Return Value:

    None.

--*/
{

    DebugTrace (("DO %p, Irp %p, Completing Irp in D3Completion routine\n",
                  DeviceObject, SystemPowerIrp));
    REVIEW();

    //
    // BUGBUG: Is it possible for the IoStatus to not be STATUS_SUCCESS? How
    // do we approach failure processing in that case?
    //

    ASSERT (NT_SUCCESS (IoStatus->Status));

    //
    // NB: Do we need to set the IRP status before calling PoStartNextPowerIrp?
    //
    PoStartNextPowerIrp (SystemPowerIrp);
    RaidCompleteRequest (SystemPowerIrp, IO_NO_INCREMENT, IoStatus->Status);
    
}


NTSTATUS
RaidUnitSetDevicePowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the set power irp, for a device state on the unit.

Arguments:

    Unit - Unit that this irp is for.

    Irp - Set power irp to handle.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_POWER_STATE CurrentState;
    DEVICE_POWER_STATE RequestedState;  

    ASSERT_UNIT (Unit);
    ASSERT (RaidPowerTypeFromIrp (Irp) == DevicePowerState);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Unit->Power.DeviceState;
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;
    
    Unit->Power.DeviceState = RequestedState;

    //
    // NB: Do we need to set the IRP IO status before calling
    // PoStartNextPowerIrp?
    //
    
    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);

    return Status;
}
    

NTSTATUS
RaUnitDeviceControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for device control (ioctl) irps.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Device control irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Ioctl;

    PAGED_CODE ();

    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }
    
    Ioctl = RaidIoctlFromIrp (Irp);
    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x\n",
                  Unit,
                  Irp,
                  Ioctl));
                 
    switch (Ioctl) {

        //
        // SCSI Ioctls
        //
        
        case IOCTL_SCSI_PASS_THROUGH:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_MINIPORT:
            Status = RaUnitScsiMiniportIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_INQUIRY_DATA:
            Status = RaUnitScsiGetInquiryDataIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_CAPABILITIES:
            Status = RaUnitScsiGetCapabilitesIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            Status = RaUnitScsiPassThroughDirectIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_ADDRESS:
            Status = RaUnitScsiGetAddressIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_RESCAN_BUS:
            Status = RaUnitScsiRescanBusIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_DUMP_POINTERS:
            Status = RaUnitScsiGetDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_FREE_DUMP_POINTERS:
            Status = RaUnitScsiFreeDumpPointersIoctl (Unit, Irp);
            break;

        //
        // Storage Ioctls
        //
        
        case IOCTL_STORAGE_RESET_BUS:
            Status = RaUnitStorageResetBusIoctl (Unit, Irp);
            break;
            
        case IOCTL_STORAGE_QUERY_PROPERTY:
            Status = RaUnitStorageQueryPropertyIoctl (Unit, Irp);
            break;

        default:
            Status = RaUnitUnknownIoctl (Unit, Irp);
    }

    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x, ret = %08x\n", 
                  Unit,
                  Irp,
                  Ioctl,
                  Status));

    IoReleaseRemoveLock (&Unit->RemoveLock, Irp);

    return Status;
}


//
// IRP_MJ_DEVICE_CONTROL IRP handlers.
//

NTSTATUS
RaUnitScsiPassThroughIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiMiniportIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetInquiryDataIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetCapabilitesIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiPassThroughDirectIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetAddressIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_ADDRESS ScsiAddress;
    ULONG BufferLength;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    ScsiAddress = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (BufferLength < sizeof (SCSI_ADDRESS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        ScsiAddress->Length = sizeof (SCSI_ADDRESS);
        ScsiAddress->PortNumber = -1; // BUGBUG: S/B Unit->PortNumber;
        ScsiAddress->PathId = Unit->Address.PathId;
        ScsiAddress->TargetId = Unit->Address.TargetId;
        ScsiAddress->Lun = Unit->Address.Lun;

        Irp->IoStatus.Information = sizeof (SCSI_ADDRESS);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitScsiRescanBusIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Create a DUMP_POINTERS structure describing any resources necessary
    for crashdump and hiber.

Arguments:

    Unit - Unit the ioctl is for.

    Irp - Get dump pointers ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PPORT_CONFIGURATION_INFORMATION Configuration;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;

    PAGED_CODE();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    
    //
    // Only kernel mode is allowed to get the dump pointers.
    //

    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = sizeof (DUMP_POINTERS);
        goto done;
    }

    DumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));

    //
    // Diskdump requires a complete copy of the configuration information.
    // This must be nonpaged. Also, this memory is never freed, since in
    // practice we never call FreeDumpStack.
    //
    
    Configuration = RaidAllocatePool (NonPagedPool,
                                      sizeof (PORT_CONFIGURATION_INFORMATION),
                                      CRASHDUMP_TAG,
                                      Unit->DeviceObject);

    if (Configuration == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    //
    // Initialize DMA information.
    //
    
    DumpPointers->AdapterObject = (PVOID)Dma->DmaAdapter;

    //
    // This is head of a list of MAPPED_ADDRESS structures that
    // diskdump uses to map io addresses.
    //
    
    DumpPointers->MappedRegisterBase = &Adapter->MappedAddressList;

    //
    // Copy the private port configuration.
    //

    RtlCopyMemory (Configuration,
                   &Adapter->Miniport.PortConfiguration,
                   sizeof (PORT_CONFIGURATION_INFORMATION));
    
    Configuration->SlotNumber = Adapter->SlotNumber;
    Configuration->SystemIoBusNumber = Adapter->BusNumber;
    DumpPointers->DumpData = Configuration;

    //
    // We do not fill in values for the CommonBufferVa, CommonBufferPa
    // and CommonBufferSize. Instead, we leave it to the crashdump
    // mechanism to do this for us.
    //
    
    DumpPointers->AllocateCommonBuffers = TRUE;
    DumpPointers->UseDiskDump = TRUE;
    DumpPointers->DeviceObject = Adapter->DeviceObject;

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof (DUMP_POINTERS);

done:

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitScsiFreeDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Free any resources associated with the crashdump, hiber DUMP_POINTERS
    structure previously allocated by the get dump pointers ioctl.

Arguments:

    Unit - Unit this ioctl is for.

    Irp - Free dump pointers irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;

    PAGED_CODE ();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Only kernel mode is allowed to get or free the dump pointers.
    //
    
    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    DumpPointers= (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

    //
    // Do some basic validation that we were actually passed in
    // a valid DUMP_POINTERS structure.
    //
    
    ASSERT (DumpPointers->AdapterObject == (PVOID)Dma->DmaAdapter);
    ASSERT (DumpPointers->MappedRegisterBase == Dma->MapRegisterBase);
    ASSERT (DumpPointers->CommonBufferSize == 0);
    ASSERT (DumpPointers->CommonBufferVa == NULL);

    RaidFreePool (DumpPointers->DumpData, CRASHDUMP_TAG);
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));

done:

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitStorageResetBusIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitStorageQueryPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;
    BOOLEAN CompleteRequest;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    

    //
    // We do not support the mask property or any others above mask.
    //
    
    if (Query->QueryType >= PropertyMaskQuery) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,
                                    IO_NO_INCREMENT,
                                    STATUS_INVALID_PARAMETER_1);
    }

    CompleteRequest = FALSE;
    
    switch (Query->PropertyId) {

        case StorageDeviceProperty:
            if (Query->QueryType == PropertyStandardQuery) {
                Status = RaGetUnitStorageDeviceProperty (Unit,
                                                         Buffer,
                                                         &BufferSize);
                Irp->IoStatus.Information = BufferSize;
                CompleteRequest = TRUE;
            } else {
                ASSERT (Query->QueryType == PropertyExistsQuery);
                Status = STATUS_SUCCESS;
                CompleteRequest = TRUE;
            }
            break;              


#if 0
        //
        // NYI
        //
        
        case StorageDeviceIdProperty:
            if (Query->QueryType == PropertyExistsQuery) {
                Status = STATUS_SUCCESS;
            } else {
                ASSERT (Query->QueryType == ...);
                Status = RiGetUnitStorageDeviceIdProperty (Unit, Buffer, &BufferSize);
            }
            break;
#endif

        default:

            //
            // Setting CompleteRequest to FALSE causes the IRP to be forwarded
            // to the next lower driver.x
            //

            CompleteRequest = FALSE;
    }


    //
    // If we need to complete this request, complete it now. Otherwise, forward
    // it to the next lower level driver.
    //
    
    if (CompleteRequest) {
        Status = RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        Status = IoCallDriver (Unit->Adapter->DeviceObject, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitUnknownIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,
                                IO_NO_INCREMENT,
                                STATUS_INVALID_DEVICE_REQUEST);
}


NTSTATUS
RaidUnitGetDeviceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* DeviceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR DeviceId;
    PSCSI_DEVICE_TYPE DeviceType;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    CHAR Revision [SCSI_REVISION_ID_LENGTH + 1];
    ULONG i;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    DeviceId = RaidAllocatePool (PagedPool,
                                 DEVICE_ID_LENGTH * sizeof (WCHAR),
                                 ID_TAG,
                                 Unit->DeviceObject);

    if (DeviceId != NULL) {

        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        StorGetIdentityVendorId (&Unit->Identity,
                                 VendorId,
                                 sizeof (VendorId),
                                 TRUE);

        StorGetIdentityProductId (&Unit->Identity,
                                  ProductId,
                                  sizeof (ProductId),
                                  TRUE);

        StorGetIdentityRevision (&Unit->Identity,
                                 Revision,
                                 sizeof (Revision),
                                 TRUE);

        swprintf (DeviceId,
             L"SCSI\\%hs&Ven_%hs&Prod_%hs&Rev_%hs",
             DeviceType->Name,
             VendorId,
             ProductId,
             Revision);

        RaFixupIds (DeviceId, FALSE);

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *DeviceIdBuffer = DeviceId;

    return Status;
}


NTSTATUS
RaidUnitGetInstanceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* InstanceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR InstanceId;
    ULONG Count;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    InstanceId = RaidAllocatePool (PagedPool,
                                   INSTANCE_ID_LENGTH * sizeof (WCHAR),
                                   ID_TAG,
                                   Unit->DeviceObject);

    if (InstanceId != NULL) {

        Count = swprintf (InstanceId,
                          L"%x%x%x",
                          Unit->Address.PathId,
                          Unit->Address.TargetId,
                          Unit->Address.Lun
                          );

        //
        // Sanity check that we didn't overflow our buffer.
        //
        
        ASSERT ((Count + 1) < INSTANCE_ID_LENGTH);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *InstanceIdBuffer = InstanceId;

    return Status;
}


NTSTATUS
RaidUnitGetHardwareIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* HardwareIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR HardwareIds;
    ULONG Count;
    PWCHAR Buffer;
    PSCSI_DEVICE_TYPE DeviceType;
    PINQUIRYDATA InquiryData;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    HardwareIds = RaidAllocatePool (PagedPool,
                                    HARDWARE_ID_LENGTH * sizeof (WCHAR),
                                    ID_TAG,
                                    Unit->DeviceObject);
                                         

    if (HardwareIds != NULL) {

        Buffer = HardwareIds;
        InquiryData = StorGetIdentityInquiryData (&Unit->Identity);
        DeviceType = RaGetDeviceType (InquiryData->DeviceType);

        //
        // bus + device + vendor + product + revision
        //
        
        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs%4.4hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel);

        Buffer += (Count + 1);

        //
        // bus + device + vendor + product
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId);

        Buffer += (Count + 1);

        //
        // bus + device + vendor
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs",
                          DeviceType->Name,
                          InquiryData->VendorId);

        Buffer += (Count + 1);

        //
        // bus + vendor + product + revision[0]
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%8.8hs%16.16hs%hc___",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);

        Buffer += (Count + 1);

        //
        // vendor + product + revision[0] (win9x)
        //

        Count = swprintf (Buffer,
                          L"%8.8hs%16.16hs%hc___",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);
                          
        Buffer += (Count + 1);
        
        //
        // generic device
        //

        Count = swprintf (Buffer,
                          L"%hs",
                          DeviceType->GenericName);

        Buffer += (Count + 1);

        *Buffer++ = UNICODE_NULL;
        RaFixupIds (HardwareIds, TRUE);
        Status = STATUS_SUCCESS;

        ASSERT ((LONG)(Buffer - HardwareIds) < HARDWARE_ID_LENGTH);

    } else {

        Status = STATUS_NO_MEMORY;
    }

    *HardwareIdsBuffer = HardwareIds;

    return Status;
}


NTSTATUS
RaidUnitGetCompatibleIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* CompatibleIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR CompatibleIds;
    PWCHAR Buffer;
    ULONG Count;
    PSCSI_DEVICE_TYPE DeviceType;

    PAGED_CODE ();

    CompatibleIds = RaidAllocatePool (PagedPool,
                                      COMPATIBLE_ID_LENGTH * sizeof (WCHAR),
                                      ID_TAG,
                                      Unit->DeviceObject);

    if (CompatibleIds != NULL) {

        Buffer = CompatibleIds;
        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        //
        // First is, SCSI\<DEVICE>
        //
        
        Count = swprintf (Buffer, L"SCSI\\%hs", DeviceType->Name);
        Buffer += (Count + 1);

        //
        // Second is SCSI\RAW
        //
        
        Count = swprintf (Buffer, L"SCSI\\RAW");
        Buffer += (Count + 1);

        //
        // Append the final UNICODE_NULL because this is a multi-sz string.
        //
        
        *Buffer++ = UNICODE_NULL;

        //
        // Remove invalid characters.
        //
        
        RaFixupIds (CompatibleIds, TRUE);

        //
        // Sanity check that we didn't overflow our allocated buffer.
        //
        
        ASSERT ((ULONG)(Buffer - CompatibleIds) < COMPATIBLE_ID_LENGTH);

        Status = STATUS_SUCCESS;

    } else {
        Status = STATUS_NO_MEMORY;
    }

    *CompatibleIdsBuffer = CompatibleIds;

    return Status;
}


NTSTATUS
RaGetUnitStorageDeviceProperty(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    Create a device descriptor based on the information in the device
    extension. Copy as much data as possible into the Decescriptor and
    update the DescriptorLength to indicate the number of bytes copied

Arguments:

    Unit - Supplies Unit we are querying property for.

    DescriptorBuffer - Pointer to a buffer where the data for this
            property will be copied. The buffer size is determined by the
            input value of the BufferLength parameter.

    BufferLength - On input, supplies the length of the buffer, on output
            return the number of bytes copied.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_DRIVER_EXTENSION Driver;
    PINQUIRYDATA InquiryData;
    RAID_DEVICE_DESCRIPTOR Descriptor;
    ULONG Length;


    PAGED_CODE();
    ASSERT_UNIT (Unit);
    ASSERT (DescriptorBuffer != NULL);


    InquiryData = StorGetIdentityInquiryData (&Unit->Identity);

    //
    // Zero the temporary descriptor buffer out. Note that since
    // we don't explicitly zero out or NULL-terminated strings
    // below, the zeroing is necessary.
    //

    RtlZeroMemory (&Descriptor, sizeof (Descriptor));

    //
    // Length is the number of bytes we will copy into the descriptor
    // buffer. The Size field in the storage descriptor is the size
    // of the descriptor we want to copy -- not the number of bytes
    // copied. This is important.
    //
    
    Length = min (((ULONG)sizeof (Descriptor)), *BufferLength);

    Descriptor.Storage.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    Descriptor.Storage.Size = sizeof (Descriptor);
    Descriptor.Storage.DeviceType = InquiryData->DeviceType;
    Descriptor.Storage.DeviceTypeModifier = InquiryData->DeviceTypeModifier;
    Descriptor.Storage.RemovableMedia = InquiryData->RemovableMedia;
    Descriptor.Storage.CommandQueueing = InquiryData->CommandQueue; 
    Descriptor.Storage.BusType = Unit->Adapter->Driver->BusType;

    //
    // Copy the VendorId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.VendorId,
                   InquiryData->VendorId,
                   sizeof (Descriptor.VendorId) - 1);

    Descriptor.Storage.VendorIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, VendorId);

    //
    // Copy the ProductId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.ProductId,
                   InquiryData->ProductId,
                   sizeof (Descriptor.ProductId) - 1);

    Descriptor.Storage.ProductIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductId);

    //
    // Copy the RevisionLevel and initialize it's offset.
    //

    RtlCopyMemory (Descriptor.ProductRevision,
                   InquiryData->ProductRevisionLevel,
                   sizeof (Descriptor.ProductRevision) - 1);

    Descriptor.Storage.ProductRevisionOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductRevision);

    //
    // BUGBUG: We don't provide a serial number yet.
    //

    Descriptor.Storage.SerialNumberOffset = 0;

    //
    // Copy the temporary descriptor back to the buffer, and update the
    // length parameter.
    //
    
    RtlCopyMemory (DescriptorBuffer, &Descriptor, Length);
    *BufferLength = Length;

    return STATUS_SUCCESS;
}



VOID
RaidFreezeUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // We should never double freeze the queue.
    //
    
    ASSERT (!Unit->Flags.QueueFrozen);
    Unit->Flags.QueueFrozen = TRUE;

    //
    // The lower-level IoQueue can be frozen either through an error or
    // because of a lock queue request. Since it doesn't support double
    // freezing, only request it to be actually frozen if it isn't locked.
    //
    
    if (!Unit->Flags.QueueLocked) {
        RaidFreezeIoQueue (&Unit->IoQueue);
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


VOID
RaidResumeUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    ASSERT (Unit->Flags.QueueFrozen);
    Unit->Flags.QueueFrozen = FALSE;

    if (!Unit->Flags.QueueLocked) {
        RaidResumeIoQueue (&Unit->IoQueue);
    }   
    
    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


BOOLEAN
RaidIsUnitQueueFrozen(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    BOOLEAN Frozen;
    KLOCK_QUEUE_HANDLE LockHandle;

    PAGED_CODE ();
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    Frozen = Unit->Flags.QueueFrozen;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return Frozen;
}

VOID
RaidLockUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // We should never double freeze the queue.
    //
    
    ASSERT (!Unit->Flags.QueueLocked);
    Unit->Flags.QueueLocked = TRUE;

    //
    // The lower-level IoQueue can be frozen either through an error or
    // because of a lock queue request. Since it doesn't support double
    // freezing, only request it to be actually frozen if it isn't locked.
    //
    
    if (!Unit->Flags.QueueFrozen) {
        RaidFreezeIoQueue (&Unit->IoQueue);
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


VOID
RaidUnlockUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    ASSERT (Unit->Flags.QueueLocked);
    Unit->Flags.QueueLocked = FALSE;

    if (!Unit->Flags.QueueFrozen) {
        RaidResumeIoQueue (&Unit->IoQueue);
    }   
    
    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


BOOLEAN
RaidIsUnitQueueLocked(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    BOOLEAN Locked;
    KLOCK_QUEUE_HANDLE LockHandle;

    PAGED_CODE ();
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    Locked = Unit->Flags.QueueLocked;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return Locked;
}
    

BOOLEAN
RaidIsUnitQueueStopped(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    BOOLEAN Stopped;
    KLOCK_QUEUE_HANDLE LockHandle;

    PAGED_CODE ();
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    Stopped = (Unit->Flags.QueueLocked || Unit->Flags.QueueFrozen);
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return Stopped;
}

VOID
RaidUnitProcessBusyRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Process a request that has come to us as busy.

Arguments:

    Unit - Supplies the logical unit that this request was submitted to.

    Xrb - Supplies the request.

Return Value:

    None.

--*/
{
    BOOLEAN Inserted;
    PKDEVICE_QUEUE_ENTRY Entry;
    PEXTENDED_DEVICE_QUEUE ExQueue;
    PSCSI_REQUEST_BLOCK Srb;
    PIRP Irp;
    PRAID_ADAPTER_EXTENSION Adapter;
    KLOCK_QUEUE_HANDLE LockHandle;


    Srb = Xrb->Srb;
    Irp = Xrb->Irp;

    //
    // SRB_STATUS_BUSY signals an adapter is busy.
    //

    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY) {

        LOGICAL RestartQueues;

        RaidUnitReleaseIrp (Irp, NULL);

        //
        // After releasing the Irp, we no longer have a Xrb to play with.
        //
        
        Xrb = NULL;
        
        Adapter = Unit->Adapter;

        //
        // Mark the adapter queue as busy.
        //

        //
        // REVIEW: Check this for race conditions. In particular,
        // can it happen that we mark the queue as busy, but by the
        // time we queue the request to the queue, it's not busy?
        // This could happen, for example, if the dpc routine is
        // running on a different processor at the same time
        // as we're submitting items. Note that there's
        // also a race condition between when we're told by the
        // adapter that we're busy and when we mark it as busy.
        // In that time period, we could have completed enough
        // requests to make us not busy.
        //

#if 0
        StorBusyIoGateway (&Adapter->Gateway, TRUE);
#endif
#if 0

        //
        // Remove it from the gateway queue
        //

        RestartQueues = StorRemoveIoGatewayItem (&Adapter->Gateway);

        if (RestartQueues) {
            REVIEW();
            StorBusyIoGateway (&Adapter->Gateway);
        }



        //
        // Return the IRP to the head of the queue.
        //
        
        RaidReturnExDeviceQueue (&Unit->IoQueue.DeviceQueue,
                                 &Irp->Tail.Overlay.DeviceQueueEntry);
#endif

        //
        // Remove the item from the various queues.
        //
        // NB: Fix this.
        //
        
        InterlockedDecrement (&Adapter->Gateway.Outstanding);
        InterlockedDecrement (&Unit->IoQueue.DeviceQueue.OutstandingRequests);

        //
        // Then resubmit it.
        //

        RaidUnitSubmitRequest (Unit, Irp);
                            
    } else {

        ASSERT (Srb->ScsiStatus == SCSISTAT_BUSY ||
                Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);

        //
        // Logical unit busy has not been dealt with yet.
        //

        NYI ();
    }
}


LOGICAL
INLINE
IsBusy(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);
}



VOID
RaUnitAsyncError(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine handles errors asynchronous errors.

Arguments:

    Unit - Supplies Logical Unit that Xrb is for.

    Xrb - Supplies Xrb that caused an error.

Return Value:

    None.

--*/
{

    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    BOOLEAN RestartQueues;

    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    RestartQueues = FALSE;

    DebugTrace (("Unit %p Srb %p, generated err = %08x\n",
                  Unit,
                  Srb,
                  SRB_STATUS (Srb->SrbStatus)));

    //
    // Busy processing is handled synchronous with the StartIo call.
    // Therefore, we should never get a busy error in the async error
    // handler.
    //

    if (IsBusy (Srb)) {
        RaidUnitProcessBusyRequest (Unit, Xrb);
        return;
    }

    if (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {

        //
        // Freeze the queue so the class driver has a chance to process
        // the error.
        //
        
        RaidFreezeUnitQueue (Unit);
        SET_FLAG (Srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Propagate the translated error condition in the IRP.
    //
    
    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);

    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Information = Srb->DataTransferLength;
    } else {
        Irp->IoStatus.Information = 0;
    }

    //
    // Release any resources associated with the IRP.
    //

    RaidUnitReleaseIrp (Irp, NULL);

    //
    // Finally, complete the request.
    //
    
    DebugTrace (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    RaidCompleteRequest (Irp, IO_NO_INCREMENT, Irp->IoStatus.Status);

    RaidStartNextIoPacket (&Unit->IoQueue,
                           FALSE,
                           NULL,
                           &RestartQueues);

    if (RestartQueues) {
        RaidAdapterRestartQueues (Unit->Adapter);
    }
}


VOID
RaidUnitRestartQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidRestartIoQueue (&Unit->IoQueue);
}


VOID
RaUnitAddToPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);
    ASSERT (Xrb->Srb != NULL);
    
    StorInsertEventQueue (&Unit->PendingQueue,
                          &Xrb->PendingLink,
                          Xrb->Srb->TimeOutValue);
}


VOID
RaUnitRemoveFromPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);

    StorRemoveEventQueue (&Unit->PendingQueue, &Xrb->PendingLink);
}


BOOLEAN
RaidUnitIsEnumerated(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    //
    // This should be an atomic operation, so there is no need to
    // acquire the SlowLock.
    //
    
    return Unit->Flags.Enumerated;
}


BOOLEAN
RaidUnitSetEnumerated(
    IN PRAID_UNIT_EXTENSION Unit,
    IN BOOLEAN Enumerated
    )
{
    BOOLEAN PreviouslyEnumerated;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    PreviouslyEnumerated = Unit->Flags.Enumerated;
    Unit->Flags.Enumerated = Enumerated;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return PreviouslyEnumerated;
}


PVOID
RaidGetKeyFromUnit(
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
{
    PVOID Key;
    PRAID_UNIT_EXTENSION Unit;
    
    Unit = CONTAINING_RECORD (Entry,
                              RAID_UNIT_EXTENSION,
                              UnitTableLink);

    ASSERT_UNIT (Unit);

    Key = RaidAddressToKey (Unit->Address);

    return (PVOID) Key;
}



VOID
RaidUnitPendingDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    
    Status = StorTickEventQueue (&Unit->PendingQueue);

    if (NT_SUCCESS (Status)) {
        return;
    }

    //
    // We timed out. Reset the unit
    //
    
    RaidUnitReset (Unit);
}



NTSTATUS
RaidUnitReset(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Perform a hierarchical reset on the logical unit.

Arguments:

    Unit - Logical unit to reset.

Return Value:

    NTSTATUS code.

--*/
{
    UCHAR PathId;

    PathId = StorGetAddressPathId (Unit->Address);
    return RaidAdapterReset (Unit->Adapter, PathId);
}



LOGICAL
RaidUnitNotifyHardwareGone(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is invoked by the enumeration code when a logical unit
    goes away.

Arguments:

    Unit - Logical unit that went away.

Return Value:

    TRUE - If PnP should be notified of the removal.

    FALSE - If PnP does not need to be notified.

--*/
{
    NTSTATUS Status;
    LOGICAL ChangeDetected;
    
    if (Unit->Flags.Present) {
        Unit->Flags.Present = FALSE;
        Status = RaidUnitCancelPendingRequestsAsync (Unit);
    }

    if (Unit->Flags.Enumerated) {
        ChangeDetected = TRUE;
    }

    return ChangeDetected;
}


NTSTATUS
RaidUnitCancelPendingRequestsAsync(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Asynchronously remove all queued requests from the logical unit. 

Arguments:

    Unit - Logical unit to remove queued requests for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_WORKITEM WorkItem;
    
    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {
        IoQueueWorkItem (WorkItem,
                         RaidCancelRequestsWorkRoutine,
                         DelayedWorkQueue,
                         WorkItem);
        Status = STATUS_SUCCESS;
    } else {
        //
        // Low memory: we failed to allocate the work item, so perform
        // the operation(s) synchronously.
        //
        REVIEW();
        Status = RaidUnitCancelPendingRequests (Unit);
    }

    return Status;
}



NTSTATUS
RaidCancelRequestsWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    Called from a work queue; this routine synchronously cancels all
    queued requests on a device queue.

Arguments:

    DeviceObject - Device object of queue to flush.

    Context - Context representing the work item.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;

    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);
    
    Status = RaidUnitCancelPendingRequests (Unit);

    IoFreeWorkItem (WorkItem);

    return Status;
}



NTSTATUS
RaidUnitCancelPendingRequests(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Synchronously cancel all pending requests.

Arguments:

    Unit - Logical unit to cancel pending requests for.

Return Value:

    NTSTATUS code.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;

    REVIEW();

    for (Irp = RaidRemoveIoQueue (&Unit->IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (&Unit->IoQueue)) {

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_NO_SUCH_DEVICE);
    }


    return STATUS_SUCCESS;
}
        

        

    

