/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    This driver is a sample that shows how a storage filter driver could
    be written.  This driver is not optimized for performance, but shows
    proper remove-lock usage and sets a completion routine for all read,
    write, and IOCTL irps.

Environment:

    kernel mode only

Notes:

--*/


#include "filter.h"
#include <classpnp.h>  // SRB_CLASS_FLAGS_PAGING

//
// for any file that has software tracing printouts, you must include a
// header file <filename>.tmh
// this file will be generated by the WPP processing phase
//
#include "filter.tmh"


#if DBG
ULONG Noop = 0;
ULONG DebugLevel = 0; // bitmask!
#endif

ULONG FailEveryNCommands = 0x0000;



//
// Define the sections that allow for discarding (i.e. paging) some of
// the code.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, FilterSyncFilterWithTarget)
#pragma alloc_text (PAGE, FilterAddDevice)
#pragma alloc_text (PAGE, FilterDispatchPnp)
#pragma alloc_text (PAGE, FilterStartDevice)
#pragma alloc_text (PAGE, FilterRemoveDevice)
#pragma alloc_text (PAGE, FilterSetAllowedBitMask)
#pragma alloc_text (PAGE, FilterUnload)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O manager to set up the disk
    failure prediction filter driver. The driver object is set up and
    then the Pnp manager calls FilterAddDevice to attach to the boot
    devices.

Arguments:

    DriverObject - The disk performance driver object.

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful

--*/

{

    ULONG               ulIndex;
    PDRIVER_DISPATCH  * dispatch;

    //
    // Enable software tracing by registering using the WPP macro.
    // <unfortunately, this may not allow immediate prints such
    //  as the below KdPrintEx.  need to check.>
    //

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "DriverEntry %p %p\n",
               DriverObject,
               RegistryPath
               ));

    //
    // Create dispatch points
    //
    for (ulIndex = 0, dispatch = DriverObject->MajorFunction;
         ulIndex <= IRP_MJ_MAXIMUM_FUNCTION;
         ulIndex++, dispatch++) {

        *dispatch = FilterSendToNextDriver;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_SCSI]            = FilterScsi;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = FilterDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = FilterDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = FilterDispatchPower;

    DriverObject->DriverExtension->AddDevice            = FilterAddDevice;
    DriverObject->DriverUnload                          = FilterUnload;

    return(STATUS_SUCCESS);

} // end DriverEntry()

VOID
FilterSyncFilterWithTarget(
    IN PDEVICE_OBJECT FilterDevice,
    IN PDEVICE_OBJECT TargetDevice
    )
{
    ULONG                   propFlags;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "SyncFilterWithTarget %p %p\n",
               FilterDevice,
               TargetDevice
               ));


    //
    // Propogate all useful flags from target to Filter. MountMgr will look
    // at the Filter object capabilities to figure out if the disk is
    // a removable and perhaps other things.
    //
    
    propFlags = TargetDevice->Flags & FILTER_DEVICE_PROPOGATE_FLAGS;
    SET_FLAG(FilterDevice->Flags, propFlags);

    propFlags = TargetDevice->Characteristics & FILTER_DEVICE_PROPOGATE_CHARACTERISTICS;
    SET_FLAG(FilterDevice->Characteristics, propFlags);

    return;
}

NTSTATUS
FilterAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object FDO for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject - Filter driver object.
    PhysicalDeviceObject - Physical Device Object from the underlying driver

Return Value:

    NTSTATUS
--*/

{
    NTSTATUS                 status;
    PDEVICE_OBJECT           filterDeviceObject;
    PFILTER_DEVICE_EXTENSION deviceExtension;
    PIRP                     irp;
    ULONG                    registrationFlag = 0;
    PCHAR                    buffer;
    ULONG                    buffersize;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "AddDevice %p %p\n",
               DriverObject,
               PhysicalDeviceObject
               ));


    //
    // Create a filter device object for this device stack.
    // since we don't handle relative opens, we create the device
    // with the FILE_DEVICE_SECURE_OPEN flag set.
    //

    status = IoCreateDevice(DriverObject,
                            sizeof(FILTER_DEVICE_EXTENSION),
                            NULL,
                            PhysicalDeviceObject->DeviceType,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &filterDeviceObject);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugWarning,
                   "FilterAddDevice: Cannot create filterDeviceObject\n"));
        return status;
    }

    SET_FLAG(filterDeviceObject->Flags, DO_DIRECT_IO);

    
    deviceExtension = (PFILTER_DEVICE_EXTENSION) filterDeviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension, sizeof(FILTER_DEVICE_EXTENSION));

    //
    // Attaches the device object to the highest device object in the chain and
    // return the previously highest device object, which is passed to
    // IoCallDriver when pass IRPs down the device stack
    //

    deviceExtension->TargetDeviceObject =
        IoAttachDeviceToDeviceStack(filterDeviceObject, PhysicalDeviceObject);

    if (deviceExtension->TargetDeviceObject == NULL) {
        IoDeleteDevice(filterDeviceObject);
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugWarning,
                   "FilterAddDevice: Unable to attach %p to target %p\n",
                   filterDeviceObject,
                   PhysicalDeviceObject
                   ));
        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // NOTE: the bitmap usually requires synchronization.  since the fields
    // are static for this example, we won't require any synchronization
    // to the RTL_BITMAP structure (READ_ONLY).
    //

    RtlInitializeBitMap(&deviceExtension->AllowedCommands,
                        deviceExtension->BitmapBuffer,
                        256);
    RtlClearAllBits(&deviceExtension->AllowedCommands);
    FilterSetAllowedBitMask(deviceExtension);

    //
    // keep a back pointer to the device object
    //
    
    deviceExtension->DeviceObject = filterDeviceObject;

    KeInitializeEvent(&deviceExtension->PagingPathCountEvent,
                      NotificationEvent, TRUE);

    //
    // default to DO_POWER_PAGABLE
    //

    SET_FLAG(filterDeviceObject->Flags,  DO_POWER_PAGABLE);

    //
    // Initialize the remove lock
    //

    IoInitializeRemoveLock(&deviceExtension->RemoveLock,
                           REMLOCK_TAG,
                           REMLOCK_MAXIMUM,
                           REMLOCK_HIGHWATER);

    //
    // we want to fail some commands....
    //

    deviceExtension->FailEvery = FailEveryNCommands;

    //
    // Clear the DO_DEVICE_INITIALIZING flag
    //

    CLEAR_FLAG(filterDeviceObject->Flags, DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;

} // end FilterAddDevice()

NTSTATUS
FilterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PFILTER_DEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN lockHeld;
    BOOLEAN irpCompleted;

    PAGED_CODE();

    KdPrintEx((DPFLTR_STORFILT_ID, 
               FilterDebugFunction,
               "DispatchPnp %p %p\n",
               DeviceObject,
               Irp
               ));


    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_STORFILT_ID, 
                   FilterDebugRemove,
                   "DispathPnp: Remove lock failed PNP Irp type [%#02x]\n",
                   irpSp->MinorFunction));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    lockHeld = TRUE;
    irpCompleted = FALSE;

    switch(irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE: {

            //
            // Call the Start Routine handler. 
            //
            
            KdPrintEx((DPFLTR_STORFILT_ID, 
                       FilterDebugPnp,
                       "DispatchPnp: Schedule completion for "
                       "START_DEVICE\n"));
            status = FilterStartDevice(DeviceObject, Irp);
            KdPrintEx((DPFLTR_STORFILT_ID, 
                       FilterDebugPnp,
                       "DispatchPnp: START_DEVICE completed "
                       "with status %x\n", status));
            break;

        }

        case IRP_MN_REMOVE_DEVICE: {
            
            //
            // Call the Remove Routine handler. 
            //

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: Schedule completion for "
                       "REMOVE_DEVICE\n"));
            status = FilterRemoveDevice(DeviceObject, Irp);
            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: REMOVE_DEVICE completed "
                       "with status %x\n", status));
            
            //
            // Remove locked released by FilterRemoveDevice
            //
            
            lockHeld = FALSE;
            break;

        }
        
        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

            PIO_STACK_LOCATION irpStack;
            ULONG count;
            BOOLEAN setPagable;

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: Processing DEVICE_USAGE_NOTIFICATION\n"
                       ));
            irpStack = IoGetCurrentIrpStackLocation(Irp);

            if (irpStack->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
                IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                lockHeld = FALSE;
                status = FilterSendToNextDriver(DeviceObject, Irp);
                irpCompleted = TRUE;
                break; // out of case statement
            }

            deviceExtension = DeviceObject->DeviceExtension;

            //
            // wait on the paging path event
            //

            status = KeWaitForSingleObject(&deviceExtension->PagingPathCountEvent,
                                           Executive, KernelMode,
                                           FALSE, NULL);

            //
            // if removing last paging device, need to set DO_POWER_PAGABLE
            // bit here, and possible re-set it below on failure.
            //

            setPagable = FALSE;
            if (!irpStack->Parameters.UsageNotification.InPath &&
                deviceExtension->PagingPathCount == 1 ) {

                //
                // removing the last paging file
                // must have DO_POWER_PAGABLE bits set
                //

                if (TEST_FLAG(DeviceObject->Flags, DO_POWER_INRUSH)) {
                    
                    KdPrintEx((DPFLTR_STORFILT_ID,
                               FilterDebugPnp,
                               "DispatchPnp: last paging file "
                               "removed but DO_POWER_INRUSH set, so not "
                               "setting PAGABLE bit for DO %p\n",
                               DeviceObject
                               ));

                } else {
                    
                    KdPrintEx((DPFLTR_STORFILT_ID, 
                               FilterDebugPnp,
                               "DispatchPnp: Setting  PAGABLE "
                               "bit for DO %p\n",
                               DeviceObject
                               ));
                    SET_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = TRUE;

                }

            }

            //
            // send the irp synchronously
            //

            status = FilterForwardIrpSynchronous(DeviceObject, Irp);

            //
            // now deal with the failure and success cases.
            // note that we are not allowed to fail the irp
            // once it is sent to the lower drivers.
            //

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(
                    &deviceExtension->PagingPathCount,
                    irpStack->Parameters.UsageNotification.InPath);

                if (irpStack->Parameters.UsageNotification.InPath) {
                    if (deviceExtension->PagingPathCount == 1) {

                        //
                        // first paging file addition
                        //

                        KdPrintEx((DPFLTR_STORFILT_ID,
                                   FilterDebugPnp,
                                   "DispatchPnp: Clearing PAGABLE bit "
                                   "for DO %p\n",
                                   DeviceObject));
                        CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);

                    }
                }

            } else {

                //
                // cleanup the changes done above
                //

                if (setPagable == TRUE) {
                    CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = FALSE;
                }

            }

            //
            // set the event so the next one can occur.
            //

            KeSetEvent(&deviceExtension->PagingPathCountEvent,
                       IO_NO_INCREMENT, FALSE);
        }

        default: {

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugPnp,
                       "DispatchPnp: Forwarding irp\n"));
            //
            // Simply forward all other Irps
            //
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            lockHeld = FALSE;
            status = FilterSendToNextDriver(DeviceObject, Irp);
            irpCompleted = TRUE;

        }
    
    } // end switch on IRP_MN_ type


    if (lockHeld) {
        
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    }
    
    if (! irpCompleted) {

        Irp->IoStatus.Status = status;
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugPnp,
                   "DispatchPnp: Completing Irp %p with status %x\n",
                   Irp, status));
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }
    

    return status;

} // end FilterDispatchPnp()

NTSTATUS
FilterIrpSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:

    DeviceObject is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT Event = (PKEVENT) Context;
    
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "SignalCompletion %p %p %p\n",
               DeviceObject,
               Irp,
               Context
               ));

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // end FilterIrpSignalCompletion()

NTSTATUS
FilterStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when a Pnp Start Irp is received.
    It will schedule a completion routine to initialize and register with WMI.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of processing the Start Irp

--*/
{
    PFILTER_DEVICE_EXTENSION   deviceExtension;
    KEVENT              event;
    NTSTATUS            status;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "StartDevice %p %p\n",
               DeviceObject,
               Irp
               ));

    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = FilterForwardIrpSynchronous(DeviceObject, Irp);

    FilterSyncFilterWithTarget(DeviceObject,
                               deviceExtension->TargetDeviceObject);

    return status;
}

NTSTATUS
FilterRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the device is to be removed.
    It will de-register itself from WMI first, detach itself from the
    stack before deleting itself.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of removing the device

--*/
{
    NTSTATUS            status;
    PFILTER_DEVICE_EXTENSION   deviceExtension;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "RemoveDevice %p %p\n",
               DeviceObject,
               Irp
               ));


    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = FilterForwardIrpSynchronous(DeviceObject, Irp);

    IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

    IoDetachDevice(deviceExtension->TargetDeviceObject);
    IoDeleteDevice(DeviceObject);

    return status;
}

NTSTATUS
FilterSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFILTER_DEVICE_EXTENSION   deviceExtension;
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "SendToNextDriver %p %p\n",
               DeviceObject,
               Irp
               ));

    IoSkipCurrentIrpStackLocation(Irp);
    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // end FilterSendToNextDriver()

NTSTATUS
FilterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PFILTER_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "DispatchPower %p %p\n",
               DeviceObject,
               Irp
               ));


    deviceExtension = (PFILTER_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugRemove,
                   "FilterPower: Remove lock failed Power Irp\n"));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    status = PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    return status;

} // end FilterDispatchPower

NTSTATUS
FilterForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.
    
    The remove lock must be acquired when calling this routine.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PFILTER_DEVICE_EXTENSION   deviceExtension;
    KEVENT event;
    NTSTATUS status;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "ForwardIrpSynchronous %p %p\n",
               DeviceObject,
               Irp
               ));

    //
    // NOTE: setting this to be paged code could cause issues since
    //       this driver is in the storage stack.
    //
    // PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    deviceExtension = (PFILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // copy the irpstack for the next device
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // set a completion routine
    //

    IoSetCompletionRoutine(Irp, FilterIrpSignalCompletion,
                            &event, TRUE, TRUE, TRUE);

    //
    // call the next lower device
    //

    status = IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    //
    // wait for the actual completion
    //

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;

} // end FilterForwardIrpSynchronous()

NTSTATUS
FilterDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the failure prediction
    device control. All others are passed down to the disk drivers.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PFILTER_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG controlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status;

    PSENSE_DATA senseData = NULL; // for logging/modification on rejection
    UCHAR senseDataSize = 0;      // for logging/modification on rejection
    PUCHAR scsiStatus = NULL;     // modification on rejection
    PCDB cdb = NULL;              // for logging
    ULONG validCommand = FALSE;   // default to not allowing the cmd



    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "DeviceControl %p %p\n",
               DeviceObject,
               Irp
               ));

    if ((controlCode != IOCTL_SCSI_PASS_THROUGH) &&
        (controlCode != IOCTL_SCSI_PASS_THROUGH_DIRECT)) {
        return FilterSendToNextDriver(DeviceObject, Irp);
    }

    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
    
        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugRemove,
                   "FilterDeviceControl: Remove lock failed IOCTL [%x]\n",
                   irpStack->Parameters.DeviceIoControl.IoControlCode));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if ((controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT) &&
        (irpStack->MinorFunction != IRP_MN_SCSI_CLASS)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto CompleteWithError;
    }

    //
    // Validiate the user buffer
    // set pointers to the CDB and SENSE_DATA
    //

#if defined (_WIN64)

    if (IoIs32bitProcess(Irp)) {


        //
        // NOTE: the payload (passThrough->DataBuffer) is different for both
        //       these ioctls.  we don't currently care, and hope the compiler
        //       will properly optimize both cases to a single code path.
        //

        if (controlCode == IOCTL_SCSI_PASS_THROUGH) {
            PSCSI_PASS_THROUGH32 passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH32)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;
            
            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;
            

        } else if (controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT) {
            PSCSI_PASS_THROUGH_DIRECT32 passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH_DIRECT32)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;
            
            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;

        }
    
    } else
#endif // defined (_WIN64)

    {
        //
        // NOTE: the payload (passThrough->DataBuffer) is different for both
        //       these ioctls.  we don't currently care, and hope the compiler
        //       will properly optimize both cases to a single code path.
        //

        if (controlCode == IOCTL_SCSI_PASS_THROUGH) {
            PSCSI_PASS_THROUGH passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;
            
            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;

        } else if (controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT) {
            PSCSI_PASS_THROUGH_DIRECT passThrough;
            if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SCSI_PASS_THROUGH_DIRECT)) {

                status = STATUS_INVALID_PARAMETER;
                goto CompleteWithError;

            }
            passThrough = Irp->AssociatedIrp.SystemBuffer;
            scsiStatus = &passThrough->ScsiStatus;
            cdb = (PCDB)passThrough->Cdb;

            senseData = (PSENSE_DATA)( ((PUCHAR)passThrough) +
                                       passThrough->SenseInfoOffset);
            senseDataSize = passThrough->SenseInfoLength;
        }

    }

    //
    // all required pointers have been set.
    //

    ASSERT(scsiStatus != NULL);
    ASSERT(cdb != NULL);
    ASSERT((senseData != NULL) || (senseDataSize == 0));

    validCommand = FilterIsCmdValid(deviceExtension, cdb->AsByte[0]);

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugBusTrace,
               "PassThrough: trace"
               "  %02x %02x %02x %02x"
               "  %02x %02x %02x %02x"
               "    %02x %02x %02x %02x"
               "  %02x %02x %02x %02x\n",
               cdb->AsByte[0x0], cdb->AsByte[0x1],
               cdb->AsByte[0x2], cdb->AsByte[0x3],
               cdb->AsByte[0x4], cdb->AsByte[0x5],
               cdb->AsByte[0x6], cdb->AsByte[0x7],
               cdb->AsByte[0x8], cdb->AsByte[0x9],
               cdb->AsByte[0xa], cdb->AsByte[0xb],
               cdb->AsByte[0xc], cdb->AsByte[0xd],
               cdb->AsByte[0xe], cdb->AsByte[0xf]
               ));


    //
    // if the command was not allowed, fake an invalid
    // device request error.
    //

    if (validCommand) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugPtAllow,
                   "PassThrough: Allowing command 0x%02x\n",
                   cdb->AsByte[0]));
        status = FilterProcessIrp(deviceExtension, Irp);
        return status;

    } else { // (!validCommand)

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugPtReject,
                   "PassThrough: Rejecting command 0x%02x\n",
                   cdb->AsByte[0]));

        FilterFakeSenseDataError(
            senseData,
            senseDataSize,
            SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_INVALID_CDB, 0
            );

        *scsiStatus = SCSISTAT_CHECK_CONDITION;
        status = STATUS_SUCCESS;
        goto CompleteWithSuccess;

    }

CompleteWithError:
    
    ASSERT(!NT_SUCCESS(status));

CompleteWithSuccess:

    Irp->IoStatus.Status = status;
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

} // end FilterDeviceControl()

NTSTATUS
FilterScsi(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PFILTER_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    PSCSI_REQUEST_BLOCK srb;   
    ULONG validCommand;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "Scsi %p %p\n",
               DeviceObject,
               Irp
               ));

    //
    // Acquire the remove lock so that device will not be removed while
    // processing this irp.
    //

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugRemove,
                   "Scsi: Remove lock failed\n"));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    srb = irpStack->Parameters.Scsi.Srb;

    validCommand = FilterIsCmdValid(deviceExtension,
                                    srb->Cdb[0]
                                    );

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugBusTrace,
               "Scsi: trace %02x %02x %02x %02x  %02x %02x %02x %02x"
               "   %02x %02x %02x %02x  %02x %02x %02x %02x\n",
               srb->Cdb[0x0], srb->Cdb[0x1], srb->Cdb[0x2], srb->Cdb[0x3],
               srb->Cdb[0x4], srb->Cdb[0x5], srb->Cdb[0x6], srb->Cdb[0x7],
               srb->Cdb[0x8], srb->Cdb[0x9], srb->Cdb[0xa], srb->Cdb[0xb],
               srb->Cdb[0xc], srb->Cdb[0xd], srb->Cdb[0xe], srb->Cdb[0xf]
               ));
    
    if (!validCommand) {

        KdPrintEx((DPFLTR_STORFILT_ID,
                   FilterDebugScsiReject,
                   "Scsi: Rejecting command 0x%02x\n",
                   srb->Cdb[0]));

        srb->DataTransferLength = 0;
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        //
        // we don't mark the sense valid above, but if available
        // fill it in anyways to find bugs in that code path.
        //

        FilterFakeSenseDataError(
            srb->SenseInfoBuffer,
            srb->SenseInfoBufferLength,
            SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_INVALID_CDB, 0
            );

        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    
    
    if (deviceExtension->FailEvery != 0) {
        
        ULONG t = InterlockedIncrement(&deviceExtension->IoCount);

        if ((t%deviceExtension->FailEvery) == 0 &&
            !TEST_FLAG(srb->SrbFlags, SRB_CLASS_FLAGS_PAGING)
            ) {

            KdPrintEx((DPFLTR_STORFILT_ID,
                       FilterDebugScsiAllow,
                       "Scsi: Failing command 0x%02x for PERF testing\n",
                       srb->Cdb[0]));
            RtlZeroMemory(srb->SenseInfoBuffer, srb->SenseInfoBufferLength);
            srb->SrbStatus = SRB_STATUS_COMMAND_TIMEOUT;
            status = STATUS_IO_TIMEOUT;
            Irp->IoStatus.Status = status;
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        }

    }

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugScsiAllow,
               "Scsi: Allowing command 0x%02x\n",
               srb->Cdb[0]));

    status = FilterProcessIrp(deviceExtension, Irp);
    return status;

} // end FilterScsi()

NTSTATUS
FilterProcessIrpCompletion(
    IN PDEVICE_OBJECT Unreferenced,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFILTER_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "ProcessIrpCompletion %p %p\n",
               DeviceObject,
               Irp
               ));

    //
    // do any post-processing work here.
    // ie. ioctl processing to print sense buffers or modification of
    //     data returned by device for given commands.
    //

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    return Irp->IoStatus.Status;
    
} // end FilterProcessIrpCompletion()

NTSTATUS
FilterProcessIrp(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction2,
               "ProcessIrp %p %p\n",
               DeviceExtension,
               Irp
               ));
    
    IoMarkIrpPending(Irp);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           FilterProcessIrpCompletion,
                           DeviceExtension->DeviceObject,
                           TRUE, TRUE, TRUE);
    IoCallDriver(DeviceExtension->TargetDeviceObject, Irp);
    return STATUS_PENDING;

} // end FilterProcessIrp()

VOID
FilterSetAllowedBitMask(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG i;

    PAGED_CODE();
    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "SetAllowedBitMask %p\n",
               DeviceExtension
               ));

    //
    // it is presumed the user can make this more efficient.
    // this method was chosen for clarity and ease of modification.
    //

    RtlClearAllBits(&DeviceExtension->AllowedCommands);

    for (i=0; i < 0x100; i++) {

        if (AllowedCommandsW2kCdrom[i]) {
            RtlSetBit(&DeviceExtension->AllowedCommands, i);
        }
    
    }

    return;
} // end FilterSetAllowedBitMask()

VOID
FilterUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "Unload %p\n",
               DriverObject
               ));

    //
    // WPP_CLEANUP can only occur after all KdPrintEx routines
    // since it deallocates any resources used by that and also
    // deregisters from WMI...
    //

    WPP_CLEANUP(DriverObject);

    return;
}

VOID
FilterFakeSenseDataError(
    IN PSENSE_DATA Sense,
    IN UCHAR SenseLength,
    IN UCHAR SenseKey,
    IN UCHAR Asc,
    IN UCHAR Ascq
    )
{

    KdPrintEx((DPFLTR_STORFILT_ID,
               FilterDebugFunction,
               "FakeSenseDataError %p %x\n",
               Sense,
               SenseLength
               ));

    if (SenseLength == 0) {
        return;
    }
    
    RtlZeroMemory(Sense, SenseLength);

    if (SenseLength >= 3) {  // cannot use RTL_CONTAINS_FIELD of a bitfield
        Sense->Valid = 1;
        Sense->SenseKey = SenseKey;
    }
    
    //
    // set the additional sense length appropriately
    //
    
    if (RTL_CONTAINS_FIELD(Sense, SenseLength, AdditionalSenseLength)) {
        
        Sense->AdditionalSenseLength =
            (UCHAR)(SenseLength -
                    RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength)
                    );

    }

    //
    // set the additional sense code (if possible) to say the cdb is invalid
    //

    if (RTL_CONTAINS_FIELD(Sense, SenseLength, AdditionalSenseCode)) {
        Sense->AdditionalSenseCode = Asc;
    }

    if (RTL_CONTAINS_FIELD(Sense, SenseLength, AdditionalSenseCodeQualifier)) {
        Sense->AdditionalSenseCodeQualifier = Ascq;
    }
    

    return;

}

BOOLEAN
FilterIsCmdValid(
    IN PFILTER_DEVICE_EXTENSION DeviceExtension,
    IN UCHAR Cmd
    )
{
#if DBG
    if (Noop) {
        return TRUE;
    }
#endif // DBG
    if (RtlCheckBit(&DeviceExtension->AllowedCommands, Cmd)) {
        return TRUE;
    }
    return FALSE;

}


